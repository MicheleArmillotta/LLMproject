[
  {
    "function_name": "ResourceOwnerForgetJIT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1297-1303",
    "snippet": "void\nResourceOwnerForgetJIT(ResourceOwner owner, Datum handle)\n{\n\tif (!ResourceArrayRemove(&(owner->jitarr), handle))\n\t\telog(ERROR, \"JIT context %p is not owned by resource owner %s\",\n\t\t\t DatumGetPointer(handle), owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"JIT context %p is not owned by resource owner %s\"",
            "DatumGetPointer(handle)",
            "owner->name"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "handle"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->jitarr)",
            "handle"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerForgetJIT(ResourceOwner owner, Datum handle)\n{\n\tif (!ResourceArrayRemove(&(owner->jitarr), handle))\n\t\telog(ERROR, \"JIT context %p is not owned by resource owner %s\",\n\t\t\t DatumGetPointer(handle), owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberJIT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1288-1292",
    "snippet": "void\nResourceOwnerRememberJIT(ResourceOwner owner, Datum handle)\n{\n\tResourceArrayAdd(&(owner->jitarr), handle);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->jitarr)",
            "handle"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberJIT(ResourceOwner owner, Datum handle)\n{\n\tResourceArrayAdd(&(owner->jitarr), handle);\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeJIT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1277-1281",
    "snippet": "void\nResourceOwnerEnlargeJIT(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->jitarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->jitarr)"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeJIT(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->jitarr));\n}"
  },
  {
    "function_name": "PrintDSMLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1263-1268",
    "snippet": "static void\nPrintDSMLeakWarning(dsm_segment *seg)\n{\n\telog(WARNING, \"dynamic shared memory leak: segment %u still referenced\",\n\t\t dsm_segment_handle(seg));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintDSMLeakWarning(dsm_segment *seg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"dynamic shared memory leak: segment %u still referenced\"",
            "dsm_segment_handle(seg)"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_segment_handle",
          "args": [
            "seg"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintDSMLeakWarning(dsm_segment *seg);\n\nstatic void\nPrintDSMLeakWarning(dsm_segment *seg)\n{\n\telog(WARNING, \"dynamic shared memory leak: segment %u still referenced\",\n\t\t dsm_segment_handle(seg));\n}"
  },
  {
    "function_name": "ResourceOwnerForgetDSM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1252-1258",
    "snippet": "void\nResourceOwnerForgetDSM(ResourceOwner owner, dsm_segment *seg)\n{\n\tif (!ResourceArrayRemove(&(owner->dsmarr), PointerGetDatum(seg)))\n\t\telog(ERROR, \"dynamic shared memory segment %u is not owned by resource owner %s\",\n\t\t\t dsm_segment_handle(seg), owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintDSMLeakWarning(dsm_segment *seg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"dynamic shared memory segment %u is not owned by resource owner %s\"",
            "dsm_segment_handle(seg)",
            "owner->name"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_segment_handle",
          "args": [
            "seg"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->dsmarr)",
            "PointerGetDatum(seg)"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "seg"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintDSMLeakWarning(dsm_segment *seg);\n\nvoid\nResourceOwnerForgetDSM(ResourceOwner owner, dsm_segment *seg)\n{\n\tif (!ResourceArrayRemove(&(owner->dsmarr), PointerGetDatum(seg)))\n\t\telog(ERROR, \"dynamic shared memory segment %u is not owned by resource owner %s\",\n\t\t\t dsm_segment_handle(seg), owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberDSM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1243-1247",
    "snippet": "void\nResourceOwnerRememberDSM(ResourceOwner owner, dsm_segment *seg)\n{\n\tResourceArrayAdd(&(owner->dsmarr), PointerGetDatum(seg));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintDSMLeakWarning(dsm_segment *seg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->dsmarr)",
            "PointerGetDatum(seg)"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "seg"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintDSMLeakWarning(dsm_segment *seg);\n\nvoid\nResourceOwnerRememberDSM(ResourceOwner owner, dsm_segment *seg)\n{\n\tResourceArrayAdd(&(owner->dsmarr), PointerGetDatum(seg));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeDSMs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1232-1236",
    "snippet": "void\nResourceOwnerEnlargeDSMs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->dsmarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->dsmarr)"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeDSMs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->dsmarr));\n}"
  },
  {
    "function_name": "PrintFileLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1218-1223",
    "snippet": "static void\nPrintFileLeakWarning(File file)\n{\n\telog(WARNING, \"temporary file leak: File %d still referenced\",\n\t\t file);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintFileLeakWarning(File file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"temporary file leak: File %d still referenced\"",
            "file"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintFileLeakWarning(File file);\n\nstatic void\nPrintFileLeakWarning(File file)\n{\n\telog(WARNING, \"temporary file leak: File %d still referenced\",\n\t\t file);\n}"
  },
  {
    "function_name": "ResourceOwnerForgetFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1207-1213",
    "snippet": "void\nResourceOwnerForgetFile(ResourceOwner owner, File file)\n{\n\tif (!ResourceArrayRemove(&(owner->filearr), FileGetDatum(file)))\n\t\telog(ERROR, \"temporary file %d is not owned by resource owner %s\",\n\t\t\t file, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintFileLeakWarning(File file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"temporary file %d is not owned by resource owner %s\"",
            "file",
            "owner->name"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->filearr)",
            "FileGetDatum(file)"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FileGetDatum",
          "args": [
            "file"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintFileLeakWarning(File file);\n\nvoid\nResourceOwnerForgetFile(ResourceOwner owner, File file)\n{\n\tif (!ResourceArrayRemove(&(owner->filearr), FileGetDatum(file)))\n\t\telog(ERROR, \"temporary file %d is not owned by resource owner %s\",\n\t\t\t file, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1198-1202",
    "snippet": "void\nResourceOwnerRememberFile(ResourceOwner owner, File file)\n{\n\tResourceArrayAdd(&(owner->filearr), FileGetDatum(file));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintFileLeakWarning(File file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->filearr)",
            "FileGetDatum(file)"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FileGetDatum",
          "args": [
            "file"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintFileLeakWarning(File file);\n\nvoid\nResourceOwnerRememberFile(ResourceOwner owner, File file)\n{\n\tResourceArrayAdd(&(owner->filearr), FileGetDatum(file));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeFiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1187-1191",
    "snippet": "void\nResourceOwnerEnlargeFiles(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->filearr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->filearr)"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeFiles(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->filearr));\n}"
  },
  {
    "function_name": "PrintSnapshotLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1172-1177",
    "snippet": "static void\nPrintSnapshotLeakWarning(Snapshot snapshot)\n{\n\telog(WARNING, \"Snapshot reference leak: Snapshot %p still referenced\",\n\t\t snapshot);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"Snapshot reference leak: Snapshot %p still referenced\"",
            "snapshot"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nstatic void\nPrintSnapshotLeakWarning(Snapshot snapshot)\n{\n\telog(WARNING, \"Snapshot reference leak: Snapshot %p still referenced\",\n\t\t snapshot);\n}"
  },
  {
    "function_name": "ResourceOwnerForgetSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1161-1167",
    "snippet": "void\nResourceOwnerForgetSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tif (!ResourceArrayRemove(&(owner->snapshotarr), PointerGetDatum(snapshot)))\n\t\telog(ERROR, \"snapshot reference %p is not owned by resource owner %s\",\n\t\t\t snapshot, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"snapshot reference %p is not owned by resource owner %s\"",
            "snapshot",
            "owner->name"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->snapshotarr)",
            "PointerGetDatum(snapshot)"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "snapshot"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nvoid\nResourceOwnerForgetSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tif (!ResourceArrayRemove(&(owner->snapshotarr), PointerGetDatum(snapshot)))\n\t\telog(ERROR, \"snapshot reference %p is not owned by resource owner %s\",\n\t\t\t snapshot, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1152-1156",
    "snippet": "void\nResourceOwnerRememberSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tResourceArrayAdd(&(owner->snapshotarr), PointerGetDatum(snapshot));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->snapshotarr)",
            "PointerGetDatum(snapshot)"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "snapshot"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nvoid\nResourceOwnerRememberSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tResourceArrayAdd(&(owner->snapshotarr), PointerGetDatum(snapshot));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeSnapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1141-1145",
    "snippet": "void\nResourceOwnerEnlargeSnapshots(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->snapshotarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->snapshotarr)"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeSnapshots(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->snapshotarr));\n}"
  },
  {
    "function_name": "PrintTupleDescLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1126-1132",
    "snippet": "static void\nPrintTupleDescLeakWarning(TupleDesc tupdesc)\n{\n\telog(WARNING,\n\t\t \"TupleDesc reference leak: TupleDesc %p (%u,%d) still referenced\",\n\t\t tupdesc, tupdesc->tdtypeid, tupdesc->tdtypmod);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"TupleDesc reference leak: TupleDesc %p (%u,%d) still referenced\"",
            "tupdesc",
            "tupdesc->tdtypeid",
            "tupdesc->tdtypmod"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\n\nstatic void\nPrintTupleDescLeakWarning(TupleDesc tupdesc)\n{\n\telog(WARNING,\n\t\t \"TupleDesc reference leak: TupleDesc %p (%u,%d) still referenced\",\n\t\t tupdesc, tupdesc->tdtypeid, tupdesc->tdtypmod);\n}"
  },
  {
    "function_name": "ResourceOwnerForgetTupleDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1115-1121",
    "snippet": "void\nResourceOwnerForgetTupleDesc(ResourceOwner owner, TupleDesc tupdesc)\n{\n\tif (!ResourceArrayRemove(&(owner->tupdescarr), PointerGetDatum(tupdesc)))\n\t\telog(ERROR, \"tupdesc reference %p is not owned by resource owner %s\",\n\t\t\t tupdesc, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"tupdesc reference %p is not owned by resource owner %s\"",
            "tupdesc",
            "owner->name"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->tupdescarr)",
            "PointerGetDatum(tupdesc)"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "tupdesc"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\n\nvoid\nResourceOwnerForgetTupleDesc(ResourceOwner owner, TupleDesc tupdesc)\n{\n\tif (!ResourceArrayRemove(&(owner->tupdescarr), PointerGetDatum(tupdesc)))\n\t\telog(ERROR, \"tupdesc reference %p is not owned by resource owner %s\",\n\t\t\t tupdesc, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberTupleDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1106-1110",
    "snippet": "void\nResourceOwnerRememberTupleDesc(ResourceOwner owner, TupleDesc tupdesc)\n{\n\tResourceArrayAdd(&(owner->tupdescarr), PointerGetDatum(tupdesc));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->tupdescarr)",
            "PointerGetDatum(tupdesc)"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "tupdesc"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\n\nvoid\nResourceOwnerRememberTupleDesc(ResourceOwner owner, TupleDesc tupdesc)\n{\n\tResourceArrayAdd(&(owner->tupdescarr), PointerGetDatum(tupdesc));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeTupleDescs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1095-1099",
    "snippet": "void\nResourceOwnerEnlargeTupleDescs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->tupdescarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->tupdescarr)"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeTupleDescs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->tupdescarr));\n}"
  },
  {
    "function_name": "PrintPlanCacheLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1082-1086",
    "snippet": "static void\nPrintPlanCacheLeakWarning(CachedPlan *plan)\n{\n\telog(WARNING, \"plancache reference leak: plan %p not closed\", plan);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintPlanCacheLeakWarning(CachedPlan *plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"plancache reference leak: plan %p not closed\"",
            "plan"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintPlanCacheLeakWarning(CachedPlan *plan);\n\nstatic void\nPrintPlanCacheLeakWarning(CachedPlan *plan)\n{\n\telog(WARNING, \"plancache reference leak: plan %p not closed\", plan);\n}"
  },
  {
    "function_name": "ResourceOwnerForgetPlanCacheRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1071-1077",
    "snippet": "void\nResourceOwnerForgetPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tif (!ResourceArrayRemove(&(owner->planrefarr), PointerGetDatum(plan)))\n\t\telog(ERROR, \"plancache reference %p is not owned by resource owner %s\",\n\t\t\t plan, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintPlanCacheLeakWarning(CachedPlan *plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"plancache reference %p is not owned by resource owner %s\"",
            "plan",
            "owner->name"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->planrefarr)",
            "PointerGetDatum(plan)"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "plan"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintPlanCacheLeakWarning(CachedPlan *plan);\n\nvoid\nResourceOwnerForgetPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tif (!ResourceArrayRemove(&(owner->planrefarr), PointerGetDatum(plan)))\n\t\telog(ERROR, \"plancache reference %p is not owned by resource owner %s\",\n\t\t\t plan, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberPlanCacheRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1062-1066",
    "snippet": "void\nResourceOwnerRememberPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tResourceArrayAdd(&(owner->planrefarr), PointerGetDatum(plan));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintPlanCacheLeakWarning(CachedPlan *plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->planrefarr)",
            "PointerGetDatum(plan)"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "plan"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintPlanCacheLeakWarning(CachedPlan *plan);\n\nvoid\nResourceOwnerRememberPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tResourceArrayAdd(&(owner->planrefarr), PointerGetDatum(plan));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargePlanCacheRefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1051-1055",
    "snippet": "void\nResourceOwnerEnlargePlanCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->planrefarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->planrefarr)"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargePlanCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->planrefarr));\n}"
  },
  {
    "function_name": "PrintRelCacheLeakWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1037-1042",
    "snippet": "static void\nPrintRelCacheLeakWarning(Relation rel)\n{\n\telog(WARNING, \"relcache reference leak: relation \\\"%s\\\" not closed\",\n\t\t RelationGetRelationName(rel));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintRelCacheLeakWarning(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"relcache reference leak: relation \\\"%s\\\" not closed\"",
            "RelationGetRelationName(rel)"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintRelCacheLeakWarning(Relation rel);\n\nstatic void\nPrintRelCacheLeakWarning(Relation rel)\n{\n\telog(WARNING, \"relcache reference leak: relation \\\"%s\\\" not closed\",\n\t\t RelationGetRelationName(rel));\n}"
  },
  {
    "function_name": "ResourceOwnerForgetRelationRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1026-1032",
    "snippet": "void\nResourceOwnerForgetRelationRef(ResourceOwner owner, Relation rel)\n{\n\tif (!ResourceArrayRemove(&(owner->relrefarr), PointerGetDatum(rel)))\n\t\telog(ERROR, \"relcache reference %s is not owned by resource owner %s\",\n\t\t\t RelationGetRelationName(rel), owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintRelCacheLeakWarning(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"relcache reference %s is not owned by resource owner %s\"",
            "RelationGetRelationName(rel)",
            "owner->name"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->relrefarr)",
            "PointerGetDatum(rel)"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "rel"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintRelCacheLeakWarning(Relation rel);\n\nvoid\nResourceOwnerForgetRelationRef(ResourceOwner owner, Relation rel)\n{\n\tif (!ResourceArrayRemove(&(owner->relrefarr), PointerGetDatum(rel)))\n\t\telog(ERROR, \"relcache reference %s is not owned by resource owner %s\",\n\t\t\t RelationGetRelationName(rel), owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberRelationRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1017-1021",
    "snippet": "void\nResourceOwnerRememberRelationRef(ResourceOwner owner, Relation rel)\n{\n\tResourceArrayAdd(&(owner->relrefarr), PointerGetDatum(rel));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintRelCacheLeakWarning(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->relrefarr)",
            "PointerGetDatum(rel)"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "rel"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintRelCacheLeakWarning(Relation rel);\n\nvoid\nResourceOwnerRememberRelationRef(ResourceOwner owner, Relation rel)\n{\n\tResourceArrayAdd(&(owner->relrefarr), PointerGetDatum(rel));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeRelationRefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "1006-1010",
    "snippet": "void\nResourceOwnerEnlargeRelationRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->relrefarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->relrefarr)"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeRelationRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->relrefarr));\n}"
  },
  {
    "function_name": "ResourceOwnerForgetCatCacheListRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "991-997",
    "snippet": "void\nResourceOwnerForgetCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tif (!ResourceArrayRemove(&(owner->catlistrefarr), PointerGetDatum(list)))\n\t\telog(ERROR, \"catcache list reference %p is not owned by resource owner %s\",\n\t\t\t list, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"catcache list reference %p is not owned by resource owner %s\"",
            "list",
            "owner->name"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->catlistrefarr)",
            "PointerGetDatum(list)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "list"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerForgetCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tif (!ResourceArrayRemove(&(owner->catlistrefarr), PointerGetDatum(list)))\n\t\telog(ERROR, \"catcache list reference %p is not owned by resource owner %s\",\n\t\t\t list, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberCatCacheListRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "982-986",
    "snippet": "void\nResourceOwnerRememberCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tResourceArrayAdd(&(owner->catlistrefarr), PointerGetDatum(list));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->catlistrefarr)",
            "PointerGetDatum(list)"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "list"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberCatCacheListRef(ResourceOwner owner, CatCList *list)\n{\n\tResourceArrayAdd(&(owner->catlistrefarr), PointerGetDatum(list));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeCatCacheListRefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "971-975",
    "snippet": "void\nResourceOwnerEnlargeCatCacheListRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catlistrefarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->catlistrefarr)"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeCatCacheListRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catlistrefarr));\n}"
  },
  {
    "function_name": "ResourceOwnerForgetCatCacheRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "956-962",
    "snippet": "void\nResourceOwnerForgetCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tif (!ResourceArrayRemove(&(owner->catrefarr), PointerGetDatum(tuple)))\n\t\telog(ERROR, \"catcache reference %p is not owned by resource owner %s\",\n\t\t\t tuple, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"catcache reference %p is not owned by resource owner %s\"",
            "tuple",
            "owner->name"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->catrefarr)",
            "PointerGetDatum(tuple)"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "tuple"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerForgetCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tif (!ResourceArrayRemove(&(owner->catrefarr), PointerGetDatum(tuple)))\n\t\telog(ERROR, \"catcache reference %p is not owned by resource owner %s\",\n\t\t\t tuple, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberCatCacheRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "947-951",
    "snippet": "void\nResourceOwnerRememberCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tResourceArrayAdd(&(owner->catrefarr), PointerGetDatum(tuple));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->catrefarr)",
            "PointerGetDatum(tuple)"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "tuple"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberCatCacheRef(ResourceOwner owner, HeapTuple tuple)\n{\n\tResourceArrayAdd(&(owner->catrefarr), PointerGetDatum(tuple));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeCatCacheRefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "936-940",
    "snippet": "void\nResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catrefarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->catrefarr)"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->catrefarr));\n}"
  },
  {
    "function_name": "ResourceOwnerForgetLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "907-927",
    "snippet": "void\nResourceOwnerForgetLock(ResourceOwner owner, LOCALLOCK *locallock)\n{\n\tint\t\t\ti;\n\n\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\treturn;\t\t\t\t\t/* we have overflowed */\n\n\tAssert(owner->nlocks > 0);\n\tfor (i = owner->nlocks - 1; i >= 0; i--)\n\t{\n\t\tif (locallock == owner->locks[i])\n\t\t{\n\t\t\towner->locks[i] = owner->locks[owner->nlocks - 1];\n\t\t\towner->nlocks--;\n\t\t\treturn;\n\t\t}\n\t}\n\telog(ERROR, \"lock reference %p is not owned by resource owner %s\",\n\t\t locallock, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_RESOWNER_LOCKS 15"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"lock reference %p is not owned by resource owner %s\"",
            "locallock",
            "owner->name"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->nlocks > 0"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nvoid\nResourceOwnerForgetLock(ResourceOwner owner, LOCALLOCK *locallock)\n{\n\tint\t\t\ti;\n\n\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\treturn;\t\t\t\t\t/* we have overflowed */\n\n\tAssert(owner->nlocks > 0);\n\tfor (i = owner->nlocks - 1; i >= 0; i--)\n\t{\n\t\tif (locallock == owner->locks[i])\n\t\t{\n\t\t\towner->locks[i] = owner->locks[owner->nlocks - 1];\n\t\t\towner->nlocks--;\n\t\t\treturn;\n\t\t}\n\t}\n\telog(ERROR, \"lock reference %p is not owned by resource owner %s\",\n\t\t locallock, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "887-902",
    "snippet": "void\nResourceOwnerRememberLock(ResourceOwner owner, LOCALLOCK *locallock)\n{\n\tAssert(locallock != NULL);\n\n\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\treturn;\t\t\t\t\t/* we have already overflowed */\n\n\tif (owner->nlocks < MAX_RESOWNER_LOCKS)\n\t\towner->locks[owner->nlocks] = locallock;\n\telse\n\t{\n\t\t/* overflowed */\n\t}\n\towner->nlocks++;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_RESOWNER_LOCKS 15"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "locallock != NULL"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nvoid\nResourceOwnerRememberLock(ResourceOwner owner, LOCALLOCK *locallock)\n{\n\tAssert(locallock != NULL);\n\n\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\treturn;\t\t\t\t\t/* we have already overflowed */\n\n\tif (owner->nlocks < MAX_RESOWNER_LOCKS)\n\t\towner->locks[owner->nlocks] = locallock;\n\telse\n\t{\n\t\t/* overflowed */\n\t}\n\towner->nlocks++;\n}"
  },
  {
    "function_name": "ResourceOwnerForgetBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "867-875",
    "snippet": "void\nResourceOwnerForgetBuffer(ResourceOwner owner, Buffer buffer)\n{\n\tif (owner == NULL)\n\t\treturn;\n\tif (!ResourceArrayRemove(&(owner->bufferarr), BufferGetDatum(buffer)))\n\t\telog(ERROR, \"buffer %d is not owned by resource owner %s\",\n\t\t\t buffer, owner->name);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"buffer %d is not owned by resource owner %s\"",
            "buffer",
            "owner->name"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayRemove",
          "args": [
            "&(owner->bufferarr)",
            "BufferGetDatum(buffer)"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "296-354",
          "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufferGetDatum",
          "args": [
            "buffer"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerForgetBuffer(ResourceOwner owner, Buffer buffer)\n{\n\tif (owner == NULL)\n\t\treturn;\n\tif (!ResourceArrayRemove(&(owner->bufferarr), BufferGetDatum(buffer)))\n\t\telog(ERROR, \"buffer %d is not owned by resource owner %s\",\n\t\t\t buffer, owner->name);\n}"
  },
  {
    "function_name": "ResourceOwnerRememberBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "853-859",
    "snippet": "void\nResourceOwnerRememberBuffer(ResourceOwner owner, Buffer buffer)\n{\n\tif (owner == NULL)\n\t\treturn;\n\tResourceArrayAdd(&(owner->bufferarr), BufferGetDatum(buffer));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "&(owner->bufferarr)",
            "BufferGetDatum(buffer)"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufferGetDatum",
          "args": [
            "buffer"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerRememberBuffer(ResourceOwner owner, Buffer buffer)\n{\n\tif (owner == NULL)\n\t\treturn;\n\tResourceArrayAdd(&(owner->bufferarr), BufferGetDatum(buffer));\n}"
  },
  {
    "function_name": "ResourceOwnerEnlargeBuffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "837-843",
    "snippet": "void\nResourceOwnerEnlargeBuffers(ResourceOwner owner)\n{\n\tif (owner == NULL)\n\t\treturn;\n\tResourceArrayEnlarge(&(owner->bufferarr));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayEnlarge",
          "args": [
            "&(owner->bufferarr)"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayEnlarge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "203-251",
          "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RESARRAY_INIT_SIZE 16"
          ],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeBuffers(ResourceOwner owner)\n{\n\tif (owner == NULL)\n\t\treturn;\n\tResourceArrayEnlarge(&(owner->bufferarr));\n}"
  },
  {
    "function_name": "UnregisterResourceReleaseCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "805-824",
    "snippet": "void\nUnregisterResourceReleaseCallback(ResourceReleaseCallback callback, void *arg)\n{\n\tResourceReleaseCallbackItem *item;\n\tResourceReleaseCallbackItem *prev;\n\n\tprev = NULL;\n\tfor (item = ResourceRelease_callbacks; item; prev = item, item = item->next)\n\t{\n\t\tif (item->callback == callback && item->arg == arg)\n\t\t{\n\t\t\tif (prev)\n\t\t\t\tprev->next = item->next;\n\t\t\telse\n\t\t\t\tResourceRelease_callbacks = item->next;\n\t\t\tpfree(item);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "item"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;\n\nvoid\nUnregisterResourceReleaseCallback(ResourceReleaseCallback callback, void *arg)\n{\n\tResourceReleaseCallbackItem *item;\n\tResourceReleaseCallbackItem *prev;\n\n\tprev = NULL;\n\tfor (item = ResourceRelease_callbacks; item; prev = item, item = item->next)\n\t{\n\t\tif (item->callback == callback && item->arg == arg)\n\t\t{\n\t\t\tif (prev)\n\t\t\t\tprev->next = item->next;\n\t\t\telse\n\t\t\t\tResourceRelease_callbacks = item->next;\n\t\t\tpfree(item);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "RegisterResourceReleaseCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "791-803",
    "snippet": "void\nRegisterResourceReleaseCallback(ResourceReleaseCallback callback, void *arg)\n{\n\tResourceReleaseCallbackItem *item;\n\n\titem = (ResourceReleaseCallbackItem *)\n\t\tMemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t   sizeof(ResourceReleaseCallbackItem));\n\titem->callback = callback;\n\titem->arg = arg;\n\titem->next = ResourceRelease_callbacks;\n\tResourceRelease_callbacks = item;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopMemoryContext",
            "sizeof(ResourceReleaseCallbackItem)"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;\n\nvoid\nRegisterResourceReleaseCallback(ResourceReleaseCallback callback, void *arg)\n{\n\tResourceReleaseCallbackItem *item;\n\n\titem = (ResourceReleaseCallbackItem *)\n\t\tMemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t   sizeof(ResourceReleaseCallbackItem));\n\titem->callback = callback;\n\titem->arg = arg;\n\titem->next = ResourceRelease_callbacks;\n\tResourceRelease_callbacks = item;\n}"
  },
  {
    "function_name": "ResourceOwnerNewParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "743-780",
    "snippet": "void\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner != newparent"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}"
  },
  {
    "function_name": "ResourceOwnerGetParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "734-738",
    "snippet": "ResourceOwner\nResourceOwnerGetParent(ResourceOwner owner)\n{\n\treturn owner->parent;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nResourceOwner\nResourceOwnerGetParent(ResourceOwner owner)\n{\n\treturn owner->parent;\n}"
  },
  {
    "function_name": "ResourceOwnerDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "683-729",
    "snippet": "void\nResourceOwnerDelete(ResourceOwner owner)\n{\n\t/* We had better not be deleting CurrentResourceOwner ... */\n\tAssert(owner != CurrentResourceOwner);\n\n\t/* And it better not own any resources, either */\n\tAssert(owner->bufferarr.nitems == 0);\n\tAssert(owner->catrefarr.nitems == 0);\n\tAssert(owner->catlistrefarr.nitems == 0);\n\tAssert(owner->relrefarr.nitems == 0);\n\tAssert(owner->planrefarr.nitems == 0);\n\tAssert(owner->tupdescarr.nitems == 0);\n\tAssert(owner->snapshotarr.nitems == 0);\n\tAssert(owner->filearr.nitems == 0);\n\tAssert(owner->dsmarr.nitems == 0);\n\tAssert(owner->jitarr.nitems == 0);\n\tAssert(owner->nlocks == 0 || owner->nlocks == MAX_RESOWNER_LOCKS + 1);\n\n\t/*\n\t * Delete children.  The recursive call will delink the child from me, so\n\t * just iterate as long as there is a child.\n\t */\n\twhile (owner->firstchild != NULL)\n\t\tResourceOwnerDelete(owner->firstchild);\n\n\t/*\n\t * We delink the owner from its parent before deleting it, so that if\n\t * there's an error we won't have deleted/busted owners still attached to\n\t * the owner tree.  Better a leak than a crash.\n\t */\n\tResourceOwnerNewParent(owner, NULL);\n\n\t/* And free the object. */\n\tResourceArrayFree(&(owner->bufferarr));\n\tResourceArrayFree(&(owner->catrefarr));\n\tResourceArrayFree(&(owner->catlistrefarr));\n\tResourceArrayFree(&(owner->relrefarr));\n\tResourceArrayFree(&(owner->planrefarr));\n\tResourceArrayFree(&(owner->tupdescarr));\n\tResourceArrayFree(&(owner->snapshotarr));\n\tResourceArrayFree(&(owner->filearr));\n\tResourceArrayFree(&(owner->dsmarr));\n\tResourceArrayFree(&(owner->jitarr));\n\n\tpfree(owner);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_RESOWNER_LOCKS 15"
    ],
    "globals_used": [
      "ResourceOwner CurrentResourceOwner = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "owner"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayFree",
          "args": [
            "&(owner->jitarr)"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "397-402",
          "snippet": "static void\nResourceArrayFree(ResourceArray *resarr)\n{\n\tif (resarr->itemsarr)\n\t\tpfree(resarr->itemsarr);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayFree(ResourceArray *resarr)\n{\n\tif (resarr->itemsarr)\n\t\tpfree(resarr->itemsarr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerNewParent",
          "args": [
            "owner",
            "NULL"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerNewParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "743-780",
          "snippet": "void\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerDelete",
          "args": [
            "owner->firstchild"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "683-729",
          "snippet": "void\nResourceOwnerDelete(ResourceOwner owner)\n{\n\t/* We had better not be deleting CurrentResourceOwner ... */\n\tAssert(owner != CurrentResourceOwner);\n\n\t/* And it better not own any resources, either */\n\tAssert(owner->bufferarr.nitems == 0);\n\tAssert(owner->catrefarr.nitems == 0);\n\tAssert(owner->catlistrefarr.nitems == 0);\n\tAssert(owner->relrefarr.nitems == 0);\n\tAssert(owner->planrefarr.nitems == 0);\n\tAssert(owner->tupdescarr.nitems == 0);\n\tAssert(owner->snapshotarr.nitems == 0);\n\tAssert(owner->filearr.nitems == 0);\n\tAssert(owner->dsmarr.nitems == 0);\n\tAssert(owner->jitarr.nitems == 0);\n\tAssert(owner->nlocks == 0 || owner->nlocks == MAX_RESOWNER_LOCKS + 1);\n\n\t/*\n\t * Delete children.  The recursive call will delink the child from me, so\n\t * just iterate as long as there is a child.\n\t */\n\twhile (owner->firstchild != NULL)\n\t\tResourceOwnerDelete(owner->firstchild);\n\n\t/*\n\t * We delink the owner from its parent before deleting it, so that if\n\t * there's an error we won't have deleted/busted owners still attached to\n\t * the owner tree.  Better a leak than a crash.\n\t */\n\tResourceOwnerNewParent(owner, NULL);\n\n\t/* And free the object. */\n\tResourceArrayFree(&(owner->bufferarr));\n\tResourceArrayFree(&(owner->catrefarr));\n\tResourceArrayFree(&(owner->catlistrefarr));\n\tResourceArrayFree(&(owner->relrefarr));\n\tResourceArrayFree(&(owner->planrefarr));\n\tResourceArrayFree(&(owner->tupdescarr));\n\tResourceArrayFree(&(owner->snapshotarr));\n\tResourceArrayFree(&(owner->filearr));\n\tResourceArrayFree(&(owner->dsmarr));\n\tResourceArrayFree(&(owner->jitarr));\n\n\tpfree(owner);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->nlocks == 0 || owner->nlocks == MAX_RESOWNER_LOCKS + 1"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->jitarr.nitems == 0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->dsmarr.nitems == 0"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->filearr.nitems == 0"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->snapshotarr.nitems == 0"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->tupdescarr.nitems == 0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->planrefarr.nitems == 0"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->relrefarr.nitems == 0"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->catlistrefarr.nitems == 0"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->catrefarr.nitems == 0"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->bufferarr.nitems == 0"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner != CurrentResourceOwner"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nResourceOwner CurrentResourceOwner = NULL;\n\nvoid\nResourceOwnerDelete(ResourceOwner owner)\n{\n\t/* We had better not be deleting CurrentResourceOwner ... */\n\tAssert(owner != CurrentResourceOwner);\n\n\t/* And it better not own any resources, either */\n\tAssert(owner->bufferarr.nitems == 0);\n\tAssert(owner->catrefarr.nitems == 0);\n\tAssert(owner->catlistrefarr.nitems == 0);\n\tAssert(owner->relrefarr.nitems == 0);\n\tAssert(owner->planrefarr.nitems == 0);\n\tAssert(owner->tupdescarr.nitems == 0);\n\tAssert(owner->snapshotarr.nitems == 0);\n\tAssert(owner->filearr.nitems == 0);\n\tAssert(owner->dsmarr.nitems == 0);\n\tAssert(owner->jitarr.nitems == 0);\n\tAssert(owner->nlocks == 0 || owner->nlocks == MAX_RESOWNER_LOCKS + 1);\n\n\t/*\n\t * Delete children.  The recursive call will delink the child from me, so\n\t * just iterate as long as there is a child.\n\t */\n\twhile (owner->firstchild != NULL)\n\t\tResourceOwnerDelete(owner->firstchild);\n\n\t/*\n\t * We delink the owner from its parent before deleting it, so that if\n\t * there's an error we won't have deleted/busted owners still attached to\n\t * the owner tree.  Better a leak than a crash.\n\t */\n\tResourceOwnerNewParent(owner, NULL);\n\n\t/* And free the object. */\n\tResourceArrayFree(&(owner->bufferarr));\n\tResourceArrayFree(&(owner->catrefarr));\n\tResourceArrayFree(&(owner->catlistrefarr));\n\tResourceArrayFree(&(owner->relrefarr));\n\tResourceArrayFree(&(owner->planrefarr));\n\tResourceArrayFree(&(owner->tupdescarr));\n\tResourceArrayFree(&(owner->snapshotarr));\n\tResourceArrayFree(&(owner->filearr));\n\tResourceArrayFree(&(owner->dsmarr));\n\tResourceArrayFree(&(owner->jitarr));\n\n\tpfree(owner);\n}"
  },
  {
    "function_name": "ResourceOwnerReleaseInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "483-675",
    "snippet": "static void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_RESOWNER_LOCKS 15"
    ],
    "globals_used": [
      "ResourceOwner CurrentResourceOwner = NULL;",
      "ResourceOwner TopTransactionResourceOwner = NULL;",
      "static ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;",
      "static void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);",
      "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);",
      "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "item->callback",
          "args": [
            "phase",
            "isCommit",
            "isTopLevel",
            "item->arg"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileClose",
          "args": [
            "res"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintFileLeakWarning",
          "args": [
            "res"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "PrintFileLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1218-1223",
          "snippet": "static void\nPrintFileLeakWarning(File file)\n{\n\telog(WARNING, \"temporary file leak: File %d still referenced\",\n\t\t file);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintFileLeakWarning(File file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintFileLeakWarning(File file);\n\nstatic void\nPrintFileLeakWarning(File file)\n{\n\telog(WARNING, \"temporary file leak: File %d still referenced\",\n\t\t file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFile",
          "args": [
            "foundres"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceArrayGetAny",
          "args": [
            "&(owner->filearr)",
            "&foundres"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayGetAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "365-392",
          "snippet": "static bool\nResourceArrayGetAny(ResourceArray *resarr, Datum *value)\n{\n\tif (resarr->nitems == 0)\n\t\treturn false;\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Linear array: just return the first element. */\n\t\tresarr->lastidx = 0;\n\t}\n\telse\n\t{\n\t\t/* Hash: search forward from wherever we were last. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tresarr->lastidx &= mask;\n\t\t\tif (resarr->itemsarr[resarr->lastidx] != resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tresarr->lastidx++;\n\t\t}\n\t}\n\n\t*value = resarr->itemsarr[resarr->lastidx];\n\treturn true;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayGetAny(ResourceArray *resarr, Datum *value)\n{\n\tif (resarr->nitems == 0)\n\t\treturn false;\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Linear array: just return the first element. */\n\t\tresarr->lastidx = 0;\n\t}\n\telse\n\t{\n\t\t/* Hash: search forward from wherever we were last. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tresarr->lastidx &= mask;\n\t\t\tif (resarr->itemsarr[resarr->lastidx] != resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tresarr->lastidx++;\n\t\t}\n\t}\n\n\t*value = resarr->itemsarr[resarr->lastidx];\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnregisterSnapshot",
          "args": [
            "res"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "UnregisterSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "904-911",
          "snippet": "void\nUnregisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tUnregisterSnapshotFromOwner(snapshot, CurrentResourceOwner);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nUnregisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tUnregisterSnapshotFromOwner(snapshot, CurrentResourceOwner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintSnapshotLeakWarning",
          "args": [
            "res"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "PrintSnapshotLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1172-1177",
          "snippet": "static void\nPrintSnapshotLeakWarning(Snapshot snapshot)\n{\n\telog(WARNING, \"Snapshot reference leak: Snapshot %p still referenced\",\n\t\t snapshot);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nstatic void\nPrintSnapshotLeakWarning(Snapshot snapshot)\n{\n\telog(WARNING, \"Snapshot reference leak: Snapshot %p still referenced\",\n\t\t snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecrTupleDescRefCount",
          "args": [
            "res"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintTupleDescLeakWarning",
          "args": [
            "res"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "PrintTupleDescLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1126-1132",
          "snippet": "static void\nPrintTupleDescLeakWarning(TupleDesc tupdesc)\n{\n\telog(WARNING,\n\t\t \"TupleDesc reference leak: TupleDesc %p (%u,%d) still referenced\",\n\t\t tupdesc, tupdesc->tdtypeid, tupdesc->tdtypmod);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\n\nstatic void\nPrintTupleDescLeakWarning(TupleDesc tupdesc)\n{\n\telog(WARNING,\n\t\t \"TupleDesc reference leak: TupleDesc %p (%u,%d) still referenced\",\n\t\t tupdesc, tupdesc->tdtypeid, tupdesc->tdtypmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseCachedPlan",
          "args": [
            "res",
            "true"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1257-1277",
          "snippet": "void\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintPlanCacheLeakWarning",
          "args": [
            "res"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "PrintPlanCacheLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1082-1086",
          "snippet": "static void\nPrintPlanCacheLeakWarning(CachedPlan *plan)\n{\n\telog(WARNING, \"plancache reference leak: plan %p not closed\", plan);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintPlanCacheLeakWarning(CachedPlan *plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintPlanCacheLeakWarning(CachedPlan *plan);\n\nstatic void\nPrintPlanCacheLeakWarning(CachedPlan *plan)\n{\n\telog(WARNING, \"plancache reference leak: plan %p not closed\", plan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseCatCacheList",
          "args": [
            "res"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseCatCacheList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "1799-1814",
          "snippet": "void\nReleaseCatCacheList(CatCList *list)\n{\n\t/* Safety checks to ensure we were handed a cache entry */\n\tAssert(list->cl_magic == CL_MAGIC);\n\tAssert(list->refcount > 0);\n\tlist->refcount--;\n\tResourceOwnerForgetCatCacheListRef(CurrentResourceOwner, list);\n\n\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\tlist->dead &&\n#endif\n\t\tlist->refcount == 0)\n\t\tCatCacheRemoveCList(list->my_cache, list);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nReleaseCatCacheList(CatCList *list)\n{\n\t/* Safety checks to ensure we were handed a cache entry */\n\tAssert(list->cl_magic == CL_MAGIC);\n\tAssert(list->refcount > 0);\n\tlist->refcount--;\n\tResourceOwnerForgetCatCacheListRef(CurrentResourceOwner, list);\n\n\tif (\n#ifndef CATCACHE_FORCE_RELEASE\n\t\tlist->dead &&\n#endif\n\t\tlist->refcount == 0)\n\t\tCatCacheRemoveCList(list->my_cache, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintCatCacheListLeakWarning",
          "args": [
            "res"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintCatCacheLeakWarning",
          "args": [
            "res"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2098-2112",
          "snippet": "void\nPrintCatCacheLeakWarning(HeapTuple tuple)\n{\n\tCatCTup    *ct = (CatCTup *) (((char *) tuple) -\n\t\t\t\t\t\t\t\t  offsetof(CatCTup, tuple));\n\n\t/* Safety check to ensure we were handed a cache entry */\n\tAssert(ct->ct_magic == CT_MAGIC);\n\n\telog(WARNING, \"cache reference leak: cache %s (%d), tuple %u/%u has count %d\",\n\t\t ct->my_cache->cc_relname, ct->my_cache->id,\n\t\t ItemPointerGetBlockNumber(&(tuple->t_self)),\n\t\t ItemPointerGetOffsetNumber(&(tuple->t_self)),\n\t\t ct->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatCacheRemoveCTup(CatCache *cache, CatCTup *ct);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheLeakWarning(HeapTuple tuple)\n{\n\tCatCTup    *ct = (CatCTup *) (((char *) tuple) -\n\t\t\t\t\t\t\t\t  offsetof(CatCTup, tuple));\n\n\t/* Safety check to ensure we were handed a cache entry */\n\tAssert(ct->ct_magic == CT_MAGIC);\n\n\telog(WARNING, \"cache reference leak: cache %s (%d), tuple %u/%u has count %d\",\n\t\t ct->my_cache->cc_relname, ct->my_cache->id,\n\t\t ItemPointerGetBlockNumber(&(tuple->t_self)),\n\t\t ItemPointerGetOffsetNumber(&(tuple->t_self)),\n\t\t ct->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockReleaseCurrentOwner",
          "args": [
            "locks",
            "nlocks"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockReassignCurrentOwner",
          "args": [
            "locks",
            "nlocks"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "owner->parent != NULL"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleasePredicateLocks",
          "args": [
            "isCommit"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcReleaseLocks",
          "args": [
            "isCommit"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jit_release_context",
          "args": [
            "context"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "foundres"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_detach",
          "args": [
            "res"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintDSMLeakWarning",
          "args": [
            "res"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "PrintDSMLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1263-1268",
          "snippet": "static void\nPrintDSMLeakWarning(dsm_segment *seg)\n{\n\telog(WARNING, \"dynamic shared memory leak: segment %u still referenced\",\n\t\t dsm_segment_handle(seg));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintDSMLeakWarning(dsm_segment *seg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintDSMLeakWarning(dsm_segment *seg);\n\nstatic void\nPrintDSMLeakWarning(dsm_segment *seg)\n{\n\telog(WARNING, \"dynamic shared memory leak: segment %u still referenced\",\n\t\t dsm_segment_handle(seg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationClose",
          "args": [
            "res"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCloseSmgrByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2776-2787",
          "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintRelCacheLeakWarning",
          "args": [
            "res"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "PrintRelCacheLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1037-1042",
          "snippet": "static void\nPrintRelCacheLeakWarning(Relation rel)\n{\n\telog(WARNING, \"relcache reference leak: relation \\\"%s\\\" not closed\",\n\t\t RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintRelCacheLeakWarning(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintRelCacheLeakWarning(Relation rel);\n\nstatic void\nPrintRelCacheLeakWarning(Relation rel)\n{\n\telog(WARNING, \"relcache reference leak: relation \\\"%s\\\" not closed\",\n\t\t RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "foundres"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseBuffer",
          "args": [
            "res"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintBufferLeakWarning",
          "args": [
            "res"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBuffer",
          "args": [
            "foundres"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerReleaseInternal",
          "args": [
            "child",
            "phase",
            "isCommit",
            "isTopLevel"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerReleaseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "483-675",
          "snippet": "static void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nResourceOwner CurrentResourceOwner = NULL;\nResourceOwner TopTransactionResourceOwner = NULL;\nstatic ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;\nstatic void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nstatic void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}"
  },
  {
    "function_name": "ResourceOwnerRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "473-481",
    "snippet": "void\nResourceOwnerRelease(ResourceOwner owner,\n\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t bool isCommit,\n\t\t\t\t\t bool isTopLevel)\n{\n\t/* There's not currently any setup needed before recursing */\n\tResourceOwnerReleaseInternal(owner, phase, isCommit, isTopLevel);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceOwnerReleaseInternal",
          "args": [
            "owner",
            "phase",
            "isCommit",
            "isTopLevel"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerReleaseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "483-675",
          "snippet": "static void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RESOWNER_LOCKS 15"
          ],
          "globals_used": [
            "ResourceOwner CurrentResourceOwner = NULL;",
            "ResourceOwner TopTransactionResourceOwner = NULL;",
            "static ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;",
            "static void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);",
            "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);",
            "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nResourceOwner CurrentResourceOwner = NULL;\nResourceOwner TopTransactionResourceOwner = NULL;\nstatic ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;\nstatic void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nstatic void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);\n\nvoid\nResourceOwnerRelease(ResourceOwner owner,\n\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t bool isCommit,\n\t\t\t\t\t bool isTopLevel)\n{\n\t/* There's not currently any setup needed before recursing */\n\tResourceOwnerReleaseInternal(owner, phase, isCommit, isTopLevel);\n}"
  },
  {
    "function_name": "ResourceOwnerCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "417-445",
    "snippet": "ResourceOwner\nResourceOwnerCreate(ResourceOwner parent, const char *name)\n{\n\tResourceOwner owner;\n\n\towner = (ResourceOwner) MemoryContextAllocZero(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ResourceOwnerData));\n\towner->name = name;\n\n\tif (parent)\n\t{\n\t\towner->parent = parent;\n\t\towner->nextchild = parent->firstchild;\n\t\tparent->firstchild = owner;\n\t}\n\n\tResourceArrayInit(&(owner->bufferarr), BufferGetDatum(InvalidBuffer));\n\tResourceArrayInit(&(owner->catrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->catlistrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->relrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->planrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->tupdescarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->snapshotarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->filearr), FileGetDatum(-1));\n\tResourceArrayInit(&(owner->dsmarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->jitarr), PointerGetDatum(NULL));\n\n\treturn owner;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceArrayInit",
          "args": [
            "&(owner->jitarr)",
            "PointerGetDatum(NULL)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "184-195",
          "snippet": "static void\nResourceArrayInit(ResourceArray *resarr, Datum invalidval)\n{\n\t/* Assert it's empty */\n\tAssert(resarr->itemsarr == NULL);\n\tAssert(resarr->capacity == 0);\n\tAssert(resarr->nitems == 0);\n\tAssert(resarr->maxitems == 0);\n\t/* Remember the appropriate \"invalid\" value */\n\tresarr->invalidval = invalidval;\n\t/* We don't allocate any storage until needed */\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayInit(ResourceArray *resarr, Datum invalidval)\n{\n\t/* Assert it's empty */\n\tAssert(resarr->itemsarr == NULL);\n\tAssert(resarr->capacity == 0);\n\tAssert(resarr->nitems == 0);\n\tAssert(resarr->maxitems == 0);\n\t/* Remember the appropriate \"invalid\" value */\n\tresarr->invalidval = invalidval;\n\t/* We don't allocate any storage until needed */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileGetDatum",
          "args": [
            "-1"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufferGetDatum",
          "args": [
            "InvalidBuffer"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "TopMemoryContext",
            "sizeof(ResourceOwnerData)"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nResourceOwner\nResourceOwnerCreate(ResourceOwner parent, const char *name)\n{\n\tResourceOwner owner;\n\n\towner = (ResourceOwner) MemoryContextAllocZero(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ResourceOwnerData));\n\towner->name = name;\n\n\tif (parent)\n\t{\n\t\towner->parent = parent;\n\t\towner->nextchild = parent->firstchild;\n\t\tparent->firstchild = owner;\n\t}\n\n\tResourceArrayInit(&(owner->bufferarr), BufferGetDatum(InvalidBuffer));\n\tResourceArrayInit(&(owner->catrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->catlistrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->relrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->planrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->tupdescarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->snapshotarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->filearr), FileGetDatum(-1));\n\tResourceArrayInit(&(owner->dsmarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->jitarr), PointerGetDatum(NULL));\n\n\treturn owner;\n}"
  },
  {
    "function_name": "ResourceArrayFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "397-402",
    "snippet": "static void\nResourceArrayFree(ResourceArray *resarr)\n{\n\tif (resarr->itemsarr)\n\t\tpfree(resarr->itemsarr);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ResourceArrayEnlarge(ResourceArray *resarr);",
      "static void ResourceArrayFree(ResourceArray *resarr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "resarr->itemsarr"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayFree(ResourceArray *resarr)\n{\n\tif (resarr->itemsarr)\n\t\tpfree(resarr->itemsarr);\n}"
  },
  {
    "function_name": "ResourceArrayGetAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "365-392",
    "snippet": "static bool\nResourceArrayGetAny(ResourceArray *resarr, Datum *value)\n{\n\tif (resarr->nitems == 0)\n\t\treturn false;\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Linear array: just return the first element. */\n\t\tresarr->lastidx = 0;\n\t}\n\telse\n\t{\n\t\t/* Hash: search forward from wherever we were last. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tresarr->lastidx &= mask;\n\t\t\tif (resarr->itemsarr[resarr->lastidx] != resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tresarr->lastidx++;\n\t\t}\n\t}\n\n\t*value = resarr->itemsarr[resarr->lastidx];\n\treturn true;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
      "static void ResourceArrayEnlarge(ResourceArray *resarr);",
      "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
      "static void ResourceArrayFree(ResourceArray *resarr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RESARRAY_IS_ARRAY",
          "args": [
            "resarr"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayGetAny(ResourceArray *resarr, Datum *value)\n{\n\tif (resarr->nitems == 0)\n\t\treturn false;\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Linear array: just return the first element. */\n\t\tresarr->lastidx = 0;\n\t}\n\telse\n\t{\n\t\t/* Hash: search forward from wherever we were last. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tresarr->lastidx &= mask;\n\t\t\tif (resarr->itemsarr[resarr->lastidx] != resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tresarr->lastidx++;\n\t\t}\n\t}\n\n\t*value = resarr->itemsarr[resarr->lastidx];\n\treturn true;\n}"
  },
  {
    "function_name": "ResourceArrayRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "296-354",
    "snippet": "static bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
      "static void ResourceArrayEnlarge(ResourceArray *resarr);",
      "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
      "static void ResourceArrayFree(ResourceArray *resarr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_any((void *) &value, sizeof(value))"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(void *) &value",
            "sizeof(value)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESARRAY_IS_ARRAY",
          "args": [
            "resarr"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "value != resarr->invalidval"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic bool\nResourceArrayRemove(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\ti,\n\t\t\t\tidx,\n\t\t\t\tlastidx = resarr->lastidx;\n\n\tAssert(value != resarr->invalidval);\n\n\t/* Search through all items, but try lastidx first. */\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\tif (lastidx < resarr->nitems &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\tresarr->nitems--;\n\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (i = 0; i < resarr->nitems; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[i] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[i] = resarr->itemsarr[resarr->nitems - 1];\n\t\t\t\tresarr->nitems--;\n\t\t\t\t/* Update lastidx to make reverse-order removals fast. */\n\t\t\t\tresarr->lastidx = resarr->nitems - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tif (lastidx < resarr->capacity &&\n\t\t\tresarr->itemsarr[lastidx] == value)\n\t\t{\n\t\t\tresarr->itemsarr[lastidx] = resarr->invalidval;\n\t\t\tresarr->nitems--;\n\t\t\treturn true;\n\t\t}\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (i = 0; i < resarr->capacity; i++)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == value)\n\t\t\t{\n\t\t\t\tresarr->itemsarr[idx] = resarr->invalidval;\n\t\t\t\tresarr->nitems--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "ResourceArrayAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "258-287",
    "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
      "static void ResourceArrayEnlarge(ResourceArray *resarr);",
      "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
      "static void ResourceArrayFree(ResourceArray *resarr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_any((void *) &value, sizeof(value))"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(void *) &value",
            "sizeof(value)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESARRAY_IS_ARRAY",
          "args": [
            "resarr"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resarr->nitems < resarr->maxitems"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "value != resarr->invalidval"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
  },
  {
    "function_name": "ResourceArrayEnlarge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "203-251",
    "snippet": "static void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RESARRAY_INIT_SIZE 16"
    ],
    "globals_used": [
      "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
      "static void ResourceArrayEnlarge(ResourceArray *resarr);",
      "static void ResourceArrayFree(ResourceArray *resarr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resarr->nitems < resarr->maxitems"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "olditemsarr"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceArrayAdd",
          "args": [
            "resarr",
            "olditemsarr[i]"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceArrayAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "258-287",
          "snippet": "static void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
            "static void ResourceArrayEnlarge(ResourceArray *resarr);",
            "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
            "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
            "static void ResourceArrayFree(ResourceArray *resarr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayAdd(ResourceArray *resarr, Datum value)\n{\n\tuint32\t\tidx;\n\n\tAssert(value != resarr->invalidval);\n\tAssert(resarr->nitems < resarr->maxitems);\n\n\tif (RESARRAY_IS_ARRAY(resarr))\n\t{\n\t\t/* Append to linear array. */\n\t\tidx = resarr->nitems;\n\t}\n\telse\n\t{\n\t\t/* Insert into first free slot at or after hash location. */\n\t\tuint32\t\tmask = resarr->capacity - 1;\n\n\t\tidx = DatumGetUInt32(hash_any((void *) &value, sizeof(value))) & mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (resarr->itemsarr[idx] == resarr->invalidval)\n\t\t\t\tbreak;\n\t\t\tidx = (idx + 1) & mask;\n\t\t}\n\t}\n\tresarr->lastidx = idx;\n\tresarr->itemsarr[idx] = value;\n\tresarr->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RESARRAY_MAX_ITEMS",
          "args": [
            "newcap"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopMemoryContext",
            "newcap * sizeof(Datum)"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RESARRAY_INIT_SIZE 16\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayEnlarge(ResourceArray *resarr)\n{\n\tuint32\t\ti,\n\t\t\t\toldcap,\n\t\t\t\tnewcap;\n\tDatum\t   *olditemsarr;\n\tDatum\t   *newitemsarr;\n\n\tif (resarr->nitems < resarr->maxitems)\n\t\treturn;\t\t\t\t\t/* no work needed */\n\n\tolditemsarr = resarr->itemsarr;\n\toldcap = resarr->capacity;\n\n\t/* Double the capacity of the array (capacity must stay a power of 2!) */\n\tnewcap = (oldcap > 0) ? oldcap * 2 : RESARRAY_INIT_SIZE;\n\tnewitemsarr = (Datum *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   newcap * sizeof(Datum));\n\tfor (i = 0; i < newcap; i++)\n\t\tnewitemsarr[i] = resarr->invalidval;\n\n\t/* We assume we can't fail below this point, so OK to scribble on resarr */\n\tresarr->itemsarr = newitemsarr;\n\tresarr->capacity = newcap;\n\tresarr->maxitems = RESARRAY_MAX_ITEMS(newcap);\n\tresarr->nitems = 0;\n\n\tif (olditemsarr != NULL)\n\t{\n\t\t/*\n\t\t * Transfer any pre-existing entries into the new array; they don't\n\t\t * necessarily go where they were before, so this simple logic is the\n\t\t * best way.  Note that if we were managing the set as a simple array,\n\t\t * the entries after nitems are garbage, but that shouldn't matter\n\t\t * because we won't get here unless nitems was equal to oldcap.\n\t\t */\n\t\tfor (i = 0; i < oldcap; i++)\n\t\t{\n\t\t\tif (olditemsarr[i] != resarr->invalidval)\n\t\t\t\tResourceArrayAdd(resarr, olditemsarr[i]);\n\t\t}\n\n\t\t/* And release old array. */\n\t\tpfree(olditemsarr);\n\t}\n\n\tAssert(resarr->nitems < resarr->maxitems);\n}"
  },
  {
    "function_name": "ResourceArrayInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
    "lines": "184-195",
    "snippet": "static void\nResourceArrayInit(ResourceArray *resarr, Datum invalidval)\n{\n\t/* Assert it's empty */\n\tAssert(resarr->itemsarr == NULL);\n\tAssert(resarr->capacity == 0);\n\tAssert(resarr->nitems == 0);\n\tAssert(resarr->maxitems == 0);\n\t/* Remember the appropriate \"invalid\" value */\n\tresarr->invalidval = invalidval;\n\t/* We don't allocate any storage until needed */\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"jit/jit.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);",
      "static void ResourceArrayEnlarge(ResourceArray *resarr);",
      "static void ResourceArrayAdd(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayRemove(ResourceArray *resarr, Datum value);",
      "static bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);",
      "static void ResourceArrayFree(ResourceArray *resarr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resarr->maxitems == 0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resarr->nitems == 0"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resarr->capacity == 0"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resarr->itemsarr == NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void ResourceArrayInit(ResourceArray *resarr, Datum invalidval);\nstatic void ResourceArrayEnlarge(ResourceArray *resarr);\nstatic void ResourceArrayAdd(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayRemove(ResourceArray *resarr, Datum value);\nstatic bool ResourceArrayGetAny(ResourceArray *resarr, Datum *value);\nstatic void ResourceArrayFree(ResourceArray *resarr);\n\nstatic void\nResourceArrayInit(ResourceArray *resarr, Datum invalidval)\n{\n\t/* Assert it's empty */\n\tAssert(resarr->itemsarr == NULL);\n\tAssert(resarr->capacity == 0);\n\tAssert(resarr->nitems == 0);\n\tAssert(resarr->maxitems == 0);\n\t/* Remember the appropriate \"invalid\" value */\n\tresarr->invalidval = invalidval;\n\t/* We don't allocate any storage until needed */\n}"
  }
]