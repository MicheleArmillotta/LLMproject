[
  {
    "function_name": "check_domain_for_new_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1579-1637",
    "snippet": "static pg_noinline void\ncheck_domain_for_new_tuple(ExpandedRecordHeader *erh, HeapTuple tuple)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* If we're being told to set record to empty, just see if NULL is OK */\n\tif (tuple == NULL)\n\t{\n\t\t/* We run domain_check in a short-lived context to limit cruft */\n\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\n\t\tdomain_check((Datum) 0, true,\n\t\t\t\t\t erh->er_decltypeid,\n\t\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t\t erh->hdr.eoh_context);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We might as well clean up cruft immediately. */\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\treturn;\n\t}\n\n\t/* Construct dummy header to contain replacement tuple */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/* Insert tuple, but don't bother to deconstruct its fields for now */\n\tdummy_erh->fvalue = tuple;\n\tdummy_erh->fstartptr = (char *) tuple->t_data;\n\tdummy_erh->fendptr = ((char *) tuple->t_data) + tuple->t_len;\n\tdummy_erh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Remember if we have any out-of-line field values */\n\tif (HeapTupleHasExternal(tuple))\n\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_check",
          "args": [
            "ExpandedRecordGetRODatum(dummy_erh)",
            "false",
            "erh->er_decltypeid",
            "&erh->er_domaininfo",
            "erh->hdr.eoh_context"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "326-353",
          "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExpandedRecordGetRODatum",
          "args": [
            "dummy_erh"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHasExternal",
          "args": [
            "tuple"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_dummy_expanded_header",
          "args": [
            "erh"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "build_dummy_expanded_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1405-1492",
          "snippet": "static void\nbuild_dummy_expanded_header(ExpandedRecordHeader *main_erh)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(main_erh);\n\n\t/* Ensure we have a short-lived context */\n\t(void) get_short_term_cxt(main_erh);\n\n\t/*\n\t * Allocate dummy header on first time through, or in the unlikely event\n\t * that the number of fields changes (in which case we just leak the old\n\t * one).  Include space for its field values in the request.\n\t */\n\terh = main_erh->er_dummy_header;\n\tif (erh == NULL || erh->nfields != tupdesc->natts)\n\t{\n\t\tchar\t   *chunk;\n\n\t\terh = (ExpandedRecordHeader *)\n\t\t\tMemoryContextAlloc(main_erh->hdr.eoh_context,\n\t\t\t\t\t\t\t   MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t\t/* Ensure all header fields are initialized to 0/null */\n\t\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\t\t/*\n\t\t * We set up the dummy header with an indication that its memory\n\t\t * context is the short-lived context.  This is so that, if any\n\t\t * detoasting of out-of-line values happens due to an attempt to\n\t\t * extract a composite datum from the dummy header, the detoasted\n\t\t * stuff will end up in the short-lived context and not cause a leak.\n\t\t * This is cheating a bit on the expanded-object protocol; but since\n\t\t * we never pass a R/W pointer to the dummy object to any other code,\n\t\t * nothing else is authorized to delete or transfer ownership of the\n\t\t * object's context, so it should be safe enough.\n\t\t */\n\t\tEOH_init_header(&erh->hdr, &ER_methods, main_erh->er_short_term_cxt);\n\t\terh->er_magic = ER_MAGIC;\n\n\t\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\t\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\t\terh->dvalues = (Datum *) chunk;\n\t\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\t\terh->nfields = tupdesc->natts;\n\n\t\t/*\n\t\t * The fields we just set are assumed to remain constant through\n\t\t * multiple uses of the dummy header to check domain constraints.  All\n\t\t * other dummy header fields should be explicitly reset below, to\n\t\t * ensure there's not accidental effects of one check on the next one.\n\t\t */\n\n\t\tmain_erh->er_dummy_header = erh;\n\t}\n\n\t/*\n\t * If anything inquires about the dummy header's declared type, it should\n\t * report the composite base type, not the domain type (since the VALUE in\n\t * a domain check constraint is of the base type not the domain).  Hence\n\t * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main\n\t * header's flags, since the dummy header is empty of data at this point.\n\t * But don't forget to mark header as dummy.\n\t */\n\terh->flags = ER_FLAG_IS_DUMMY;\n\n\t/* Copy composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = main_erh->er_typeid;\n\terh->er_typmod = main_erh->er_typmod;\n\n\t/* Dummy header does not need its own tupdesc refcount */\n\terh->er_tupdesc = tupdesc;\n\terh->er_tupdesc_id = main_erh->er_tupdesc_id;\n\n\t/*\n\t * It's tempting to copy over whatever we know about the flat size, but\n\t * there's no point since we're surely about to modify the dummy record's\n\t * field(s).  Instead just clear anything left over from a previous usage\n\t * cycle.\n\t */\n\terh->flat_size = 0;\n\n\t/* Copy over fvalue if we have it, so that system columns are available */\n\terh->fvalue = main_erh->fvalue;\n\terh->fstartptr = main_erh->fstartptr;\n\terh->fendptr = main_erh->fendptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static void build_dummy_expanded_header(ExpandedRecordHeader *main_erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic void build_dummy_expanded_header(ExpandedRecordHeader *main_erh);\n\nstatic void\nbuild_dummy_expanded_header(ExpandedRecordHeader *main_erh)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(main_erh);\n\n\t/* Ensure we have a short-lived context */\n\t(void) get_short_term_cxt(main_erh);\n\n\t/*\n\t * Allocate dummy header on first time through, or in the unlikely event\n\t * that the number of fields changes (in which case we just leak the old\n\t * one).  Include space for its field values in the request.\n\t */\n\terh = main_erh->er_dummy_header;\n\tif (erh == NULL || erh->nfields != tupdesc->natts)\n\t{\n\t\tchar\t   *chunk;\n\n\t\terh = (ExpandedRecordHeader *)\n\t\t\tMemoryContextAlloc(main_erh->hdr.eoh_context,\n\t\t\t\t\t\t\t   MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t\t/* Ensure all header fields are initialized to 0/null */\n\t\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\t\t/*\n\t\t * We set up the dummy header with an indication that its memory\n\t\t * context is the short-lived context.  This is so that, if any\n\t\t * detoasting of out-of-line values happens due to an attempt to\n\t\t * extract a composite datum from the dummy header, the detoasted\n\t\t * stuff will end up in the short-lived context and not cause a leak.\n\t\t * This is cheating a bit on the expanded-object protocol; but since\n\t\t * we never pass a R/W pointer to the dummy object to any other code,\n\t\t * nothing else is authorized to delete or transfer ownership of the\n\t\t * object's context, so it should be safe enough.\n\t\t */\n\t\tEOH_init_header(&erh->hdr, &ER_methods, main_erh->er_short_term_cxt);\n\t\terh->er_magic = ER_MAGIC;\n\n\t\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\t\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\t\terh->dvalues = (Datum *) chunk;\n\t\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\t\terh->nfields = tupdesc->natts;\n\n\t\t/*\n\t\t * The fields we just set are assumed to remain constant through\n\t\t * multiple uses of the dummy header to check domain constraints.  All\n\t\t * other dummy header fields should be explicitly reset below, to\n\t\t * ensure there's not accidental effects of one check on the next one.\n\t\t */\n\n\t\tmain_erh->er_dummy_header = erh;\n\t}\n\n\t/*\n\t * If anything inquires about the dummy header's declared type, it should\n\t * report the composite base type, not the domain type (since the VALUE in\n\t * a domain check constraint is of the base type not the domain).  Hence\n\t * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main\n\t * header's flags, since the dummy header is empty of data at this point.\n\t * But don't forget to mark header as dummy.\n\t */\n\terh->flags = ER_FLAG_IS_DUMMY;\n\n\t/* Copy composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = main_erh->er_typeid;\n\terh->er_typmod = main_erh->er_typmod;\n\n\t/* Dummy header does not need its own tupdesc refcount */\n\terh->er_tupdesc = tupdesc;\n\terh->er_tupdesc_id = main_erh->er_tupdesc_id;\n\n\t/*\n\t * It's tempting to copy over whatever we know about the flat size, but\n\t * there's no point since we're surely about to modify the dummy record's\n\t * field(s).  Instead just clear anything left over from a previous usage\n\t * cycle.\n\t */\n\terh->flat_size = 0;\n\n\t/* Copy over fvalue if we have it, so that system columns are available */\n\terh->fvalue = main_erh->fvalue;\n\terh->fstartptr = main_erh->fstartptr;\n\terh->fendptr = main_erh->fendptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "get_short_term_cxt(erh)"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_short_term_cxt",
          "args": [
            "erh"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "get_short_term_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1382-1393",
          "snippet": "static MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nstatic pg_noinline void\ncheck_domain_for_new_tuple(ExpandedRecordHeader *erh, HeapTuple tuple)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* If we're being told to set record to empty, just see if NULL is OK */\n\tif (tuple == NULL)\n\t{\n\t\t/* We run domain_check in a short-lived context to limit cruft */\n\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\n\t\tdomain_check((Datum) 0, true,\n\t\t\t\t\t erh->er_decltypeid,\n\t\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t\t erh->hdr.eoh_context);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We might as well clean up cruft immediately. */\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\treturn;\n\t}\n\n\t/* Construct dummy header to contain replacement tuple */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/* Insert tuple, but don't bother to deconstruct its fields for now */\n\tdummy_erh->fvalue = tuple;\n\tdummy_erh->fstartptr = (char *) tuple->t_data;\n\tdummy_erh->fendptr = ((char *) tuple->t_data) + tuple->t_len;\n\tdummy_erh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Remember if we have any out-of-line field values */\n\tif (HeapTupleHasExternal(tuple))\n\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}"
  },
  {
    "function_name": "check_domain_for_new_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1497-1574",
    "snippet": "static pg_noinline void\ncheck_domain_for_new_field(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* Construct dummy header to contain proposed new field set */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/*\n\t * If record isn't empty, just deconstruct it (if needed) and copy over\n\t * the existing field values.  If it is empty, just fill fields with nulls\n\t * manually --- don't call deconstruct_expanded_record prematurely.\n\t */\n\tif (!ExpandedRecordIsEmpty(erh))\n\t{\n\t\tdeconstruct_expanded_record(erh);\n\t\tmemcpy(dummy_erh->dvalues, erh->dvalues,\n\t\t\t   dummy_erh->nfields * sizeof(Datum));\n\t\tmemcpy(dummy_erh->dnulls, erh->dnulls,\n\t\t\t   dummy_erh->nfields * sizeof(bool));\n\t\t/* There might be some external values in there... */\n\t\tdummy_erh->flags |= erh->flags & ER_FLAG_HAVE_EXTERNAL;\n\t}\n\telse\n\t{\n\t\tmemset(dummy_erh->dvalues, 0, dummy_erh->nfields * sizeof(Datum));\n\t\tmemset(dummy_erh->dnulls, true, dummy_erh->nfields * sizeof(bool));\n\t}\n\n\t/* Either way, we now have valid dvalues */\n\tdummy_erh->flags |= ER_FLAG_DVALUES_VALID;\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > dummy_erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/* Insert proposed new value into dummy field array */\n\tdummy_erh->dvalues[fnumber - 1] = newValue;\n\tdummy_erh->dnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * The proposed new value might be external, in which case we'd better set\n\t * the flag for that in dummy_erh.  (This matters in case something in the\n\t * domain check expressions tries to extract a flat value from the dummy\n\t * header.)\n\t */\n\tif (!isnull)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(erh->er_tupdesc, fnumber - 1);\n\n\t\tif (!attr->attbyval && attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_check",
          "args": [
            "ExpandedRecordGetRODatum(dummy_erh)",
            "false",
            "erh->er_decltypeid",
            "&erh->er_domaininfo",
            "erh->hdr.eoh_context"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "326-353",
          "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExpandedRecordGetRODatum",
          "args": [
            "dummy_erh"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(newValue)"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "erh->er_tupdesc",
            "fnumber - 1"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot assign to field %d of expanded record\"",
            "fnumber"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fnumber <= 0 || fnumber > dummy_erh->nfields"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dummy_erh->dnulls",
            "true",
            "dummy_erh->nfields * sizeof(bool)"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dummy_erh->dvalues",
            "0",
            "dummy_erh->nfields * sizeof(Datum)"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dummy_erh->dnulls",
            "erh->dnulls",
            "dummy_erh->nfields * sizeof(bool)"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dummy_erh->dvalues",
            "erh->dvalues",
            "dummy_erh->nfields * sizeof(Datum)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_record",
          "args": [
            "erh"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "956-1013",
          "snippet": "void\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExpandedRecordIsEmpty",
          "args": [
            "erh"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_dummy_expanded_header",
          "args": [
            "erh"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "build_dummy_expanded_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1405-1492",
          "snippet": "static void\nbuild_dummy_expanded_header(ExpandedRecordHeader *main_erh)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(main_erh);\n\n\t/* Ensure we have a short-lived context */\n\t(void) get_short_term_cxt(main_erh);\n\n\t/*\n\t * Allocate dummy header on first time through, or in the unlikely event\n\t * that the number of fields changes (in which case we just leak the old\n\t * one).  Include space for its field values in the request.\n\t */\n\terh = main_erh->er_dummy_header;\n\tif (erh == NULL || erh->nfields != tupdesc->natts)\n\t{\n\t\tchar\t   *chunk;\n\n\t\terh = (ExpandedRecordHeader *)\n\t\t\tMemoryContextAlloc(main_erh->hdr.eoh_context,\n\t\t\t\t\t\t\t   MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t\t/* Ensure all header fields are initialized to 0/null */\n\t\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\t\t/*\n\t\t * We set up the dummy header with an indication that its memory\n\t\t * context is the short-lived context.  This is so that, if any\n\t\t * detoasting of out-of-line values happens due to an attempt to\n\t\t * extract a composite datum from the dummy header, the detoasted\n\t\t * stuff will end up in the short-lived context and not cause a leak.\n\t\t * This is cheating a bit on the expanded-object protocol; but since\n\t\t * we never pass a R/W pointer to the dummy object to any other code,\n\t\t * nothing else is authorized to delete or transfer ownership of the\n\t\t * object's context, so it should be safe enough.\n\t\t */\n\t\tEOH_init_header(&erh->hdr, &ER_methods, main_erh->er_short_term_cxt);\n\t\terh->er_magic = ER_MAGIC;\n\n\t\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\t\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\t\terh->dvalues = (Datum *) chunk;\n\t\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\t\terh->nfields = tupdesc->natts;\n\n\t\t/*\n\t\t * The fields we just set are assumed to remain constant through\n\t\t * multiple uses of the dummy header to check domain constraints.  All\n\t\t * other dummy header fields should be explicitly reset below, to\n\t\t * ensure there's not accidental effects of one check on the next one.\n\t\t */\n\n\t\tmain_erh->er_dummy_header = erh;\n\t}\n\n\t/*\n\t * If anything inquires about the dummy header's declared type, it should\n\t * report the composite base type, not the domain type (since the VALUE in\n\t * a domain check constraint is of the base type not the domain).  Hence\n\t * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main\n\t * header's flags, since the dummy header is empty of data at this point.\n\t * But don't forget to mark header as dummy.\n\t */\n\terh->flags = ER_FLAG_IS_DUMMY;\n\n\t/* Copy composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = main_erh->er_typeid;\n\terh->er_typmod = main_erh->er_typmod;\n\n\t/* Dummy header does not need its own tupdesc refcount */\n\terh->er_tupdesc = tupdesc;\n\terh->er_tupdesc_id = main_erh->er_tupdesc_id;\n\n\t/*\n\t * It's tempting to copy over whatever we know about the flat size, but\n\t * there's no point since we're surely about to modify the dummy record's\n\t * field(s).  Instead just clear anything left over from a previous usage\n\t * cycle.\n\t */\n\terh->flat_size = 0;\n\n\t/* Copy over fvalue if we have it, so that system columns are available */\n\terh->fvalue = main_erh->fvalue;\n\terh->fstartptr = main_erh->fstartptr;\n\terh->fendptr = main_erh->fendptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static void build_dummy_expanded_header(ExpandedRecordHeader *main_erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic void build_dummy_expanded_header(ExpandedRecordHeader *main_erh);\n\nstatic void\nbuild_dummy_expanded_header(ExpandedRecordHeader *main_erh)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(main_erh);\n\n\t/* Ensure we have a short-lived context */\n\t(void) get_short_term_cxt(main_erh);\n\n\t/*\n\t * Allocate dummy header on first time through, or in the unlikely event\n\t * that the number of fields changes (in which case we just leak the old\n\t * one).  Include space for its field values in the request.\n\t */\n\terh = main_erh->er_dummy_header;\n\tif (erh == NULL || erh->nfields != tupdesc->natts)\n\t{\n\t\tchar\t   *chunk;\n\n\t\terh = (ExpandedRecordHeader *)\n\t\t\tMemoryContextAlloc(main_erh->hdr.eoh_context,\n\t\t\t\t\t\t\t   MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t\t/* Ensure all header fields are initialized to 0/null */\n\t\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\t\t/*\n\t\t * We set up the dummy header with an indication that its memory\n\t\t * context is the short-lived context.  This is so that, if any\n\t\t * detoasting of out-of-line values happens due to an attempt to\n\t\t * extract a composite datum from the dummy header, the detoasted\n\t\t * stuff will end up in the short-lived context and not cause a leak.\n\t\t * This is cheating a bit on the expanded-object protocol; but since\n\t\t * we never pass a R/W pointer to the dummy object to any other code,\n\t\t * nothing else is authorized to delete or transfer ownership of the\n\t\t * object's context, so it should be safe enough.\n\t\t */\n\t\tEOH_init_header(&erh->hdr, &ER_methods, main_erh->er_short_term_cxt);\n\t\terh->er_magic = ER_MAGIC;\n\n\t\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\t\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\t\terh->dvalues = (Datum *) chunk;\n\t\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\t\terh->nfields = tupdesc->natts;\n\n\t\t/*\n\t\t * The fields we just set are assumed to remain constant through\n\t\t * multiple uses of the dummy header to check domain constraints.  All\n\t\t * other dummy header fields should be explicitly reset below, to\n\t\t * ensure there's not accidental effects of one check on the next one.\n\t\t */\n\n\t\tmain_erh->er_dummy_header = erh;\n\t}\n\n\t/*\n\t * If anything inquires about the dummy header's declared type, it should\n\t * report the composite base type, not the domain type (since the VALUE in\n\t * a domain check constraint is of the base type not the domain).  Hence\n\t * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main\n\t * header's flags, since the dummy header is empty of data at this point.\n\t * But don't forget to mark header as dummy.\n\t */\n\terh->flags = ER_FLAG_IS_DUMMY;\n\n\t/* Copy composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = main_erh->er_typeid;\n\terh->er_typmod = main_erh->er_typmod;\n\n\t/* Dummy header does not need its own tupdesc refcount */\n\terh->er_tupdesc = tupdesc;\n\terh->er_tupdesc_id = main_erh->er_tupdesc_id;\n\n\t/*\n\t * It's tempting to copy over whatever we know about the flat size, but\n\t * there's no point since we're surely about to modify the dummy record's\n\t * field(s).  Instead just clear anything left over from a previous usage\n\t * cycle.\n\t */\n\terh->flat_size = 0;\n\n\t/* Copy over fvalue if we have it, so that system columns are available */\n\terh->fvalue = main_erh->fvalue;\n\terh->fstartptr = main_erh->fstartptr;\n\terh->fendptr = main_erh->fendptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\n\nstatic pg_noinline void\ncheck_domain_for_new_field(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* Construct dummy header to contain proposed new field set */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/*\n\t * If record isn't empty, just deconstruct it (if needed) and copy over\n\t * the existing field values.  If it is empty, just fill fields with nulls\n\t * manually --- don't call deconstruct_expanded_record prematurely.\n\t */\n\tif (!ExpandedRecordIsEmpty(erh))\n\t{\n\t\tdeconstruct_expanded_record(erh);\n\t\tmemcpy(dummy_erh->dvalues, erh->dvalues,\n\t\t\t   dummy_erh->nfields * sizeof(Datum));\n\t\tmemcpy(dummy_erh->dnulls, erh->dnulls,\n\t\t\t   dummy_erh->nfields * sizeof(bool));\n\t\t/* There might be some external values in there... */\n\t\tdummy_erh->flags |= erh->flags & ER_FLAG_HAVE_EXTERNAL;\n\t}\n\telse\n\t{\n\t\tmemset(dummy_erh->dvalues, 0, dummy_erh->nfields * sizeof(Datum));\n\t\tmemset(dummy_erh->dnulls, true, dummy_erh->nfields * sizeof(bool));\n\t}\n\n\t/* Either way, we now have valid dvalues */\n\tdummy_erh->flags |= ER_FLAG_DVALUES_VALID;\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > dummy_erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/* Insert proposed new value into dummy field array */\n\tdummy_erh->dvalues[fnumber - 1] = newValue;\n\tdummy_erh->dnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * The proposed new value might be external, in which case we'd better set\n\t * the flag for that in dummy_erh.  (This matters in case something in the\n\t * domain check expressions tries to extract a flat value from the dummy\n\t * header.)\n\t */\n\tif (!isnull)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(erh->er_tupdesc, fnumber - 1);\n\n\t\tif (!attr->attbyval && attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}"
  },
  {
    "function_name": "build_dummy_expanded_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1405-1492",
    "snippet": "static void\nbuild_dummy_expanded_header(ExpandedRecordHeader *main_erh)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(main_erh);\n\n\t/* Ensure we have a short-lived context */\n\t(void) get_short_term_cxt(main_erh);\n\n\t/*\n\t * Allocate dummy header on first time through, or in the unlikely event\n\t * that the number of fields changes (in which case we just leak the old\n\t * one).  Include space for its field values in the request.\n\t */\n\terh = main_erh->er_dummy_header;\n\tif (erh == NULL || erh->nfields != tupdesc->natts)\n\t{\n\t\tchar\t   *chunk;\n\n\t\terh = (ExpandedRecordHeader *)\n\t\t\tMemoryContextAlloc(main_erh->hdr.eoh_context,\n\t\t\t\t\t\t\t   MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t\t/* Ensure all header fields are initialized to 0/null */\n\t\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\t\t/*\n\t\t * We set up the dummy header with an indication that its memory\n\t\t * context is the short-lived context.  This is so that, if any\n\t\t * detoasting of out-of-line values happens due to an attempt to\n\t\t * extract a composite datum from the dummy header, the detoasted\n\t\t * stuff will end up in the short-lived context and not cause a leak.\n\t\t * This is cheating a bit on the expanded-object protocol; but since\n\t\t * we never pass a R/W pointer to the dummy object to any other code,\n\t\t * nothing else is authorized to delete or transfer ownership of the\n\t\t * object's context, so it should be safe enough.\n\t\t */\n\t\tEOH_init_header(&erh->hdr, &ER_methods, main_erh->er_short_term_cxt);\n\t\terh->er_magic = ER_MAGIC;\n\n\t\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\t\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\t\terh->dvalues = (Datum *) chunk;\n\t\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\t\terh->nfields = tupdesc->natts;\n\n\t\t/*\n\t\t * The fields we just set are assumed to remain constant through\n\t\t * multiple uses of the dummy header to check domain constraints.  All\n\t\t * other dummy header fields should be explicitly reset below, to\n\t\t * ensure there's not accidental effects of one check on the next one.\n\t\t */\n\n\t\tmain_erh->er_dummy_header = erh;\n\t}\n\n\t/*\n\t * If anything inquires about the dummy header's declared type, it should\n\t * report the composite base type, not the domain type (since the VALUE in\n\t * a domain check constraint is of the base type not the domain).  Hence\n\t * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main\n\t * header's flags, since the dummy header is empty of data at this point.\n\t * But don't forget to mark header as dummy.\n\t */\n\terh->flags = ER_FLAG_IS_DUMMY;\n\n\t/* Copy composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = main_erh->er_typeid;\n\terh->er_typmod = main_erh->er_typmod;\n\n\t/* Dummy header does not need its own tupdesc refcount */\n\terh->er_tupdesc = tupdesc;\n\terh->er_tupdesc_id = main_erh->er_tupdesc_id;\n\n\t/*\n\t * It's tempting to copy over whatever we know about the flat size, but\n\t * there's no point since we're surely about to modify the dummy record's\n\t * field(s).  Instead just clear anything left over from a previous usage\n\t * cycle.\n\t */\n\terh->flat_size = 0;\n\n\t/* Copy over fvalue if we have it, so that system columns are available */\n\terh->fvalue = main_erh->fvalue;\n\terh->fstartptr = main_erh->fstartptr;\n\terh->fendptr = main_erh->fendptr;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static void build_dummy_expanded_header(ExpandedRecordHeader *main_erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_init_header",
          "args": [
            "&erh->hdr",
            "&ER_methods",
            "main_erh->er_short_term_cxt"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "47-65",
          "snippet": "void\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "erh",
            "0",
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "main_erh->hdr.eoh_context",
            "MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool))"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_short_term_cxt",
          "args": [
            "main_erh"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "get_short_term_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1382-1393",
          "snippet": "static MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expanded_record_get_tupdesc",
          "args": [
            "main_erh"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic void build_dummy_expanded_header(ExpandedRecordHeader *main_erh);\n\nstatic void\nbuild_dummy_expanded_header(ExpandedRecordHeader *main_erh)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(main_erh);\n\n\t/* Ensure we have a short-lived context */\n\t(void) get_short_term_cxt(main_erh);\n\n\t/*\n\t * Allocate dummy header on first time through, or in the unlikely event\n\t * that the number of fields changes (in which case we just leak the old\n\t * one).  Include space for its field values in the request.\n\t */\n\terh = main_erh->er_dummy_header;\n\tif (erh == NULL || erh->nfields != tupdesc->natts)\n\t{\n\t\tchar\t   *chunk;\n\n\t\terh = (ExpandedRecordHeader *)\n\t\t\tMemoryContextAlloc(main_erh->hdr.eoh_context,\n\t\t\t\t\t\t\t   MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t\t/* Ensure all header fields are initialized to 0/null */\n\t\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\t\t/*\n\t\t * We set up the dummy header with an indication that its memory\n\t\t * context is the short-lived context.  This is so that, if any\n\t\t * detoasting of out-of-line values happens due to an attempt to\n\t\t * extract a composite datum from the dummy header, the detoasted\n\t\t * stuff will end up in the short-lived context and not cause a leak.\n\t\t * This is cheating a bit on the expanded-object protocol; but since\n\t\t * we never pass a R/W pointer to the dummy object to any other code,\n\t\t * nothing else is authorized to delete or transfer ownership of the\n\t\t * object's context, so it should be safe enough.\n\t\t */\n\t\tEOH_init_header(&erh->hdr, &ER_methods, main_erh->er_short_term_cxt);\n\t\terh->er_magic = ER_MAGIC;\n\n\t\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\t\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\t\terh->dvalues = (Datum *) chunk;\n\t\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\t\terh->nfields = tupdesc->natts;\n\n\t\t/*\n\t\t * The fields we just set are assumed to remain constant through\n\t\t * multiple uses of the dummy header to check domain constraints.  All\n\t\t * other dummy header fields should be explicitly reset below, to\n\t\t * ensure there's not accidental effects of one check on the next one.\n\t\t */\n\n\t\tmain_erh->er_dummy_header = erh;\n\t}\n\n\t/*\n\t * If anything inquires about the dummy header's declared type, it should\n\t * report the composite base type, not the domain type (since the VALUE in\n\t * a domain check constraint is of the base type not the domain).  Hence\n\t * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main\n\t * header's flags, since the dummy header is empty of data at this point.\n\t * But don't forget to mark header as dummy.\n\t */\n\terh->flags = ER_FLAG_IS_DUMMY;\n\n\t/* Copy composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = main_erh->er_typeid;\n\terh->er_typmod = main_erh->er_typmod;\n\n\t/* Dummy header does not need its own tupdesc refcount */\n\terh->er_tupdesc = tupdesc;\n\terh->er_tupdesc_id = main_erh->er_tupdesc_id;\n\n\t/*\n\t * It's tempting to copy over whatever we know about the flat size, but\n\t * there's no point since we're surely about to modify the dummy record's\n\t * field(s).  Instead just clear anything left over from a previous usage\n\t * cycle.\n\t */\n\terh->flat_size = 0;\n\n\t/* Copy over fvalue if we have it, so that system columns are available */\n\terh->fvalue = main_erh->fvalue;\n\terh->fstartptr = main_erh->fstartptr;\n\terh->fendptr = main_erh->fendptr;\n}"
  },
  {
    "function_name": "get_short_term_cxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1382-1393",
    "snippet": "static MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "erh->hdr.eoh_context",
            "\"expanded record short-term context\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}"
  },
  {
    "function_name": "expanded_record_set_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1252-1370",
    "snippet": "void\nexpanded_record_set_fields(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   const Datum *newValues, const bool *isnulls,\n\t\t\t\t\t\t   bool expand_external)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tfnumber;\n\tMemoryContext oldcxt;\n\n\t/* Shouldn't ever be trying to assign new data to a dummy header */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY));\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\tAssert(erh->nfields == tupdesc->natts);\n\n\t/* Flattened value will no longer represent record accurately */\n\terh->flags &= ~ER_FLAG_FVALUE_VALID;\n\t/* And we don't know the flattened size either */\n\terh->flat_size = 0;\n\n\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\n\tdvalues = erh->dvalues;\n\tdnulls = erh->dnulls;\n\n\tfor (fnumber = 0; fnumber < erh->nfields; fnumber++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, fnumber);\n\t\tDatum\t\tnewValue;\n\t\tbool\t\tisnull;\n\n\t\t/* Ignore dropped columns */\n\t\tif (attr->attisdropped)\n\t\t\tcontinue;\n\n\t\tnewValue = newValues[fnumber];\n\t\tisnull = isnulls[fnumber];\n\n\t\tif (!attr->attbyval)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy new field value into record's context, and deal with\n\t\t\t * detoasting, if needed.\n\t\t\t */\n\t\t\tif (!isnull)\n\t\t\t{\n\t\t\t\t/* Is it an external toasted value? */\n\t\t\t\tif (attr->attlen == -1 &&\n\t\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t\t{\n\t\t\t\t\tif (expand_external)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Detoast as requested while copying the value */\n\t\t\t\t\t\tnewValue = PointerGetDatum(heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue)));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Just copy the value */\n\t\t\t\t\t\tnewValue = datumCopy(newValue, false, -1);\n\t\t\t\t\t\t/* If it's still external, remember that */\n\t\t\t\t\t\tif (VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t\t\t\t\terh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Not an external value, just copy it */\n\t\t\t\t\tnewValue = datumCopy(newValue, false, attr->attlen);\n\t\t\t\t}\n\n\t\t\t\t/* Remember that we have field(s) that need to be pfree'd */\n\t\t\t\terh->flags |= ER_FLAG_DVALUES_ALLOCED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Free old field value, if any (not likely, since really we ought\n\t\t\t * to be inserting into an empty record).\n\t\t\t */\n\t\t\tif (unlikely(!dnulls[fnumber]))\n\t\t\t{\n\t\t\t\tchar\t   *oldValue;\n\n\t\t\t\toldValue = (char *) DatumGetPointer(dvalues[fnumber]);\n\t\t\t\t/* Don't try to pfree a part of the original flat record */\n\t\t\t\tif (oldValue < erh->fstartptr || oldValue >= erh->fendptr)\n\t\t\t\t\tpfree(oldValue);\n\t\t\t}\n\t\t}\n\n\t\t/* And finally we can insert the new field. */\n\t\tdvalues[fnumber] = newValue;\n\t\tdnulls[fnumber] = isnull;\n\t}\n\n\t/*\n\t * Because we don't guarantee atomicity of set_fields(), we can just leave\n\t * checking of domain constraints to occur as the final step; if it throws\n\t * an error, too bad.\n\t */\n\tif (erh->flags & ER_FLAG_IS_DOMAIN)\n\t{\n\t\t/* We run domain_check in a short-lived context to limit cruft */\n\t\tMemoryContextSwitchTo(get_short_term_cxt(erh));\n\n\t\tdomain_check(ExpandedRecordGetRODatum(erh), false,\n\t\t\t\t\t erh->er_decltypeid,\n\t\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t\t erh->hdr.eoh_context);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_check",
          "args": [
            "ExpandedRecordGetRODatum(erh)",
            "false",
            "erh->er_decltypeid",
            "&erh->er_domaininfo",
            "erh->hdr.eoh_context"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "326-353",
          "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExpandedRecordGetRODatum",
          "args": [
            "erh"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "get_short_term_cxt(erh)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_short_term_cxt",
          "args": [
            "erh"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "get_short_term_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1382-1393",
          "snippet": "static MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "oldValue"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "dvalues[fnumber]"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dnulls[fnumber]"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "newValue",
            "false",
            "attr->attlen"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(newValue)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue))"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_tuple_fetch_attr",
          "args": [
            "(struct varlena *) DatumGetPointer(newValue)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(newValue)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "fnumber"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "erh->hdr.eoh_context"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "erh->nfields == tupdesc->natts"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_record",
          "args": [
            "erh"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "956-1013",
          "snippet": "void\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(erh->flags & ER_FLAG_IS_DUMMY)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\nexpanded_record_set_fields(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   const Datum *newValues, const bool *isnulls,\n\t\t\t\t\t\t   bool expand_external)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tfnumber;\n\tMemoryContext oldcxt;\n\n\t/* Shouldn't ever be trying to assign new data to a dummy header */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY));\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\tAssert(erh->nfields == tupdesc->natts);\n\n\t/* Flattened value will no longer represent record accurately */\n\terh->flags &= ~ER_FLAG_FVALUE_VALID;\n\t/* And we don't know the flattened size either */\n\terh->flat_size = 0;\n\n\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\n\tdvalues = erh->dvalues;\n\tdnulls = erh->dnulls;\n\n\tfor (fnumber = 0; fnumber < erh->nfields; fnumber++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, fnumber);\n\t\tDatum\t\tnewValue;\n\t\tbool\t\tisnull;\n\n\t\t/* Ignore dropped columns */\n\t\tif (attr->attisdropped)\n\t\t\tcontinue;\n\n\t\tnewValue = newValues[fnumber];\n\t\tisnull = isnulls[fnumber];\n\n\t\tif (!attr->attbyval)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy new field value into record's context, and deal with\n\t\t\t * detoasting, if needed.\n\t\t\t */\n\t\t\tif (!isnull)\n\t\t\t{\n\t\t\t\t/* Is it an external toasted value? */\n\t\t\t\tif (attr->attlen == -1 &&\n\t\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t\t{\n\t\t\t\t\tif (expand_external)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Detoast as requested while copying the value */\n\t\t\t\t\t\tnewValue = PointerGetDatum(heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue)));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Just copy the value */\n\t\t\t\t\t\tnewValue = datumCopy(newValue, false, -1);\n\t\t\t\t\t\t/* If it's still external, remember that */\n\t\t\t\t\t\tif (VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t\t\t\t\terh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Not an external value, just copy it */\n\t\t\t\t\tnewValue = datumCopy(newValue, false, attr->attlen);\n\t\t\t\t}\n\n\t\t\t\t/* Remember that we have field(s) that need to be pfree'd */\n\t\t\t\terh->flags |= ER_FLAG_DVALUES_ALLOCED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Free old field value, if any (not likely, since really we ought\n\t\t\t * to be inserting into an empty record).\n\t\t\t */\n\t\t\tif (unlikely(!dnulls[fnumber]))\n\t\t\t{\n\t\t\t\tchar\t   *oldValue;\n\n\t\t\t\toldValue = (char *) DatumGetPointer(dvalues[fnumber]);\n\t\t\t\t/* Don't try to pfree a part of the original flat record */\n\t\t\t\tif (oldValue < erh->fstartptr || oldValue >= erh->fendptr)\n\t\t\t\t\tpfree(oldValue);\n\t\t\t}\n\t\t}\n\n\t\t/* And finally we can insert the new field. */\n\t\tdvalues[fnumber] = newValue;\n\t\tdnulls[fnumber] = isnull;\n\t}\n\n\t/*\n\t * Because we don't guarantee atomicity of set_fields(), we can just leave\n\t * checking of domain constraints to occur as the final step; if it throws\n\t * an error, too bad.\n\t */\n\tif (erh->flags & ER_FLAG_IS_DOMAIN)\n\t{\n\t\t/* We run domain_check in a short-lived context to limit cruft */\n\t\tMemoryContextSwitchTo(get_short_term_cxt(erh));\n\n\t\tdomain_check(ExpandedRecordGetRODatum(erh), false,\n\t\t\t\t\t erh->er_decltypeid,\n\t\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t\t erh->hdr.eoh_context);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "expanded_record_set_field_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1115-1234",
    "snippet": "void\nexpanded_record_set_field_internal(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t\t\t   Datum newValue, bool isnull,\n\t\t\t\t\t\t\t\t   bool expand_external,\n\t\t\t\t\t\t\t\t   bool check_constraints)\n{\n\tTupleDesc\ttupdesc;\n\tForm_pg_attribute attr;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tchar\t   *oldValue;\n\n\t/*\n\t * Shouldn't ever be trying to assign new data to a dummy header, except\n\t * in the case of an internal call for field inlining.\n\t */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY) || !check_constraints);\n\n\t/* Before performing the assignment, see if result will satisfy domain */\n\tif ((erh->flags & ER_FLAG_IS_DOMAIN) && check_constraints)\n\t\tcheck_domain_for_new_field(erh, fnumber, newValue, isnull);\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\tAssert(erh->nfields == tupdesc->natts);\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/*\n\t * Copy new field value into record's context, and deal with detoasting,\n\t * if needed.\n\t */\n\tattr = TupleDescAttr(tupdesc, fnumber - 1);\n\tif (!isnull && !attr->attbyval)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\t/* If requested, detoast any external value */\n\t\tif (expand_external)\n\t\t{\n\t\t\tif (attr->attlen == -1 &&\n\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t{\n\t\t\t\t/* Detoasting should be done in short-lived context. */\n\t\t\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\t\t\t\tnewValue = PointerGetDatum(heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue)));\n\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t}\n\t\t\telse\n\t\t\t\texpand_external = false;\t/* need not clean up below */\n\t\t}\n\n\t\t/* Copy value into record's context */\n\t\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\t\tnewValue = datumCopy(newValue, false, attr->attlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We can now flush anything that detoasting might have leaked */\n\t\tif (expand_external)\n\t\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\t/* Remember that we have field(s) that may need to be pfree'd */\n\t\terh->flags |= ER_FLAG_DVALUES_ALLOCED;\n\n\t\t/*\n\t\t * While we're here, note whether it's an external toasted value,\n\t\t * because that could mean we need to inline it later.  (Think not to\n\t\t * merge this into the previous expand_external logic: datumCopy could\n\t\t * by itself have made the value non-external.)\n\t\t */\n\t\tif (attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\terh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We're ready to make irreversible changes.\n\t */\n\tdvalues = erh->dvalues;\n\tdnulls = erh->dnulls;\n\n\t/* Flattened value will no longer represent record accurately */\n\terh->flags &= ~ER_FLAG_FVALUE_VALID;\n\t/* And we don't know the flattened size either */\n\terh->flat_size = 0;\n\n\t/* Grab old field value for pfree'ing, if needed. */\n\tif (!attr->attbyval && !dnulls[fnumber - 1])\n\t\toldValue = (char *) DatumGetPointer(dvalues[fnumber - 1]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new field. */\n\tdvalues[fnumber - 1] = newValue;\n\tdnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * Free old field if needed; this keeps repeated field replacements from\n\t * bloating the record's storage.  If the pfree somehow fails, it won't\n\t * corrupt the record.\n\t *\n\t * If we're updating a dummy header, we can't risk pfree'ing the old\n\t * value, because most likely the expanded record's main header still has\n\t * a pointer to it.  This won't result in any sustained memory leak, since\n\t * whatever we just allocated here is in the short-lived domain check\n\t * context.\n\t */\n\tif (oldValue && !(erh->flags & ER_FLAG_IS_DUMMY))\n\t{\n\t\t/* Don't try to pfree a part of the original flat record */\n\t\tif (oldValue < erh->fstartptr || oldValue >= erh->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "oldValue"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "dvalues[fnumber - 1]"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(newValue)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "newValue",
            "false",
            "attr->attlen"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "erh->hdr.eoh_context"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue))"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_tuple_fetch_attr",
          "args": [
            "(struct varlena *) DatumGetPointer(newValue)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "get_short_term_cxt(erh)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_short_term_cxt",
          "args": [
            "erh"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "get_short_term_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1382-1393",
          "snippet": "static MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(newValue)"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "newValue"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "fnumber - 1"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot assign to field %d of expanded record\"",
            "fnumber"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fnumber <= 0 || fnumber > erh->nfields"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "erh->nfields == tupdesc->natts"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_record",
          "args": [
            "erh"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "956-1013",
          "snippet": "void\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_domain_for_new_field",
          "args": [
            "erh",
            "fnumber",
            "newValue",
            "isnull"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "check_domain_for_new_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1497-1574",
          "snippet": "static pg_noinline void\ncheck_domain_for_new_field(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* Construct dummy header to contain proposed new field set */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/*\n\t * If record isn't empty, just deconstruct it (if needed) and copy over\n\t * the existing field values.  If it is empty, just fill fields with nulls\n\t * manually --- don't call deconstruct_expanded_record prematurely.\n\t */\n\tif (!ExpandedRecordIsEmpty(erh))\n\t{\n\t\tdeconstruct_expanded_record(erh);\n\t\tmemcpy(dummy_erh->dvalues, erh->dvalues,\n\t\t\t   dummy_erh->nfields * sizeof(Datum));\n\t\tmemcpy(dummy_erh->dnulls, erh->dnulls,\n\t\t\t   dummy_erh->nfields * sizeof(bool));\n\t\t/* There might be some external values in there... */\n\t\tdummy_erh->flags |= erh->flags & ER_FLAG_HAVE_EXTERNAL;\n\t}\n\telse\n\t{\n\t\tmemset(dummy_erh->dvalues, 0, dummy_erh->nfields * sizeof(Datum));\n\t\tmemset(dummy_erh->dnulls, true, dummy_erh->nfields * sizeof(bool));\n\t}\n\n\t/* Either way, we now have valid dvalues */\n\tdummy_erh->flags |= ER_FLAG_DVALUES_VALID;\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > dummy_erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/* Insert proposed new value into dummy field array */\n\tdummy_erh->dvalues[fnumber - 1] = newValue;\n\tdummy_erh->dnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * The proposed new value might be external, in which case we'd better set\n\t * the flag for that in dummy_erh.  (This matters in case something in the\n\t * domain check expressions tries to extract a flat value from the dummy\n\t * header.)\n\t */\n\tif (!isnull)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(erh->er_tupdesc, fnumber - 1);\n\n\t\tif (!attr->attbyval && attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\n\nstatic pg_noinline void\ncheck_domain_for_new_field(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* Construct dummy header to contain proposed new field set */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/*\n\t * If record isn't empty, just deconstruct it (if needed) and copy over\n\t * the existing field values.  If it is empty, just fill fields with nulls\n\t * manually --- don't call deconstruct_expanded_record prematurely.\n\t */\n\tif (!ExpandedRecordIsEmpty(erh))\n\t{\n\t\tdeconstruct_expanded_record(erh);\n\t\tmemcpy(dummy_erh->dvalues, erh->dvalues,\n\t\t\t   dummy_erh->nfields * sizeof(Datum));\n\t\tmemcpy(dummy_erh->dnulls, erh->dnulls,\n\t\t\t   dummy_erh->nfields * sizeof(bool));\n\t\t/* There might be some external values in there... */\n\t\tdummy_erh->flags |= erh->flags & ER_FLAG_HAVE_EXTERNAL;\n\t}\n\telse\n\t{\n\t\tmemset(dummy_erh->dvalues, 0, dummy_erh->nfields * sizeof(Datum));\n\t\tmemset(dummy_erh->dnulls, true, dummy_erh->nfields * sizeof(bool));\n\t}\n\n\t/* Either way, we now have valid dvalues */\n\tdummy_erh->flags |= ER_FLAG_DVALUES_VALID;\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > dummy_erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/* Insert proposed new value into dummy field array */\n\tdummy_erh->dvalues[fnumber - 1] = newValue;\n\tdummy_erh->dnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * The proposed new value might be external, in which case we'd better set\n\t * the flag for that in dummy_erh.  (This matters in case something in the\n\t * domain check expressions tries to extract a flat value from the dummy\n\t * header.)\n\t */\n\tif (!isnull)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(erh->er_tupdesc, fnumber - 1);\n\n\t\tif (!attr->attbyval && attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(erh->flags & ER_FLAG_IS_DUMMY) || !check_constraints"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\nexpanded_record_set_field_internal(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t\t\t   Datum newValue, bool isnull,\n\t\t\t\t\t\t\t\t   bool expand_external,\n\t\t\t\t\t\t\t\t   bool check_constraints)\n{\n\tTupleDesc\ttupdesc;\n\tForm_pg_attribute attr;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tchar\t   *oldValue;\n\n\t/*\n\t * Shouldn't ever be trying to assign new data to a dummy header, except\n\t * in the case of an internal call for field inlining.\n\t */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY) || !check_constraints);\n\n\t/* Before performing the assignment, see if result will satisfy domain */\n\tif ((erh->flags & ER_FLAG_IS_DOMAIN) && check_constraints)\n\t\tcheck_domain_for_new_field(erh, fnumber, newValue, isnull);\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\tAssert(erh->nfields == tupdesc->natts);\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/*\n\t * Copy new field value into record's context, and deal with detoasting,\n\t * if needed.\n\t */\n\tattr = TupleDescAttr(tupdesc, fnumber - 1);\n\tif (!isnull && !attr->attbyval)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\t/* If requested, detoast any external value */\n\t\tif (expand_external)\n\t\t{\n\t\t\tif (attr->attlen == -1 &&\n\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t{\n\t\t\t\t/* Detoasting should be done in short-lived context. */\n\t\t\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\t\t\t\tnewValue = PointerGetDatum(heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue)));\n\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t}\n\t\t\telse\n\t\t\t\texpand_external = false;\t/* need not clean up below */\n\t\t}\n\n\t\t/* Copy value into record's context */\n\t\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\t\tnewValue = datumCopy(newValue, false, attr->attlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We can now flush anything that detoasting might have leaked */\n\t\tif (expand_external)\n\t\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\t/* Remember that we have field(s) that may need to be pfree'd */\n\t\terh->flags |= ER_FLAG_DVALUES_ALLOCED;\n\n\t\t/*\n\t\t * While we're here, note whether it's an external toasted value,\n\t\t * because that could mean we need to inline it later.  (Think not to\n\t\t * merge this into the previous expand_external logic: datumCopy could\n\t\t * by itself have made the value non-external.)\n\t\t */\n\t\tif (attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\terh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We're ready to make irreversible changes.\n\t */\n\tdvalues = erh->dvalues;\n\tdnulls = erh->dnulls;\n\n\t/* Flattened value will no longer represent record accurately */\n\terh->flags &= ~ER_FLAG_FVALUE_VALID;\n\t/* And we don't know the flattened size either */\n\terh->flat_size = 0;\n\n\t/* Grab old field value for pfree'ing, if needed. */\n\tif (!attr->attbyval && !dnulls[fnumber - 1])\n\t\toldValue = (char *) DatumGetPointer(dvalues[fnumber - 1]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new field. */\n\tdvalues[fnumber - 1] = newValue;\n\tdnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * Free old field if needed; this keeps repeated field replacements from\n\t * bloating the record's storage.  If the pfree somehow fails, it won't\n\t * corrupt the record.\n\t *\n\t * If we're updating a dummy header, we can't risk pfree'ing the old\n\t * value, because most likely the expanded record's main header still has\n\t * a pointer to it.  This won't result in any sustained memory leak, since\n\t * whatever we just allocated here is in the short-lived domain check\n\t * context.\n\t */\n\tif (oldValue && !(erh->flags & ER_FLAG_IS_DUMMY))\n\t{\n\t\t/* Don't try to pfree a part of the original flat record */\n\t\tif (oldValue < erh->fstartptr || oldValue >= erh->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n}"
  },
  {
    "function_name": "expanded_record_fetch_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1066-1100",
    "snippet": "Datum\nexpanded_record_fetch_field(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t\tbool *isnull)\n{\n\tif (fnumber > 0)\n\t{\n\t\t/* Empty record has null fields */\n\t\tif (ExpandedRecordIsEmpty(erh))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t\t/* Make sure we have deconstructed form */\n\t\tdeconstruct_expanded_record(erh);\n\t\t/* Out-of-range field number reads as null */\n\t\tif (unlikely(fnumber > erh->nfields))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t\t*isnull = erh->dnulls[fnumber - 1];\n\t\treturn erh->dvalues[fnumber - 1];\n\t}\n\telse\n\t{\n\t\t/* System columns read as null if we haven't got flat tuple */\n\t\tif (erh->fvalue == NULL)\n\t\t{\n\t\t\t*isnull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t\t/* heap_getsysattr doesn't actually use tupdesc, so just pass null */\n\t\treturn heap_getsysattr(erh->fvalue, fnumber, NULL, isnull);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_getsysattr",
          "args": [
            "erh->fvalue",
            "fnumber",
            "NULL",
            "isnull"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fnumber > erh->nfields"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_record",
          "args": [
            "erh"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "956-1013",
          "snippet": "void\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExpandedRecordIsEmpty",
          "args": [
            "erh"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nDatum\nexpanded_record_fetch_field(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t\tbool *isnull)\n{\n\tif (fnumber > 0)\n\t{\n\t\t/* Empty record has null fields */\n\t\tif (ExpandedRecordIsEmpty(erh))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t\t/* Make sure we have deconstructed form */\n\t\tdeconstruct_expanded_record(erh);\n\t\t/* Out-of-range field number reads as null */\n\t\tif (unlikely(fnumber > erh->nfields))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t\t*isnull = erh->dnulls[fnumber - 1];\n\t\treturn erh->dvalues[fnumber - 1];\n\t}\n\telse\n\t{\n\t\t/* System columns read as null if we haven't got flat tuple */\n\t\tif (erh->fvalue == NULL)\n\t\t{\n\t\t\t*isnull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t\t/* heap_getsysattr doesn't actually use tupdesc, so just pass null */\n\t\treturn heap_getsysattr(erh->fvalue, fnumber, NULL, isnull);\n\t}\n}"
  },
  {
    "function_name": "expanded_record_lookup_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "1021-1058",
    "snippet": "bool\nexpanded_record_lookup_field(ExpandedRecordHeader *erh, const char *fieldname,\n\t\t\t\t\t\t\t ExpandedRecordFieldInfo *finfo)\n{\n\tTupleDesc\ttupdesc;\n\tint\t\t\tfno;\n\tForm_pg_attribute attr;\n\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/* First, check user-defined attributes */\n\tfor (fno = 0; fno < tupdesc->natts; fno++)\n\t{\n\t\tattr = TupleDescAttr(tupdesc, fno);\n\t\tif (namestrcmp(&attr->attname, fieldname) == 0 &&\n\t\t\t!attr->attisdropped)\n\t\t{\n\t\t\tfinfo->fnumber = attr->attnum;\n\t\t\tfinfo->ftypeid = attr->atttypid;\n\t\t\tfinfo->ftypmod = attr->atttypmod;\n\t\t\tfinfo->fcollation = attr->attcollation;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* How about system attributes? */\n\tattr = SystemAttributeByName(fieldname, tupdesc->tdhasoid);\n\tif (attr != NULL)\n\t{\n\t\tfinfo->fnumber = attr->attnum;\n\t\tfinfo->ftypeid = attr->atttypid;\n\t\tfinfo->ftypmod = attr->atttypmod;\n\t\tfinfo->fcollation = attr->attcollation;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SystemAttributeByName",
          "args": [
            "fieldname",
            "tupdesc->tdhasoid"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namestrcmp",
          "args": [
            "&attr->attname",
            "fieldname"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "fno"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expanded_record_get_tupdesc",
          "args": [
            "erh"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nbool\nexpanded_record_lookup_field(ExpandedRecordHeader *erh, const char *fieldname,\n\t\t\t\t\t\t\t ExpandedRecordFieldInfo *finfo)\n{\n\tTupleDesc\ttupdesc;\n\tint\t\t\tfno;\n\tForm_pg_attribute attr;\n\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/* First, check user-defined attributes */\n\tfor (fno = 0; fno < tupdesc->natts; fno++)\n\t{\n\t\tattr = TupleDescAttr(tupdesc, fno);\n\t\tif (namestrcmp(&attr->attname, fieldname) == 0 &&\n\t\t\t!attr->attisdropped)\n\t\t{\n\t\t\tfinfo->fnumber = attr->attnum;\n\t\t\tfinfo->ftypeid = attr->atttypid;\n\t\t\tfinfo->ftypmod = attr->atttypmod;\n\t\t\tfinfo->fcollation = attr->attcollation;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* How about system attributes? */\n\tattr = SystemAttributeByName(fieldname, tupdesc->tdhasoid);\n\tif (attr != NULL)\n\t{\n\t\tfinfo->fnumber = attr->attnum;\n\t\tfinfo->ftypeid = attr->atttypid;\n\t\tfinfo->ftypmod = attr->atttypmod;\n\t\tfinfo->fcollation = attr->attcollation;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "deconstruct_expanded_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "956-1013",
    "snippet": "void\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dnulls",
            "true",
            "nfields * sizeof(bool)"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dvalues",
            "0",
            "nfields * sizeof(Datum)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "erh->fvalue",
            "tupdesc",
            "dvalues",
            "dnulls"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "erh->hdr.eoh_context",
            "nfields * (sizeof(Datum) + sizeof(bool))"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expanded_record_get_tupdesc",
          "args": [
            "erh"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}"
  },
  {
    "function_name": "DatumGetExpandedRecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "931-946",
    "snippet": "ExpandedRecordHeader *\nDatumGetExpandedRecord(Datum d)\n{\n\t/* If it's a writable expanded record already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) DatumGetEOHP(d);\n\n\t\tAssert(erh->er_magic == ER_MAGIC);\n\t\treturn erh;\n\t}\n\n\t/* Else expand the hard way */\n\td = make_expanded_record_from_datum(d, CurrentMemoryContext);\n\treturn (ExpandedRecordHeader *) DatumGetEOHP(d);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "d"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_expanded_record_from_datum",
          "args": [
            "d",
            "CurrentMemoryContext"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "make_expanded_record_from_datum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "578-642",
          "snippet": "Datum\nmake_expanded_record_from_datum(Datum recorddatum, MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tHeapTupleHeader tuphdr;\n\tHeapTupleData tmptup;\n\tHeapTuple\tnewtuple;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/* Set up expanded record header, initializing fields to 0/null */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAllocZero(objcxt, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/*\n\t * Detoast and copy source record into private context, as a HeapTuple.\n\t * (If we actually have to detoast the source, we'll leak some memory in\n\t * the caller's context, but it doesn't seem worth worrying about.)\n\t */\n\ttuphdr = DatumGetHeapTupleHeader(recorddatum);\n\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);\n\tItemPointerSetInvalid(&(tmptup.t_self));\n\ttmptup.t_tableOid = InvalidOid;\n\ttmptup.t_data = tuphdr;\n\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tnewtuple = heap_copytuple(&tmptup);\n\terh->flags |= ER_FLAG_FVALUE_ALLOCED;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = HeapTupleHeaderGetTypeId(tuphdr);\n\terh->er_typmod = HeapTupleHeaderGetTypMod(tuphdr);\n\n\t/* remember we have a flat representation */\n\terh->fvalue = newtuple;\n\terh->fstartptr = (char *) newtuple->t_data;\n\terh->fendptr = ((char *) newtuple->t_data) + newtuple->t_len;\n\terh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Shouldn't need to set ER_FLAG_HAVE_EXTERNAL */\n\tAssert(!HeapTupleHeaderHasExternal(tuphdr));\n\n\t/*\n\t * We won't look up the tupdesc till we have to, nor make a deconstructed\n\t * representation.  We don't have enough info to fill flat_size and\n\t * friends, either.\n\t */\n\n\t/* return a R/W pointer to the expanded record */\n\treturn EOHPGetRWDatum(&erh->hdr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nDatum\nmake_expanded_record_from_datum(Datum recorddatum, MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tHeapTupleHeader tuphdr;\n\tHeapTupleData tmptup;\n\tHeapTuple\tnewtuple;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/* Set up expanded record header, initializing fields to 0/null */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAllocZero(objcxt, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/*\n\t * Detoast and copy source record into private context, as a HeapTuple.\n\t * (If we actually have to detoast the source, we'll leak some memory in\n\t * the caller's context, but it doesn't seem worth worrying about.)\n\t */\n\ttuphdr = DatumGetHeapTupleHeader(recorddatum);\n\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);\n\tItemPointerSetInvalid(&(tmptup.t_self));\n\ttmptup.t_tableOid = InvalidOid;\n\ttmptup.t_data = tuphdr;\n\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tnewtuple = heap_copytuple(&tmptup);\n\terh->flags |= ER_FLAG_FVALUE_ALLOCED;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = HeapTupleHeaderGetTypeId(tuphdr);\n\terh->er_typmod = HeapTupleHeaderGetTypMod(tuphdr);\n\n\t/* remember we have a flat representation */\n\terh->fvalue = newtuple;\n\terh->fstartptr = (char *) newtuple->t_data;\n\terh->fendptr = ((char *) newtuple->t_data) + newtuple->t_len;\n\terh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Shouldn't need to set ER_FLAG_HAVE_EXTERNAL */\n\tAssert(!HeapTupleHeaderHasExternal(tuphdr));\n\n\t/*\n\t * We won't look up the tupdesc till we have to, nor make a deconstructed\n\t * representation.  We don't have enough info to fill flat_size and\n\t * friends, either.\n\t */\n\n\t/* return a R/W pointer to the expanded record */\n\treturn EOHPGetRWDatum(&erh->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "erh->er_magic == ER_MAGIC"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED_RW",
          "args": [
            "DatumGetPointer(d)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "d"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nExpandedRecordHeader *\nDatumGetExpandedRecord(Datum d)\n{\n\t/* If it's a writable expanded record already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) DatumGetEOHP(d);\n\n\t\tAssert(erh->er_magic == ER_MAGIC);\n\t\treturn erh;\n\t}\n\n\t/* Else expand the hard way */\n\td = make_expanded_record_from_datum(d, CurrentMemoryContext);\n\treturn (ExpandedRecordHeader *) DatumGetEOHP(d);\n}"
  },
  {
    "function_name": "ER_mc_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "906-922",
    "snippet": "static void\nER_mc_callback(void *arg)\n{\n\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) arg;\n\tTupleDesc\ttupdesc = erh->er_tupdesc;\n\n\t/* Release our privately-managed tupdesc refcount, if any */\n\tif (tupdesc)\n\t{\n\t\terh->er_tupdesc = NULL; /* just for luck */\n\t\tif (tupdesc->tdrefcount > 0)\n\t\t{\n\t\t\tif (--tupdesc->tdrefcount == 0)\n\t\t\t\tFreeTupleDesc(tupdesc);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ER_mc_callback(void *arg);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ER_mc_callback(void *arg);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic void\nER_mc_callback(void *arg)\n{\n\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) arg;\n\tTupleDesc\ttupdesc = erh->er_tupdesc;\n\n\t/* Release our privately-managed tupdesc refcount, if any */\n\tif (tupdesc)\n\t{\n\t\terh->er_tupdesc = NULL; /* just for luck */\n\t\tif (tupdesc->tdrefcount > 0)\n\t\t{\n\t\t\tif (--tupdesc->tdrefcount == 0)\n\t\t\t\tFreeTupleDesc(tupdesc);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "expanded_record_get_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "888-901",
    "snippet": "HeapTuple\nexpanded_record_get_tuple(ExpandedRecordHeader *erh)\n{\n\t/* Easy case if we still have original tuple */\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t\treturn erh->fvalue;\n\n\t/* Else just build a tuple from datums */\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn heap_form_tuple(erh->er_tupdesc, erh->dvalues, erh->dnulls);\n\n\t/* Expanded record is empty */\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "erh->er_tupdesc",
            "erh->dvalues",
            "erh->dnulls"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nHeapTuple\nexpanded_record_get_tuple(ExpandedRecordHeader *erh)\n{\n\t/* Easy case if we still have original tuple */\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t\treturn erh->fvalue;\n\n\t/* Else just build a tuple from datums */\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn heap_form_tuple(erh->er_tupdesc, erh->dvalues, erh->dnulls);\n\n\t/* Expanded record is empty */\n\treturn NULL;\n}"
  },
  {
    "function_name": "expanded_record_fetch_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "828-875",
    "snippet": "TupleDesc\nexpanded_record_fetch_tupdesc(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\n\t/* Easy if we already have it (but caller should have checked already) */\n\tif (erh->er_tupdesc)\n\t\treturn erh->er_tupdesc;\n\n\t/* Lookup the composite type's tupdesc using the typcache */\n\ttupdesc = lookup_rowtype_tupdesc(erh->er_typeid, erh->er_typmod);\n\n\t/*\n\t * If it's a refcounted tupdesc rather than a statically allocated one, we\n\t * want to manage the refcount with a memory context callback rather than\n\t * assuming that the CurrentResourceOwner is longer-lived than this\n\t * expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback if we didn't already */\n\t\tif (erh->er_mcb.arg == NULL)\n\t\t{\n\t\t\terh->er_mcb.func = ER_mc_callback;\n\t\t\terh->er_mcb.arg = (void *) erh;\n\t\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\t\t}\n\n\t\t/* Remember our own pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\n\t\t/* Release the pin lookup_rowtype_tupdesc acquired */\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse\n\t{\n\t\t/* Just remember the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t}\n\n\t/* In either case, fetch the process-global ID for this tupdesc */\n\terh->er_tupdesc_id = assign_record_type_identifier(tupdesc->tdtypeid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   tupdesc->tdtypmod);\n\n\treturn tupdesc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ER_mc_callback(void *arg);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_record_type_identifier",
          "args": [
            "tupdesc->tdtypeid",
            "tupdesc->tdtypmod"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "assign_record_type_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1835-1869",
          "snippet": "uint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nuint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecrTupleDescRefCount",
          "args": [
            "tupdesc"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextRegisterResetCallback",
          "args": [
            "erh->hdr.eoh_context",
            "&erh->er_mcb"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextRegisterResetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "284-295",
          "snippet": "void\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "erh->er_typeid",
            "erh->er_typmod"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ER_mc_callback(void *arg);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nTupleDesc\nexpanded_record_fetch_tupdesc(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\n\t/* Easy if we already have it (but caller should have checked already) */\n\tif (erh->er_tupdesc)\n\t\treturn erh->er_tupdesc;\n\n\t/* Lookup the composite type's tupdesc using the typcache */\n\ttupdesc = lookup_rowtype_tupdesc(erh->er_typeid, erh->er_typmod);\n\n\t/*\n\t * If it's a refcounted tupdesc rather than a statically allocated one, we\n\t * want to manage the refcount with a memory context callback rather than\n\t * assuming that the CurrentResourceOwner is longer-lived than this\n\t * expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback if we didn't already */\n\t\tif (erh->er_mcb.arg == NULL)\n\t\t{\n\t\t\terh->er_mcb.func = ER_mc_callback;\n\t\t\terh->er_mcb.arg = (void *) erh;\n\t\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\t\t}\n\n\t\t/* Remember our own pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\n\t\t/* Release the pin lookup_rowtype_tupdesc acquired */\n\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse\n\t{\n\t\t/* Just remember the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t}\n\n\t/* In either case, fetch the process-global ID for this tupdesc */\n\terh->er_tupdesc_id = assign_record_type_identifier(tupdesc->tdtypeid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   tupdesc->tdtypmod);\n\n\treturn tupdesc;\n}"
  },
  {
    "function_name": "ER_flatten_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "765-818",
    "snippet": "static void\nER_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size)\n{\n\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr;\n\tHeapTupleHeader tuphdr = (HeapTupleHeader) result;\n\tTupleDesc\ttupdesc;\n\n\tAssert(erh->er_magic == ER_MAGIC);\n\n\t/* Easy if we have a valid flattened value without out-of-line fields */\n\tif (erh->flags & ER_FLAG_FVALUE_VALID &&\n\t\t!(erh->flags & ER_FLAG_HAVE_EXTERNAL))\n\t{\n\t\tAssert(allocated_size == erh->fvalue->t_len);\n\t\tmemcpy(tuphdr, erh->fvalue->t_data, allocated_size);\n\t\t/* The original flattened value might not have datum header fields */\n\t\tHeapTupleHeaderSetDatumLength(tuphdr, allocated_size);\n\t\tHeapTupleHeaderSetTypeId(tuphdr, erh->er_typeid);\n\t\tHeapTupleHeaderSetTypMod(tuphdr, erh->er_typmod);\n\t\treturn;\n\t}\n\n\t/* Else allocation should match previous get_flat_size result */\n\tAssert(allocated_size == erh->flat_size);\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/* We must ensure that any pad space is zero-filled */\n\tmemset(tuphdr, 0, allocated_size);\n\n\t/* Set up header fields of composite Datum */\n\tHeapTupleHeaderSetDatumLength(tuphdr, allocated_size);\n\tHeapTupleHeaderSetTypeId(tuphdr, erh->er_typeid);\n\tHeapTupleHeaderSetTypMod(tuphdr, erh->er_typmod);\n\t/* We also make sure that t_ctid is invalid unless explicitly set */\n\tItemPointerSetInvalid(&(tuphdr->t_ctid));\n\n\tHeapTupleHeaderSetNatts(tuphdr, tupdesc->natts);\n\ttuphdr->t_hoff = erh->hoff;\n\n\tif (tupdesc->tdhasoid)\t\t/* else leave infomask = 0 */\n\t\ttuphdr->t_infomask = HEAP_HASOID;\n\n\t/* And fill the data area from dvalues/dnulls */\n\theap_fill_tuple(tupdesc,\n\t\t\t\t\terh->dvalues,\n\t\t\t\t\terh->dnulls,\n\t\t\t\t\t(char *) tuphdr + erh->hoff,\n\t\t\t\t\terh->data_len,\n\t\t\t\t\t&tuphdr->t_infomask,\n\t\t\t\t\t(erh->hasnull ? tuphdr->t_bits : NULL));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size ER_get_flat_size(ExpandedObjectHeader *eohptr);",
      "static void ER_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_fill_tuple",
          "args": [
            "tupdesc",
            "erh->dvalues",
            "erh->dnulls",
            "(char *) tuphdr + erh->hoff",
            "erh->data_len",
            "&tuphdr->t_infomask",
            "(erh->hasnull ? tuphdr->t_bits : NULL)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetNatts",
          "args": [
            "tuphdr",
            "tupdesc->natts"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuphdr->t_ctid)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetTypMod",
          "args": [
            "tuphdr",
            "erh->er_typmod"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetTypeId",
          "args": [
            "tuphdr",
            "erh->er_typeid"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetDatumLength",
          "args": [
            "tuphdr",
            "allocated_size"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tuphdr",
            "0",
            "allocated_size"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expanded_record_get_tupdesc",
          "args": [
            "erh"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "allocated_size == erh->flat_size"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetTypMod",
          "args": [
            "tuphdr",
            "erh->er_typmod"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetTypeId",
          "args": [
            "tuphdr",
            "erh->er_typeid"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetDatumLength",
          "args": [
            "tuphdr",
            "allocated_size"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tuphdr",
            "erh->fvalue->t_data",
            "allocated_size"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "allocated_size == erh->fvalue->t_len"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "erh->er_magic == ER_MAGIC"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Size ER_get_flat_size(ExpandedObjectHeader *eohptr);\nstatic void ER_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nstatic void\nER_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size)\n{\n\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr;\n\tHeapTupleHeader tuphdr = (HeapTupleHeader) result;\n\tTupleDesc\ttupdesc;\n\n\tAssert(erh->er_magic == ER_MAGIC);\n\n\t/* Easy if we have a valid flattened value without out-of-line fields */\n\tif (erh->flags & ER_FLAG_FVALUE_VALID &&\n\t\t!(erh->flags & ER_FLAG_HAVE_EXTERNAL))\n\t{\n\t\tAssert(allocated_size == erh->fvalue->t_len);\n\t\tmemcpy(tuphdr, erh->fvalue->t_data, allocated_size);\n\t\t/* The original flattened value might not have datum header fields */\n\t\tHeapTupleHeaderSetDatumLength(tuphdr, allocated_size);\n\t\tHeapTupleHeaderSetTypeId(tuphdr, erh->er_typeid);\n\t\tHeapTupleHeaderSetTypMod(tuphdr, erh->er_typmod);\n\t\treturn;\n\t}\n\n\t/* Else allocation should match previous get_flat_size result */\n\tAssert(allocated_size == erh->flat_size);\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/* We must ensure that any pad space is zero-filled */\n\tmemset(tuphdr, 0, allocated_size);\n\n\t/* Set up header fields of composite Datum */\n\tHeapTupleHeaderSetDatumLength(tuphdr, allocated_size);\n\tHeapTupleHeaderSetTypeId(tuphdr, erh->er_typeid);\n\tHeapTupleHeaderSetTypMod(tuphdr, erh->er_typmod);\n\t/* We also make sure that t_ctid is invalid unless explicitly set */\n\tItemPointerSetInvalid(&(tuphdr->t_ctid));\n\n\tHeapTupleHeaderSetNatts(tuphdr, tupdesc->natts);\n\ttuphdr->t_hoff = erh->hoff;\n\n\tif (tupdesc->tdhasoid)\t\t/* else leave infomask = 0 */\n\t\ttuphdr->t_infomask = HEAP_HASOID;\n\n\t/* And fill the data area from dvalues/dnulls */\n\theap_fill_tuple(tupdesc,\n\t\t\t\t\terh->dvalues,\n\t\t\t\t\terh->dnulls,\n\t\t\t\t\t(char *) tuphdr + erh->hoff,\n\t\t\t\t\terh->data_len,\n\t\t\t\t\t&tuphdr->t_infomask,\n\t\t\t\t\t(erh->hasnull ? tuphdr->t_bits : NULL));\n}"
  },
  {
    "function_name": "ER_get_flat_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "650-760",
    "snippet": "static Size\nER_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr;\n\tTupleDesc\ttupdesc;\n\tSize\t\tlen;\n\tSize\t\tdata_len;\n\tint\t\t\thoff;\n\tbool\t\thasnull;\n\tint\t\t\ti;\n\n\tAssert(erh->er_magic == ER_MAGIC);\n\n\t/*\n\t * The flat representation has to be a valid composite datum.  Make sure\n\t * that we have a registered, not anonymous, RECORD type.\n\t */\n\tif (erh->er_typeid == RECORDOID &&\n\t\terh->er_typmod < 0)\n\t{\n\t\ttupdesc = expanded_record_get_tupdesc(erh);\n\t\tassign_record_type_typmod(tupdesc);\n\t\terh->er_typmod = tupdesc->tdtypmod;\n\t}\n\n\t/*\n\t * If we have a valid flattened value without out-of-line fields, we can\n\t * just use it as-is.\n\t */\n\tif (erh->flags & ER_FLAG_FVALUE_VALID &&\n\t\t!(erh->flags & ER_FLAG_HAVE_EXTERNAL))\n\t\treturn erh->fvalue->t_len;\n\n\t/* If we have a cached size value, believe that */\n\tif (erh->flat_size)\n\t\treturn erh->flat_size;\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\n\t/*\n\t * Composite datums mustn't contain any out-of-line values.\n\t */\n\tif (erh->flags & ER_FLAG_HAVE_EXTERNAL)\n\t{\n\t\tfor (i = 0; i < erh->nfields; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (!erh->dnulls[i] &&\n\t\t\t\t!attr->attbyval && attr->attlen == -1 &&\n\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(erh->dvalues[i])))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * expanded_record_set_field_internal can do the actual work\n\t\t\t\t * of detoasting.  It needn't recheck domain constraints.\n\t\t\t\t */\n\t\t\t\texpanded_record_set_field_internal(erh, i + 1,\n\t\t\t\t\t\t\t\t\t\t\t\t   erh->dvalues[i], false,\n\t\t\t\t\t\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t\t\t\t\t\t   false);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We have now removed all external field values, so we can clear the\n\t\t * flag about them.  This won't cause ER_flatten_into() to mistakenly\n\t\t * take the fast path, since expanded_record_set_field() will have\n\t\t * cleared ER_FLAG_FVALUE_VALID.\n\t\t */\n\t\terh->flags &= ~ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/* Test if we currently have any null values */\n\thasnull = false;\n\tfor (i = 0; i < erh->nfields; i++)\n\t{\n\t\tif (erh->dnulls[i])\n\t\t{\n\t\t\thasnull = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Determine total space needed */\n\tlen = offsetof(HeapTupleHeaderData, t_bits);\n\n\tif (hasnull)\n\t\tlen += BITMAPLEN(tupdesc->natts);\n\n\tif (tupdesc->tdhasoid)\n\t\tlen += sizeof(Oid);\n\n\thoff = len = MAXALIGN(len); /* align user data safely */\n\n\tdata_len = heap_compute_data_size(tupdesc, erh->dvalues, erh->dnulls);\n\n\tlen += data_len;\n\n\t/* Cache for next time */\n\terh->flat_size = len;\n\terh->data_len = data_len;\n\terh->hoff = hoff;\n\terh->hasnull = hasnull;\n\n\treturn len;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size ER_get_flat_size(ExpandedObjectHeader *eohptr);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_compute_data_size",
          "args": [
            "tupdesc",
            "erh->dvalues",
            "erh->dnulls"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "len"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITMAPLEN",
          "args": [
            "tupdesc->natts"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expanded_record_set_field_internal",
          "args": [
            "erh",
            "i + 1",
            "erh->dvalues[i]",
            "false",
            "true",
            "false"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "expanded_record_set_field_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1115-1234",
          "snippet": "void\nexpanded_record_set_field_internal(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t\t\t   Datum newValue, bool isnull,\n\t\t\t\t\t\t\t\t   bool expand_external,\n\t\t\t\t\t\t\t\t   bool check_constraints)\n{\n\tTupleDesc\ttupdesc;\n\tForm_pg_attribute attr;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tchar\t   *oldValue;\n\n\t/*\n\t * Shouldn't ever be trying to assign new data to a dummy header, except\n\t * in the case of an internal call for field inlining.\n\t */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY) || !check_constraints);\n\n\t/* Before performing the assignment, see if result will satisfy domain */\n\tif ((erh->flags & ER_FLAG_IS_DOMAIN) && check_constraints)\n\t\tcheck_domain_for_new_field(erh, fnumber, newValue, isnull);\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\tAssert(erh->nfields == tupdesc->natts);\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/*\n\t * Copy new field value into record's context, and deal with detoasting,\n\t * if needed.\n\t */\n\tattr = TupleDescAttr(tupdesc, fnumber - 1);\n\tif (!isnull && !attr->attbyval)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\t/* If requested, detoast any external value */\n\t\tif (expand_external)\n\t\t{\n\t\t\tif (attr->attlen == -1 &&\n\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t{\n\t\t\t\t/* Detoasting should be done in short-lived context. */\n\t\t\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\t\t\t\tnewValue = PointerGetDatum(heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue)));\n\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t}\n\t\t\telse\n\t\t\t\texpand_external = false;\t/* need not clean up below */\n\t\t}\n\n\t\t/* Copy value into record's context */\n\t\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\t\tnewValue = datumCopy(newValue, false, attr->attlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We can now flush anything that detoasting might have leaked */\n\t\tif (expand_external)\n\t\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\t/* Remember that we have field(s) that may need to be pfree'd */\n\t\terh->flags |= ER_FLAG_DVALUES_ALLOCED;\n\n\t\t/*\n\t\t * While we're here, note whether it's an external toasted value,\n\t\t * because that could mean we need to inline it later.  (Think not to\n\t\t * merge this into the previous expand_external logic: datumCopy could\n\t\t * by itself have made the value non-external.)\n\t\t */\n\t\tif (attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\terh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We're ready to make irreversible changes.\n\t */\n\tdvalues = erh->dvalues;\n\tdnulls = erh->dnulls;\n\n\t/* Flattened value will no longer represent record accurately */\n\terh->flags &= ~ER_FLAG_FVALUE_VALID;\n\t/* And we don't know the flattened size either */\n\terh->flat_size = 0;\n\n\t/* Grab old field value for pfree'ing, if needed. */\n\tif (!attr->attbyval && !dnulls[fnumber - 1])\n\t\toldValue = (char *) DatumGetPointer(dvalues[fnumber - 1]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new field. */\n\tdvalues[fnumber - 1] = newValue;\n\tdnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * Free old field if needed; this keeps repeated field replacements from\n\t * bloating the record's storage.  If the pfree somehow fails, it won't\n\t * corrupt the record.\n\t *\n\t * If we're updating a dummy header, we can't risk pfree'ing the old\n\t * value, because most likely the expanded record's main header still has\n\t * a pointer to it.  This won't result in any sustained memory leak, since\n\t * whatever we just allocated here is in the short-lived domain check\n\t * context.\n\t */\n\tif (oldValue && !(erh->flags & ER_FLAG_IS_DUMMY))\n\t{\n\t\t/* Don't try to pfree a part of the original flat record */\n\t\tif (oldValue < erh->fstartptr || oldValue >= erh->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\nexpanded_record_set_field_internal(ExpandedRecordHeader *erh, int fnumber,\n\t\t\t\t\t\t\t\t   Datum newValue, bool isnull,\n\t\t\t\t\t\t\t\t   bool expand_external,\n\t\t\t\t\t\t\t\t   bool check_constraints)\n{\n\tTupleDesc\ttupdesc;\n\tForm_pg_attribute attr;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tchar\t   *oldValue;\n\n\t/*\n\t * Shouldn't ever be trying to assign new data to a dummy header, except\n\t * in the case of an internal call for field inlining.\n\t */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY) || !check_constraints);\n\n\t/* Before performing the assignment, see if result will satisfy domain */\n\tif ((erh->flags & ER_FLAG_IS_DOMAIN) && check_constraints)\n\t\tcheck_domain_for_new_field(erh, fnumber, newValue, isnull);\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\tAssert(erh->nfields == tupdesc->natts);\n\n\t/* Caller error if fnumber is system column or nonexistent column */\n\tif (unlikely(fnumber <= 0 || fnumber > erh->nfields))\n\t\telog(ERROR, \"cannot assign to field %d of expanded record\", fnumber);\n\n\t/*\n\t * Copy new field value into record's context, and deal with detoasting,\n\t * if needed.\n\t */\n\tattr = TupleDescAttr(tupdesc, fnumber - 1);\n\tif (!isnull && !attr->attbyval)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\t/* If requested, detoast any external value */\n\t\tif (expand_external)\n\t\t{\n\t\t\tif (attr->attlen == -1 &&\n\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\t{\n\t\t\t\t/* Detoasting should be done in short-lived context. */\n\t\t\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\t\t\t\tnewValue = PointerGetDatum(heap_tuple_fetch_attr((struct varlena *) DatumGetPointer(newValue)));\n\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t}\n\t\t\telse\n\t\t\t\texpand_external = false;\t/* need not clean up below */\n\t\t}\n\n\t\t/* Copy value into record's context */\n\t\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\t\tnewValue = datumCopy(newValue, false, attr->attlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We can now flush anything that detoasting might have leaked */\n\t\tif (expand_external)\n\t\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\t/* Remember that we have field(s) that may need to be pfree'd */\n\t\terh->flags |= ER_FLAG_DVALUES_ALLOCED;\n\n\t\t/*\n\t\t * While we're here, note whether it's an external toasted value,\n\t\t * because that could mean we need to inline it later.  (Think not to\n\t\t * merge this into the previous expand_external logic: datumCopy could\n\t\t * by itself have made the value non-external.)\n\t\t */\n\t\tif (attr->attlen == -1 &&\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(newValue)))\n\t\t\terh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/*\n\t * We're ready to make irreversible changes.\n\t */\n\tdvalues = erh->dvalues;\n\tdnulls = erh->dnulls;\n\n\t/* Flattened value will no longer represent record accurately */\n\terh->flags &= ~ER_FLAG_FVALUE_VALID;\n\t/* And we don't know the flattened size either */\n\terh->flat_size = 0;\n\n\t/* Grab old field value for pfree'ing, if needed. */\n\tif (!attr->attbyval && !dnulls[fnumber - 1])\n\t\toldValue = (char *) DatumGetPointer(dvalues[fnumber - 1]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new field. */\n\tdvalues[fnumber - 1] = newValue;\n\tdnulls[fnumber - 1] = isnull;\n\n\t/*\n\t * Free old field if needed; this keeps repeated field replacements from\n\t * bloating the record's storage.  If the pfree somehow fails, it won't\n\t * corrupt the record.\n\t *\n\t * If we're updating a dummy header, we can't risk pfree'ing the old\n\t * value, because most likely the expanded record's main header still has\n\t * a pointer to it.  This won't result in any sustained memory leak, since\n\t * whatever we just allocated here is in the short-lived domain check\n\t * context.\n\t */\n\tif (oldValue && !(erh->flags & ER_FLAG_IS_DUMMY))\n\t{\n\t\t/* Don't try to pfree a part of the original flat record */\n\t\tif (oldValue < erh->fstartptr || oldValue >= erh->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(erh->dvalues[i])"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "erh->dvalues[i]"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_record",
          "args": [
            "erh"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "956-1013",
          "snippet": "void\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_field(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   int fnumber,\n\t\t\t\t\t\t   Datum newValue, bool isnull);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\ndeconstruct_expanded_record(ExpandedRecordHeader *erh)\n{\n\tTupleDesc\ttupdesc;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\tnfields;\n\n\tif (erh->flags & ER_FLAG_DVALUES_VALID)\n\t\treturn;\t\t\t\t\t/* already valid, nothing to do */\n\n\t/* We'll need the tuple descriptor */\n\ttupdesc = expanded_record_get_tupdesc(erh);\n\n\t/*\n\t * Allocate arrays in private context, if we don't have them already.  We\n\t * don't expect to see a change in nfields here, so while we cope if it\n\t * happens, we don't bother avoiding a leak of the old arrays (which might\n\t * not be separately palloc'd, anyway).\n\t */\n\tnfields = tupdesc->natts;\n\tif (erh->dvalues == NULL || erh->nfields != nfields)\n\t{\n\t\tchar\t   *chunk;\n\n\t\t/*\n\t\t * To save a palloc cycle, we allocate both the Datum and isnull\n\t\t * arrays in one palloc chunk.\n\t\t */\n\t\tchunk = MemoryContextAlloc(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   nfields * (sizeof(Datum) + sizeof(bool)));\n\t\tdvalues = (Datum *) chunk;\n\t\tdnulls = (bool *) (chunk + nfields * sizeof(Datum));\n\t\terh->dvalues = dvalues;\n\t\terh->dnulls = dnulls;\n\t\terh->nfields = nfields;\n\t}\n\telse\n\t{\n\t\tdvalues = erh->dvalues;\n\t\tdnulls = erh->dnulls;\n\t}\n\n\tif (erh->flags & ER_FLAG_FVALUE_VALID)\n\t{\n\t\t/* Deconstruct tuple */\n\t\theap_deform_tuple(erh->fvalue, tupdesc, dvalues, dnulls);\n\t}\n\telse\n\t{\n\t\t/* If record was empty, instantiate it as a row of nulls */\n\t\tmemset(dvalues, 0, nfields * sizeof(Datum));\n\t\tmemset(dnulls, true, nfields * sizeof(bool));\n\t}\n\n\t/* Mark the dvalues as valid */\n\terh->flags |= ER_FLAG_DVALUES_VALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_record_type_typmod",
          "args": [
            "tupdesc"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "assign_record_type_typmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1760-1823",
          "snippet": "void\nassign_record_type_typmod(TupleDesc tupDesc)\n{\n\tRecordCacheEntry *recentry;\n\tTupleDesc\tentDesc;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\n\tAssert(tupDesc->tdtypeid == RECORDOID);\n\n\tif (RecordCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(TupleDesc);\t/* just the pointer */\n\t\tctl.entrysize = sizeof(RecordCacheEntry);\n\t\tctl.hash = record_type_typmod_hash;\n\t\tctl.match = record_type_typmod_compare;\n\t\tRecordCacheHash = hash_create(\"Record information cache\", 64,\n\t\t\t\t\t\t\t\t\t  &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Find or create a hashtable entry for this tuple descriptor */\n\trecentry = (RecordCacheEntry *) hash_search(RecordCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (found && recentry->tupdesc != NULL)\n\t{\n\t\ttupDesc->tdtypmod = recentry->tupdesc->tdtypmod;\n\t\treturn;\n\t}\n\n\t/* Not present, so need to manufacture an entry */\n\trecentry->tupdesc = NULL;\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/* Look in the SharedRecordTypmodRegistry, if attached */\n\tentDesc = find_or_make_matching_shared_tupledesc(tupDesc);\n\tif (entDesc == NULL)\n\t{\n\t\t/* Reference-counted local cache only. */\n\t\tentDesc = CreateTupleDescCopy(tupDesc);\n\t\tentDesc->tdrefcount = 1;\n\t\tentDesc->tdtypmod = NextRecordTypmod++;\n\t}\n\tensure_record_cache_typmod_slot_exists(entDesc->tdtypmod);\n\tRecordCacheArray[entDesc->tdtypmod] = entDesc;\n\trecentry->tupdesc = entDesc;\n\n\t/* Assign a unique tupdesc identifier, too. */\n\tRecordIdentifierArray[entDesc->tdtypmod] = ++tupledesc_id_counter;\n\n\t/* Update the caller's tuple descriptor. */\n\ttupDesc->tdtypmod = entDesc->tdtypmod;\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *RecordCacheHash = NULL;",
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 NextRecordTypmod = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *RecordCacheHash = NULL;\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 NextRecordTypmod = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nvoid\nassign_record_type_typmod(TupleDesc tupDesc)\n{\n\tRecordCacheEntry *recentry;\n\tTupleDesc\tentDesc;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\n\tAssert(tupDesc->tdtypeid == RECORDOID);\n\n\tif (RecordCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(TupleDesc);\t/* just the pointer */\n\t\tctl.entrysize = sizeof(RecordCacheEntry);\n\t\tctl.hash = record_type_typmod_hash;\n\t\tctl.match = record_type_typmod_compare;\n\t\tRecordCacheHash = hash_create(\"Record information cache\", 64,\n\t\t\t\t\t\t\t\t\t  &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Find or create a hashtable entry for this tuple descriptor */\n\trecentry = (RecordCacheEntry *) hash_search(RecordCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (found && recentry->tupdesc != NULL)\n\t{\n\t\ttupDesc->tdtypmod = recentry->tupdesc->tdtypmod;\n\t\treturn;\n\t}\n\n\t/* Not present, so need to manufacture an entry */\n\trecentry->tupdesc = NULL;\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/* Look in the SharedRecordTypmodRegistry, if attached */\n\tentDesc = find_or_make_matching_shared_tupledesc(tupDesc);\n\tif (entDesc == NULL)\n\t{\n\t\t/* Reference-counted local cache only. */\n\t\tentDesc = CreateTupleDescCopy(tupDesc);\n\t\tentDesc->tdrefcount = 1;\n\t\tentDesc->tdtypmod = NextRecordTypmod++;\n\t}\n\tensure_record_cache_typmod_slot_exists(entDesc->tdtypmod);\n\tRecordCacheArray[entDesc->tdtypmod] = entDesc;\n\trecentry->tupdesc = entDesc;\n\n\t/* Assign a unique tupdesc identifier, too. */\n\tRecordIdentifierArray[entDesc->tdtypmod] = ++tupledesc_id_counter;\n\n\t/* Update the caller's tuple descriptor. */\n\ttupDesc->tdtypmod = entDesc->tdtypmod;\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expanded_record_get_tupdesc",
          "args": [
            "erh"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "erh->er_magic == ER_MAGIC"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Size ER_get_flat_size(ExpandedObjectHeader *eohptr);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nstatic Size\nER_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\tExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr;\n\tTupleDesc\ttupdesc;\n\tSize\t\tlen;\n\tSize\t\tdata_len;\n\tint\t\t\thoff;\n\tbool\t\thasnull;\n\tint\t\t\ti;\n\n\tAssert(erh->er_magic == ER_MAGIC);\n\n\t/*\n\t * The flat representation has to be a valid composite datum.  Make sure\n\t * that we have a registered, not anonymous, RECORD type.\n\t */\n\tif (erh->er_typeid == RECORDOID &&\n\t\terh->er_typmod < 0)\n\t{\n\t\ttupdesc = expanded_record_get_tupdesc(erh);\n\t\tassign_record_type_typmod(tupdesc);\n\t\terh->er_typmod = tupdesc->tdtypmod;\n\t}\n\n\t/*\n\t * If we have a valid flattened value without out-of-line fields, we can\n\t * just use it as-is.\n\t */\n\tif (erh->flags & ER_FLAG_FVALUE_VALID &&\n\t\t!(erh->flags & ER_FLAG_HAVE_EXTERNAL))\n\t\treturn erh->fvalue->t_len;\n\n\t/* If we have a cached size value, believe that */\n\tif (erh->flat_size)\n\t\treturn erh->flat_size;\n\n\t/* If we haven't yet deconstructed the tuple, do that */\n\tif (!(erh->flags & ER_FLAG_DVALUES_VALID))\n\t\tdeconstruct_expanded_record(erh);\n\n\t/* Tuple descriptor must be valid by now */\n\ttupdesc = erh->er_tupdesc;\n\n\t/*\n\t * Composite datums mustn't contain any out-of-line values.\n\t */\n\tif (erh->flags & ER_FLAG_HAVE_EXTERNAL)\n\t{\n\t\tfor (i = 0; i < erh->nfields; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (!erh->dnulls[i] &&\n\t\t\t\t!attr->attbyval && attr->attlen == -1 &&\n\t\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(erh->dvalues[i])))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * expanded_record_set_field_internal can do the actual work\n\t\t\t\t * of detoasting.  It needn't recheck domain constraints.\n\t\t\t\t */\n\t\t\t\texpanded_record_set_field_internal(erh, i + 1,\n\t\t\t\t\t\t\t\t\t\t\t\t   erh->dvalues[i], false,\n\t\t\t\t\t\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t\t\t\t\t\t   false);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We have now removed all external field values, so we can clear the\n\t\t * flag about them.  This won't cause ER_flatten_into() to mistakenly\n\t\t * take the fast path, since expanded_record_set_field() will have\n\t\t * cleared ER_FLAG_FVALUE_VALID.\n\t\t */\n\t\terh->flags &= ~ER_FLAG_HAVE_EXTERNAL;\n\t}\n\n\t/* Test if we currently have any null values */\n\thasnull = false;\n\tfor (i = 0; i < erh->nfields; i++)\n\t{\n\t\tif (erh->dnulls[i])\n\t\t{\n\t\t\thasnull = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Determine total space needed */\n\tlen = offsetof(HeapTupleHeaderData, t_bits);\n\n\tif (hasnull)\n\t\tlen += BITMAPLEN(tupdesc->natts);\n\n\tif (tupdesc->tdhasoid)\n\t\tlen += sizeof(Oid);\n\n\thoff = len = MAXALIGN(len); /* align user data safely */\n\n\tdata_len = heap_compute_data_size(tupdesc, erh->dvalues, erh->dnulls);\n\n\tlen += data_len;\n\n\t/* Cache for next time */\n\terh->flat_size = len;\n\terh->data_len = data_len;\n\terh->hoff = hoff;\n\terh->hasnull = hasnull;\n\n\treturn len;\n}"
  },
  {
    "function_name": "make_expanded_record_from_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "578-642",
    "snippet": "Datum\nmake_expanded_record_from_datum(Datum recorddatum, MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tHeapTupleHeader tuphdr;\n\tHeapTupleData tmptup;\n\tHeapTuple\tnewtuple;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/* Set up expanded record header, initializing fields to 0/null */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAllocZero(objcxt, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/*\n\t * Detoast and copy source record into private context, as a HeapTuple.\n\t * (If we actually have to detoast the source, we'll leak some memory in\n\t * the caller's context, but it doesn't seem worth worrying about.)\n\t */\n\ttuphdr = DatumGetHeapTupleHeader(recorddatum);\n\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);\n\tItemPointerSetInvalid(&(tmptup.t_self));\n\ttmptup.t_tableOid = InvalidOid;\n\ttmptup.t_data = tuphdr;\n\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tnewtuple = heap_copytuple(&tmptup);\n\terh->flags |= ER_FLAG_FVALUE_ALLOCED;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = HeapTupleHeaderGetTypeId(tuphdr);\n\terh->er_typmod = HeapTupleHeaderGetTypMod(tuphdr);\n\n\t/* remember we have a flat representation */\n\terh->fvalue = newtuple;\n\terh->fstartptr = (char *) newtuple->t_data;\n\terh->fendptr = ((char *) newtuple->t_data) + newtuple->t_len;\n\terh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Shouldn't need to set ER_FLAG_HAVE_EXTERNAL */\n\tAssert(!HeapTupleHeaderHasExternal(tuphdr));\n\n\t/*\n\t * We won't look up the tupdesc till we have to, nor make a deconstructed\n\t * representation.  We don't have enough info to fill flat_size and\n\t * friends, either.\n\t */\n\n\t/* return a R/W pointer to the expanded record */\n\treturn EOHPGetRWDatum(&erh->hdr);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&erh->hdr"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!HeapTupleHeaderHasExternal(tuphdr)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderHasExternal",
          "args": [
            "tuphdr"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "tuphdr"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "tuphdr"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "&tmptup"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "objcxt"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tmptup.t_self)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "tuphdr"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetHeapTupleHeader",
          "args": [
            "recorddatum"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_init_header",
          "args": [
            "&erh->hdr",
            "&ER_methods",
            "objcxt"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "47-65",
          "snippet": "void\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "objcxt",
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "parentcontext",
            "\"expanded record\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nDatum\nmake_expanded_record_from_datum(Datum recorddatum, MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tHeapTupleHeader tuphdr;\n\tHeapTupleData tmptup;\n\tHeapTuple\tnewtuple;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/* Set up expanded record header, initializing fields to 0/null */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAllocZero(objcxt, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/*\n\t * Detoast and copy source record into private context, as a HeapTuple.\n\t * (If we actually have to detoast the source, we'll leak some memory in\n\t * the caller's context, but it doesn't seem worth worrying about.)\n\t */\n\ttuphdr = DatumGetHeapTupleHeader(recorddatum);\n\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);\n\tItemPointerSetInvalid(&(tmptup.t_self));\n\ttmptup.t_tableOid = InvalidOid;\n\ttmptup.t_data = tuphdr;\n\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tnewtuple = heap_copytuple(&tmptup);\n\terh->flags |= ER_FLAG_FVALUE_ALLOCED;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = HeapTupleHeaderGetTypeId(tuphdr);\n\terh->er_typmod = HeapTupleHeaderGetTypMod(tuphdr);\n\n\t/* remember we have a flat representation */\n\terh->fvalue = newtuple;\n\terh->fstartptr = (char *) newtuple->t_data;\n\terh->fendptr = ((char *) newtuple->t_data) + newtuple->t_len;\n\terh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Shouldn't need to set ER_FLAG_HAVE_EXTERNAL */\n\tAssert(!HeapTupleHeaderHasExternal(tuphdr));\n\n\t/*\n\t * We won't look up the tupdesc till we have to, nor make a deconstructed\n\t * representation.  We don't have enough info to fill flat_size and\n\t * friends, either.\n\t */\n\n\t/* return a R/W pointer to the expanded record */\n\treturn EOHPGetRWDatum(&erh->hdr);\n}"
  },
  {
    "function_name": "expanded_record_set_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "438-564",
    "snippet": "void\nexpanded_record_set_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t  HeapTuple tuple,\n\t\t\t\t\t\t  bool copy,\n\t\t\t\t\t\t  bool expand_external)\n{\n\tint\t\t\toldflags;\n\tHeapTuple\toldtuple;\n\tchar\t   *oldfstartptr;\n\tchar\t   *oldfendptr;\n\tint\t\t\tnewflags;\n\tHeapTuple\tnewtuple;\n\tMemoryContext oldcxt;\n\n\t/* Shouldn't ever be trying to assign new data to a dummy header */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY));\n\n\t/*\n\t * Before performing the assignment, see if result will satisfy domain.\n\t */\n\tif (erh->flags & ER_FLAG_IS_DOMAIN)\n\t\tcheck_domain_for_new_tuple(erh, tuple);\n\n\t/*\n\t * If we need to get rid of out-of-line field values, do so, using the\n\t * short-term context to avoid leaking whatever cruft the toast fetch\n\t * might generate.\n\t */\n\tif (expand_external && tuple)\n\t{\n\t\t/* Assert caller didn't ask for unsupported case */\n\t\tAssert(copy);\n\t\tif (HeapTupleHasExternal(tuple))\n\t\t{\n\t\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\t\t\ttuple = toast_flatten_tuple(tuple, erh->er_tupdesc);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\t\telse\n\t\t\texpand_external = false;\t/* need not clean up below */\n\t}\n\n\t/*\n\t * Initialize new flags, keeping only non-data status bits.\n\t */\n\toldflags = erh->flags;\n\tnewflags = oldflags & ER_FLAGS_NON_DATA;\n\n\t/*\n\t * Copy tuple into local storage if needed.  We must be sure this succeeds\n\t * before we start to modify the expanded record's state.\n\t */\n\tif (copy && tuple)\n\t{\n\t\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\t\tnewtuple = heap_copytuple(tuple);\n\t\tnewflags |= ER_FLAG_FVALUE_ALLOCED;\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We can now flush anything that detoasting might have leaked. */\n\t\tif (expand_external)\n\t\t\tMemoryContextReset(erh->er_short_term_cxt);\n\t}\n\telse\n\t\tnewtuple = tuple;\n\n\t/* Make copies of fields we're about to overwrite */\n\toldtuple = erh->fvalue;\n\toldfstartptr = erh->fstartptr;\n\toldfendptr = erh->fendptr;\n\n\t/*\n\t * It's now safe to update the expanded record's state.\n\t */\n\tif (newtuple)\n\t{\n\t\t/* Save flat representation */\n\t\terh->fvalue = newtuple;\n\t\terh->fstartptr = (char *) newtuple->t_data;\n\t\terh->fendptr = ((char *) newtuple->t_data) + newtuple->t_len;\n\t\tnewflags |= ER_FLAG_FVALUE_VALID;\n\n\t\t/* Remember if we have any out-of-line field values */\n\t\tif (HeapTupleHasExternal(newtuple))\n\t\t\tnewflags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\telse\n\t{\n\t\terh->fvalue = NULL;\n\t\terh->fstartptr = erh->fendptr = NULL;\n\t}\n\n\terh->flags = newflags;\n\n\t/* Reset flat-size info; we don't bother to make it valid now */\n\terh->flat_size = 0;\n\n\t/*\n\t * Now, release any storage belonging to old field values.  It's safe to\n\t * do this because ER_FLAG_DVALUES_VALID is no longer set in erh->flags;\n\t * even if we fail partway through, the record is valid, and at worst\n\t * we've failed to reclaim some space.\n\t */\n\tif (oldflags & ER_FLAG_DVALUES_ALLOCED)\n\t{\n\t\tTupleDesc\ttupdesc = erh->er_tupdesc;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < erh->nfields; i++)\n\t\t{\n\t\t\tif (!erh->dnulls[i] &&\n\t\t\t\t!(TupleDescAttr(tupdesc, i)->attbyval))\n\t\t\t{\n\t\t\t\tchar\t   *oldValue = (char *) DatumGetPointer(erh->dvalues[i]);\n\n\t\t\t\tif (oldValue < oldfstartptr || oldValue >= oldfendptr)\n\t\t\t\t\tpfree(oldValue);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Likewise free the old tuple, if it was locally allocated */\n\tif (oldflags & ER_FLAG_FVALUE_ALLOCED)\n\t\theap_freetuple(oldtuple);\n\n\t/* We won't make a new deconstructed representation until/unless needed */\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
      "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "oldtuple"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "oldValue"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "erh->dvalues[i]"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHasExternal",
          "args": [
            "newtuple"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "erh->er_short_term_cxt"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "tuple"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "erh->hdr.eoh_context"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_flatten_tuple",
          "args": [
            "tuple",
            "erh->er_tupdesc"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "get_short_term_cxt(erh)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_short_term_cxt",
          "args": [
            "erh"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "get_short_term_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1382-1393",
          "snippet": "static MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nstatic MemoryContext\nget_short_term_cxt(ExpandedRecordHeader *erh)\n{\n\tif (erh->er_short_term_cxt == NULL)\n\t\terh->er_short_term_cxt =\n\t\t\tAllocSetContextCreate(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t  \"expanded record short-term context\",\n\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\telse\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\treturn erh->er_short_term_cxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHasExternal",
          "args": [
            "tuple"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "copy"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_domain_for_new_tuple",
          "args": [
            "erh",
            "tuple"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "check_domain_for_new_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
          "lines": "1579-1637",
          "snippet": "static pg_noinline void\ncheck_domain_for_new_tuple(ExpandedRecordHeader *erh, HeapTuple tuple)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* If we're being told to set record to empty, just see if NULL is OK */\n\tif (tuple == NULL)\n\t{\n\t\t/* We run domain_check in a short-lived context to limit cruft */\n\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\n\t\tdomain_check((Datum) 0, true,\n\t\t\t\t\t erh->er_decltypeid,\n\t\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t\t erh->hdr.eoh_context);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We might as well clean up cruft immediately. */\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\treturn;\n\t}\n\n\t/* Construct dummy header to contain replacement tuple */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/* Insert tuple, but don't bother to deconstruct its fields for now */\n\tdummy_erh->fvalue = tuple;\n\tdummy_erh->fstartptr = (char *) tuple->t_data;\n\tdummy_erh->fendptr = ((char *) tuple->t_data) + tuple->t_len;\n\tdummy_erh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Remember if we have any out-of-line field values */\n\tif (HeapTupleHasExternal(tuple))\n\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandedrecord.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);",
            "static pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nstatic pg_noinline void\ncheck_domain_for_new_tuple(ExpandedRecordHeader *erh, HeapTuple tuple)\n{\n\tExpandedRecordHeader *dummy_erh;\n\tMemoryContext oldcxt;\n\n\t/* If we're being told to set record to empty, just see if NULL is OK */\n\tif (tuple == NULL)\n\t{\n\t\t/* We run domain_check in a short-lived context to limit cruft */\n\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\n\t\tdomain_check((Datum) 0, true,\n\t\t\t\t\t erh->er_decltypeid,\n\t\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t\t erh->hdr.eoh_context);\n\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We might as well clean up cruft immediately. */\n\t\tMemoryContextReset(erh->er_short_term_cxt);\n\n\t\treturn;\n\t}\n\n\t/* Construct dummy header to contain replacement tuple */\n\tbuild_dummy_expanded_header(erh);\n\tdummy_erh = erh->er_dummy_header;\n\n\t/* Insert tuple, but don't bother to deconstruct its fields for now */\n\tdummy_erh->fvalue = tuple;\n\tdummy_erh->fstartptr = (char *) tuple->t_data;\n\tdummy_erh->fendptr = ((char *) tuple->t_data) + tuple->t_len;\n\tdummy_erh->flags |= ER_FLAG_FVALUE_VALID;\n\n\t/* Remember if we have any out-of-line field values */\n\tif (HeapTupleHasExternal(tuple))\n\t\tdummy_erh->flags |= ER_FLAG_HAVE_EXTERNAL;\n\n\t/*\n\t * We call domain_check in the short-lived context, so that any cruft\n\t * leaked by expression evaluation can be reclaimed.\n\t */\n\toldcxt = MemoryContextSwitchTo(erh->er_short_term_cxt);\n\n\t/*\n\t * And now we can apply the check.  Note we use main header's domain cache\n\t * space, so that caching carries across repeated uses.\n\t */\n\tdomain_check(ExpandedRecordGetRODatum(dummy_erh), false,\n\t\t\t\t erh->er_decltypeid,\n\t\t\t\t &erh->er_domaininfo,\n\t\t\t\t erh->hdr.eoh_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We might as well clean up cruft immediately. */\n\tMemoryContextReset(erh->er_short_term_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(erh->flags & ER_FLAG_IS_DUMMY)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\nstatic pg_noinline void check_domain_for_new_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t   HeapTuple tuple);\n\nvoid\nexpanded_record_set_tuple(ExpandedRecordHeader *erh,\n\t\t\t\t\t\t  HeapTuple tuple,\n\t\t\t\t\t\t  bool copy,\n\t\t\t\t\t\t  bool expand_external)\n{\n\tint\t\t\toldflags;\n\tHeapTuple\toldtuple;\n\tchar\t   *oldfstartptr;\n\tchar\t   *oldfendptr;\n\tint\t\t\tnewflags;\n\tHeapTuple\tnewtuple;\n\tMemoryContext oldcxt;\n\n\t/* Shouldn't ever be trying to assign new data to a dummy header */\n\tAssert(!(erh->flags & ER_FLAG_IS_DUMMY));\n\n\t/*\n\t * Before performing the assignment, see if result will satisfy domain.\n\t */\n\tif (erh->flags & ER_FLAG_IS_DOMAIN)\n\t\tcheck_domain_for_new_tuple(erh, tuple);\n\n\t/*\n\t * If we need to get rid of out-of-line field values, do so, using the\n\t * short-term context to avoid leaking whatever cruft the toast fetch\n\t * might generate.\n\t */\n\tif (expand_external && tuple)\n\t{\n\t\t/* Assert caller didn't ask for unsupported case */\n\t\tAssert(copy);\n\t\tif (HeapTupleHasExternal(tuple))\n\t\t{\n\t\t\toldcxt = MemoryContextSwitchTo(get_short_term_cxt(erh));\n\t\t\ttuple = toast_flatten_tuple(tuple, erh->er_tupdesc);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\t\telse\n\t\t\texpand_external = false;\t/* need not clean up below */\n\t}\n\n\t/*\n\t * Initialize new flags, keeping only non-data status bits.\n\t */\n\toldflags = erh->flags;\n\tnewflags = oldflags & ER_FLAGS_NON_DATA;\n\n\t/*\n\t * Copy tuple into local storage if needed.  We must be sure this succeeds\n\t * before we start to modify the expanded record's state.\n\t */\n\tif (copy && tuple)\n\t{\n\t\toldcxt = MemoryContextSwitchTo(erh->hdr.eoh_context);\n\t\tnewtuple = heap_copytuple(tuple);\n\t\tnewflags |= ER_FLAG_FVALUE_ALLOCED;\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\t/* We can now flush anything that detoasting might have leaked. */\n\t\tif (expand_external)\n\t\t\tMemoryContextReset(erh->er_short_term_cxt);\n\t}\n\telse\n\t\tnewtuple = tuple;\n\n\t/* Make copies of fields we're about to overwrite */\n\toldtuple = erh->fvalue;\n\toldfstartptr = erh->fstartptr;\n\toldfendptr = erh->fendptr;\n\n\t/*\n\t * It's now safe to update the expanded record's state.\n\t */\n\tif (newtuple)\n\t{\n\t\t/* Save flat representation */\n\t\terh->fvalue = newtuple;\n\t\terh->fstartptr = (char *) newtuple->t_data;\n\t\terh->fendptr = ((char *) newtuple->t_data) + newtuple->t_len;\n\t\tnewflags |= ER_FLAG_FVALUE_VALID;\n\n\t\t/* Remember if we have any out-of-line field values */\n\t\tif (HeapTupleHasExternal(newtuple))\n\t\t\tnewflags |= ER_FLAG_HAVE_EXTERNAL;\n\t}\n\telse\n\t{\n\t\terh->fvalue = NULL;\n\t\terh->fstartptr = erh->fendptr = NULL;\n\t}\n\n\terh->flags = newflags;\n\n\t/* Reset flat-size info; we don't bother to make it valid now */\n\terh->flat_size = 0;\n\n\t/*\n\t * Now, release any storage belonging to old field values.  It's safe to\n\t * do this because ER_FLAG_DVALUES_VALID is no longer set in erh->flags;\n\t * even if we fail partway through, the record is valid, and at worst\n\t * we've failed to reclaim some space.\n\t */\n\tif (oldflags & ER_FLAG_DVALUES_ALLOCED)\n\t{\n\t\tTupleDesc\ttupdesc = erh->er_tupdesc;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < erh->nfields; i++)\n\t\t{\n\t\t\tif (!erh->dnulls[i] &&\n\t\t\t\t!(TupleDescAttr(tupdesc, i)->attbyval))\n\t\t\t{\n\t\t\t\tchar\t   *oldValue = (char *) DatumGetPointer(erh->dvalues[i]);\n\n\t\t\t\tif (oldValue < oldfstartptr || oldValue >= oldfendptr)\n\t\t\t\t\tpfree(oldValue);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Likewise free the old tuple, if it was locally allocated */\n\tif (oldflags & ER_FLAG_FVALUE_ALLOCED)\n\t\theap_freetuple(oldtuple);\n\n\t/* We won't make a new deconstructed representation until/unless needed */\n}"
  },
  {
    "function_name": "make_expanded_record_from_exprecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "327-418",
    "snippet": "ExpandedRecordHeader *\nmake_expanded_record_from_exprecord(ExpandedRecordHeader *olderh,\n\t\t\t\t\t\t\t\t\tMemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(olderh);\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tchar\t   *chunk;\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Since we already know the number of fields in the tupdesc, we can\n\t * allocate the dvalues/dnulls arrays along with the record header.  This\n\t * is useless if we never need those arrays, but it costs almost nothing,\n\t * and it will save a palloc cycle if we do need them.\n\t */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAlloc(objcxt, MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t/* Ensure all header fields are initialized to 0/null */\n\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\terh->dvalues = (Datum *) chunk;\n\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\terh->nfields = tupdesc->natts;\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = olderh->er_decltypeid;\n\terh->er_typeid = olderh->er_typeid;\n\terh->er_typmod = olderh->er_typmod;\n\terh->er_tupdesc_id = olderh->er_tupdesc_id;\n\n\t/* The only flag bit that transfers over is IS_DOMAIN */\n\terh->flags = olderh->flags & ER_FLAG_IS_DOMAIN;\n\n\t/*\n\t * Copy tupdesc if needed, but we prefer to bump its refcount if possible.\n\t * We manage the refcount with a memory context callback rather than\n\t * assuming that the CurrentResourceOwner is longer-lived than this\n\t * expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback to release the refcount */\n\t\terh->er_mcb.func = ER_mc_callback;\n\t\terh->er_mcb.arg = (void *) erh;\n\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\n\t\t/* And save the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\t}\n\telse if (olderh->flags & ER_FLAG_TUPDESC_ALLOCED)\n\t{\n\t\t/* We need to make our own copy of the tupdesc */\n\t\toldcxt = MemoryContextSwitchTo(objcxt);\n\t\terh->er_tupdesc = CreateTupleDescCopy(tupdesc);\n\t\terh->flags |= ER_FLAG_TUPDESC_ALLOCED;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume the tupdesc will outlive this expanded object, just like\n\t\t * we're assuming it will outlive the source object.\n\t\t */\n\t\terh->er_tupdesc = tupdesc;\n\t}\n\n\t/*\n\t * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the\n\t * record remains logically empty.\n\t */\n\n\treturn erh;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
      "static void ER_mc_callback(void *arg);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "objcxt"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextRegisterResetCallback",
          "args": [
            "erh->hdr.eoh_context",
            "&erh->er_mcb"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextRegisterResetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "284-295",
          "snippet": "void\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_init_header",
          "args": [
            "&erh->hdr",
            "&ER_methods",
            "objcxt"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "47-65",
          "snippet": "void\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "erh",
            "0",
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "objcxt",
            "MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool))"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "parentcontext",
            "\"expanded record\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expanded_record_get_tupdesc",
          "args": [
            "olderh"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic void ER_mc_callback(void *arg);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nExpandedRecordHeader *\nmake_expanded_record_from_exprecord(ExpandedRecordHeader *olderh,\n\t\t\t\t\t\t\t\t\tMemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tTupleDesc\ttupdesc = expanded_record_get_tupdesc(olderh);\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tchar\t   *chunk;\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Since we already know the number of fields in the tupdesc, we can\n\t * allocate the dvalues/dnulls arrays along with the record header.  This\n\t * is useless if we never need those arrays, but it costs almost nothing,\n\t * and it will save a palloc cycle if we do need them.\n\t */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAlloc(objcxt, MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t/* Ensure all header fields are initialized to 0/null */\n\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\terh->dvalues = (Datum *) chunk;\n\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\terh->nfields = tupdesc->natts;\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = olderh->er_decltypeid;\n\terh->er_typeid = olderh->er_typeid;\n\terh->er_typmod = olderh->er_typmod;\n\terh->er_tupdesc_id = olderh->er_tupdesc_id;\n\n\t/* The only flag bit that transfers over is IS_DOMAIN */\n\terh->flags = olderh->flags & ER_FLAG_IS_DOMAIN;\n\n\t/*\n\t * Copy tupdesc if needed, but we prefer to bump its refcount if possible.\n\t * We manage the refcount with a memory context callback rather than\n\t * assuming that the CurrentResourceOwner is longer-lived than this\n\t * expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback to release the refcount */\n\t\terh->er_mcb.func = ER_mc_callback;\n\t\terh->er_mcb.arg = (void *) erh;\n\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\n\t\t/* And save the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\t}\n\telse if (olderh->flags & ER_FLAG_TUPDESC_ALLOCED)\n\t{\n\t\t/* We need to make our own copy of the tupdesc */\n\t\toldcxt = MemoryContextSwitchTo(objcxt);\n\t\terh->er_tupdesc = CreateTupleDescCopy(tupdesc);\n\t\terh->flags |= ER_FLAG_TUPDESC_ALLOCED;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume the tupdesc will outlive this expanded object, just like\n\t\t * we're assuming it will outlive the source object.\n\t\t */\n\t\terh->er_tupdesc = tupdesc;\n\t}\n\n\t/*\n\t * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the\n\t * record remains logically empty.\n\t */\n\n\treturn erh;\n}"
  },
  {
    "function_name": "make_expanded_record_from_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "203-314",
    "snippet": "ExpandedRecordHeader *\nmake_expanded_record_from_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\t\t  MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tuint64\t\ttupdesc_id;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tchar\t   *chunk;\n\n\tif (tupdesc->tdtypeid != RECORDOID)\n\t{\n\t\t/*\n\t\t * If it's a named composite type (not RECORD), we prefer to reference\n\t\t * the typcache's copy of the tupdesc, which is guaranteed to be\n\t\t * refcounted (the given tupdesc might not be).  In any case, we need\n\t\t * to consult the typcache to get the correct tupdesc identifier.\n\t\t *\n\t\t * Note that tdtypeid couldn't be a domain type, so we need not\n\t\t * consider that case here.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(tupdesc->tdtypeid, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(tupdesc->tdtypeid))));\n\t\ttupdesc = typentry->tupDesc;\n\t\ttupdesc_id = typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For RECORD types, get the appropriate unique identifier (possibly\n\t\t * freshly assigned).\n\t\t */\n\t\ttupdesc_id = assign_record_type_identifier(tupdesc->tdtypeid,\n\t\t\t\t\t\t\t\t\t\t\t\t   tupdesc->tdtypmod);\n\t}\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Since we already know the number of fields in the tupdesc, we can\n\t * allocate the dvalues/dnulls arrays along with the record header.  This\n\t * is useless if we never need those arrays, but it costs almost nothing,\n\t * and it will save a palloc cycle if we do need them.\n\t */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAlloc(objcxt, MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t/* Ensure all header fields are initialized to 0/null */\n\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\terh->dvalues = (Datum *) chunk;\n\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\terh->nfields = tupdesc->natts;\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = tupdesc->tdtypeid;\n\terh->er_typmod = tupdesc->tdtypmod;\n\terh->er_tupdesc_id = tupdesc_id;\n\n\t/*\n\t * Copy tupdesc if needed, but we prefer to bump its refcount if possible.\n\t * We manage the refcount with a memory context callback rather than\n\t * assuming that the CurrentResourceOwner is longer-lived than this\n\t * expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback to release the refcount */\n\t\terh->er_mcb.func = ER_mc_callback;\n\t\terh->er_mcb.arg = (void *) erh;\n\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\n\t\t/* And save the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\t}\n\telse\n\t{\n\t\t/* Just copy it */\n\t\toldcxt = MemoryContextSwitchTo(objcxt);\n\t\terh->er_tupdesc = CreateTupleDescCopy(tupdesc);\n\t\terh->flags |= ER_FLAG_TUPDESC_ALLOCED;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the\n\t * record remains logically empty.\n\t */\n\n\treturn erh;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
      "static void ER_mc_callback(void *arg);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "objcxt"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextRegisterResetCallback",
          "args": [
            "erh->hdr.eoh_context",
            "&erh->er_mcb"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextRegisterResetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "284-295",
          "snippet": "void\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_init_header",
          "args": [
            "&erh->hdr",
            "&ER_methods",
            "objcxt"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "47-65",
          "snippet": "void\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "erh",
            "0",
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "objcxt",
            "MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool))"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "parentcontext",
            "\"expanded record\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assign_record_type_identifier",
          "args": [
            "tupdesc->tdtypeid",
            "tupdesc->tdtypmod"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "assign_record_type_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1835-1869",
          "snippet": "uint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nuint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(tupdesc->tdtypeid)))"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"type %s is not composite\"",
            "format_type_be(tupdesc->tdtypeid)"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "tupdesc->tdtypeid"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "tupdesc->tdtypeid",
            "TYPECACHE_TUPDESC"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic void ER_mc_callback(void *arg);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nExpandedRecordHeader *\nmake_expanded_record_from_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\t\t  MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tuint64\t\ttupdesc_id;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tchar\t   *chunk;\n\n\tif (tupdesc->tdtypeid != RECORDOID)\n\t{\n\t\t/*\n\t\t * If it's a named composite type (not RECORD), we prefer to reference\n\t\t * the typcache's copy of the tupdesc, which is guaranteed to be\n\t\t * refcounted (the given tupdesc might not be).  In any case, we need\n\t\t * to consult the typcache to get the correct tupdesc identifier.\n\t\t *\n\t\t * Note that tdtypeid couldn't be a domain type, so we need not\n\t\t * consider that case here.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(tupdesc->tdtypeid, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(tupdesc->tdtypeid))));\n\t\ttupdesc = typentry->tupDesc;\n\t\ttupdesc_id = typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For RECORD types, get the appropriate unique identifier (possibly\n\t\t * freshly assigned).\n\t\t */\n\t\ttupdesc_id = assign_record_type_identifier(tupdesc->tdtypeid,\n\t\t\t\t\t\t\t\t\t\t\t\t   tupdesc->tdtypmod);\n\t}\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Since we already know the number of fields in the tupdesc, we can\n\t * allocate the dvalues/dnulls arrays along with the record header.  This\n\t * is useless if we never need those arrays, but it costs almost nothing,\n\t * and it will save a palloc cycle if we do need them.\n\t */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAlloc(objcxt, MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t/* Ensure all header fields are initialized to 0/null */\n\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\terh->dvalues = (Datum *) chunk;\n\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\terh->nfields = tupdesc->natts;\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = erh->er_typeid = tupdesc->tdtypeid;\n\terh->er_typmod = tupdesc->tdtypmod;\n\terh->er_tupdesc_id = tupdesc_id;\n\n\t/*\n\t * Copy tupdesc if needed, but we prefer to bump its refcount if possible.\n\t * We manage the refcount with a memory context callback rather than\n\t * assuming that the CurrentResourceOwner is longer-lived than this\n\t * expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback to release the refcount */\n\t\terh->er_mcb.func = ER_mc_callback;\n\t\terh->er_mcb.arg = (void *) erh;\n\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\n\t\t/* And save the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\t}\n\telse\n\t{\n\t\t/* Just copy it */\n\t\toldcxt = MemoryContextSwitchTo(objcxt);\n\t\terh->er_tupdesc = CreateTupleDescCopy(tupdesc);\n\t\terh->flags |= ER_FLAG_TUPDESC_ALLOCED;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the\n\t * record remains logically empty.\n\t */\n\n\treturn erh;\n}"
  },
  {
    "function_name": "make_expanded_record_from_typeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandedrecord.c",
    "lines": "67-190",
    "snippet": "ExpandedRecordHeader *\nmake_expanded_record_from_typeid(Oid type_id, int32 typmod,\n\t\t\t\t\t\t\t\t MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tint\t\t\tflags = 0;\n\tTupleDesc\ttupdesc;\n\tuint64\t\ttupdesc_id;\n\tMemoryContext objcxt;\n\tchar\t   *chunk;\n\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * Consult the typcache to see if it's a domain over composite, and in\n\t\t * any case to get the tupdesc and tupdesc identifier.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id,\n\t\t\t\t\t\t\t\t\t TYPECACHE_TUPDESC |\n\t\t\t\t\t\t\t\t\t TYPECACHE_DOMAIN_BASE_INFO);\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\tflags |= ER_FLAG_IS_DOMAIN;\n\t\t\ttypentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_TUPDESC);\n\t\t}\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\ttupdesc = typentry->tupDesc;\n\t\ttupdesc_id = typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For RECORD types, get the tupdesc and identifier from typcache.\n\t\t */\n\t\ttupdesc = lookup_rowtype_tupdesc(type_id, typmod);\n\t\ttupdesc_id = assign_record_type_identifier(type_id, typmod);\n\t}\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.  (This code path doesn't\n\t * ever need to copy a tupdesc into the expanded record, but let's be\n\t * consistent with the other ways of making an expanded record.)\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Since we already know the number of fields in the tupdesc, we can\n\t * allocate the dvalues/dnulls arrays along with the record header.  This\n\t * is useless if we never need those arrays, but it costs almost nothing,\n\t * and it will save a palloc cycle if we do need them.\n\t */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAlloc(objcxt, MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t/* Ensure all header fields are initialized to 0/null */\n\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\terh->dvalues = (Datum *) chunk;\n\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\terh->nfields = tupdesc->natts;\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = type_id;\n\terh->er_typeid = tupdesc->tdtypeid;\n\terh->er_typmod = tupdesc->tdtypmod;\n\terh->er_tupdesc_id = tupdesc_id;\n\n\terh->flags = flags;\n\n\t/*\n\t * If what we got from the typcache is a refcounted tupdesc, we need to\n\t * acquire our own refcount on it.  We manage the refcount with a memory\n\t * context callback rather than assuming that the CurrentResourceOwner is\n\t * longer-lived than this expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback to release the refcount */\n\t\terh->er_mcb.func = ER_mc_callback;\n\t\terh->er_mcb.arg = (void *) erh;\n\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\n\t\t/* And save the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\n\t\t/* If we called lookup_rowtype_tupdesc, release the pin it took */\n\t\tif (type_id == RECORDOID)\n\t\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If it's not refcounted, just assume it will outlive the expanded\n\t\t * object.  (This can happen for shared record types, for instance.)\n\t\t */\n\t\terh->er_tupdesc = tupdesc;\n\t}\n\n\t/*\n\t * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the\n\t * record remains logically empty.\n\t */\n\n\treturn erh;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/expandedrecord.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};",
      "static void ER_mc_callback(void *arg);",
      "static MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecrTupleDescRefCount",
          "args": [
            "tupdesc"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextRegisterResetCallback",
          "args": [
            "erh->hdr.eoh_context",
            "&erh->er_mcb"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextRegisterResetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "284-295",
          "snippet": "void\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextRegisterResetCallback(MemoryContext context,\n\t\t\t\t\t\t\t\t   MemoryContextCallback *cb)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Push onto head so this will be called before older registrants. */\n\tcb->next = context->reset_cbs;\n\tcontext->reset_cbs = cb;\n\t/* Mark the context as non-reset (it probably is already). */\n\tcontext->isReset = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_init_header",
          "args": [
            "&erh->hdr",
            "&ER_methods",
            "objcxt"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "47-65",
          "snippet": "void\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "erh",
            "0",
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "objcxt",
            "MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool))"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(ExpandedRecordHeader)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "parentcontext",
            "\"expanded record\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assign_record_type_identifier",
          "args": [
            "type_id",
            "typmod"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "assign_record_type_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1835-1869",
          "snippet": "uint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 RecordCacheArrayLen = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 RecordCacheArrayLen = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nuint64\nassign_record_type_identifier(Oid type_id, int32 typmod)\n{\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * It's a named composite type, so use the regular typcache.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id, TYPECACHE_TUPDESC);\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\tAssert(typentry->tupDesc_identifier != 0);\n\t\treturn typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * It's a transient record type, so look in our record-type table.\n\t\t */\n\t\tif (typmod >= 0 && typmod < RecordCacheArrayLen &&\n\t\t\tRecordCacheArray[typmod] != NULL)\n\t\t{\n\t\t\tAssert(RecordIdentifierArray[typmod] != 0);\n\t\t\treturn RecordIdentifierArray[typmod];\n\t\t}\n\n\t\t/* For anonymous or unrecognized record type, generate a new ID */\n\t\treturn ++tupledesc_id_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "type_id",
            "typmod"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id)))"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"type %s is not composite\"",
            "format_type_be(type_id)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "type_id"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "typentry->domainBaseType",
            "TYPECACHE_TUPDESC"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/expandedrecord.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/heap.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods ER_methods =\n{\n\tER_get_flat_size,\n\tER_flatten_into\n};\nstatic void ER_mc_callback(void *arg);\nstatic MemoryContext get_short_term_cxt(ExpandedRecordHeader *erh);\n\nExpandedRecordHeader *\nmake_expanded_record_from_typeid(Oid type_id, int32 typmod,\n\t\t\t\t\t\t\t\t MemoryContext parentcontext)\n{\n\tExpandedRecordHeader *erh;\n\tint\t\t\tflags = 0;\n\tTupleDesc\ttupdesc;\n\tuint64\t\ttupdesc_id;\n\tMemoryContext objcxt;\n\tchar\t   *chunk;\n\n\tif (type_id != RECORDOID)\n\t{\n\t\t/*\n\t\t * Consult the typcache to see if it's a domain over composite, and in\n\t\t * any case to get the tupdesc and tupdesc identifier.\n\t\t */\n\t\tTypeCacheEntry *typentry;\n\n\t\ttypentry = lookup_type_cache(type_id,\n\t\t\t\t\t\t\t\t\t TYPECACHE_TUPDESC |\n\t\t\t\t\t\t\t\t\t TYPECACHE_DOMAIN_BASE_INFO);\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\tflags |= ER_FLAG_IS_DOMAIN;\n\t\t\ttypentry = lookup_type_cache(typentry->domainBaseType,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_TUPDESC);\n\t\t}\n\t\tif (typentry->tupDesc == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(type_id))));\n\t\ttupdesc = typentry->tupDesc;\n\t\ttupdesc_id = typentry->tupDesc_identifier;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For RECORD types, get the tupdesc and identifier from typcache.\n\t\t */\n\t\ttupdesc = lookup_rowtype_tupdesc(type_id, typmod);\n\t\ttupdesc_id = assign_record_type_identifier(type_id, typmod);\n\t}\n\n\t/*\n\t * Allocate private context for expanded object.  We use a regular-size\n\t * context, not a small one, to improve the odds that we can fit a tupdesc\n\t * into it without needing an extra malloc block.  (This code path doesn't\n\t * ever need to copy a tupdesc into the expanded record, but let's be\n\t * consistent with the other ways of making an expanded record.)\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded record\",\n\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Since we already know the number of fields in the tupdesc, we can\n\t * allocate the dvalues/dnulls arrays along with the record header.  This\n\t * is useless if we never need those arrays, but it costs almost nothing,\n\t * and it will save a palloc cycle if we do need them.\n\t */\n\terh = (ExpandedRecordHeader *)\n\t\tMemoryContextAlloc(objcxt, MAXALIGN(sizeof(ExpandedRecordHeader))\n\t\t\t\t\t\t   + tupdesc->natts * (sizeof(Datum) + sizeof(bool)));\n\n\t/* Ensure all header fields are initialized to 0/null */\n\tmemset(erh, 0, sizeof(ExpandedRecordHeader));\n\n\tEOH_init_header(&erh->hdr, &ER_methods, objcxt);\n\terh->er_magic = ER_MAGIC;\n\n\t/* Set up dvalues/dnulls, with no valid contents as yet */\n\tchunk = (char *) erh + MAXALIGN(sizeof(ExpandedRecordHeader));\n\terh->dvalues = (Datum *) chunk;\n\terh->dnulls = (bool *) (chunk + tupdesc->natts * sizeof(Datum));\n\terh->nfields = tupdesc->natts;\n\n\t/* Fill in composite-type identification info */\n\terh->er_decltypeid = type_id;\n\terh->er_typeid = tupdesc->tdtypeid;\n\terh->er_typmod = tupdesc->tdtypmod;\n\terh->er_tupdesc_id = tupdesc_id;\n\n\terh->flags = flags;\n\n\t/*\n\t * If what we got from the typcache is a refcounted tupdesc, we need to\n\t * acquire our own refcount on it.  We manage the refcount with a memory\n\t * context callback rather than assuming that the CurrentResourceOwner is\n\t * longer-lived than this expanded object.\n\t */\n\tif (tupdesc->tdrefcount >= 0)\n\t{\n\t\t/* Register callback to release the refcount */\n\t\terh->er_mcb.func = ER_mc_callback;\n\t\terh->er_mcb.arg = (void *) erh;\n\t\tMemoryContextRegisterResetCallback(erh->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t   &erh->er_mcb);\n\n\t\t/* And save the pointer */\n\t\terh->er_tupdesc = tupdesc;\n\t\ttupdesc->tdrefcount++;\n\n\t\t/* If we called lookup_rowtype_tupdesc, release the pin it took */\n\t\tif (type_id == RECORDOID)\n\t\t\tDecrTupleDescRefCount(tupdesc);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If it's not refcounted, just assume it will outlive the expanded\n\t\t * object.  (This can happen for shared record types, for instance.)\n\t\t */\n\t\terh->er_tupdesc = tupdesc;\n\t}\n\n\t/*\n\t * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the\n\t * record remains logically empty.\n\t */\n\n\treturn erh;\n}"
  }
]