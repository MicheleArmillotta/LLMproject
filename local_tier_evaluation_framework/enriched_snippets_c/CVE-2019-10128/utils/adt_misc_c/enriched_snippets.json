[
  {
    "function_name": "pg_get_replica_identity_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "1009-1024",
    "snippet": "Datum\npg_get_replica_identity_index(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tOid\t\t\tidxoid;\n\tRelation\trel;\n\n\trel = heap_open(reloid, AccessShareLock);\n\tidxoid = RelationGetReplicaIndex(rel);\n\theap_close(rel, AccessShareLock);\n\n\tif (OidIsValid(idxoid))\n\t\tPG_RETURN_OID(idxoid);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "idxoid"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "idxoid"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetReplicaIndex",
          "args": [
            "rel"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetReplicaIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4573-4587",
          "snippet": "Oid\nRelationGetReplicaIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_replidindex;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nOid\nRelationGetReplicaIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_replidindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "reloid",
            "AccessShareLock"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_get_replica_identity_index(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tOid\t\t\tidxoid;\n\tRelation\trel;\n\n\trel = heap_open(reloid, AccessShareLock);\n\tidxoid = RelationGetReplicaIndex(rel);\n\theap_close(rel, AccessShareLock);\n\n\tif (OidIsValid(idxoid))\n\t\tPG_RETURN_OID(idxoid);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "pg_current_logfile_1arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "1000-1004",
    "snippet": "Datum\npg_current_logfile_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_current_logfile(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_current_logfile",
          "args": [
            "fcinfo"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "pg_current_logfile_1arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "1000-1004",
          "snippet": "Datum\npg_current_logfile_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_current_logfile(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_current_logfile_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_current_logfile(fcinfo);\n}"
  },
  {
    "function_name": "pg_current_logfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "914-991",
    "snippet": "Datum\npg_current_logfile(PG_FUNCTION_ARGS)\n{\n\tFILE\t   *fd;\n\tchar\t\tlbuffer[MAXPGPATH];\n\tchar\t   *logfmt;\n\tchar\t   *log_filepath;\n\tchar\t   *log_format = lbuffer;\n\tchar\t   *nlpos;\n\n\t/* The log format parameter is optional */\n\tif (PG_NARGS() == 0 || PG_ARGISNULL(0))\n\t\tlogfmt = NULL;\n\telse\n\t{\n\t\tlogfmt = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\n\t\tif (strcmp(logfmt, \"stderr\") != 0 && strcmp(logfmt, \"csvlog\") != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"log format \\\"%s\\\" is not supported\", logfmt),\n\t\t\t\t\t errhint(\"The supported log formats are \\\"stderr\\\" and \\\"csvlog\\\".\")));\n\t}\n\n\tfd = AllocateFile(LOG_METAINFO_DATAFILE, \"r\");\n\tif (fd == NULL)\n\t{\n\t\tif (errno != ENOENT)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tLOG_METAINFO_DATAFILE)));\n\t\tPG_RETURN_NULL();\n\t}\n\n\t/*\n\t * Read the file to gather current log filename(s) registered by the\n\t * syslogger.\n\t */\n\twhile (fgets(lbuffer, sizeof(lbuffer), fd) != NULL)\n\t{\n\t\t/*\n\t\t * Extract log format and log file path from the line; lbuffer ==\n\t\t * log_format, they share storage.\n\t\t */\n\t\tlog_filepath = strchr(lbuffer, ' ');\n\t\tif (log_filepath == NULL)\n\t\t{\n\t\t\t/* Uh oh.  No space found, so file content is corrupted. */\n\t\t\telog(ERROR,\n\t\t\t\t \"missing space character in \\\"%s\\\"\", LOG_METAINFO_DATAFILE);\n\t\t\tbreak;\n\t\t}\n\n\t\t*log_filepath = '\\0';\n\t\tlog_filepath++;\n\t\tnlpos = strchr(log_filepath, '\\n');\n\t\tif (nlpos == NULL)\n\t\t{\n\t\t\t/* Uh oh.  No newline found, so file content is corrupted. */\n\t\t\telog(ERROR,\n\t\t\t\t \"missing newline character in \\\"%s\\\"\", LOG_METAINFO_DATAFILE);\n\t\t\tbreak;\n\t\t}\n\t\t*nlpos = '\\0';\n\n\t\tif (logfmt == NULL || strcmp(logfmt, log_format) == 0)\n\t\t{\n\t\t\tFreeFile(fd);\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(log_filepath));\n\t\t}\n\t}\n\n\t/* Close the current log filename file. */\n\tFreeFile(fd);\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "fd"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(log_filepath)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "log_filepath"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "fd"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "logfmt",
            "log_format"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing newline character in \\\"%s\\\"\"",
            "LOG_METAINFO_DATAFILE"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "log_filepath",
            "'\\n'"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "lbuffer",
            "' '"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "lbuffer",
            "sizeof(lbuffer)",
            "fd"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tLOG_METAINFO_DATAFILE))"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read file \\\"%s\\\": %m\"",
            "LOG_METAINFO_DATAFILE"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "LOG_METAINFO_DATAFILE",
            "\"r\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"log format \\\"%s\\\" is not supported\", logfmt),\n\t\t\t\t\t errhint(\"The supported log formats are \\\"stderr\\\" and \\\"csvlog\\\".\"))"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"The supported log formats are \\\"stderr\\\" and \\\"csvlog\\\".\""
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_current_logfile(PG_FUNCTION_ARGS)\n{\n\tFILE\t   *fd;\n\tchar\t\tlbuffer[MAXPGPATH];\n\tchar\t   *logfmt;\n\tchar\t   *log_filepath;\n\tchar\t   *log_format = lbuffer;\n\tchar\t   *nlpos;\n\n\t/* The log format parameter is optional */\n\tif (PG_NARGS() == 0 || PG_ARGISNULL(0))\n\t\tlogfmt = NULL;\n\telse\n\t{\n\t\tlogfmt = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\n\t\tif (strcmp(logfmt, \"stderr\") != 0 && strcmp(logfmt, \"csvlog\") != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"log format \\\"%s\\\" is not supported\", logfmt),\n\t\t\t\t\t errhint(\"The supported log formats are \\\"stderr\\\" and \\\"csvlog\\\".\")));\n\t}\n\n\tfd = AllocateFile(LOG_METAINFO_DATAFILE, \"r\");\n\tif (fd == NULL)\n\t{\n\t\tif (errno != ENOENT)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tLOG_METAINFO_DATAFILE)));\n\t\tPG_RETURN_NULL();\n\t}\n\n\t/*\n\t * Read the file to gather current log filename(s) registered by the\n\t * syslogger.\n\t */\n\twhile (fgets(lbuffer, sizeof(lbuffer), fd) != NULL)\n\t{\n\t\t/*\n\t\t * Extract log format and log file path from the line; lbuffer ==\n\t\t * log_format, they share storage.\n\t\t */\n\t\tlog_filepath = strchr(lbuffer, ' ');\n\t\tif (log_filepath == NULL)\n\t\t{\n\t\t\t/* Uh oh.  No space found, so file content is corrupted. */\n\t\t\telog(ERROR,\n\t\t\t\t \"missing space character in \\\"%s\\\"\", LOG_METAINFO_DATAFILE);\n\t\t\tbreak;\n\t\t}\n\n\t\t*log_filepath = '\\0';\n\t\tlog_filepath++;\n\t\tnlpos = strchr(log_filepath, '\\n');\n\t\tif (nlpos == NULL)\n\t\t{\n\t\t\t/* Uh oh.  No newline found, so file content is corrupted. */\n\t\t\telog(ERROR,\n\t\t\t\t \"missing newline character in \\\"%s\\\"\", LOG_METAINFO_DATAFILE);\n\t\t\tbreak;\n\t\t}\n\t\t*nlpos = '\\0';\n\n\t\tif (logfmt == NULL || strcmp(logfmt, log_format) == 0)\n\t\t{\n\t\t\tFreeFile(fd);\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(log_filepath));\n\t\t}\n\t}\n\n\t/* Close the current log filename file. */\n\tFreeFile(fd);\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "parse_ident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "775-907",
    "snippet": "Datum\nparse_ident(PG_FUNCTION_ARGS)\n{\n\ttext\t   *qualname = PG_GETARG_TEXT_PP(0);\n\tbool\t\tstrict = PG_GETARG_BOOL(1);\n\tchar\t   *qualname_str = text_to_cstring(qualname);\n\tArrayBuildState *astate = NULL;\n\tchar\t   *nextp;\n\tbool\t\tafter_dot = false;\n\n\t/*\n\t * The code below scribbles on qualname_str in some cases, so we should\n\t * reconvert qualname if we need to show the original string in error\n\t * messages.\n\t */\n\tnextp = qualname_str;\n\n\t/* skip leading whitespace */\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\n\n\tfor (;;)\n\t{\n\t\tchar\t   *curname;\n\t\tbool\t\tmissing_ident = true;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\tchar\t   *endp;\n\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t\t errdetail(\"String has unclosed double quotes.\")));\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\tnextp = endp + 1;\n\t\t\t*endp = '\\0';\n\n\t\t\tif (endp - curname == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"Quoted identifier must not be empty.\")));\n\n\t\t\tastate = accumArrayResult(astate, CStringGetTextDatum(curname),\n\t\t\t\t\t\t\t\t\t  false, TEXTOID, CurrentMemoryContext);\n\t\t\tmissing_ident = false;\n\t\t}\n\t\telse if (is_ident_start((unsigned char) *nextp))\n\t\t{\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\t\t\ttext\t   *part;\n\n\t\t\tcurname = nextp++;\n\t\t\twhile (is_ident_cont((unsigned char) *nextp))\n\t\t\t\tnextp++;\n\n\t\t\tlen = nextp - curname;\n\n\t\t\t/*\n\t\t\t * We don't implicitly truncate identifiers. This is useful for\n\t\t\t * allowing the user to check for specific parts of the identifier\n\t\t\t * being too long. It's easy enough for the user to get the\n\t\t\t * truncated names by casting our output to name[].\n\t\t\t */\n\t\t\tdownname = downcase_identifier(curname, len, false, false);\n\t\t\tpart = cstring_to_text_with_len(downname, len);\n\t\t\tastate = accumArrayResult(astate, PointerGetDatum(part), false,\n\t\t\t\t\t\t\t\t\t  TEXTOID, CurrentMemoryContext);\n\t\t\tmissing_ident = false;\n\t\t}\n\n\t\tif (missing_ident)\n\t\t{\n\t\t\t/* Different error messages based on where we failed. */\n\t\t\tif (*nextp == '.')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"No valid identifier before \\\".\\\".\")));\n\t\t\telse if (after_dot)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"No valid identifier after \\\".\\\".\")));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname))));\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\n\n\t\tif (*nextp == '.')\n\t\t{\n\t\t\tafter_dot = true;\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (strict)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname))));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPG_RETURN_DATUM(makeArrayResult(astate, CurrentMemoryContext));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "makeArrayResult(astate, CurrentMemoryContext)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeArrayResult",
          "args": [
            "astate",
            "CurrentMemoryContext"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5117-5132",
          "snippet": "Datum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)))"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"string is not a valid identifier: \\\"%s\\\"\"",
            "text_to_cstring(qualname)"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "qualname"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)))"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"No valid identifier after \\\".\\\".\"))"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"No valid identifier after \\\".\\\".\""
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"No valid identifier before \\\".\\\".\"))"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "astate",
            "PointerGetDatum(part)",
            "false",
            "TEXTOID",
            "CurrentMemoryContext"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "part"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "downname",
            "len"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_identifier",
          "args": [
            "curname",
            "len",
            "false",
            "false"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ident_cont",
          "args": [
            "(unsigned char) *nextp"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "is_ident_cont",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "760-768",
          "snippet": "static bool\nis_ident_cont(unsigned char c)\n{\n\t/* Can be digit or dollar sign ... */\n\tif ((c >= '0' && c <= '9') || c == '$')\n\t\treturn true;\n\t/* ... or an identifier start character */\n\treturn is_ident_start(c);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nis_ident_cont(unsigned char c)\n{\n\t/* Can be digit or dollar sign ... */\n\tif ((c >= '0' && c <= '9') || c == '$')\n\t\treturn true;\n\t/* ... or an identifier start character */\n\treturn is_ident_start(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ident_start",
          "args": [
            "(unsigned char) *nextp"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "is_ident_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "742-754",
          "snippet": "static bool\nis_ident_start(unsigned char c)\n{\n\t/* Underscores and ASCII letters are OK */\n\tif (c == '_')\n\t\treturn true;\n\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\treturn true;\n\t/* Any high-bit-set character is OK (might be part of a multibyte char) */\n\tif (IS_HIGHBIT_SET(c))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nis_ident_start(unsigned char c)\n{\n\t/* Underscores and ASCII letters are OK */\n\tif (c == '_')\n\t\treturn true;\n\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\treturn true;\n\t/* Any high-bit-set character is OK (might be part of a multibyte char) */\n\tif (IS_HIGHBIT_SET(c))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "curname"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"Quoted identifier must not be empty.\"))"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "endp",
            "endp + 1",
            "strlen(endp)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "endp"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t\t errdetail(\"String has unclosed double quotes.\"))"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nextp + 1",
            "'\"'"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\nparse_ident(PG_FUNCTION_ARGS)\n{\n\ttext\t   *qualname = PG_GETARG_TEXT_PP(0);\n\tbool\t\tstrict = PG_GETARG_BOOL(1);\n\tchar\t   *qualname_str = text_to_cstring(qualname);\n\tArrayBuildState *astate = NULL;\n\tchar\t   *nextp;\n\tbool\t\tafter_dot = false;\n\n\t/*\n\t * The code below scribbles on qualname_str in some cases, so we should\n\t * reconvert qualname if we need to show the original string in error\n\t * messages.\n\t */\n\tnextp = qualname_str;\n\n\t/* skip leading whitespace */\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\n\n\tfor (;;)\n\t{\n\t\tchar\t   *curname;\n\t\tbool\t\tmissing_ident = true;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\tchar\t   *endp;\n\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t\t errdetail(\"String has unclosed double quotes.\")));\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\tnextp = endp + 1;\n\t\t\t*endp = '\\0';\n\n\t\t\tif (endp - curname == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"Quoted identifier must not be empty.\")));\n\n\t\t\tastate = accumArrayResult(astate, CStringGetTextDatum(curname),\n\t\t\t\t\t\t\t\t\t  false, TEXTOID, CurrentMemoryContext);\n\t\t\tmissing_ident = false;\n\t\t}\n\t\telse if (is_ident_start((unsigned char) *nextp))\n\t\t{\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\t\t\ttext\t   *part;\n\n\t\t\tcurname = nextp++;\n\t\t\twhile (is_ident_cont((unsigned char) *nextp))\n\t\t\t\tnextp++;\n\n\t\t\tlen = nextp - curname;\n\n\t\t\t/*\n\t\t\t * We don't implicitly truncate identifiers. This is useful for\n\t\t\t * allowing the user to check for specific parts of the identifier\n\t\t\t * being too long. It's easy enough for the user to get the\n\t\t\t * truncated names by casting our output to name[].\n\t\t\t */\n\t\t\tdownname = downcase_identifier(curname, len, false, false);\n\t\t\tpart = cstring_to_text_with_len(downname, len);\n\t\t\tastate = accumArrayResult(astate, PointerGetDatum(part), false,\n\t\t\t\t\t\t\t\t\t  TEXTOID, CurrentMemoryContext);\n\t\t\tmissing_ident = false;\n\t\t}\n\n\t\tif (missing_ident)\n\t\t{\n\t\t\t/* Different error messages based on where we failed. */\n\t\t\tif (*nextp == '.')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"No valid identifier before \\\".\\\".\")));\n\t\t\telse if (after_dot)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname)),\n\t\t\t\t\t\t errdetail(\"No valid identifier after \\\".\\\".\")));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname))));\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\n\n\t\tif (*nextp == '.')\n\t\t{\n\t\t\tafter_dot = true;\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (strict)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"string is not a valid identifier: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttext_to_cstring(qualname))));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPG_RETURN_DATUM(makeArrayResult(astate, CurrentMemoryContext));\n}"
  },
  {
    "function_name": "is_ident_cont",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "760-768",
    "snippet": "static bool\nis_ident_cont(unsigned char c)\n{\n\t/* Can be digit or dollar sign ... */\n\tif ((c >= '0' && c <= '9') || c == '$')\n\t\treturn true;\n\t/* ... or an identifier start character */\n\treturn is_ident_start(c);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_ident_start",
          "args": [
            "c"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "is_ident_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "742-754",
          "snippet": "static bool\nis_ident_start(unsigned char c)\n{\n\t/* Underscores and ASCII letters are OK */\n\tif (c == '_')\n\t\treturn true;\n\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\treturn true;\n\t/* Any high-bit-set character is OK (might be part of a multibyte char) */\n\tif (IS_HIGHBIT_SET(c))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nis_ident_start(unsigned char c)\n{\n\t/* Underscores and ASCII letters are OK */\n\tif (c == '_')\n\t\treturn true;\n\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\treturn true;\n\t/* Any high-bit-set character is OK (might be part of a multibyte char) */\n\tif (IS_HIGHBIT_SET(c))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nis_ident_cont(unsigned char c)\n{\n\t/* Can be digit or dollar sign ... */\n\tif ((c >= '0' && c <= '9') || c == '$')\n\t\treturn true;\n\t/* ... or an identifier start character */\n\treturn is_ident_start(c);\n}"
  },
  {
    "function_name": "is_ident_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "742-754",
    "snippet": "static bool\nis_ident_start(unsigned char c)\n{\n\t/* Underscores and ASCII letters are OK */\n\tif (c == '_')\n\t\treturn true;\n\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\treturn true;\n\t/* Any high-bit-set character is OK (might be part of a multibyte char) */\n\tif (IS_HIGHBIT_SET(c))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nis_ident_start(unsigned char c)\n{\n\t/* Underscores and ASCII letters are OK */\n\tif (c == '_')\n\t\treturn true;\n\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\treturn true;\n\t/* Any high-bit-set character is OK (might be part of a multibyte char) */\n\tif (IS_HIGHBIT_SET(c))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "pg_column_is_updatable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "715-735",
    "snippet": "Datum\npg_column_is_updatable(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tAttrNumber\tattnum = PG_GETARG_INT16(1);\n\tAttrNumber\tcol = attnum - FirstLowInvalidHeapAttributeNumber;\n\tbool\t\tinclude_triggers = PG_GETARG_BOOL(2);\n\tint\t\t\tevents;\n\n\t/* System columns are never updatable */\n\tif (attnum <= 0)\n\t\tPG_RETURN_BOOL(false);\n\n\tevents = relation_is_updatable(reloid, include_triggers,\n\t\t\t\t\t\t\t\t   bms_make_singleton(col));\n\n\t/* We require both updatability and deletability of the relation */\n#define REQ_EVENTS ((1 << CMD_UPDATE) | (1 << CMD_DELETE))\n\n\tPG_RETURN_BOOL((events & REQ_EVENTS) == REQ_EVENTS);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define REQ_EVENTS ((1 << CMD_UPDATE) | (1 << CMD_DELETE))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "(events & REQ_EVENTS) == REQ_EVENTS"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_is_updatable",
          "args": [
            "reloid",
            "include_triggers",
            "bms_make_singleton(col)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_make_singleton",
          "args": [
            "col"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "1"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define REQ_EVENTS ((1 << CMD_UPDATE) | (1 << CMD_DELETE))\n\nDatum\npg_column_is_updatable(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tAttrNumber\tattnum = PG_GETARG_INT16(1);\n\tAttrNumber\tcol = attnum - FirstLowInvalidHeapAttributeNumber;\n\tbool\t\tinclude_triggers = PG_GETARG_BOOL(2);\n\tint\t\t\tevents;\n\n\t/* System columns are never updatable */\n\tif (attnum <= 0)\n\t\tPG_RETURN_BOOL(false);\n\n\tevents = relation_is_updatable(reloid, include_triggers,\n\t\t\t\t\t\t\t\t   bms_make_singleton(col));\n\n\t/* We require both updatability and deletability of the relation */\n#define REQ_EVENTS ((1 << CMD_UPDATE) | (1 << CMD_DELETE))\n\n\tPG_RETURN_BOOL((events & REQ_EVENTS) == REQ_EVENTS);\n}"
  },
  {
    "function_name": "pg_relation_is_updatable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "698-705",
    "snippet": "Datum\npg_relation_is_updatable(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tbool\t\tinclude_triggers = PG_GETARG_BOOL(1);\n\n\tPG_RETURN_INT32(relation_is_updatable(reloid, include_triggers, NULL));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "relation_is_updatable(reloid, include_triggers, NULL)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_is_updatable",
          "args": [
            "reloid",
            "include_triggers",
            "NULL"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_relation_is_updatable(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tbool\t\tinclude_triggers = PG_GETARG_BOOL(1);\n\n\tPG_RETURN_INT32(relation_is_updatable(reloid, include_triggers, NULL));\n}"
  },
  {
    "function_name": "pg_collation_for",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "669-688",
    "snippet": "Datum\npg_collation_for(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypeid;\n\tOid\t\t\tcollid;\n\n\ttypeid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (!typeid)\n\t\tPG_RETURN_NULL();\n\tif (!type_is_collatable(typeid) && typeid != UNKNOWNOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"collations are not supported by type %s\",\n\t\t\t\t\t\tformat_type_be(typeid))));\n\n\tcollid = PG_GET_COLLATION();\n\tif (!collid)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_TEXT_P(cstring_to_text(generate_collation_name(collid)));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(generate_collation_name(collid))"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "generate_collation_name(collid)"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "generate_collation_name",
          "args": [
            "collid"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "generate_collation_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "11068-11093",
          "snippet": "char *\ngenerate_collation_name(Oid collid)\n{\n\tHeapTuple\ttp;\n\tForm_pg_collation colltup;\n\tchar\t   *collname;\n\tchar\t   *nspname;\n\tchar\t   *result;\n\n\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\tcolltup = (Form_pg_collation) GETSTRUCT(tp);\n\tcollname = NameStr(colltup->collname);\n\n\tif (!CollationIsVisible(collid))\n\t\tnspname = get_namespace_name(colltup->collnamespace);\n\telse\n\t\tnspname = NULL;\n\n\tresult = quote_qualified_identifier(nspname, collname);\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\ngenerate_collation_name(Oid collid)\n{\n\tHeapTuple\ttp;\n\tForm_pg_collation colltup;\n\tchar\t   *collname;\n\tchar\t   *nspname;\n\tchar\t   *result;\n\n\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\tcolltup = (Form_pg_collation) GETSTRUCT(tp);\n\tcollname = NameStr(colltup->collname);\n\n\tif (!CollationIsVisible(collid))\n\t\tnspname = get_namespace_name(colltup->collnamespace);\n\telse\n\t\tnspname = NULL;\n\n\tresult = quote_qualified_identifier(nspname, collname);\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"collations are not supported by type %s\",\n\t\t\t\t\t\tformat_type_be(typeid)))"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"collations are not supported by type %s\"",
            "format_type_be(typeid)"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "typeid"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "type_is_collatable",
          "args": [
            "typeid"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "type_is_collatable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2847-2851",
          "snippet": "bool\ntype_is_collatable(Oid typid)\n{\n\treturn OidIsValid(get_typcollation(typid));\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\ntype_is_collatable(Oid typid)\n{\n\treturn OidIsValid(get_typcollation(typid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_collation_for(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypeid;\n\tOid\t\t\tcollid;\n\n\ttypeid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (!typeid)\n\t\tPG_RETURN_NULL();\n\tif (!type_is_collatable(typeid) && typeid != UNKNOWNOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"collations are not supported by type %s\",\n\t\t\t\t\t\tformat_type_be(typeid))));\n\n\tcollid = PG_GET_COLLATION();\n\tif (!collid)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_TEXT_P(cstring_to_text(generate_collation_name(collid)));\n}"
  },
  {
    "function_name": "pg_typeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "658-662",
    "snippet": "Datum\npg_typeof(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_OID(get_fn_expr_argtype(fcinfo->flinfo, 0));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "get_fn_expr_argtype(fcinfo->flinfo, 0)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_typeof(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_OID(get_fn_expr_argtype(fcinfo->flinfo, 0));\n}"
  },
  {
    "function_name": "pg_get_keywords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "586-652",
    "snippet": "Datum\npg_get_keywords(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"catcode\",\n\t\t\t\t\t\t   CHAROID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"catdesc\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\n\t\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\tif (funcctx->call_cntr < NumScanKeywords)\n\t{\n\t\tchar\t   *values[3];\n\t\tHeapTuple\ttuple;\n\n\t\t/* cast-away-const is ugly but alternatives aren't much better */\n\t\tvalues[0] = (char *) ScanKeywords[funcctx->call_cntr].name;\n\n\t\tswitch (ScanKeywords[funcctx->call_cntr].category)\n\t\t{\n\t\t\tcase UNRESERVED_KEYWORD:\n\t\t\t\tvalues[1] = \"U\";\n\t\t\t\tvalues[2] = _(\"unreserved\");\n\t\t\t\tbreak;\n\t\t\tcase COL_NAME_KEYWORD:\n\t\t\t\tvalues[1] = \"C\";\n\t\t\t\tvalues[2] = _(\"unreserved (cannot be function or type name)\");\n\t\t\t\tbreak;\n\t\t\tcase TYPE_FUNC_NAME_KEYWORD:\n\t\t\t\tvalues[1] = \"T\";\n\t\t\t\tvalues[2] = _(\"reserved (can be function or type name)\");\n\t\t\t\tbreak;\n\t\t\tcase RESERVED_KEYWORD:\n\t\t\t\tvalues[1] = \"R\";\n\t\t\t\tvalues[2] = _(\"reserved\");\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t/* shouldn't be possible */\n\t\t\t\tvalues[1] = NULL;\n\t\t\t\tvalues[2] = NULL;\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "HeapTupleGetDatum(tuple)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BuildTupleFromCStrings",
          "args": [
            "funcctx->attinmeta",
            "values"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"reserved\""
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_replica_identity_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "1009-1024",
          "snippet": "Datum\npg_get_replica_identity_index(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tOid\t\t\tidxoid;\n\tRelation\trel;\n\n\trel = heap_open(reloid, AccessShareLock);\n\tidxoid = RelationGetReplicaIndex(rel);\n\theap_close(rel, AccessShareLock);\n\n\tif (OidIsValid(idxoid))\n\t\tPG_RETURN_OID(idxoid);\n\telse\n\t\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_get_replica_identity_index(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\tOid\t\t\tidxoid;\n\tRelation\trel;\n\n\trel = heap_open(reloid, AccessShareLock);\n\tidxoid = RelationGetReplicaIndex(rel);\n\theap_close(rel, AccessShareLock);\n\n\tif (OidIsValid(idxoid))\n\t\tPG_RETURN_OID(idxoid);\n\telse\n\t\tPG_RETURN_NULL();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescGetAttInMetadata",
          "args": [
            "tupdesc"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"catdesc\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"catcode\"",
            "CHAROID",
            "-1",
            "0"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"word\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "3",
            "false"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_get_keywords(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"catcode\",\n\t\t\t\t\t\t   CHAROID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"catdesc\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\n\t\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\tif (funcctx->call_cntr < NumScanKeywords)\n\t{\n\t\tchar\t   *values[3];\n\t\tHeapTuple\ttuple;\n\n\t\t/* cast-away-const is ugly but alternatives aren't much better */\n\t\tvalues[0] = (char *) ScanKeywords[funcctx->call_cntr].name;\n\n\t\tswitch (ScanKeywords[funcctx->call_cntr].category)\n\t\t{\n\t\t\tcase UNRESERVED_KEYWORD:\n\t\t\t\tvalues[1] = \"U\";\n\t\t\t\tvalues[2] = _(\"unreserved\");\n\t\t\t\tbreak;\n\t\t\tcase COL_NAME_KEYWORD:\n\t\t\t\tvalues[1] = \"C\";\n\t\t\t\tvalues[2] = _(\"unreserved (cannot be function or type name)\");\n\t\t\t\tbreak;\n\t\t\tcase TYPE_FUNC_NAME_KEYWORD:\n\t\t\t\tvalues[1] = \"T\";\n\t\t\t\tvalues[2] = _(\"reserved (can be function or type name)\");\n\t\t\t\tbreak;\n\t\t\tcase RESERVED_KEYWORD:\n\t\t\t\tvalues[1] = \"R\";\n\t\t\t\tvalues[2] = _(\"reserved\");\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t/* shouldn't be possible */\n\t\t\t\tvalues[1] = NULL;\n\t\t\t\tvalues[2] = NULL;\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "pg_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "538-583",
    "snippet": "Datum\npg_sleep(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tsecs = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tendtime;\n\n\t/*\n\t * We sleep using WaitLatch, to ensure that we'll wake up promptly if an\n\t * important signal (such as SIGALRM or SIGINT) arrives.  Because\n\t * WaitLatch's upper limit of delay is INT_MAX milliseconds, and the user\n\t * might ask for more than that, we sleep for at most 10 minutes and then\n\t * loop.\n\t *\n\t * By computing the intended stop time initially, we avoid accumulation of\n\t * extra delay across multiple sleeps.  This also ensures we won't delay\n\t * less than the specified time when WaitLatch is terminated early by a\n\t * non-query-canceling signal such as SIGHUP.\n\t */\n#define GetNowFloat()\t((float8) GetCurrentTimestamp() / 1000000.0)\n\n\tendtime = GetNowFloat() + secs;\n\n\tfor (;;)\n\t{\n\t\tfloat8\t\tdelay;\n\t\tlong\t\tdelay_ms;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tdelay = endtime - GetNowFloat();\n\t\tif (delay >= 600.0)\n\t\t\tdelay_ms = 600000;\n\t\telse if (delay > 0.0)\n\t\t\tdelay_ms = (long) ceil(delay * 1000.0);\n\t\telse\n\t\t\tbreak;\n\n\t\t(void) WaitLatch(MyLatch,\n\t\t\t\t\t\t WL_LATCH_SET | WL_TIMEOUT,\n\t\t\t\t\t\t delay_ms,\n\t\t\t\t\t\t WAIT_EVENT_PG_SLEEP);\n\t\tResetLatch(MyLatch);\n\t}\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetLatch",
          "args": [
            "MyLatch"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WaitLatch",
          "args": [
            "MyLatch",
            "WL_LATCH_SET | WL_TIMEOUT",
            "delay_ms",
            "WAIT_EVENT_PG_SLEEP"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "delay * 1000.0"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetNowFloat",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNowFloat",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_sleep(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tsecs = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tendtime;\n\n\t/*\n\t * We sleep using WaitLatch, to ensure that we'll wake up promptly if an\n\t * important signal (such as SIGALRM or SIGINT) arrives.  Because\n\t * WaitLatch's upper limit of delay is INT_MAX milliseconds, and the user\n\t * might ask for more than that, we sleep for at most 10 minutes and then\n\t * loop.\n\t *\n\t * By computing the intended stop time initially, we avoid accumulation of\n\t * extra delay across multiple sleeps.  This also ensures we won't delay\n\t * less than the specified time when WaitLatch is terminated early by a\n\t * non-query-canceling signal such as SIGHUP.\n\t */\n#define GetNowFloat()\t((float8) GetCurrentTimestamp() / 1000000.0)\n\n\tendtime = GetNowFloat() + secs;\n\n\tfor (;;)\n\t{\n\t\tfloat8\t\tdelay;\n\t\tlong\t\tdelay_ms;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tdelay = endtime - GetNowFloat();\n\t\tif (delay >= 600.0)\n\t\t\tdelay_ms = 600000;\n\t\telse if (delay > 0.0)\n\t\t\tdelay_ms = (long) ceil(delay * 1000.0);\n\t\telse\n\t\t\tbreak;\n\n\t\t(void) WaitLatch(MyLatch,\n\t\t\t\t\t\t WL_LATCH_SET | WL_TIMEOUT,\n\t\t\t\t\t\t delay_ms,\n\t\t\t\t\t\t WAIT_EVENT_PG_SLEEP);\n\t\tResetLatch(MyLatch);\n\t}\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_tablespace_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "482-533",
    "snippet": "Datum\npg_tablespace_location(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttablespaceOid = PG_GETARG_OID(0);\n\tchar\t\tsourcepath[MAXPGPATH];\n\tchar\t\ttargetpath[MAXPGPATH];\n\tint\t\t\trllen;\n\n\t/*\n\t * It's useful to apply this function to pg_class.reltablespace, wherein\n\t * zero means \"the database's default tablespace\".  So, rather than\n\t * throwing an error for zero, we choose to assume that's what is meant.\n\t */\n\tif (tablespaceOid == InvalidOid)\n\t\ttablespaceOid = MyDatabaseTableSpace;\n\n\t/*\n\t * Return empty string for the cluster's default tablespaces\n\t */\n\tif (tablespaceOid == DEFAULTTABLESPACE_OID ||\n\t\ttablespaceOid == GLOBALTABLESPACE_OID)\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\n#if defined(HAVE_READLINK) || defined(WIN32)\n\n\t/*\n\t * Find the location of the tablespace by reading the symbolic link that\n\t * is in pg_tblspc/<oid>.\n\t */\n\tsnprintf(sourcepath, sizeof(sourcepath), \"pg_tblspc/%u\", tablespaceOid);\n\n\trllen = readlink(sourcepath, targetpath, sizeof(targetpath));\n\tif (rllen < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read symbolic link \\\"%s\\\": %m\",\n\t\t\t\t\t\tsourcepath)));\n\tif (rllen >= sizeof(targetpath))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"symbolic link \\\"%s\\\" target is too long\",\n\t\t\t\t\t\tsourcepath)));\n\ttargetpath[rllen] = '\\0';\n\n\tPG_RETURN_TEXT_P(cstring_to_text(targetpath));\n#else\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"tablespaces are not supported on this platform\")));\n\tPG_RETURN_NULL();\n#endif\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"tablespaces are not supported on this platform\"))"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"tablespaces are not supported on this platform\""
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(targetpath)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "targetpath"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"symbolic link \\\"%s\\\" target is too long\",\n\t\t\t\t\t\tsourcepath))"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read symbolic link \\\"%s\\\": %m\",\n\t\t\t\t\t\tsourcepath))"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "sourcepath",
            "targetpath",
            "sizeof(targetpath)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sourcepath",
            "sizeof(sourcepath)",
            "\"pg_tblspc/%u\"",
            "tablespaceOid"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(\"\")"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_tablespace_location(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttablespaceOid = PG_GETARG_OID(0);\n\tchar\t\tsourcepath[MAXPGPATH];\n\tchar\t\ttargetpath[MAXPGPATH];\n\tint\t\t\trllen;\n\n\t/*\n\t * It's useful to apply this function to pg_class.reltablespace, wherein\n\t * zero means \"the database's default tablespace\".  So, rather than\n\t * throwing an error for zero, we choose to assume that's what is meant.\n\t */\n\tif (tablespaceOid == InvalidOid)\n\t\ttablespaceOid = MyDatabaseTableSpace;\n\n\t/*\n\t * Return empty string for the cluster's default tablespaces\n\t */\n\tif (tablespaceOid == DEFAULTTABLESPACE_OID ||\n\t\ttablespaceOid == GLOBALTABLESPACE_OID)\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\n#if defined(HAVE_READLINK) || defined(WIN32)\n\n\t/*\n\t * Find the location of the tablespace by reading the symbolic link that\n\t * is in pg_tblspc/<oid>.\n\t */\n\tsnprintf(sourcepath, sizeof(sourcepath), \"pg_tblspc/%u\", tablespaceOid);\n\n\trllen = readlink(sourcepath, targetpath, sizeof(targetpath));\n\tif (rllen < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read symbolic link \\\"%s\\\": %m\",\n\t\t\t\t\t\tsourcepath)));\n\tif (rllen >= sizeof(targetpath))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"symbolic link \\\"%s\\\" target is too long\",\n\t\t\t\t\t\tsourcepath)));\n\ttargetpath[rllen] = '\\0';\n\n\tPG_RETURN_TEXT_P(cstring_to_text(targetpath));\n#else\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"tablespaces are not supported on this platform\")));\n\tPG_RETURN_NULL();\n#endif\n}"
  },
  {
    "function_name": "pg_tablespace_databases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "397-476",
    "snippet": "Datum\npg_tablespace_databases(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tts_db_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tOid\t\t\ttablespaceOid = PG_GETARG_OID(0);\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(ts_db_fctx));\n\n\t\tif (tablespaceOid == GLOBALTABLESPACE_OID)\n\t\t{\n\t\t\tfctx->dirdesc = NULL;\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errmsg(\"global tablespace never has databases\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tablespaceOid == DEFAULTTABLESPACE_OID)\n\t\t\t\tfctx->location = psprintf(\"base\");\n\t\t\telse\n\t\t\t\tfctx->location = psprintf(\"pg_tblspc/%u/%s\", tablespaceOid,\n\t\t\t\t\t\t\t\t\t\t  TABLESPACE_VERSION_DIRECTORY);\n\n\t\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\t\tif (!fctx->dirdesc)\n\t\t\t{\n\t\t\t\t/* the only expected error is ENOENT */\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\tfctx->location)));\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"%u is not a tablespace OID\", tablespaceOid)));\n\t\t\t}\n\t\t}\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (ts_db_fctx *) funcctx->user_fctx;\n\n\tif (!fctx->dirdesc)\t\t\t/* not a tablespace */\n\t\tSRF_RETURN_DONE(funcctx);\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tOid\t\t\tdatOid = atooid(de->d_name);\n\t\tchar\t   *subdir;\n\t\tbool\t\tisempty;\n\n\t\t/* this test skips . and .., but is awfully weak */\n\t\tif (!datOid)\n\t\t\tcontinue;\n\n\t\t/* if database subdir is empty, don't report tablespace as used */\n\n\t\tsubdir = psprintf(\"%s/%s\", fctx->location, de->d_name);\n\t\tisempty = directory_is_empty(subdir);\n\t\tpfree(subdir);\n\n\t\tif (isempty)\n\t\t\tcontinue;\t\t\t/* indeed, nothing in it */\n\n\t\tSRF_RETURN_NEXT(funcctx, ObjectIdGetDatum(datOid));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "fctx->dirdesc"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "ObjectIdGetDatum(datOid)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "datOid"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "subdir"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "directory_is_empty",
          "args": [
            "subdir"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s/%s\"",
            "fctx->location",
            "de->d_name"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atooid",
          "args": [
            "de->d_name"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDir",
          "args": [
            "fctx->dirdesc",
            "fctx->location"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"%u is not a tablespace OID\", tablespaceOid))"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"%u is not a tablespace OID\"",
            "tablespaceOid"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\tfctx->location))"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "fctx->location"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"pg_tblspc/%u/%s\"",
            "tablespaceOid",
            "TABLESPACE_VERSION_DIRECTORY"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"base\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"global tablespace never has databases\"))"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(ts_db_fctx)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_tablespace_databases(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tts_db_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tOid\t\t\ttablespaceOid = PG_GETARG_OID(0);\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(ts_db_fctx));\n\n\t\tif (tablespaceOid == GLOBALTABLESPACE_OID)\n\t\t{\n\t\t\tfctx->dirdesc = NULL;\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errmsg(\"global tablespace never has databases\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tablespaceOid == DEFAULTTABLESPACE_OID)\n\t\t\t\tfctx->location = psprintf(\"base\");\n\t\t\telse\n\t\t\t\tfctx->location = psprintf(\"pg_tblspc/%u/%s\", tablespaceOid,\n\t\t\t\t\t\t\t\t\t\t  TABLESPACE_VERSION_DIRECTORY);\n\n\t\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\t\tif (!fctx->dirdesc)\n\t\t\t{\n\t\t\t\t/* the only expected error is ENOENT */\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\tfctx->location)));\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"%u is not a tablespace OID\", tablespaceOid)));\n\t\t\t}\n\t\t}\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (ts_db_fctx *) funcctx->user_fctx;\n\n\tif (!fctx->dirdesc)\t\t\t/* not a tablespace */\n\t\tSRF_RETURN_DONE(funcctx);\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tOid\t\t\tdatOid = atooid(de->d_name);\n\t\tchar\t   *subdir;\n\t\tbool\t\tisempty;\n\n\t\t/* this test skips . and .., but is awfully weak */\n\t\tif (!datOid)\n\t\t\tcontinue;\n\n\t\t/* if database subdir is empty, don't report tablespace as used */\n\n\t\tsubdir = psprintf(\"%s/%s\", fctx->location, de->d_name);\n\t\tisempty = directory_is_empty(subdir);\n\t\tpfree(subdir);\n\n\t\tif (isempty)\n\t\t\tcontinue;\t\t\t/* indeed, nothing in it */\n\n\t\tSRF_RETURN_NEXT(funcctx, ObjectIdGetDatum(datOid));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "pg_rotate_logfile_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "375-387",
    "snippet": "Datum\npg_rotate_logfile_v2(PG_FUNCTION_ARGS)\n{\n\tif (!Logging_collector)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"rotation not possible because log collection not active\")));\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tSendPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE);\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendPostmasterSignal",
          "args": [
            "PMSIGNAL_ROTATE_LOGFILE"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"rotation not possible because log collection not active\"))"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"rotation not possible because log collection not active\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_rotate_logfile_v2(PG_FUNCTION_ARGS)\n{\n\tif (!Logging_collector)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"rotation not possible because log collection not active\")));\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tSendPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE);\n\tPG_RETURN_BOOL(true);\n}"
  },
  {
    "function_name": "pg_rotate_logfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "349-367",
    "snippet": "Datum\npg_rotate_logfile(PG_FUNCTION_ARGS)\n{\n\tif (!superuser())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be superuser to rotate log files with adminpack 1.0\"),\n\t\t\t\t  errhint(\"Consider using pg_logfile_rotate(), which is part of core, instead.\"))));\n\n\tif (!Logging_collector)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"rotation not possible because log collection not active\")));\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tSendPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE);\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendPostmasterSignal",
          "args": [
            "PMSIGNAL_ROTATE_LOGFILE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"rotation not possible because log collection not active\"))"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"rotation not possible because log collection not active\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be superuser to rotate log files with adminpack 1.0\"),\n\t\t\t\t  errhint(\"Consider using pg_logfile_rotate(), which is part of core, instead.\")))"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Consider using pg_logfile_rotate(), which is part of core, instead.\""
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "superuser",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "superuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "46-50",
          "snippet": "bool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_rotate_logfile(PG_FUNCTION_ARGS)\n{\n\tif (!superuser())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be superuser to rotate log files with adminpack 1.0\"),\n\t\t\t\t  errhint(\"Consider using pg_logfile_rotate(), which is part of core, instead.\"))));\n\n\tif (!Logging_collector)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"rotation not possible because log collection not active\")));\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tSendPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE);\n\tPG_RETURN_BOOL(true);\n}"
  },
  {
    "function_name": "pg_reload_conf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "330-341",
    "snippet": "Datum\npg_reload_conf(PG_FUNCTION_ARGS)\n{\n\tif (kill(PostmasterPid, SIGHUP))\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"failed to send signal to postmaster: %m\")));\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"failed to send signal to postmaster: %m\"))"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"failed to send signal to postmaster: %m\""
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "PostmasterPid",
            "SIGHUP"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_reload_conf(PG_FUNCTION_ARGS)\n{\n\tif (kill(PostmasterPid, SIGHUP))\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"failed to send signal to postmaster: %m\")));\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tPG_RETURN_BOOL(true);\n}"
  },
  {
    "function_name": "pg_terminate_backend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "306-322",
    "snippet": "Datum\npg_terminate_backend(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tr = pg_signal_backend(PG_GETARG_INT32(0), SIGTERM);\n\n\tif (r == SIGNAL_BACKEND_NOSUPERUSER)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a superuser to terminate superuser process\"))));\n\n\tif (r == SIGNAL_BACKEND_NOPERMISSION)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a member of the role whose process is being terminated or member of pg_signal_backend\"))));\n\n\tPG_RETURN_BOOL(r == SIGNAL_BACKEND_SUCCESS);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SIGNAL_BACKEND_NOSUPERUSER 3",
      "#define SIGNAL_BACKEND_NOPERMISSION 2",
      "#define SIGNAL_BACKEND_SUCCESS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "r == SIGNAL_BACKEND_SUCCESS"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a member of the role whose process is being terminated or member of pg_signal_backend\")))"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"must be a member of the role whose process is being terminated or member of pg_signal_backend\""
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a superuser to terminate superuser process\")))"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_signal_backend",
          "args": [
            "PG_GETARG_INT32(0)",
            "SIGTERM"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "pg_signal_backend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "219-274",
          "snippet": "static int\npg_signal_backend(int pid, int sig)\n{\n\tPGPROC\t   *proc = BackendPidGetProc(pid);\n\n\t/*\n\t * BackendPidGetProc returns NULL if the pid isn't valid; but by the time\n\t * we reach kill(), a process for which we get a valid proc here might\n\t * have terminated on its own.  There's no way to acquire a lock on an\n\t * arbitrary process to prevent that. But since so far all the callers of\n\t * this mechanism involve some request for ending the process anyway, that\n\t * it might end on its own first is not a problem.\n\t */\n\tif (proc == NULL)\n\t{\n\t\t/*\n\t\t * This is just a warning so a loop-through-resultset will not abort\n\t\t * if one backend terminated on its own during the run.\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"PID %d is not a PostgreSQL server process\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\n\t/* Only allow superusers to signal superuser-owned backends. */\n\tif (superuser_arg(proc->roleId) && !superuser())\n\t\treturn SIGNAL_BACKEND_NOSUPERUSER;\n\n\t/* Users can signal backends they have role membership in. */\n\tif (!has_privs_of_role(GetUserId(), proc->roleId) &&\n\t\t!has_privs_of_role(GetUserId(), DEFAULT_ROLE_SIGNAL_BACKENDID))\n\t\treturn SIGNAL_BACKEND_NOPERMISSION;\n\n\t/*\n\t * Can the process we just validated above end, followed by the pid being\n\t * recycled for a new process, before reaching here?  Then we'd be trying\n\t * to kill the wrong thing.  Seems near impossible when sequential pid\n\t * assignment and wraparound is used.  Perhaps it could happen on a system\n\t * where pid re-use is randomized.  That race condition possibility seems\n\t * too unlikely to worry about.\n\t */\n\n\t/* If we have setsid(), signal the backend's whole process group */\n#ifdef HAVE_SETSID\n\tif (kill(-pid, sig))\n#else\n\tif (kill(pid, sig))\n#endif\n\t{\n\t\t/* Again, just a warning to allow loops */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"could not send signal to process %d: %m\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\treturn SIGNAL_BACKEND_SUCCESS;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SIGNAL_BACKEND_NOSUPERUSER 3",
            "#define SIGNAL_BACKEND_NOPERMISSION 2",
            "#define SIGNAL_BACKEND_ERROR 1",
            "#define SIGNAL_BACKEND_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define SIGNAL_BACKEND_NOSUPERUSER 3\n#define SIGNAL_BACKEND_NOPERMISSION 2\n#define SIGNAL_BACKEND_ERROR 1\n#define SIGNAL_BACKEND_SUCCESS 0\n\nstatic int\npg_signal_backend(int pid, int sig)\n{\n\tPGPROC\t   *proc = BackendPidGetProc(pid);\n\n\t/*\n\t * BackendPidGetProc returns NULL if the pid isn't valid; but by the time\n\t * we reach kill(), a process for which we get a valid proc here might\n\t * have terminated on its own.  There's no way to acquire a lock on an\n\t * arbitrary process to prevent that. But since so far all the callers of\n\t * this mechanism involve some request for ending the process anyway, that\n\t * it might end on its own first is not a problem.\n\t */\n\tif (proc == NULL)\n\t{\n\t\t/*\n\t\t * This is just a warning so a loop-through-resultset will not abort\n\t\t * if one backend terminated on its own during the run.\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"PID %d is not a PostgreSQL server process\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\n\t/* Only allow superusers to signal superuser-owned backends. */\n\tif (superuser_arg(proc->roleId) && !superuser())\n\t\treturn SIGNAL_BACKEND_NOSUPERUSER;\n\n\t/* Users can signal backends they have role membership in. */\n\tif (!has_privs_of_role(GetUserId(), proc->roleId) &&\n\t\t!has_privs_of_role(GetUserId(), DEFAULT_ROLE_SIGNAL_BACKENDID))\n\t\treturn SIGNAL_BACKEND_NOPERMISSION;\n\n\t/*\n\t * Can the process we just validated above end, followed by the pid being\n\t * recycled for a new process, before reaching here?  Then we'd be trying\n\t * to kill the wrong thing.  Seems near impossible when sequential pid\n\t * assignment and wraparound is used.  Perhaps it could happen on a system\n\t * where pid re-use is randomized.  That race condition possibility seems\n\t * too unlikely to worry about.\n\t */\n\n\t/* If we have setsid(), signal the backend's whole process group */\n#ifdef HAVE_SETSID\n\tif (kill(-pid, sig))\n#else\n\tif (kill(pid, sig))\n#endif\n\t{\n\t\t/* Again, just a warning to allow loops */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"could not send signal to process %d: %m\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\treturn SIGNAL_BACKEND_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define SIGNAL_BACKEND_NOSUPERUSER 3\n#define SIGNAL_BACKEND_NOPERMISSION 2\n#define SIGNAL_BACKEND_SUCCESS 0\n\nDatum\npg_terminate_backend(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tr = pg_signal_backend(PG_GETARG_INT32(0), SIGTERM);\n\n\tif (r == SIGNAL_BACKEND_NOSUPERUSER)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a superuser to terminate superuser process\"))));\n\n\tif (r == SIGNAL_BACKEND_NOPERMISSION)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a member of the role whose process is being terminated or member of pg_signal_backend\"))));\n\n\tPG_RETURN_BOOL(r == SIGNAL_BACKEND_SUCCESS);\n}"
  },
  {
    "function_name": "pg_cancel_backend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "282-298",
    "snippet": "Datum\npg_cancel_backend(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tr = pg_signal_backend(PG_GETARG_INT32(0), SIGINT);\n\n\tif (r == SIGNAL_BACKEND_NOSUPERUSER)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a superuser to cancel superuser query\"))));\n\n\tif (r == SIGNAL_BACKEND_NOPERMISSION)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a member of the role whose query is being canceled or member of pg_signal_backend\"))));\n\n\tPG_RETURN_BOOL(r == SIGNAL_BACKEND_SUCCESS);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SIGNAL_BACKEND_NOSUPERUSER 3",
      "#define SIGNAL_BACKEND_NOPERMISSION 2",
      "#define SIGNAL_BACKEND_SUCCESS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "r == SIGNAL_BACKEND_SUCCESS"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a member of the role whose query is being canceled or member of pg_signal_backend\")))"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"must be a member of the role whose query is being canceled or member of pg_signal_backend\""
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a superuser to cancel superuser query\")))"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_signal_backend",
          "args": [
            "PG_GETARG_INT32(0)",
            "SIGINT"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "pg_signal_backend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "219-274",
          "snippet": "static int\npg_signal_backend(int pid, int sig)\n{\n\tPGPROC\t   *proc = BackendPidGetProc(pid);\n\n\t/*\n\t * BackendPidGetProc returns NULL if the pid isn't valid; but by the time\n\t * we reach kill(), a process for which we get a valid proc here might\n\t * have terminated on its own.  There's no way to acquire a lock on an\n\t * arbitrary process to prevent that. But since so far all the callers of\n\t * this mechanism involve some request for ending the process anyway, that\n\t * it might end on its own first is not a problem.\n\t */\n\tif (proc == NULL)\n\t{\n\t\t/*\n\t\t * This is just a warning so a loop-through-resultset will not abort\n\t\t * if one backend terminated on its own during the run.\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"PID %d is not a PostgreSQL server process\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\n\t/* Only allow superusers to signal superuser-owned backends. */\n\tif (superuser_arg(proc->roleId) && !superuser())\n\t\treturn SIGNAL_BACKEND_NOSUPERUSER;\n\n\t/* Users can signal backends they have role membership in. */\n\tif (!has_privs_of_role(GetUserId(), proc->roleId) &&\n\t\t!has_privs_of_role(GetUserId(), DEFAULT_ROLE_SIGNAL_BACKENDID))\n\t\treturn SIGNAL_BACKEND_NOPERMISSION;\n\n\t/*\n\t * Can the process we just validated above end, followed by the pid being\n\t * recycled for a new process, before reaching here?  Then we'd be trying\n\t * to kill the wrong thing.  Seems near impossible when sequential pid\n\t * assignment and wraparound is used.  Perhaps it could happen on a system\n\t * where pid re-use is randomized.  That race condition possibility seems\n\t * too unlikely to worry about.\n\t */\n\n\t/* If we have setsid(), signal the backend's whole process group */\n#ifdef HAVE_SETSID\n\tif (kill(-pid, sig))\n#else\n\tif (kill(pid, sig))\n#endif\n\t{\n\t\t/* Again, just a warning to allow loops */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"could not send signal to process %d: %m\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\treturn SIGNAL_BACKEND_SUCCESS;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SIGNAL_BACKEND_NOSUPERUSER 3",
            "#define SIGNAL_BACKEND_NOPERMISSION 2",
            "#define SIGNAL_BACKEND_ERROR 1",
            "#define SIGNAL_BACKEND_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define SIGNAL_BACKEND_NOSUPERUSER 3\n#define SIGNAL_BACKEND_NOPERMISSION 2\n#define SIGNAL_BACKEND_ERROR 1\n#define SIGNAL_BACKEND_SUCCESS 0\n\nstatic int\npg_signal_backend(int pid, int sig)\n{\n\tPGPROC\t   *proc = BackendPidGetProc(pid);\n\n\t/*\n\t * BackendPidGetProc returns NULL if the pid isn't valid; but by the time\n\t * we reach kill(), a process for which we get a valid proc here might\n\t * have terminated on its own.  There's no way to acquire a lock on an\n\t * arbitrary process to prevent that. But since so far all the callers of\n\t * this mechanism involve some request for ending the process anyway, that\n\t * it might end on its own first is not a problem.\n\t */\n\tif (proc == NULL)\n\t{\n\t\t/*\n\t\t * This is just a warning so a loop-through-resultset will not abort\n\t\t * if one backend terminated on its own during the run.\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"PID %d is not a PostgreSQL server process\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\n\t/* Only allow superusers to signal superuser-owned backends. */\n\tif (superuser_arg(proc->roleId) && !superuser())\n\t\treturn SIGNAL_BACKEND_NOSUPERUSER;\n\n\t/* Users can signal backends they have role membership in. */\n\tif (!has_privs_of_role(GetUserId(), proc->roleId) &&\n\t\t!has_privs_of_role(GetUserId(), DEFAULT_ROLE_SIGNAL_BACKENDID))\n\t\treturn SIGNAL_BACKEND_NOPERMISSION;\n\n\t/*\n\t * Can the process we just validated above end, followed by the pid being\n\t * recycled for a new process, before reaching here?  Then we'd be trying\n\t * to kill the wrong thing.  Seems near impossible when sequential pid\n\t * assignment and wraparound is used.  Perhaps it could happen on a system\n\t * where pid re-use is randomized.  That race condition possibility seems\n\t * too unlikely to worry about.\n\t */\n\n\t/* If we have setsid(), signal the backend's whole process group */\n#ifdef HAVE_SETSID\n\tif (kill(-pid, sig))\n#else\n\tif (kill(pid, sig))\n#endif\n\t{\n\t\t/* Again, just a warning to allow loops */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"could not send signal to process %d: %m\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\treturn SIGNAL_BACKEND_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define SIGNAL_BACKEND_NOSUPERUSER 3\n#define SIGNAL_BACKEND_NOPERMISSION 2\n#define SIGNAL_BACKEND_SUCCESS 0\n\nDatum\npg_cancel_backend(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tr = pg_signal_backend(PG_GETARG_INT32(0), SIGINT);\n\n\tif (r == SIGNAL_BACKEND_NOSUPERUSER)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a superuser to cancel superuser query\"))));\n\n\tif (r == SIGNAL_BACKEND_NOPERMISSION)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be a member of the role whose query is being canceled or member of pg_signal_backend\"))));\n\n\tPG_RETURN_BOOL(r == SIGNAL_BACKEND_SUCCESS);\n}"
  },
  {
    "function_name": "pg_signal_backend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "219-274",
    "snippet": "static int\npg_signal_backend(int pid, int sig)\n{\n\tPGPROC\t   *proc = BackendPidGetProc(pid);\n\n\t/*\n\t * BackendPidGetProc returns NULL if the pid isn't valid; but by the time\n\t * we reach kill(), a process for which we get a valid proc here might\n\t * have terminated on its own.  There's no way to acquire a lock on an\n\t * arbitrary process to prevent that. But since so far all the callers of\n\t * this mechanism involve some request for ending the process anyway, that\n\t * it might end on its own first is not a problem.\n\t */\n\tif (proc == NULL)\n\t{\n\t\t/*\n\t\t * This is just a warning so a loop-through-resultset will not abort\n\t\t * if one backend terminated on its own during the run.\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"PID %d is not a PostgreSQL server process\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\n\t/* Only allow superusers to signal superuser-owned backends. */\n\tif (superuser_arg(proc->roleId) && !superuser())\n\t\treturn SIGNAL_BACKEND_NOSUPERUSER;\n\n\t/* Users can signal backends they have role membership in. */\n\tif (!has_privs_of_role(GetUserId(), proc->roleId) &&\n\t\t!has_privs_of_role(GetUserId(), DEFAULT_ROLE_SIGNAL_BACKENDID))\n\t\treturn SIGNAL_BACKEND_NOPERMISSION;\n\n\t/*\n\t * Can the process we just validated above end, followed by the pid being\n\t * recycled for a new process, before reaching here?  Then we'd be trying\n\t * to kill the wrong thing.  Seems near impossible when sequential pid\n\t * assignment and wraparound is used.  Perhaps it could happen on a system\n\t * where pid re-use is randomized.  That race condition possibility seems\n\t * too unlikely to worry about.\n\t */\n\n\t/* If we have setsid(), signal the backend's whole process group */\n#ifdef HAVE_SETSID\n\tif (kill(-pid, sig))\n#else\n\tif (kill(pid, sig))\n#endif\n\t{\n\t\t/* Again, just a warning to allow loops */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"could not send signal to process %d: %m\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\treturn SIGNAL_BACKEND_SUCCESS;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SIGNAL_BACKEND_NOSUPERUSER 3",
      "#define SIGNAL_BACKEND_NOPERMISSION 2",
      "#define SIGNAL_BACKEND_ERROR 1",
      "#define SIGNAL_BACKEND_SUCCESS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"could not send signal to process %d: %m\", pid))"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not send signal to process %d: %m\"",
            "pid"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "sig"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-pid",
            "sig"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_privs_of_role",
          "args": [
            "GetUserId()",
            "DEFAULT_ROLE_SIGNAL_BACKENDID"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "has_privs_of_role",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "4907-4923",
          "snippet": "bool\nhas_privs_of_role(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/* Superusers have every privilege, so are part of every role */\n\tif (superuser_arg(member))\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member has the privileges of, including\n\t * multi-level recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_has_privs_of(member), role);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static AclMode convert_any_priv_string(text *priv_type_text,\n\t\t\t\t\t\tconst priv_map *privileges);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AclMode convert_any_priv_string(text *priv_type_text,\n\t\t\t\t\t\tconst priv_map *privileges);\n\nbool\nhas_privs_of_role(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/* Superusers have every privilege, so are part of every role */\n\tif (superuser_arg(member))\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member has the privileges of, including\n\t * multi-level recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_has_privs_of(member), role);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "superuser",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "superuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "46-50",
          "snippet": "bool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}"
        }
      },
      {
        "call_info": {
          "callee": "superuser_arg",
          "args": [
            "proc->roleId"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "superuser_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "56-97",
          "snippet": "bool\nsuperuser_arg(Oid roleid)\n{\n\tbool\t\tresult;\n\tHeapTuple\trtup;\n\n\t/* Quick out for cache hit */\n\tif (OidIsValid(last_roleid) && last_roleid == roleid)\n\t\treturn last_roleid_is_super;\n\n\t/* Special escape path in case you deleted all your users. */\n\tif (!IsUnderPostmaster && roleid == BOOTSTRAP_SUPERUSERID)\n\t\treturn true;\n\n\t/* OK, look up the information in pg_authid */\n\trtup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(rtup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(rtup))->rolsuper;\n\t\tReleaseSysCache(rtup);\n\t}\n\telse\n\t{\n\t\t/* Report \"not superuser\" for invalid roleids */\n\t\tresult = false;\n\t}\n\n\t/* If first time through, set up callback for cache flushes */\n\tif (!roleid_callback_registered)\n\t{\n\t\tCacheRegisterSyscacheCallback(AUTHOID,\n\t\t\t\t\t\t\t\t\t  RoleidCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t\troleid_callback_registered = true;\n\t}\n\n\t/* Cache the result for next time */\n\tlast_roleid = roleid;\n\tlast_roleid_is_super = result;\n\n\treturn result;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tlast_roleid = InvalidOid;",
            "static bool last_roleid_is_super = false;",
            "static bool roleid_callback_registered = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Oid\tlast_roleid = InvalidOid;\nstatic bool last_roleid_is_super = false;\nstatic bool roleid_callback_registered = false;\n\nbool\nsuperuser_arg(Oid roleid)\n{\n\tbool\t\tresult;\n\tHeapTuple\trtup;\n\n\t/* Quick out for cache hit */\n\tif (OidIsValid(last_roleid) && last_roleid == roleid)\n\t\treturn last_roleid_is_super;\n\n\t/* Special escape path in case you deleted all your users. */\n\tif (!IsUnderPostmaster && roleid == BOOTSTRAP_SUPERUSERID)\n\t\treturn true;\n\n\t/* OK, look up the information in pg_authid */\n\trtup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(rtup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(rtup))->rolsuper;\n\t\tReleaseSysCache(rtup);\n\t}\n\telse\n\t{\n\t\t/* Report \"not superuser\" for invalid roleids */\n\t\tresult = false;\n\t}\n\n\t/* If first time through, set up callback for cache flushes */\n\tif (!roleid_callback_registered)\n\t{\n\t\tCacheRegisterSyscacheCallback(AUTHOID,\n\t\t\t\t\t\t\t\t\t  RoleidCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t\troleid_callback_registered = true;\n\t}\n\n\t/* Cache the result for next time */\n\tlast_roleid = roleid;\n\tlast_roleid_is_super = result;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg(\"PID %d is not a PostgreSQL server process\", pid))"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BackendPidGetProc",
          "args": [
            "pid"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define SIGNAL_BACKEND_NOSUPERUSER 3\n#define SIGNAL_BACKEND_NOPERMISSION 2\n#define SIGNAL_BACKEND_ERROR 1\n#define SIGNAL_BACKEND_SUCCESS 0\n\nstatic int\npg_signal_backend(int pid, int sig)\n{\n\tPGPROC\t   *proc = BackendPidGetProc(pid);\n\n\t/*\n\t * BackendPidGetProc returns NULL if the pid isn't valid; but by the time\n\t * we reach kill(), a process for which we get a valid proc here might\n\t * have terminated on its own.  There's no way to acquire a lock on an\n\t * arbitrary process to prevent that. But since so far all the callers of\n\t * this mechanism involve some request for ending the process anyway, that\n\t * it might end on its own first is not a problem.\n\t */\n\tif (proc == NULL)\n\t{\n\t\t/*\n\t\t * This is just a warning so a loop-through-resultset will not abort\n\t\t * if one backend terminated on its own during the run.\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"PID %d is not a PostgreSQL server process\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\n\t/* Only allow superusers to signal superuser-owned backends. */\n\tif (superuser_arg(proc->roleId) && !superuser())\n\t\treturn SIGNAL_BACKEND_NOSUPERUSER;\n\n\t/* Users can signal backends they have role membership in. */\n\tif (!has_privs_of_role(GetUserId(), proc->roleId) &&\n\t\t!has_privs_of_role(GetUserId(), DEFAULT_ROLE_SIGNAL_BACKENDID))\n\t\treturn SIGNAL_BACKEND_NOPERMISSION;\n\n\t/*\n\t * Can the process we just validated above end, followed by the pid being\n\t * recycled for a new process, before reaching here?  Then we'd be trying\n\t * to kill the wrong thing.  Seems near impossible when sequential pid\n\t * assignment and wraparound is used.  Perhaps it could happen on a system\n\t * where pid re-use is randomized.  That race condition possibility seems\n\t * too unlikely to worry about.\n\t */\n\n\t/* If we have setsid(), signal the backend's whole process group */\n#ifdef HAVE_SETSID\n\tif (kill(-pid, sig))\n#else\n\tif (kill(pid, sig))\n#endif\n\t{\n\t\t/* Again, just a warning to allow loops */\n\t\tereport(WARNING,\n\t\t\t\t(errmsg(\"could not send signal to process %d: %m\", pid)));\n\t\treturn SIGNAL_BACKEND_ERROR;\n\t}\n\treturn SIGNAL_BACKEND_SUCCESS;\n}"
  },
  {
    "function_name": "current_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "191-199",
    "snippet": "Datum\ncurrent_query(PG_FUNCTION_ARGS)\n{\n\t/* there is no easy way to access the more concise 'query_string' */\n\tif (debug_query_string)\n\t\tPG_RETURN_TEXT_P(cstring_to_text(debug_query_string));\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(debug_query_string)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "debug_query_string"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\ncurrent_query(PG_FUNCTION_ARGS)\n{\n\t/* there is no easy way to access the more concise 'query_string' */\n\tif (debug_query_string)\n\t\tPG_RETURN_TEXT_P(cstring_to_text(debug_query_string));\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "current_database",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "174-183",
    "snippet": "Datum\ncurrent_database(PG_FUNCTION_ARGS)\n{\n\tName\t\tdb;\n\n\tdb = (Name) palloc(NAMEDATALEN);\n\n\tnamestrcpy(db, get_database_name(MyDatabaseId));\n\tPG_RETURN_NAME(db);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NAME",
          "args": [
            "db"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namestrcpy",
          "args": [
            "db",
            "get_database_name(MyDatabaseId)"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\ncurrent_database(PG_FUNCTION_ARGS)\n{\n\tName\t\tdb;\n\n\tdb = (Name) palloc(NAMEDATALEN);\n\n\tnamestrcpy(db, get_database_name(MyDatabaseId));\n\tPG_RETURN_NAME(db);\n}"
  },
  {
    "function_name": "pg_num_nonnulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "157-167",
    "snippet": "Datum\npg_num_nonnulls(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnargs,\n\t\t\t\tnulls;\n\n\tif (!count_nulls(fcinfo, &nargs, &nulls))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(nargs - nulls);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "nargs - nulls"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_nulls",
          "args": [
            "fcinfo",
            "&nargs",
            "&nulls"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "count_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "55-135",
          "snippet": "static bool\ncount_nulls(FunctionCallInfo fcinfo,\n\t\t\tint32 *nargs, int32 *nulls)\n{\n\tint32\t\tcount = 0;\n\tint\t\t\ti;\n\n\t/* Did we get a VARIADIC array argument, or separate arguments? */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint\t\t\tndims,\n\t\t\t\t\tnitems,\n\t\t\t\t   *dims;\n\t\tbits8\t   *bitmap;\n\n\t\tAssert(PG_NARGS() == 1);\n\n\t\t/*\n\t\t * If we get a null as VARIADIC array argument, we can't say anything\n\t\t * useful about the number of elements, so return NULL.  This behavior\n\t\t * is consistent with other variadic functions - see concat_internal.\n\t\t */\n\t\tif (PG_ARGISNULL(0))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(0);\n\n\t\t/* Count the array elements */\n\t\tndims = ARR_NDIM(arr);\n\t\tdims = ARR_DIMS(arr);\n\t\tnitems = ArrayGetNItems(ndims, dims);\n\n\t\t/* Count those that are NULL */\n\t\tbitmap = ARR_NULLBITMAP(arr);\n\t\tif (bitmap)\n\t\t{\n\t\t\tint\t\t\tbitmask = 1;\n\n\t\t\tfor (i = 0; i < nitems; i++)\n\t\t\t{\n\t\t\t\tif ((*bitmap & bitmask) == 0)\n\t\t\t\t\tcount++;\n\n\t\t\t\tbitmask <<= 1;\n\t\t\t\tif (bitmask == 0x100)\n\t\t\t\t{\n\t\t\t\t\tbitmap++;\n\t\t\t\t\tbitmask = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*nargs = nitems;\n\t\t*nulls = count;\n\t}\n\telse\n\t{\n\t\t/* Separate arguments, so just count 'em */\n\t\tfor (i = 0; i < PG_NARGS(); i++)\n\t\t{\n\t\t\tif (PG_ARGISNULL(i))\n\t\t\t\tcount++;\n\t\t}\n\n\t\t*nargs = PG_NARGS();\n\t\t*nulls = count;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\ncount_nulls(FunctionCallInfo fcinfo,\n\t\t\tint32 *nargs, int32 *nulls)\n{\n\tint32\t\tcount = 0;\n\tint\t\t\ti;\n\n\t/* Did we get a VARIADIC array argument, or separate arguments? */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint\t\t\tndims,\n\t\t\t\t\tnitems,\n\t\t\t\t   *dims;\n\t\tbits8\t   *bitmap;\n\n\t\tAssert(PG_NARGS() == 1);\n\n\t\t/*\n\t\t * If we get a null as VARIADIC array argument, we can't say anything\n\t\t * useful about the number of elements, so return NULL.  This behavior\n\t\t * is consistent with other variadic functions - see concat_internal.\n\t\t */\n\t\tif (PG_ARGISNULL(0))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(0);\n\n\t\t/* Count the array elements */\n\t\tndims = ARR_NDIM(arr);\n\t\tdims = ARR_DIMS(arr);\n\t\tnitems = ArrayGetNItems(ndims, dims);\n\n\t\t/* Count those that are NULL */\n\t\tbitmap = ARR_NULLBITMAP(arr);\n\t\tif (bitmap)\n\t\t{\n\t\t\tint\t\t\tbitmask = 1;\n\n\t\t\tfor (i = 0; i < nitems; i++)\n\t\t\t{\n\t\t\t\tif ((*bitmap & bitmask) == 0)\n\t\t\t\t\tcount++;\n\n\t\t\t\tbitmask <<= 1;\n\t\t\t\tif (bitmask == 0x100)\n\t\t\t\t{\n\t\t\t\t\tbitmap++;\n\t\t\t\t\tbitmask = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*nargs = nitems;\n\t\t*nulls = count;\n\t}\n\telse\n\t{\n\t\t/* Separate arguments, so just count 'em */\n\t\tfor (i = 0; i < PG_NARGS(); i++)\n\t\t{\n\t\t\tif (PG_ARGISNULL(i))\n\t\t\t\tcount++;\n\t\t}\n\n\t\t*nargs = PG_NARGS();\n\t\t*nulls = count;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_num_nonnulls(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnargs,\n\t\t\t\tnulls;\n\n\tif (!count_nulls(fcinfo, &nargs, &nulls))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(nargs - nulls);\n}"
  },
  {
    "function_name": "pg_num_nulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "141-151",
    "snippet": "Datum\npg_num_nulls(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnargs,\n\t\t\t\tnulls;\n\n\tif (!count_nulls(fcinfo, &nargs, &nulls))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(nulls);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "nulls"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_nulls",
          "args": [
            "fcinfo",
            "&nargs",
            "&nulls"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "count_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "55-135",
          "snippet": "static bool\ncount_nulls(FunctionCallInfo fcinfo,\n\t\t\tint32 *nargs, int32 *nulls)\n{\n\tint32\t\tcount = 0;\n\tint\t\t\ti;\n\n\t/* Did we get a VARIADIC array argument, or separate arguments? */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint\t\t\tndims,\n\t\t\t\t\tnitems,\n\t\t\t\t   *dims;\n\t\tbits8\t   *bitmap;\n\n\t\tAssert(PG_NARGS() == 1);\n\n\t\t/*\n\t\t * If we get a null as VARIADIC array argument, we can't say anything\n\t\t * useful about the number of elements, so return NULL.  This behavior\n\t\t * is consistent with other variadic functions - see concat_internal.\n\t\t */\n\t\tif (PG_ARGISNULL(0))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(0);\n\n\t\t/* Count the array elements */\n\t\tndims = ARR_NDIM(arr);\n\t\tdims = ARR_DIMS(arr);\n\t\tnitems = ArrayGetNItems(ndims, dims);\n\n\t\t/* Count those that are NULL */\n\t\tbitmap = ARR_NULLBITMAP(arr);\n\t\tif (bitmap)\n\t\t{\n\t\t\tint\t\t\tbitmask = 1;\n\n\t\t\tfor (i = 0; i < nitems; i++)\n\t\t\t{\n\t\t\t\tif ((*bitmap & bitmask) == 0)\n\t\t\t\t\tcount++;\n\n\t\t\t\tbitmask <<= 1;\n\t\t\t\tif (bitmask == 0x100)\n\t\t\t\t{\n\t\t\t\t\tbitmap++;\n\t\t\t\t\tbitmask = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*nargs = nitems;\n\t\t*nulls = count;\n\t}\n\telse\n\t{\n\t\t/* Separate arguments, so just count 'em */\n\t\tfor (i = 0; i < PG_NARGS(); i++)\n\t\t{\n\t\t\tif (PG_ARGISNULL(i))\n\t\t\t\tcount++;\n\t\t}\n\n\t\t*nargs = PG_NARGS();\n\t\t*nulls = count;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\ncount_nulls(FunctionCallInfo fcinfo,\n\t\t\tint32 *nargs, int32 *nulls)\n{\n\tint32\t\tcount = 0;\n\tint\t\t\ti;\n\n\t/* Did we get a VARIADIC array argument, or separate arguments? */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint\t\t\tndims,\n\t\t\t\t\tnitems,\n\t\t\t\t   *dims;\n\t\tbits8\t   *bitmap;\n\n\t\tAssert(PG_NARGS() == 1);\n\n\t\t/*\n\t\t * If we get a null as VARIADIC array argument, we can't say anything\n\t\t * useful about the number of elements, so return NULL.  This behavior\n\t\t * is consistent with other variadic functions - see concat_internal.\n\t\t */\n\t\tif (PG_ARGISNULL(0))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(0);\n\n\t\t/* Count the array elements */\n\t\tndims = ARR_NDIM(arr);\n\t\tdims = ARR_DIMS(arr);\n\t\tnitems = ArrayGetNItems(ndims, dims);\n\n\t\t/* Count those that are NULL */\n\t\tbitmap = ARR_NULLBITMAP(arr);\n\t\tif (bitmap)\n\t\t{\n\t\t\tint\t\t\tbitmask = 1;\n\n\t\t\tfor (i = 0; i < nitems; i++)\n\t\t\t{\n\t\t\t\tif ((*bitmap & bitmask) == 0)\n\t\t\t\t\tcount++;\n\n\t\t\t\tbitmask <<= 1;\n\t\t\t\tif (bitmask == 0x100)\n\t\t\t\t{\n\t\t\t\t\tbitmap++;\n\t\t\t\t\tbitmask = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*nargs = nitems;\n\t\t*nulls = count;\n\t}\n\telse\n\t{\n\t\t/* Separate arguments, so just count 'em */\n\t\tfor (i = 0; i < PG_NARGS(); i++)\n\t\t{\n\t\t\tif (PG_ARGISNULL(i))\n\t\t\t\tcount++;\n\t\t}\n\n\t\t*nargs = PG_NARGS();\n\t\t*nulls = count;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_num_nulls(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnargs,\n\t\t\t\tnulls;\n\n\tif (!count_nulls(fcinfo, &nargs, &nulls))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(nulls);\n}"
  },
  {
    "function_name": "count_nulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
    "lines": "55-135",
    "snippet": "static bool\ncount_nulls(FunctionCallInfo fcinfo,\n\t\t\tint32 *nargs, int32 *nulls)\n{\n\tint32\t\tcount = 0;\n\tint\t\t\ti;\n\n\t/* Did we get a VARIADIC array argument, or separate arguments? */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint\t\t\tndims,\n\t\t\t\t\tnitems,\n\t\t\t\t   *dims;\n\t\tbits8\t   *bitmap;\n\n\t\tAssert(PG_NARGS() == 1);\n\n\t\t/*\n\t\t * If we get a null as VARIADIC array argument, we can't say anything\n\t\t * useful about the number of elements, so return NULL.  This behavior\n\t\t * is consistent with other variadic functions - see concat_internal.\n\t\t */\n\t\tif (PG_ARGISNULL(0))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(0);\n\n\t\t/* Count the array elements */\n\t\tndims = ARR_NDIM(arr);\n\t\tdims = ARR_DIMS(arr);\n\t\tnitems = ArrayGetNItems(ndims, dims);\n\n\t\t/* Count those that are NULL */\n\t\tbitmap = ARR_NULLBITMAP(arr);\n\t\tif (bitmap)\n\t\t{\n\t\t\tint\t\t\tbitmask = 1;\n\n\t\t\tfor (i = 0; i < nitems; i++)\n\t\t\t{\n\t\t\t\tif ((*bitmap & bitmask) == 0)\n\t\t\t\t\tcount++;\n\n\t\t\t\tbitmask <<= 1;\n\t\t\t\tif (bitmask == 0x100)\n\t\t\t\t{\n\t\t\t\t\tbitmap++;\n\t\t\t\t\tbitmask = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*nargs = nitems;\n\t\t*nulls = count;\n\t}\n\telse\n\t{\n\t\t/* Separate arguments, so just count 'em */\n\t\tfor (i = 0; i < PG_NARGS(); i++)\n\t\t{\n\t\t\tif (PG_ARGISNULL(i))\n\t\t\t\tcount++;\n\t\t}\n\n\t\t*nargs = PG_NARGS();\n\t\t*nulls = count;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"utils/ruleutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pmsignal.h\"",
      "#include \"storage/fd.h\"",
      "#include \"rewrite/rewriteHandler.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/keywords.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/sysattr.h\"",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <dirent.h>",
      "#include <signal.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "arr"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0)))"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "get_fn_expr_argtype(fcinfo->flinfo, 0)"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "PG_NARGS() == 1"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_variadic",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_variadic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2128-2146",
          "snippet": "bool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\ncount_nulls(FunctionCallInfo fcinfo,\n\t\t\tint32 *nargs, int32 *nulls)\n{\n\tint32\t\tcount = 0;\n\tint\t\t\ti;\n\n\t/* Did we get a VARIADIC array argument, or separate arguments? */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint\t\t\tndims,\n\t\t\t\t\tnitems,\n\t\t\t\t   *dims;\n\t\tbits8\t   *bitmap;\n\n\t\tAssert(PG_NARGS() == 1);\n\n\t\t/*\n\t\t * If we get a null as VARIADIC array argument, we can't say anything\n\t\t * useful about the number of elements, so return NULL.  This behavior\n\t\t * is consistent with other variadic functions - see concat_internal.\n\t\t */\n\t\tif (PG_ARGISNULL(0))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 0))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(0);\n\n\t\t/* Count the array elements */\n\t\tndims = ARR_NDIM(arr);\n\t\tdims = ARR_DIMS(arr);\n\t\tnitems = ArrayGetNItems(ndims, dims);\n\n\t\t/* Count those that are NULL */\n\t\tbitmap = ARR_NULLBITMAP(arr);\n\t\tif (bitmap)\n\t\t{\n\t\t\tint\t\t\tbitmask = 1;\n\n\t\t\tfor (i = 0; i < nitems; i++)\n\t\t\t{\n\t\t\t\tif ((*bitmap & bitmask) == 0)\n\t\t\t\t\tcount++;\n\n\t\t\t\tbitmask <<= 1;\n\t\t\t\tif (bitmask == 0x100)\n\t\t\t\t{\n\t\t\t\t\tbitmap++;\n\t\t\t\t\tbitmask = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*nargs = nitems;\n\t\t*nulls = count;\n\t}\n\telse\n\t{\n\t\t/* Separate arguments, so just count 'em */\n\t\tfor (i = 0; i < PG_NARGS(); i++)\n\t\t{\n\t\t\tif (PG_ARGISNULL(i))\n\t\t\t\tcount++;\n\t\t}\n\n\t\t*nargs = PG_NARGS();\n\t\t*nulls = count;\n\t}\n\n\treturn true;\n}"
  }
]