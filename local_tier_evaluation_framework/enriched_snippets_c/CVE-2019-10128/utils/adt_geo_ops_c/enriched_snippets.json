[
  {
    "function_name": "pg_hypot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5452-5488",
    "snippet": "double\npg_hypot(double x, double y)\n{\n\tdouble\t\tyx;\n\n\t/* Handle INF and NaN properly */\n\tif (isinf(x) || isinf(y))\n\t\treturn get_float8_infinity();\n\n\tif (isnan(x) || isnan(y))\n\t\treturn get_float8_nan();\n\n\t/* Else, drop any minus signs */\n\tx = fabs(x);\n\ty = fabs(y);\n\n\t/* Swap x and y if needed to make x the larger one */\n\tif (x < y)\n\t{\n\t\tdouble\t\ttemp = x;\n\n\t\tx = y;\n\t\ty = temp;\n\t}\n\n\t/*\n\t * If y is zero, the hypotenuse is x.  This test saves a few cycles in\n\t * such cases, but more importantly it also protects against\n\t * divide-by-zero errors, since now x >= y.\n\t */\n\tif (y == 0.0)\n\t\treturn x;\n\n\t/* Determine the hypotenuse */\n\tyx = y / x;\n\treturn x * sqrt(1.0 + (yx * yx));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "1.0 + (yx * yx)"
          ],
          "line": 5487
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "y"
          ],
          "line": 5466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "x"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_nan",
          "args": [],
          "line": 5462
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "162-173",
          "snippet": "double\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAN (*(const double *) nan)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NAN (*(const double *) nan)\n\ndouble\nget_float8_nan(void)\n{\n\t/* (double) NAN doesn't work on some NetBSD/MIPS releases */\n#if defined(NAN) && !(defined(__NetBSD__) && defined(__mips__))\n\t/* C99 standard way */\n\treturn (double) NAN;\n#else\n\t/* Assume we can get a NAN via zero divide */\n\treturn (double) (0.0 / 0.0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "y"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "x"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 5459
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "y"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isinf",
          "args": [
            "x"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\ndouble\npg_hypot(double x, double y)\n{\n\tdouble\t\tyx;\n\n\t/* Handle INF and NaN properly */\n\tif (isinf(x) || isinf(y))\n\t\treturn get_float8_infinity();\n\n\tif (isnan(x) || isnan(y))\n\t\treturn get_float8_nan();\n\n\t/* Else, drop any minus signs */\n\tx = fabs(x);\n\ty = fabs(y);\n\n\t/* Swap x and y if needed to make x the larger one */\n\tif (x < y)\n\t{\n\t\tdouble\t\ttemp = x;\n\n\t\tx = y;\n\t\ty = temp;\n\t}\n\n\t/*\n\t * If y is zero, the hypotenuse is x.  This test saves a few cycles in\n\t * such cases, but more importantly it also protects against\n\t * divide-by-zero errors, since now x >= y.\n\t */\n\tif (y == 0.0)\n\t\treturn x;\n\n\t/* Determine the hypotenuse */\n\tyx = y / x;\n\treturn x * sqrt(1.0 + (yx * yx));\n}"
  },
  {
    "function_name": "plist_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5371-5428",
    "snippet": "static bool\nplist_same(int npts, Point *p1, Point *p2)\n{\n\tint\t\t\ti,\n\t\t\t\tii,\n\t\t\t\tj;\n\n\t/* find match for first point */\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif ((FPeq(p2[i].x, p1[0].x))\n\t\t\t&& (FPeq(p2[i].y, p1[0].y)))\n\t\t{\n\n\t\t\t/* match found? then look forward through remaining points */\n\t\t\tfor (ii = 1, j = i + 1; ii < npts; ii++, j++)\n\t\t\t{\n\t\t\t\tif (j >= npts)\n\t\t\t\t\tj = 0;\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed forward match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after forward match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\n\t\t\t/* match not found forwards? then look backwards */\n\t\t\tfor (ii = 1, j = i - 1; ii < npts; ii++, j--)\n\t\t\t{\n\t\t\t\tif (j < 0)\n\t\t\t\t\tj = (npts - 1);\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed reverse match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after reverse match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"plist_same- ii = %d/%d after reverse match\\n\"",
            "ii",
            "npts"
          ],
          "line": 5420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"plist_same- %d failed reverse match with %d\\n\"",
            "j",
            "ii"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "p2[j].y",
            "p1[ii].y"
          ],
          "line": 5411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "p2[j].x",
            "p1[ii].x"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"plist_same- ii = %d/%d after forward match\\n\"",
            "ii",
            "npts"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"plist_same- %d failed forward match with %d\\n\"",
            "j",
            "ii"
          ],
          "line": 5394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "p2[j].y",
            "p1[ii].y"
          ],
          "line": 5391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "p2[j].x",
            "p1[ii].x"
          ],
          "line": 5390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "p2[i].y",
            "p1[0].y"
          ],
          "line": 5382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "p2[i].x",
            "p1[0].x"
          ],
          "line": 5381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nplist_same(int npts, Point *p1, Point *p2)\n{\n\tint\t\t\ti,\n\t\t\t\tii,\n\t\t\t\tj;\n\n\t/* find match for first point */\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif ((FPeq(p2[i].x, p1[0].x))\n\t\t\t&& (FPeq(p2[i].y, p1[0].y)))\n\t\t{\n\n\t\t\t/* match found? then look forward through remaining points */\n\t\t\tfor (ii = 1, j = i + 1; ii < npts; ii++, j++)\n\t\t\t{\n\t\t\t\tif (j >= npts)\n\t\t\t\t\tj = 0;\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed forward match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after forward match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\n\t\t\t/* match not found forwards? then look backwards */\n\t\t\tfor (ii = 1, j = i - 1; ii < npts; ii++, j--)\n\t\t\t{\n\t\t\t\tif (j < 0)\n\t\t\t\t\tj = (npts - 1);\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed reverse match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after reverse match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "lseg_crossing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5316-5368",
    "snippet": "static int\nlseg_crossing(double x, double y, double prev_x, double prev_y)\n{\n\tdouble\t\tz;\n\tint\t\t\ty_sign;\n\n\tif (FPzero(y))\n\t{\t\t\t\t\t\t\t/* y == 0, on X axis */\n\t\tif (FPzero(x))\t\t\t/* (x,y) is (0,0)? */\n\t\t\treturn POINT_ON_POLYGON;\n\t\telse if (FPgt(x, 0))\n\t\t{\t\t\t\t\t\t/* x > 0 */\n\t\t\tif (FPzero(prev_y)) /* y and prev_y are zero */\n\t\t\t\t/* prev_x > 0? */\n\t\t\t\treturn FPgt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn FPlt(prev_y, 0) ? 1 : -1;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\t\t/* x < 0, x not on positive X axis */\n\t\t\tif (FPzero(prev_y))\n\t\t\t\t/* prev_x < 0? */\n\t\t\t\treturn FPlt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\t\t\t\t/* y != 0 */\n\t\t/* compute y crossing direction from previous point */\n\t\ty_sign = FPgt(y, 0) ? 1 : -1;\n\n\t\tif (FPzero(prev_y))\n\t\t\t/* previous point was on X axis, so new point is either off or on */\n\t\t\treturn FPlt(prev_x, 0) ? 0 : y_sign;\n\t\telse if (FPgt(y_sign * prev_y, 0))\n\t\t\t/* both above or below X axis */\n\t\t\treturn 0;\t\t\t/* same sign */\n\t\telse\n\t\t{\t\t\t\t\t\t/* y and prev_y cross X-axis */\n\t\t\tif (FPge(x, 0) && FPgt(prev_x, 0))\n\t\t\t\t/* both non-negative so cross positive X-axis */\n\t\t\t\treturn 2 * y_sign;\n\t\t\tif (FPlt(x, 0) && FPle(prev_x, 0))\n\t\t\t\t/* both non-positive so do not cross positive X-axis */\n\t\t\t\treturn 0;\n\n\t\t\t/* x and y cross axises, see URL above point_inside() */\n\t\t\tz = (x - prev_x) * y - (y - prev_y) * x;\n\t\t\tif (FPzero(z))\n\t\t\t\treturn POINT_ON_POLYGON;\n\t\t\treturn FPgt((y_sign * z), 0) ? 0 : 2 * y_sign;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define POINT_ON_POLYGON INT_MAX"
    ],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "(y_sign * z)",
            "0"
          ],
          "line": 5365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "z"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "prev_x",
            "0"
          ],
          "line": 5357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "x",
            "0"
          ],
          "line": 5357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "prev_x",
            "0"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "x",
            "0"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "y_sign * prev_y",
            "0"
          ],
          "line": 5349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "prev_x",
            "0"
          ],
          "line": 5348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "prev_y"
          ],
          "line": 5346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "y",
            "0"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "prev_x",
            "0"
          ],
          "line": 5337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "prev_y"
          ],
          "line": 5335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "prev_y",
            "0"
          ],
          "line": 5331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "prev_x",
            "0"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "prev_y"
          ],
          "line": 5328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "x",
            "0"
          ],
          "line": 5326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "x"
          ],
          "line": 5324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "y"
          ],
          "line": 5322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic Point *point_construct(double x, double y);\n\nstatic int\nlseg_crossing(double x, double y, double prev_x, double prev_y)\n{\n\tdouble\t\tz;\n\tint\t\t\ty_sign;\n\n\tif (FPzero(y))\n\t{\t\t\t\t\t\t\t/* y == 0, on X axis */\n\t\tif (FPzero(x))\t\t\t/* (x,y) is (0,0)? */\n\t\t\treturn POINT_ON_POLYGON;\n\t\telse if (FPgt(x, 0))\n\t\t{\t\t\t\t\t\t/* x > 0 */\n\t\t\tif (FPzero(prev_y)) /* y and prev_y are zero */\n\t\t\t\t/* prev_x > 0? */\n\t\t\t\treturn FPgt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn FPlt(prev_y, 0) ? 1 : -1;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\t\t/* x < 0, x not on positive X axis */\n\t\t\tif (FPzero(prev_y))\n\t\t\t\t/* prev_x < 0? */\n\t\t\t\treturn FPlt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\t\t\t\t/* y != 0 */\n\t\t/* compute y crossing direction from previous point */\n\t\ty_sign = FPgt(y, 0) ? 1 : -1;\n\n\t\tif (FPzero(prev_y))\n\t\t\t/* previous point was on X axis, so new point is either off or on */\n\t\t\treturn FPlt(prev_x, 0) ? 0 : y_sign;\n\t\telse if (FPgt(y_sign * prev_y, 0))\n\t\t\t/* both above or below X axis */\n\t\t\treturn 0;\t\t\t/* same sign */\n\t\telse\n\t\t{\t\t\t\t\t\t/* y and prev_y cross X-axis */\n\t\t\tif (FPge(x, 0) && FPgt(prev_x, 0))\n\t\t\t\t/* both non-negative so cross positive X-axis */\n\t\t\t\treturn 2 * y_sign;\n\t\t\tif (FPlt(x, 0) && FPle(prev_x, 0))\n\t\t\t\t/* both non-positive so do not cross positive X-axis */\n\t\t\t\treturn 0;\n\n\t\t\t/* x and y cross axises, see URL above point_inside() */\n\t\t\tz = (x - prev_x) * y - (y - prev_y) * x;\n\t\t\tif (FPzero(z))\n\t\t\t\treturn POINT_ON_POLYGON;\n\t\t\treturn FPgt((y_sign * z), 0) ? 0 : 2 * y_sign;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "point_inside",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5258-5304",
    "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define POINT_ON_POLYGON INT_MAX"
    ],
    "globals_used": [
      "static int\tpoint_inside(Point *p, int npts, Point *plist);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lseg_crossing",
          "args": [
            "x0",
            "y0",
            "prev_x",
            "prev_y"
          ],
          "line": 5297
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_crossing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5316-5368",
          "snippet": "static int\nlseg_crossing(double x, double y, double prev_x, double prev_y)\n{\n\tdouble\t\tz;\n\tint\t\t\ty_sign;\n\n\tif (FPzero(y))\n\t{\t\t\t\t\t\t\t/* y == 0, on X axis */\n\t\tif (FPzero(x))\t\t\t/* (x,y) is (0,0)? */\n\t\t\treturn POINT_ON_POLYGON;\n\t\telse if (FPgt(x, 0))\n\t\t{\t\t\t\t\t\t/* x > 0 */\n\t\t\tif (FPzero(prev_y)) /* y and prev_y are zero */\n\t\t\t\t/* prev_x > 0? */\n\t\t\t\treturn FPgt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn FPlt(prev_y, 0) ? 1 : -1;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\t\t/* x < 0, x not on positive X axis */\n\t\t\tif (FPzero(prev_y))\n\t\t\t\t/* prev_x < 0? */\n\t\t\t\treturn FPlt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\t\t\t\t/* y != 0 */\n\t\t/* compute y crossing direction from previous point */\n\t\ty_sign = FPgt(y, 0) ? 1 : -1;\n\n\t\tif (FPzero(prev_y))\n\t\t\t/* previous point was on X axis, so new point is either off or on */\n\t\t\treturn FPlt(prev_x, 0) ? 0 : y_sign;\n\t\telse if (FPgt(y_sign * prev_y, 0))\n\t\t\t/* both above or below X axis */\n\t\t\treturn 0;\t\t\t/* same sign */\n\t\telse\n\t\t{\t\t\t\t\t\t/* y and prev_y cross X-axis */\n\t\t\tif (FPge(x, 0) && FPgt(prev_x, 0))\n\t\t\t\t/* both non-negative so cross positive X-axis */\n\t\t\t\treturn 2 * y_sign;\n\t\t\tif (FPlt(x, 0) && FPle(prev_x, 0))\n\t\t\t\t/* both non-positive so do not cross positive X-axis */\n\t\t\t\treturn 0;\n\n\t\t\t/* x and y cross axises, see URL above point_inside() */\n\t\t\tz = (x - prev_x) * y - (y - prev_y) * x;\n\t\t\tif (FPzero(z))\n\t\t\t\treturn POINT_ON_POLYGON;\n\t\t\treturn FPgt((y_sign * z), 0) ? 0 : 2 * y_sign;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic Point *point_construct(double x, double y);\n\nstatic int\nlseg_crossing(double x, double y, double prev_x, double prev_y)\n{\n\tdouble\t\tz;\n\tint\t\t\ty_sign;\n\n\tif (FPzero(y))\n\t{\t\t\t\t\t\t\t/* y == 0, on X axis */\n\t\tif (FPzero(x))\t\t\t/* (x,y) is (0,0)? */\n\t\t\treturn POINT_ON_POLYGON;\n\t\telse if (FPgt(x, 0))\n\t\t{\t\t\t\t\t\t/* x > 0 */\n\t\t\tif (FPzero(prev_y)) /* y and prev_y are zero */\n\t\t\t\t/* prev_x > 0? */\n\t\t\t\treturn FPgt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn FPlt(prev_y, 0) ? 1 : -1;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\t\t/* x < 0, x not on positive X axis */\n\t\t\tif (FPzero(prev_y))\n\t\t\t\t/* prev_x < 0? */\n\t\t\t\treturn FPlt(prev_x, 0) ? 0 : POINT_ON_POLYGON;\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\t\t\t\t\t\t\t/* y != 0 */\n\t\t/* compute y crossing direction from previous point */\n\t\ty_sign = FPgt(y, 0) ? 1 : -1;\n\n\t\tif (FPzero(prev_y))\n\t\t\t/* previous point was on X axis, so new point is either off or on */\n\t\t\treturn FPlt(prev_x, 0) ? 0 : y_sign;\n\t\telse if (FPgt(y_sign * prev_y, 0))\n\t\t\t/* both above or below X axis */\n\t\t\treturn 0;\t\t\t/* same sign */\n\t\telse\n\t\t{\t\t\t\t\t\t/* y and prev_y cross X-axis */\n\t\t\tif (FPge(x, 0) && FPgt(prev_x, 0))\n\t\t\t\t/* both non-negative so cross positive X-axis */\n\t\t\t\treturn 2 * y_sign;\n\t\t\tif (FPlt(x, 0) && FPle(prev_x, 0))\n\t\t\t\t/* both non-positive so do not cross positive X-axis */\n\t\t\t\treturn 0;\n\n\t\t\t/* x and y cross axises, see URL above point_inside() */\n\t\t\tz = (x - prev_x) * y - (y - prev_y) * x;\n\t\t\tif (FPzero(z))\n\t\t\t\treturn POINT_ON_POLYGON;\n\t\t\treturn FPgt((y_sign * z), 0) ? 0 : 2 * y_sign;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "poly_circle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5205-5236",
    "snippet": "Datum\npoly_circle(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tCIRCLE\t   *circle;\n\tint\t\t\ti;\n\n\tif (poly->npts < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot convert empty polygon to circle\")));\n\n\tcircle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tcircle->center.x = 0;\n\tcircle->center.y = 0;\n\tcircle->radius = 0;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tcircle->center.x += poly->p[i].x;\n\t\tcircle->center.y += poly->p[i].y;\n\t}\n\tcircle->center.x /= poly->npts;\n\tcircle->center.y /= poly->npts;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t\tcircle->radius += point_dt(&poly->p[i], &circle->center);\n\tcircle->radius /= poly->npts;\n\n\tPG_RETURN_CIRCLE_P(circle);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "circle"
          ],
          "line": 5235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&poly->p[i]",
            "&circle->center"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CIRCLE)"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot convert empty polygon to circle\"))"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot convert empty polygon to circle\""
          ],
          "line": 5215
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 5214
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_circle(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tCIRCLE\t   *circle;\n\tint\t\t\ti;\n\n\tif (poly->npts < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot convert empty polygon to circle\")));\n\n\tcircle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tcircle->center.x = 0;\n\tcircle->center.y = 0;\n\tcircle->radius = 0;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tcircle->center.x += poly->p[i].x;\n\t\tcircle->center.y += poly->p[i].y;\n\t}\n\tcircle->center.x /= poly->npts;\n\tcircle->center.y /= poly->npts;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t\tcircle->radius += point_dt(&poly->p[i], &circle->center);\n\tcircle->radius /= poly->npts;\n\n\tPG_RETURN_CIRCLE_P(circle);\n}"
  },
  {
    "function_name": "circle_poly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5151-5198",
    "snippet": "Datum\ncircle_poly(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnpts = PG_GETARG_INT32(0);\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(1);\n\tPOLYGON    *poly;\n\tint\t\t\tbase_size,\n\t\t\t\tsize;\n\tint\t\t\ti;\n\tdouble\t\tangle;\n\tdouble\t\tanglestep;\n\n\tif (FPzero(circle->radius))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot convert circle with radius zero to polygon\")));\n\n\tif (npts < 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"must request at least 2 points\")));\n\n\tbase_size = sizeof(poly->p[0]) * npts;\n\tsize = offsetof(POLYGON, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tanglestep = (2.0 * M_PI) / npts;\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tangle = i * anglestep;\n\t\tpoly->p[i].x = circle->center.x - (circle->radius * cos(angle));\n\t\tpoly->p[i].y = circle->center.y + (circle->radius * sin(angle));\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define M_PI 3.14159265358979323846"
    ],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POLYGON_P",
          "args": [
            "poly"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bound_box",
          "args": [
            "poly"
          ],
          "line": 5195
        },
        "resolved": true,
        "details": {
          "function_name": "make_bound_box",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3375-3406",
          "snippet": "static void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sin",
          "args": [
            "angle"
          ],
          "line": 5192
        },
        "resolved": true,
        "details": {
          "function_name": "binary_upgrade_set_missing_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
          "lines": "197-210",
          "snippet": "Datum\nbinary_upgrade_set_missing_value(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttable_id = PG_GETARG_OID(0);\n\ttext\t   *attname = PG_GETARG_TEXT_P(1);\n\ttext\t   *value = PG_GETARG_TEXT_P(2);\n\tchar\t   *cattname = text_to_cstring(attname);\n\tchar\t   *cvalue = text_to_cstring(value);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tSetAttrMissing(table_id, cattname, cvalue);\n\n\tPG_RETURN_VOID();\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/extension.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/heap.h\"",
            "#include \"catalog/binary_upgrade.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_missing_value(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttable_id = PG_GETARG_OID(0);\n\ttext\t   *attname = PG_GETARG_TEXT_P(1);\n\ttext\t   *value = PG_GETARG_TEXT_P(2);\n\tchar\t   *cattname = text_to_cstring(attname);\n\tchar\t   *cvalue = text_to_cstring(value);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tSetAttrMissing(table_id, cattname, cvalue);\n\n\tPG_RETURN_VOID();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cos",
          "args": [
            "angle"
          ],
          "line": 5191
        },
        "resolved": true,
        "details": {
          "function_name": "dcosd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "2347-2394",
          "snippet": "Datum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double sind_q1(double x);",
            "static double cosd_q1(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double sind_q1(double x);\nstatic double cosd_q1(double x);\n\nDatum\ndcosd(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\tint\t\t\tsign = 1;\n\n\t/*\n\t * Per the POSIX spec, return NaN if the input is NaN and throw an error\n\t * if the input is infinite.\n\t */\n\tif (isnan(arg1))\n\t\tPG_RETURN_FLOAT8(get_float8_nan());\n\n\tif (isinf(arg1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"input is out of range\")));\n\n\tINIT_DEGREE_CONSTANTS();\n\n\t/* Reduce the range of the input to [0,90] degrees */\n\targ1 = fmod(arg1, 360.0);\n\n\tif (arg1 < 0.0)\n\t{\n\t\t/* cosd(-x) = cosd(x) */\n\t\targ1 = -arg1;\n\t}\n\n\tif (arg1 > 180.0)\n\t{\n\t\t/* cosd(360-x) = cosd(x) */\n\t\targ1 = 360.0 - arg1;\n\t}\n\n\tif (arg1 > 90.0)\n\t{\n\t\t/* cosd(180-x) = -cosd(x) */\n\t\targ1 = 180.0 - arg1;\n\t\tsign = -sign;\n\t}\n\n\tresult = sign * cosd_q1(arg1);\n\n\tCHECKFLOATVAL(result, false, true);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "poly",
            "size"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "size"
          ],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\"))"
          ],
          "line": 5178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many points requested\""
          ],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"must request at least 2 points\"))"
          ],
          "line": 5169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot convert circle with radius zero to polygon\"))"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "circle->radius"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 5155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 5154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\ncircle_poly(PG_FUNCTION_ARGS)\n{\n\tint32\t\tnpts = PG_GETARG_INT32(0);\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(1);\n\tPOLYGON    *poly;\n\tint\t\t\tbase_size,\n\t\t\t\tsize;\n\tint\t\t\ti;\n\tdouble\t\tangle;\n\tdouble\t\tanglestep;\n\n\tif (FPzero(circle->radius))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot convert circle with radius zero to polygon\")));\n\n\tif (npts < 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"must request at least 2 points\")));\n\n\tbase_size = sizeof(poly->p[0]) * npts;\n\tsize = offsetof(POLYGON, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tanglestep = (2.0 * M_PI) / npts;\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tangle = i * anglestep;\n\t\tpoly->p[i].x = circle->center.x - (circle->radius * cos(angle));\n\t\tpoly->p[i].y = circle->center.y + (circle->radius * sin(angle));\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}"
  },
  {
    "function_name": "box_circle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5134-5148",
    "snippet": "Datum\nbox_circle(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tCIRCLE\t   *circle;\n\n\tcircle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tcircle->center.x = (box->high.x + box->low.x) / 2;\n\tcircle->center.y = (box->high.y + box->low.y) / 2;\n\n\tcircle->radius = point_dt(&circle->center, &box->high);\n\n\tPG_RETURN_CIRCLE_P(circle);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "circle"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle->center",
            "&box->high"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CIRCLE)"
          ],
          "line": 5140
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 5137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_circle(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tCIRCLE\t   *circle;\n\n\tcircle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tcircle->center.x = (box->high.x + box->low.x) / 2;\n\tcircle->center.y = (box->high.y + box->low.y) / 2;\n\n\tcircle->radius = point_dt(&circle->center, &box->high);\n\n\tPG_RETURN_CIRCLE_P(circle);\n}"
  },
  {
    "function_name": "circle_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5112-5129",
    "snippet": "Datum\ncircle_box(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tBOX\t\t   *box;\n\tdouble\t\tdelta;\n\n\tbox = (BOX *) palloc(sizeof(BOX));\n\n\tdelta = circle->radius / sqrt(2.0);\n\n\tbox->high.x = circle->center.x + delta;\n\tbox->low.x = circle->center.x - delta;\n\tbox->high.y = circle->center.y + delta;\n\tbox->low.y = circle->center.y - delta;\n\n\tPG_RETURN_BOX_P(box);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box"
          ],
          "line": 5128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "2.0"
          ],
          "line": 5121
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 5119
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 5115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\ncircle_box(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tBOX\t\t   *box;\n\tdouble\t\tdelta;\n\n\tbox = (BOX *) palloc(sizeof(BOX));\n\n\tdelta = circle->radius / sqrt(2.0);\n\n\tbox->high.x = circle->center.x + delta;\n\tbox->low.x = circle->center.x - delta;\n\tbox->high.y = circle->center.y + delta;\n\tbox->low.y = circle->center.y - delta;\n\n\tPG_RETURN_BOX_P(box);\n}"
  },
  {
    "function_name": "cr_circle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5096-5110",
    "snippet": "Datum\ncr_circle(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *center = PG_GETARG_POINT_P(0);\n\tfloat8\t\tradius = PG_GETARG_FLOAT8(1);\n\tCIRCLE\t   *result;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tresult->center.x = center->x;\n\tresult->center.y = center->y;\n\tresult->radius = radius;\n\n\tPG_RETURN_CIRCLE_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "result"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CIRCLE)"
          ],
          "line": 5103
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 5100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 5099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\ncr_circle(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *center = PG_GETARG_POINT_P(0);\n\tfloat8\t\tradius = PG_GETARG_FLOAT8(1);\n\tCIRCLE\t   *result;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tresult->center.x = center->x;\n\tresult->center.y = center->y;\n\tresult->radius = radius;\n\n\tPG_RETURN_CIRCLE_P(result);\n}"
  },
  {
    "function_name": "circle_ar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5085-5089",
    "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define M_PI 3.14159265358979323846"
    ],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
  },
  {
    "function_name": "circle_center",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5069-5080",
    "snippet": "Datum\ncircle_center(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\tresult->x = circle->center.x;\n\tresult->y = circle->center.y;\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 5075
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 5072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_center(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\tresult->x = circle->center.x;\n\tresult->y = circle->center.y;\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "dist_cpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5054-5065",
    "snippet": "Datum\ndist_cpoint(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tfloat8\t\tresult;\n\n\tresult = point_dt(point, &circle->center) - circle->radius;\n\tif (result < 0)\n\t\tresult = 0;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "point",
            "&circle->center"
          ],
          "line": 5061
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 5058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 5057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\ndist_cpoint(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tfloat8\t\tresult;\n\n\tresult = point_dt(point, &circle->center) - circle->radius;\n\tif (result < 0)\n\t\tresult = 0;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5038-5049",
    "snippet": "Datum\ndist_pc(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *point = PG_GETARG_POINT_P(0);\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(1);\n\tfloat8\t\tresult;\n\n\tresult = point_dt(point, &circle->center) - circle->radius;\n\tif (result < 0)\n\t\tresult = 0;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "point",
            "&circle->center"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 5041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\ndist_pc(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *point = PG_GETARG_POINT_P(0);\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(1);\n\tfloat8\t\tresult;\n\n\tresult = point_dt(point, &circle->center) - circle->radius;\n\tif (result < 0)\n\t\tresult = 0;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "pt_contained_circle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5023-5032",
    "snippet": "Datum\npt_contained_circle(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *point = PG_GETARG_POINT_P(0);\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(1);\n\tdouble\t\td;\n\n\td = point_dt(&circle->center, point);\n\tPG_RETURN_BOOL(d <= circle->radius);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "d <= circle->radius"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle->center",
            "point"
          ],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\npt_contained_circle(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *point = PG_GETARG_POINT_P(0);\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(1);\n\tdouble\t\td;\n\n\td = point_dt(&circle->center, point);\n\tPG_RETURN_BOOL(d <= circle->radius);\n}"
  },
  {
    "function_name": "circle_contain_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "5011-5020",
    "snippet": "Datum\ncircle_contain_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tdouble\t\td;\n\n\td = point_dt(&circle->center, point);\n\tPG_RETURN_BOOL(d <= circle->radius);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "d <= circle->radius"
          ],
          "line": 5019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle->center",
            "point"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\ncircle_contain_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tdouble\t\td;\n\n\td = point_dt(&circle->center, point);\n\tPG_RETURN_BOOL(d <= circle->radius);\n}"
  },
  {
    "function_name": "circle_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4996-5008",
    "snippet": "Datum\ncircle_distance(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\tfloat8\t\tresult;\n\n\tresult = point_dt(&circle1->center, &circle2->center)\n\t\t- (circle1->radius + circle2->radius);\n\tif (result < 0)\n\t\tresult = 0;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 5007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle1->center",
            "&circle2->center"
          ],
          "line": 5003
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 5000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_distance(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\tfloat8\t\tresult;\n\n\tresult = point_dt(&circle1->center, &circle2->center)\n\t\t- (circle1->radius + circle2->radius);\n\tif (result < 0)\n\t\tresult = 0;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "circle_radius",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4984-4990",
    "snippet": "Datum\ncircle_radius(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\n\tPG_RETURN_FLOAT8(circle->radius);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "circle->radius"
          ],
          "line": 4989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\ncircle_radius(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\n\tPG_RETURN_FLOAT8(circle->radius);\n}"
  },
  {
    "function_name": "circle_diameter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4973-4979",
    "snippet": "Datum\ncircle_diameter(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\n\tPG_RETURN_FLOAT8(2 * circle->radius);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "2 * circle->radius"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\ncircle_diameter(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\n\tPG_RETURN_FLOAT8(2 * circle->radius);\n}"
  },
  {
    "function_name": "circle_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4962-4968",
    "snippet": "Datum\ncircle_area(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\n\tPG_RETURN_FLOAT8(circle_ar(circle));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "circle_ar(circle)"
          ],
          "line": 4967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle"
          ],
          "line": 4967
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nDatum\ncircle_area(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\n\tPG_RETURN_FLOAT8(circle_ar(circle));\n}"
  },
  {
    "function_name": "circle_div_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4939-4957",
    "snippet": "Datum\ncircle_div_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\tPoint\t   *p;\n\n\tresult = circle_copy(circle);\n\n\tp = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&circle->center),\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\tresult->center.x = p->x;\n\tresult->center.y = p->y;\n\tresult->radius /= HYPOT(point->x, point->y);\n\n\tPG_RETURN_CIRCLE_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "result"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "point->x",
            "point->y"
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&circle->center),\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point))"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_div",
            "PointPGetDatum(&circle->center)",
            "PointPGetDatum(point)"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "point"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&circle->center"
          ],
          "line": 4950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_copy",
          "args": [
            "circle"
          ],
          "line": 4947
        },
        "resolved": true,
        "details": {
          "function_name": "circle_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "4868-4879",
          "snippet": "static CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_div_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\tPoint\t   *p;\n\n\tresult = circle_copy(circle);\n\n\tp = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&circle->center),\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\tresult->center.x = p->x;\n\tresult->center.y = p->y;\n\tresult->radius /= HYPOT(point->x, point->y);\n\n\tPG_RETURN_CIRCLE_P(result);\n}"
  },
  {
    "function_name": "circle_mul_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4919-4937",
    "snippet": "Datum\ncircle_mul_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\tPoint\t   *p;\n\n\tresult = circle_copy(circle);\n\n\tp = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&circle->center),\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\tresult->center.x = p->x;\n\tresult->center.y = p->y;\n\tresult->radius *= HYPOT(point->x, point->y);\n\n\tPG_RETURN_CIRCLE_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "result"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "point->x",
            "point->y"
          ],
          "line": 4934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&circle->center),\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point))"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_mul",
            "PointPGetDatum(&circle->center)",
            "PointPGetDatum(point)"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "point"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&circle->center"
          ],
          "line": 4930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_copy",
          "args": [
            "circle"
          ],
          "line": 4927
        },
        "resolved": true,
        "details": {
          "function_name": "circle_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "4868-4879",
          "snippet": "static CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_mul_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\tPoint\t   *p;\n\n\tresult = circle_copy(circle);\n\n\tp = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&circle->center),\n\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\tresult->center.x = p->x;\n\tresult->center.y = p->y;\n\tresult->radius *= HYPOT(point->x, point->y);\n\n\tPG_RETURN_CIRCLE_P(result);\n}"
  },
  {
    "function_name": "circle_sub_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4900-4913",
    "snippet": "Datum\ncircle_sub_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\n\tresult = circle_copy(circle);\n\n\tresult->center.x -= point->x;\n\tresult->center.y -= point->y;\n\n\tPG_RETURN_CIRCLE_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "result"
          ],
          "line": 4912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_copy",
          "args": [
            "circle"
          ],
          "line": 4907
        },
        "resolved": true,
        "details": {
          "function_name": "circle_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "4868-4879",
          "snippet": "static CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_sub_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\n\tresult = circle_copy(circle);\n\n\tresult->center.x -= point->x;\n\tresult->center.y -= point->y;\n\n\tPG_RETURN_CIRCLE_P(result);\n}"
  },
  {
    "function_name": "circle_add_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4885-4898",
    "snippet": "Datum\ncircle_add_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\n\tresult = circle_copy(circle);\n\n\tresult->center.x += point->x;\n\tresult->center.y += point->y;\n\n\tPG_RETURN_CIRCLE_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "result"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_copy",
          "args": [
            "circle"
          ],
          "line": 4892
        },
        "resolved": true,
        "details": {
          "function_name": "circle_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "4868-4879",
          "snippet": "static CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_add_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tCIRCLE\t   *result;\n\n\tresult = circle_copy(circle);\n\n\tresult->center.x += point->x;\n\tresult->center.y += point->y;\n\n\tPG_RETURN_CIRCLE_P(result);\n}"
  },
  {
    "function_name": "circle_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4868-4879",
    "snippet": "static CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) result",
            "(char *) circle",
            "sizeof(CIRCLE)"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CIRCLE)"
          ],
          "line": 4876
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "circle"
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic CIRCLE *\ncircle_copy(CIRCLE *circle)\n{\n\tCIRCLE\t   *result;\n\n\tif (!PointerIsValid(circle))\n\t\treturn NULL;\n\n\tresult = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tmemcpy((char *) result, (char *) circle, sizeof(CIRCLE));\n\treturn result;\n}"
  },
  {
    "function_name": "circle_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4854-4861",
    "snippet": "Datum\ncircle_ge(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPge(circle_ar(circle1), circle_ar(circle2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(circle_ar(circle1), circle_ar(circle2))"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "circle_ar(circle1)",
            "circle_ar(circle2)"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle2"
          ],
          "line": 4860
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_ge(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPge(circle_ar(circle1), circle_ar(circle2)));\n}"
  },
  {
    "function_name": "circle_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4845-4852",
    "snippet": "Datum\ncircle_le(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle(circle_ar(circle1), circle_ar(circle2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(circle_ar(circle1), circle_ar(circle2))"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "circle_ar(circle1)",
            "circle_ar(circle2)"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle2"
          ],
          "line": 4851
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_le(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle(circle_ar(circle1), circle_ar(circle2)));\n}"
  },
  {
    "function_name": "circle_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4836-4843",
    "snippet": "Datum\ncircle_gt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPgt(circle_ar(circle1), circle_ar(circle2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(circle_ar(circle1), circle_ar(circle2))"
          ],
          "line": 4842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "circle_ar(circle1)",
            "circle_ar(circle2)"
          ],
          "line": 4842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle2"
          ],
          "line": 4842
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_gt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPgt(circle_ar(circle1), circle_ar(circle2)));\n}"
  },
  {
    "function_name": "circle_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4827-4834",
    "snippet": "Datum\ncircle_lt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPlt(circle_ar(circle1), circle_ar(circle2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(circle_ar(circle1), circle_ar(circle2))"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "circle_ar(circle1)",
            "circle_ar(circle2)"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle2"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_lt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPlt(circle_ar(circle1), circle_ar(circle2)));\n}"
  },
  {
    "function_name": "circle_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4818-4825",
    "snippet": "Datum\ncircle_ne(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPne(circle_ar(circle1), circle_ar(circle2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPne(circle_ar(circle1), circle_ar(circle2))"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPne",
          "args": [
            "circle_ar(circle1)",
            "circle_ar(circle2)"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle2"
          ],
          "line": 4824
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_ne(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPne(circle_ar(circle1), circle_ar(circle2)));\n}"
  },
  {
    "function_name": "circle_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4809-4816",
    "snippet": "Datum\ncircle_eq(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPeq(circle_ar(circle1), circle_ar(circle2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(circle_ar(circle1), circle_ar(circle2))"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "circle_ar(circle1)",
            "circle_ar(circle2)"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "circle_ar",
          "args": [
            "circle2"
          ],
          "line": 4815
        },
        "resolved": true,
        "details": {
          "function_name": "circle_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5085-5089",
          "snippet": "static double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define M_PI 3.14159265358979323846"
          ],
          "globals_used": [
            "static double circle_ar(CIRCLE *circle);",
            "static CIRCLE *circle_copy(CIRCLE *circle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define M_PI 3.14159265358979323846\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\n\nstatic double\ncircle_ar(CIRCLE *circle)\n{\n\treturn M_PI * (circle->radius * circle->radius);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_eq(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPeq(circle_ar(circle1), circle_ar(circle2)));\n}"
  },
  {
    "function_name": "circle_overabove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4795-4803",
    "snippet": "Datum\ncircle_overabove(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPge((circle1->center.y - circle1->radius),\n\t\t\t\t\t\t(circle2->center.y - circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge((circle1->center.y - circle1->radius),\n\t\t\t\t\t\t(circle2->center.y - circle2->radius))"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "(circle1->center.y - circle1->radius)",
            "(circle2->center.y - circle2->radius)"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_overabove(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPge((circle1->center.y - circle1->radius),\n\t\t\t\t\t\t(circle2->center.y - circle2->radius)));\n}"
  },
  {
    "function_name": "circle_overbelow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4782-4790",
    "snippet": "Datum\ncircle_overbelow(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((circle1->center.y + circle1->radius),\n\t\t\t\t\t\t(circle2->center.y + circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle((circle1->center.y + circle1->radius),\n\t\t\t\t\t\t(circle2->center.y + circle2->radius))"
          ],
          "line": 4788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "(circle1->center.y + circle1->radius)",
            "(circle2->center.y + circle2->radius)"
          ],
          "line": 4788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_overbelow(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((circle1->center.y + circle1->radius),\n\t\t\t\t\t\t(circle2->center.y + circle2->radius)));\n}"
  },
  {
    "function_name": "circle_above",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4769-4777",
    "snippet": "Datum\ncircle_above(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPgt((circle1->center.y - circle1->radius),\n\t\t\t\t\t\t(circle2->center.y + circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt((circle1->center.y - circle1->radius),\n\t\t\t\t\t\t(circle2->center.y + circle2->radius))"
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "(circle1->center.y - circle1->radius)",
            "(circle2->center.y + circle2->radius)"
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_above(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPgt((circle1->center.y - circle1->radius),\n\t\t\t\t\t\t(circle2->center.y + circle2->radius)));\n}"
  },
  {
    "function_name": "circle_below",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4757-4765",
    "snippet": "Datum\ncircle_below(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPlt((circle1->center.y + circle1->radius),\n\t\t\t\t\t\t(circle2->center.y - circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt((circle1->center.y + circle1->radius),\n\t\t\t\t\t\t(circle2->center.y - circle2->radius))"
          ],
          "line": 4763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "(circle1->center.y + circle1->radius)",
            "(circle2->center.y - circle2->radius)"
          ],
          "line": 4763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_below(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPlt((circle1->center.y + circle1->radius),\n\t\t\t\t\t\t(circle2->center.y - circle2->radius)));\n}"
  },
  {
    "function_name": "circle_contain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4745-4752",
    "snippet": "Datum\ncircle_contain(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((point_dt(&circle1->center, &circle2->center) + circle2->radius), circle1->radius));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle((point_dt(&circle1->center, &circle2->center) + circle2->radius), circle1->radius)"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "(point_dt(&circle1->center, &circle2->center) + circle2->radius)",
            "circle1->radius"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle1->center",
            "&circle2->center"
          ],
          "line": 4751
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_contain(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((point_dt(&circle1->center, &circle2->center) + circle2->radius), circle1->radius));\n}"
  },
  {
    "function_name": "circle_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4734-4741",
    "snippet": "Datum\ncircle_contained(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((point_dt(&circle1->center, &circle2->center) + circle1->radius), circle2->radius));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle((point_dt(&circle1->center, &circle2->center) + circle1->radius), circle2->radius)"
          ],
          "line": 4740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "(point_dt(&circle1->center, &circle2->center) + circle1->radius)",
            "circle2->radius"
          ],
          "line": 4740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle1->center",
            "&circle2->center"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_contained(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((point_dt(&circle1->center, &circle2->center) + circle1->radius), circle2->radius));\n}"
  },
  {
    "function_name": "circle_overright",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4722-4730",
    "snippet": "Datum\ncircle_overright(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPge((circle1->center.x - circle1->radius),\n\t\t\t\t\t\t(circle2->center.x - circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge((circle1->center.x - circle1->radius),\n\t\t\t\t\t\t(circle2->center.x - circle2->radius))"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "(circle1->center.x - circle1->radius)",
            "(circle2->center.x - circle2->radius)"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_overright(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPge((circle1->center.x - circle1->radius),\n\t\t\t\t\t\t(circle2->center.x - circle2->radius)));\n}"
  },
  {
    "function_name": "circle_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4709-4717",
    "snippet": "Datum\ncircle_right(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPgt((circle1->center.x - circle1->radius),\n\t\t\t\t\t\t(circle2->center.x + circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt((circle1->center.x - circle1->radius),\n\t\t\t\t\t\t(circle2->center.x + circle2->radius))"
          ],
          "line": 4715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "(circle1->center.x - circle1->radius)",
            "(circle2->center.x + circle2->radius)"
          ],
          "line": 4715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_right(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPgt((circle1->center.x - circle1->radius),\n\t\t\t\t\t\t(circle2->center.x + circle2->radius)));\n}"
  },
  {
    "function_name": "circle_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4697-4705",
    "snippet": "Datum\ncircle_left(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPlt((circle1->center.x + circle1->radius),\n\t\t\t\t\t\t(circle2->center.x - circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt((circle1->center.x + circle1->radius),\n\t\t\t\t\t\t(circle2->center.x - circle2->radius))"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "(circle1->center.x + circle1->radius)",
            "(circle2->center.x - circle2->radius)"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_left(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPlt((circle1->center.x + circle1->radius),\n\t\t\t\t\t\t(circle2->center.x - circle2->radius)));\n}"
  },
  {
    "function_name": "circle_overleft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4685-4693",
    "snippet": "Datum\ncircle_overleft(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((circle1->center.x + circle1->radius),\n\t\t\t\t\t\t(circle2->center.x + circle2->radius)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle((circle1->center.x + circle1->radius),\n\t\t\t\t\t\t(circle2->center.x + circle2->radius))"
          ],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "(circle1->center.x + circle1->radius)",
            "(circle2->center.x + circle2->radius)"
          ],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_overleft(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle((circle1->center.x + circle1->radius),\n\t\t\t\t\t\t(circle2->center.x + circle2->radius)));\n}"
  },
  {
    "function_name": "circle_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4672-4680",
    "snippet": "Datum\ncircle_overlap(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle(point_dt(&circle1->center, &circle2->center),\n\t\t\t\t\t\tcircle1->radius + circle2->radius));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(point_dt(&circle1->center, &circle2->center),\n\t\t\t\t\t\tcircle1->radius + circle2->radius)"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "point_dt(&circle1->center, &circle2->center)",
            "circle1->radius + circle2->radius"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&circle1->center",
            "&circle2->center"
          ],
          "line": 4678
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\ncircle_overlap(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPle(point_dt(&circle1->center, &circle2->center),\n\t\t\t\t\t\tcircle1->radius + circle2->radius));\n}"
  },
  {
    "function_name": "circle_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4659-4668",
    "snippet": "Datum\ncircle_same(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPeq(circle1->radius, circle2->radius) &&\n\t\t\t\t   FPeq(circle1->center.x, circle2->center.x) &&\n\t\t\t\t   FPeq(circle1->center.y, circle2->center.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(circle1->radius, circle2->radius) &&\n\t\t\t\t   FPeq(circle1->center.x, circle2->center.x) &&\n\t\t\t\t   FPeq(circle1->center.y, circle2->center.y)"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "circle1->center.y",
            "circle2->center.y"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "circle1->center.x",
            "circle2->center.x"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "circle1->radius",
            "circle2->radius"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "1"
          ],
          "line": 4663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_same(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0);\n\tCIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1);\n\n\tPG_RETURN_BOOL(FPeq(circle1->radius, circle2->radius) &&\n\t\t\t\t   FPeq(circle1->center.x, circle2->center.x) &&\n\t\t\t\t   FPeq(circle1->center.y, circle2->center.y));\n}"
  },
  {
    "function_name": "circle_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4638-4649",
    "snippet": "Datum\ncircle_send(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, circle->center.x);\n\tpq_sendfloat8(&buf, circle->center.y);\n\tpq_sendfloat8(&buf, circle->radius);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 4648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 4648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "circle->radius"
          ],
          "line": 4647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "circle->center.y"
          ],
          "line": 4646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "circle->center.x"
          ],
          "line": 4645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 4644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_send(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, circle->center.x);\n\tpq_sendfloat8(&buf, circle->center.y);\n\tpq_sendfloat8(&buf, circle->radius);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "circle_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4615-4633",
    "snippet": "Datum\ncircle_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tCIRCLE\t   *circle;\n\n\tcircle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tcircle->center.x = pq_getmsgfloat8(buf);\n\tcircle->center.y = pq_getmsgfloat8(buf);\n\tcircle->radius = pq_getmsgfloat8(buf);\n\n\tif (circle->radius < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid radius in external \\\"circle\\\" value\")));\n\n\tPG_RETURN_CIRCLE_P(circle);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "circle"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid radius in external \\\"circle\\\" value\"))"
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid radius in external \\\"circle\\\" value\""
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 4629
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 4624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CIRCLE)"
          ],
          "line": 4621
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 4618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\n\nDatum\ncircle_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tCIRCLE\t   *circle;\n\n\tcircle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\n\tcircle->center.x = pq_getmsgfloat8(buf);\n\tcircle->center.y = pq_getmsgfloat8(buf);\n\tcircle->radius = pq_getmsgfloat8(buf);\n\n\tif (circle->radius < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid radius in external \\\"circle\\\" value\")));\n\n\tPG_RETURN_CIRCLE_P(circle);\n}"
  },
  {
    "function_name": "circle_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4593-4610",
    "snippet": "Datum\ncircle_out(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tStringInfoData str;\n\n\tinitStringInfo(&str);\n\n\tappendStringInfoChar(&str, LDELIM_C);\n\tappendStringInfoChar(&str, LDELIM);\n\tpair_encode(circle->center.x, circle->center.y, &str);\n\tappendStringInfoChar(&str, RDELIM);\n\tappendStringInfoChar(&str, DELIM);\n\tsingle_encode(circle->radius, &str);\n\tappendStringInfoChar(&str, RDELIM_C);\n\n\tPG_RETURN_CSTRING(str.data);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RDELIM_C\t\t'>'",
      "#define LDELIM_C\t\t'<'",
      "#define DELIM\t\t\t','",
      "#define RDELIM\t\t\t')'",
      "#define LDELIM\t\t\t'('"
    ],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "str.data"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "RDELIM_C"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_encode",
          "args": [
            "circle->radius",
            "&str"
          ],
          "line": 4606
        },
        "resolved": true,
        "details": {
          "function_name": "single_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "130-137",
          "snippet": "static void\nsingle_encode(float8 x, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\n\tappendStringInfoString(str, xstr);\n\tpfree(xstr);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nstatic void\nsingle_encode(float8 x, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\n\tappendStringInfoString(str, xstr);\n\tpfree(xstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "DELIM"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "RDELIM"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_encode",
          "args": [
            "circle->center.x",
            "circle->center.y",
            "&str"
          ],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "pair_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "181-190",
          "snippet": "static void\npair_encode(float8 x, float8 y, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\tchar\t   *ystr = float8out_internal(y);\n\n\tappendStringInfo(str, \"%s,%s\", xstr, ystr);\n\tpfree(xstr);\n\tpfree(ystr);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nstatic void\npair_encode(float8 x, float8 y, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\tchar\t   *ystr = float8out_internal(y);\n\n\tappendStringInfo(str, \"%s,%s\", xstr, ystr);\n\tpfree(xstr);\n\tpfree(ystr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "LDELIM"
          ],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "LDELIM_C"
          ],
          "line": 4601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_C\t\t'>'\n#define LDELIM_C\t\t'<'\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nDatum\ncircle_out(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tStringInfoData str;\n\n\tinitStringInfo(&str);\n\n\tappendStringInfoChar(&str, LDELIM_C);\n\tappendStringInfoChar(&str, LDELIM);\n\tpair_encode(circle->center.x, circle->center.y, &str);\n\tappendStringInfoChar(&str, RDELIM);\n\tappendStringInfoChar(&str, DELIM);\n\tsingle_encode(circle->radius, &str);\n\tappendStringInfoChar(&str, RDELIM_C);\n\n\tPG_RETURN_CSTRING(str.data);\n}"
  },
  {
    "function_name": "circle_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4531-4589",
    "snippet": "Datum\ncircle_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tCIRCLE\t   *circle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tchar\t   *s,\n\t\t\t   *cp;\n\tint\t\t\tdepth = 0;\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM_C) || (*s == LDELIM))\n\t{\n\t\tdepth++;\n\t\tcp = (s + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t\ts = cp;\n\t}\n\n\tpair_decode(s, &circle->center.x, &circle->center.y, &s, \"circle\", str);\n\n\tif (*s == DELIM)\n\t\ts++;\n\n\tcircle->radius = single_decode(s, &s, \"circle\", str);\n\tif (circle->radius < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"circle\", str)));\n\n\twhile (depth > 0)\n\t{\n\t\tif ((*s == RDELIM)\n\t\t\t|| ((*s == RDELIM_C) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\ts++;\n\t\t\twhile (isspace((unsigned char) *s))\n\t\t\t\ts++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"circle\", str)));\n\t}\n\n\tif (*s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"circle\", str)));\n\n\tPG_RETURN_CIRCLE_P(circle);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RDELIM_C\t\t'>'",
      "#define LDELIM_C\t\t'<'",
      "#define DELIM\t\t\t','",
      "#define RDELIM\t\t\t')'",
      "#define LDELIM\t\t\t'('"
    ],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static Point *point_construct(double x, double y);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CIRCLE_P",
          "args": [
            "circle"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"circle\", str))"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"circle\"",
            "str"
          ],
          "line": 4585
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"circle\", str))"
          ],
          "line": 4576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 4572
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"circle\", str))"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_decode",
          "args": [
            "s",
            "&s",
            "\"circle\"",
            "str"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "single_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "123-128",
          "snippet": "static double\nsingle_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string)\n{\n\treturn float8in_internal(num, endptr_p, type_name, orig_string);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic double\nsingle_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string)\n{\n\treturn float8in_internal(num, endptr_p, type_name, orig_string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pair_decode",
          "args": [
            "s",
            "&circle->center.x",
            "&circle->center.y",
            "&s",
            "\"circle\"",
            "str"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "pair_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "139-179",
          "snippet": "static void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CIRCLE)"
          ],
          "line": 4535
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_C\t\t'>'\n#define LDELIM_C\t\t'<'\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nDatum\ncircle_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tCIRCLE\t   *circle = (CIRCLE *) palloc(sizeof(CIRCLE));\n\tchar\t   *s,\n\t\t\t   *cp;\n\tint\t\t\tdepth = 0;\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM_C) || (*s == LDELIM))\n\t{\n\t\tdepth++;\n\t\tcp = (s + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t\ts = cp;\n\t}\n\n\tpair_decode(s, &circle->center.x, &circle->center.y, &s, \"circle\", str);\n\n\tif (*s == DELIM)\n\t\ts++;\n\n\tcircle->radius = single_decode(s, &s, \"circle\", str);\n\tif (circle->radius < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"circle\", str)));\n\n\twhile (depth > 0)\n\t{\n\t\tif ((*s == RDELIM)\n\t\t\t|| ((*s == RDELIM_C) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\ts++;\n\t\t\twhile (isspace((unsigned char) *s))\n\t\t\t\ts++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"circle\", str)));\n\t}\n\n\tif (*s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"circle\", str)));\n\n\tPG_RETURN_CIRCLE_P(circle);\n}"
  },
  {
    "function_name": "poly_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4484-4512",
    "snippet": "Datum\npoly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\n\t/*\n\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n\t * smaller by a small constant.\n\t */\n\tsize = offsetof(PATH, p) + sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = true;\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "path",
            "size"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 4487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\n\t/*\n\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n\t * smaller by a small constant.\n\t */\n\tsize = offsetof(PATH, p) + sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = true;\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "box_poly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4454-4481",
    "snippet": "Datum\nbox_poly(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\n\t/* map four corners of the box to a polygon */\n\tsize = offsetof(POLYGON, p) + sizeof(poly->p[0]) * 4;\n\tpoly = (POLYGON *) palloc(size);\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = 4;\n\n\tpoly->p[0].x = box->low.x;\n\tpoly->p[0].y = box->low.y;\n\tpoly->p[1].x = box->low.x;\n\tpoly->p[1].y = box->high.y;\n\tpoly->p[2].x = box->high.x;\n\tpoly->p[2].y = box->high.y;\n\tpoly->p[3].x = box->high.x;\n\tpoly->p[3].y = box->low.y;\n\n\tbox_fill(&poly->boundbox, box->high.x, box->low.x,\n\t\t\t box->high.y, box->low.y);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POLYGON_P",
          "args": [
            "poly"
          ],
          "line": 4480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_fill",
          "args": [
            "&poly->boundbox",
            "box->high.x",
            "box->low.x",
            "box->high.y",
            "box->low.y"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "box_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "454-479",
          "snippet": "static BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic Point *point_construct(double x, double y);\n\nstatic BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "poly",
            "size"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\nbox_poly(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\n\t/* map four corners of the box to a polygon */\n\tsize = offsetof(POLYGON, p) + sizeof(poly->p[0]) * 4;\n\tpoly = (POLYGON *) palloc(size);\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = 4;\n\n\tpoly->p[0].x = box->low.x;\n\tpoly->p[0].y = box->low.y;\n\tpoly->p[1].x = box->low.x;\n\tpoly->p[1].y = box->high.y;\n\tpoly->p[2].x = box->high.x;\n\tpoly->p[2].y = box->high.y;\n\tpoly->p[3].x = box->high.x;\n\tpoly->p[3].y = box->low.y;\n\n\tbox_fill(&poly->boundbox, box->high.x, box->low.x,\n\t\t\t box->high.y, box->low.y);\n\n\tPG_RETURN_POLYGON_P(poly);\n}"
  },
  {
    "function_name": "poly_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4436-4448",
    "snippet": "Datum\npoly_box(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tBOX\t\t   *box;\n\n\tif (poly->npts < 1)\n\t\tPG_RETURN_NULL();\n\n\tbox = box_copy(&poly->boundbox);\n\n\tPG_RETURN_BOX_P(box);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static void make_bound_box(POLYGON *poly);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_copy",
          "args": [
            "&poly->boundbox"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "box_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "484-492",
          "snippet": "BOX *\nbox_copy(BOX *box)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\tmemcpy((char *) result, (char *) box, sizeof(BOX));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nBOX *\nbox_copy(BOX *box)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\tmemcpy((char *) result, (char *) box, sizeof(BOX));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_box(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tBOX\t\t   *box;\n\n\tif (poly->npts < 1)\n\t\tPG_RETURN_NULL();\n\n\tbox = box_copy(&poly->boundbox);\n\n\tPG_RETURN_BOX_P(box);\n}"
  },
  {
    "function_name": "poly_center",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4420-4433",
    "snippet": "Datum\npoly_center(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tDatum\t\tresult;\n\tCIRCLE\t   *circle;\n\n\tcircle = DatumGetCircleP(DirectFunctionCall1(poly_circle,\n\t\t\t\t\t\t\t\t\t\t\t\t PolygonPGetDatum(poly)));\n\tresult = DirectFunctionCall1(circle_center,\n\t\t\t\t\t\t\t\t CirclePGetDatum(circle));\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "circle_center",
            "CirclePGetDatum(circle)"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CirclePGetDatum",
          "args": [
            "circle"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCircleP",
          "args": [
            "DirectFunctionCall1(poly_circle,\n\t\t\t\t\t\t\t\t\t\t\t\t PolygonPGetDatum(poly))"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "poly_circle",
            "PolygonPGetDatum(poly)"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PolygonPGetDatum",
          "args": [
            "poly"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_center(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tDatum\t\tresult;\n\tCIRCLE\t   *circle;\n\n\tcircle = DatumGetCircleP(DirectFunctionCall1(poly_circle,\n\t\t\t\t\t\t\t\t\t\t\t\t PolygonPGetDatum(poly)));\n\tresult = DirectFunctionCall1(circle_center,\n\t\t\t\t\t\t\t\t CirclePGetDatum(circle));\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "poly_npoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4411-4417",
    "snippet": "Datum\npoly_npoints(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\n\tPG_RETURN_INT32(poly->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "poly->npts"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_npoints(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\n\tPG_RETURN_INT32(poly->npts);\n}"
  },
  {
    "function_name": "path_poly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4369-4402",
    "snippet": "Datum\npath_poly(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\n\t/* This is not very consistent --- other similar cases return NULL ... */\n\tif (!path->closed)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n\n\t/*\n\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n\t * just a small constant larger.\n\t */\n\tsize = offsetof(POLYGON, p) + sizeof(poly->p[0]) * path->npts;\n\tpoly = (POLYGON *) palloc(size);\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = path->npts;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpoly->p[i].x = path->p[i].x;\n\t\tpoly->p[i].y = path->p[i].y;\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POLYGON_P",
          "args": [
            "poly"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bound_box",
          "args": [
            "poly"
          ],
          "line": 4399
        },
        "resolved": true,
        "details": {
          "function_name": "make_bound_box",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3375-3406",
          "snippet": "static void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "poly",
            "size"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\"))"
          ],
          "line": 4379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"open path cannot be converted to polygon\""
          ],
          "line": 4381
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4380
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npath_poly(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\n\t/* This is not very consistent --- other similar cases return NULL ... */\n\tif (!path->closed)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n\n\t/*\n\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n\t * just a small constant larger.\n\t */\n\tsize = offsetof(POLYGON, p) + sizeof(poly->p[0]) * path->npts;\n\tpoly = (POLYGON *) palloc(size);\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = path->npts;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpoly->p[i].x = path->p[i].x;\n\t\tpoly->p[i].y = path->p[i].y;\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}"
  },
  {
    "function_name": "path_center",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4355-4367",
    "snippet": "Datum\npath_center(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n#endif\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"path_center\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"path_center\\\" not implemented\"))"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"path_center\\\" not implemented\""
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_center(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n#endif\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"path_center\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "path_div_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4334-4352",
    "snippet": "Datum\npath_div_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tPoint\t   *p;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tp = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&path->p[i]),\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\t\tpath->p[i].x = p->x;\n\t\tpath->p[i].y = p->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&path->p[i]),\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point))"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_div",
            "PointPGetDatum(&path->p[i])",
            "PointPGetDatum(point)"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "point"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&path->p[i]"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P_COPY",
          "args": [
            "0"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_div_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tPoint\t   *p;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tp = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&path->p[i]),\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\t\tpath->p[i].x = p->x;\n\t\tpath->p[i].y = p->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_mul_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4314-4332",
    "snippet": "Datum\npath_mul_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tPoint\t   *p;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tp = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&path->p[i]),\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\t\tpath->p[i].x = p->x;\n\t\tpath->p[i].y = p->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&path->p[i]),\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point))"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_mul",
            "PointPGetDatum(&path->p[i])",
            "PointPGetDatum(point)"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "point"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&path->p[i]"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P_COPY",
          "args": [
            "0"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_mul_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tPoint\t   *p;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tp = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(&path->p[i]),\n\t\t\t\t\t\t\t\t\t\t\t   PointPGetDatum(point)));\n\t\tpath->p[i].x = p->x;\n\t\tpath->p[i].y = p->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_sub_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4295-4309",
    "snippet": "Datum\npath_sub_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpath->p[i].x -= point->x;\n\t\tpath->p[i].y -= point->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P_COPY",
          "args": [
            "0"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_sub_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpath->p[i].x -= point->x;\n\t\tpath->p[i].y -= point->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_add_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4279-4293",
    "snippet": "Datum\npath_add_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpath->p[i].x += point->x;\n\t\tpath->p[i].y += point->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P_COPY",
          "args": [
            "0"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_add_pt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpath->p[i].x += point->x;\n\t\tpath->p[i].y += point->y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4231-4274",
    "snippet": "Datum\npath_add(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\tPATH\t   *result;\n\tint\t\t\tsize,\n\t\t\t\tbase_size;\n\tint\t\t\ti;\n\n\tif (p1->closed || p2->closed)\n\t\tPG_RETURN_NULL();\n\n\tbase_size = sizeof(p1->p[0]) * (p1->npts + p2->npts);\n\tsize = offsetof(PATH, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / sizeof(p1->p[0]) != (p1->npts + p2->npts) ||\n\t\tsize <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tresult = (PATH *) palloc(size);\n\n\tSET_VARSIZE(result, size);\n\tresult->npts = (p1->npts + p2->npts);\n\tresult->closed = p1->closed;\n\t/* prevent instability in unused pad bytes */\n\tresult->dummy = 0;\n\n\tfor (i = 0; i < p1->npts; i++)\n\t{\n\t\tresult->p[i].x = p1->p[i].x;\n\t\tresult->p[i].y = p1->p[i].y;\n\t}\n\tfor (i = 0; i < p2->npts; i++)\n\t{\n\t\tresult->p[i + p1->npts].x = p2->p[i].x;\n\t\tresult->p[i + p1->npts].y = p2->p[i].y;\n\t}\n\n\tPG_RETURN_PATH_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "result"
          ],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "size"
          ],
          "line": 4256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\"))"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many points requested\""
          ],
          "line": 4252
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 4234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_add(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\tPATH\t   *result;\n\tint\t\t\tsize,\n\t\t\t\tbase_size;\n\tint\t\t\ti;\n\n\tif (p1->closed || p2->closed)\n\t\tPG_RETURN_NULL();\n\n\tbase_size = sizeof(p1->p[0]) * (p1->npts + p2->npts);\n\tsize = offsetof(PATH, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / sizeof(p1->p[0]) != (p1->npts + p2->npts) ||\n\t\tsize <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tresult = (PATH *) palloc(size);\n\n\tSET_VARSIZE(result, size);\n\tresult->npts = (p1->npts + p2->npts);\n\tresult->closed = p1->closed;\n\t/* prevent instability in unused pad bytes */\n\tresult->dummy = 0;\n\n\tfor (i = 0; i < p1->npts; i++)\n\t{\n\t\tresult->p[i].x = p1->p[i].x;\n\t\tresult->p[i].y = p1->p[i].y;\n\t}\n\tfor (i = 0; i < p2->npts; i++)\n\t{\n\t\tresult->p[i + p1->npts].x = p2->p[i].x;\n\t\tresult->p[i + p1->npts].y = p2->p[i].y;\n\t}\n\n\tPG_RETURN_PATH_P(result);\n}"
  },
  {
    "function_name": "boxes_bound_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4204-4219",
    "snippet": "Datum\nboxes_bound_box(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0),\n\t\t\t   *box2 = PG_GETARG_BOX_P(1),\n\t\t\t   *container;\n\n\tcontainer = (BOX *) palloc(sizeof(BOX));\n\n\tcontainer->high.x = Max(box1->high.x, box2->high.x);\n\tcontainer->low.x = Min(box1->low.x, box2->low.x);\n\tcontainer->high.y = Max(box1->high.y, box2->high.y);\n\tcontainer->low.y = Min(box1->low.y, box2->low.y);\n\n\tPG_RETURN_BOX_P(container);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "container"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "box1->low.y",
            "box2->low.y"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "box1->high.y",
            "box2->high.y"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "box1->low.x",
            "box2->low.x"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "box1->high.x",
            "box2->high.x"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nboxes_bound_box(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0),\n\t\t\t   *box2 = PG_GETARG_BOX_P(1),\n\t\t\t   *container;\n\n\tcontainer = (BOX *) palloc(sizeof(BOX));\n\n\tcontainer->high.x = Max(box1->high.x, box2->high.x);\n\tcontainer->low.x = Min(box1->low.x, box2->low.x);\n\tcontainer->high.y = Max(box1->high.y, box2->high.y);\n\tcontainer->low.y = Min(box1->low.y, box2->low.y);\n\n\tPG_RETURN_BOX_P(container);\n}"
  },
  {
    "function_name": "point_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4185-4199",
    "snippet": "Datum\npoint_box(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box;\n\n\tbox = (BOX *) palloc(sizeof(BOX));\n\n\tbox->high.x = pt->x;\n\tbox->low.x = pt->x;\n\tbox->high.y = pt->y;\n\tbox->low.y = pt->y;\n\n\tPG_RETURN_BOX_P(box);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\npoint_box(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box;\n\n\tbox = (BOX *) palloc(sizeof(BOX));\n\n\tbox->high.x = pt->x;\n\tbox->low.x = pt->x;\n\tbox->high.y = pt->y;\n\tbox->low.y = pt->y;\n\n\tPG_RETURN_BOX_P(box);\n}"
  },
  {
    "function_name": "box_div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4161-4180",
    "snippet": "Datum\nbox_div(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\tBOX\t\t   *result;\n\tPoint\t   *high,\n\t\t\t   *low;\n\n\thigh = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(&box->high),\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(p)));\n\tlow = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&box->low),\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(p)));\n\n\tresult = box_construct(high->x, low->x, high->y, low->y);\n\n\tPG_RETURN_BOX_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "result"
          ],
          "line": 4179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_construct",
          "args": [
            "high->x",
            "low->x",
            "high->y",
            "low->y"
          ],
          "line": 4177
        },
        "resolved": true,
        "details": {
          "function_name": "box_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "443-449",
          "snippet": "static BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\n\nstatic BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&box->low),\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(p))"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_div",
            "PointPGetDatum(&box->low)",
            "PointPGetDatum(p)"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "p"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&box->low"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(&box->high),\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(p))"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_div",
            "PointPGetDatum(&box->high)",
            "PointPGetDatum(p)"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "p"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&box->high"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_div(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\tBOX\t\t   *result;\n\tPoint\t   *high,\n\t\t\t   *low;\n\n\thigh = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(&box->high),\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(p)));\n\tlow = DatumGetPointP(DirectFunctionCall2(point_div,\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&box->low),\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(p)));\n\n\tresult = box_construct(high->x, low->x, high->y, low->y);\n\n\tPG_RETURN_BOX_P(result);\n}"
  },
  {
    "function_name": "box_mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4140-4159",
    "snippet": "Datum\nbox_mul(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\tBOX\t\t   *result;\n\tPoint\t   *high,\n\t\t\t   *low;\n\n\thigh = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(&box->high),\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(p)));\n\tlow = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&box->low),\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(p)));\n\n\tresult = box_construct(high->x, low->x, high->y, low->y);\n\n\tPG_RETURN_BOX_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "result"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_construct",
          "args": [
            "high->x",
            "low->x",
            "high->y",
            "low->y"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "box_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "443-449",
          "snippet": "static BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\n\nstatic BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&box->low),\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(p))"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_mul",
            "PointPGetDatum(&box->low)",
            "PointPGetDatum(p)"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "p"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&box->low"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(&box->high),\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(p))"
          ],
          "line": 4149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "point_mul",
            "PointPGetDatum(&box->high)",
            "PointPGetDatum(p)"
          ],
          "line": 4149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "p"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&box->high"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_mul(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\tBOX\t\t   *result;\n\tPoint\t   *high,\n\t\t\t   *low;\n\n\thigh = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(&box->high),\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(p)));\n\tlow = DatumGetPointP(DirectFunctionCall2(point_mul,\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&box->low),\n\t\t\t\t\t\t\t\t\t\t\t PointPGetDatum(p)));\n\n\tresult = box_construct(high->x, low->x, high->y, low->y);\n\n\tPG_RETURN_BOX_P(result);\n}"
  },
  {
    "function_name": "box_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4128-4138",
    "snippet": "Datum\nbox_sub(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOX_P(box_construct((box->high.x - p->x),\n\t\t\t\t\t\t\t\t  (box->low.x - p->x),\n\t\t\t\t\t\t\t\t  (box->high.y - p->y),\n\t\t\t\t\t\t\t\t  (box->low.y - p->y)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box_construct((box->high.x - p->x),\n\t\t\t\t\t\t\t\t  (box->low.x - p->x),\n\t\t\t\t\t\t\t\t  (box->high.y - p->y),\n\t\t\t\t\t\t\t\t  (box->low.y - p->y))"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_construct",
          "args": [
            "(box->high.x - p->x)",
            "(box->low.x - p->x)",
            "(box->high.y - p->y)",
            "(box->low.y - p->y)"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "box_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "443-449",
          "snippet": "static BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\n\nstatic BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_sub(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOX_P(box_construct((box->high.x - p->x),\n\t\t\t\t\t\t\t\t  (box->low.x - p->x),\n\t\t\t\t\t\t\t\t  (box->high.y - p->y),\n\t\t\t\t\t\t\t\t  (box->low.y - p->y)));\n}"
  },
  {
    "function_name": "box_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4116-4126",
    "snippet": "Datum\nbox_add(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOX_P(box_construct((box->high.x + p->x),\n\t\t\t\t\t\t\t\t  (box->low.x + p->x),\n\t\t\t\t\t\t\t\t  (box->high.y + p->y),\n\t\t\t\t\t\t\t\t  (box->low.y + p->y)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box_construct((box->high.x + p->x),\n\t\t\t\t\t\t\t\t  (box->low.x + p->x),\n\t\t\t\t\t\t\t\t  (box->high.y + p->y),\n\t\t\t\t\t\t\t\t  (box->low.y + p->y))"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_construct",
          "args": [
            "(box->high.x + p->x)",
            "(box->low.x + p->x)",
            "(box->high.y + p->y)",
            "(box->low.y + p->y)"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "box_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "443-449",
          "snippet": "static BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\n\nstatic BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_add(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOX_P(box_construct((box->high.x + p->x),\n\t\t\t\t\t\t\t\t  (box->low.x + p->x),\n\t\t\t\t\t\t\t\t  (box->high.y + p->y),\n\t\t\t\t\t\t\t\t  (box->low.y + p->y)));\n}"
  },
  {
    "function_name": "points_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4107-4114",
    "snippet": "Datum\npoints_box(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOX_P(box_construct(p1->x, p2->x, p1->y, p2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box_construct(p1->x, p2->x, p1->y, p2->y)"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_construct",
          "args": [
            "p1->x",
            "p2->x",
            "p1->y",
            "p2->y"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "box_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "443-449",
          "snippet": "static BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\n\nstatic BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nDatum\npoints_box(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOX_P(box_construct(p1->x, p2->x, p1->y, p2->y));\n}"
  },
  {
    "function_name": "point_div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4077-4098",
    "snippet": "Datum\npoint_div(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\tdouble\t\tdiv;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tdiv = (p2->x * p2->x) + (p2->y * p2->y);\n\n\tif (div == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult->x = ((p1->x * p2->x) + (p1->y * p2->y)) / div;\n\tresult->y = ((p2->x * p1->y) - (p2->y * p1->x)) / div;\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nDatum\npoint_div(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\tdouble\t\tdiv;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tdiv = (p2->x * p2->x) + (p2->y * p2->y);\n\n\tif (div == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult->x = ((p1->x * p2->x) + (p1->y * p2->y)) / div;\n\tresult->y = ((p2->x * p1->y) - (p2->y * p1->x)) / div;\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "point_mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4062-4075",
    "snippet": "Datum\npoint_mul(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x * p2->x) - (p1->y * p2->y);\n\tresult->y = (p1->x * p2->y) + (p1->y * p2->x);\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 4069
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nDatum\npoint_mul(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x * p2->x) - (p1->y * p2->y);\n\tresult->y = (p1->x * p2->y) + (p1->y * p2->x);\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "point_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4047-4060",
    "snippet": "Datum\npoint_sub(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x - p2->x);\n\tresult->y = (p1->y - p2->y);\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nDatum\npoint_sub(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x - p2->x);\n\tresult->y = (p1->y - p2->y);\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "point_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4032-4045",
    "snippet": "Datum\npoint_add(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x + p2->x);\n\tresult->y = (p1->y + p2->y);\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nDatum\npoint_add(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x + p2->x);\n\tresult->y = (p1->y + p2->y);\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "construct_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4023-4030",
    "snippet": "Datum\nconstruct_point(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tx = PG_GETARG_FLOAT8(0);\n\tfloat8\t\ty = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_POINT_P(point_construct(x, y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "point_construct(x, y)"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_construct",
          "args": [
            "x",
            "y"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "point_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1783-1791",
          "snippet": "static Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nstatic Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\nconstruct_point(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tx = PG_GETARG_FLOAT8(0);\n\tfloat8\t\ty = PG_GETARG_FLOAT8(1);\n\n\tPG_RETURN_POINT_P(point_construct(x, y));\n}"
  },
  {
    "function_name": "poly_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "4001-4014",
    "snippet": "Datum\npoly_distance(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n#endif\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"poly_distance\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"poly_distance\\\" not implemented\"))"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"poly_distance\\\" not implemented\""
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_distance(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n#endif\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"poly_distance\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "pt_contained_poly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3991-3998",
    "snippet": "Datum\npt_contained_poly(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p = PG_GETARG_POINT_P(0);\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(1);\n\n\tPG_RETURN_BOOL(point_inside(p, poly->npts, poly->p) != 0);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "point_inside(p, poly->npts, poly->p) != 0"
          ],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_inside",
          "args": [
            "p",
            "poly->npts",
            "poly->p"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "point_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5258-5304",
          "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static int\tpoint_inside(Point *p, int npts, Point *plist);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npt_contained_poly(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p = PG_GETARG_POINT_P(0);\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(1);\n\n\tPG_RETURN_BOOL(point_inside(p, poly->npts, poly->p) != 0);\n}"
  },
  {
    "function_name": "poly_contain_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3982-3989",
    "snippet": "Datum\npoly_contain_pt(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(point_inside(p, poly->npts, poly->p) != 0);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "point_inside(p, poly->npts, poly->p) != 0"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_inside",
          "args": [
            "p",
            "poly->npts",
            "poly->p"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "point_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5258-5304",
          "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static int\tpoint_inside(Point *p, int npts, Point *plist);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_contain_pt(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPoint\t   *p = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(point_inside(p, poly->npts, poly->p) != 0);\n}"
  },
  {
    "function_name": "poly_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3971-3979",
    "snippet": "Datum\npoly_contained(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tpolya = PG_GETARG_DATUM(0);\n\tDatum\t\tpolyb = PG_GETARG_DATUM(1);\n\n\t/* Just switch the arguments and pass it off to poly_contain */\n\tPG_RETURN_DATUM(DirectFunctionCall2(poly_contain, polyb, polya));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(poly_contain, polyb, polya)"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "poly_contain",
            "polyb",
            "polya"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 3975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_contained(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tpolya = PG_GETARG_DATUM(0);\n\tDatum\t\tpolyb = PG_GETARG_DATUM(1);\n\n\t/* Just switch the arguments and pass it off to poly_contain */\n\tPG_RETURN_DATUM(DirectFunctionCall2(poly_contain, polyb, polya));\n}"
  },
  {
    "function_name": "poly_contain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3925-3965",
    "snippet": "Datum\npoly_contain(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\t/*\n\t * Quick check to see if bounding box is contained.\n\t */\n\tif (polya->npts > 0 && polyb->npts > 0 &&\n\t\tDatumGetBool(DirectFunctionCall2(box_contain,\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(&polya->boundbox),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(&polyb->boundbox))))\n\t{\n\t\tint\t\t\ti;\n\t\tLSEG\t\ts;\n\n\t\ts.p[0] = polyb->p[polyb->npts - 1];\n\t\tresult = true;\n\n\t\tfor (i = 0; i < polyb->npts && result; i++)\n\t\t{\n\t\t\ts.p[1] = polyb->p[i];\n\t\t\tresult = lseg_inside_poly(s.p, s.p + 1, polya, 0);\n\t\t\ts.p[0] = s.p[1];\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = false;\n\t}\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_inside_poly",
          "args": [
            "s.p",
            "s.p + 1",
            "polya",
            "0"
          ],
          "line": 3949
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_inside_poly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3855-3920",
          "snippet": "static bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(box_contain,\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(&polya->boundbox),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(&polyb->boundbox))"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "box_contain",
            "BoxPGetDatum(&polya->boundbox)",
            "BoxPGetDatum(&polyb->boundbox)"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "&polyb->boundbox"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "&polya->boundbox"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\npoly_contain(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\t/*\n\t * Quick check to see if bounding box is contained.\n\t */\n\tif (polya->npts > 0 && polyb->npts > 0 &&\n\t\tDatumGetBool(DirectFunctionCall2(box_contain,\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(&polya->boundbox),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(&polyb->boundbox))))\n\t{\n\t\tint\t\t\ti;\n\t\tLSEG\t\ts;\n\n\t\ts.p[0] = polyb->p[polyb->npts - 1];\n\t\tresult = true;\n\n\t\tfor (i = 0; i < polyb->npts && result; i++)\n\t\t{\n\t\t\ts.p[1] = polyb->p[i];\n\t\t\tresult = lseg_inside_poly(s.p, s.p + 1, polya, 0);\n\t\t\ts.p[0] = s.p[1];\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = false;\n\t}\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "lseg_inside_poly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3855-3920",
    "snippet": "static bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "point_inside",
          "args": [
            "&p",
            "poly->npts",
            "poly->p"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "point_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5258-5304",
          "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static int\tpoint_inside(Point *p, int npts, Point *plist);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "interpt"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseg_inside_poly",
          "args": [
            "t.p + 1",
            "interpt",
            "poly",
            "i + 1"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_inside_poly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3855-3920",
          "snippet": "static bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "lseg_interpt_internal",
          "args": [
            "&t",
            "&s"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_interpt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2257-2303",
          "snippet": "static Point *\nlseg_interpt_internal(LSEG *l1, LSEG *l2)\n{\n\tPoint\t   *result;\n\tLINE\t\ttmp1,\n\t\t\t\ttmp2;\n\n\t/*\n\t * Find the intersection of the appropriate lines, if any.\n\t */\n\tline_construct_pts(&tmp1, &l1->p[0], &l1->p[1]);\n\tline_construct_pts(&tmp2, &l2->p[0], &l2->p[1]);\n\tresult = line_interpt_internal(&tmp1, &tmp2);\n\tif (!PointerIsValid(result))\n\t\treturn NULL;\n\n\t/*\n\t * If the line intersection point isn't within l1 (or equivalently l2),\n\t * there is no valid segment intersection point at all.\n\t */\n\tif (!on_ps_internal(result, l1) ||\n\t\t!on_ps_internal(result, l2))\n\t{\n\t\tpfree(result);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If there is an intersection, then check explicitly for matching\n\t * endpoints since there may be rounding effects with annoying lsb\n\t * residue. - tgl 1997-07-09\n\t */\n\tif ((FPeq(l1->p[0].x, l2->p[0].x) && FPeq(l1->p[0].y, l2->p[0].y)) ||\n\t\t(FPeq(l1->p[0].x, l2->p[1].x) && FPeq(l1->p[0].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[0].x;\n\t\tresult->y = l1->p[0].y;\n\t}\n\telse if ((FPeq(l1->p[1].x, l2->p[0].x) && FPeq(l1->p[1].y, l2->p[0].y)) ||\n\t\t\t (FPeq(l1->p[1].x, l2->p[1].x) && FPeq(l1->p[1].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[1].x;\n\t\tresult->y = l1->p[1].y;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *point_construct(double x, double y);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nlseg_interpt_internal(LSEG *l1, LSEG *l2)\n{\n\tPoint\t   *result;\n\tLINE\t\ttmp1,\n\t\t\t\ttmp2;\n\n\t/*\n\t * Find the intersection of the appropriate lines, if any.\n\t */\n\tline_construct_pts(&tmp1, &l1->p[0], &l1->p[1]);\n\tline_construct_pts(&tmp2, &l2->p[0], &l2->p[1]);\n\tresult = line_interpt_internal(&tmp1, &tmp2);\n\tif (!PointerIsValid(result))\n\t\treturn NULL;\n\n\t/*\n\t * If the line intersection point isn't within l1 (or equivalently l2),\n\t * there is no valid segment intersection point at all.\n\t */\n\tif (!on_ps_internal(result, l1) ||\n\t\t!on_ps_internal(result, l2))\n\t{\n\t\tpfree(result);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If there is an intersection, then check explicitly for matching\n\t * endpoints since there may be rounding effects with annoying lsb\n\t * residue. - tgl 1997-07-09\n\t */\n\tif ((FPeq(l1->p[0].x, l2->p[0].x) && FPeq(l1->p[0].y, l2->p[0].y)) ||\n\t\t(FPeq(l1->p[0].x, l2->p[1].x) && FPeq(l1->p[0].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[0].x;\n\t\tresult->y = l1->p[0].y;\n\t}\n\telse if ((FPeq(l1->p[1].x, l2->p[0].x) && FPeq(l1->p[1].y, l2->p[0].y)) ||\n\t\t\t (FPeq(l1->p[1].x, l2->p[1].x) && FPeq(l1->p[1].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[1].x;\n\t\tresult->y = l1->p[1].y;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touched_lseg_inside_poly",
          "args": [
            "t.p + 1",
            "t.p",
            "&s",
            "poly",
            "i + 1"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "touched_lseg_inside_poly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3818-3848",
          "snippet": "static bool\ntouched_lseg_inside_poly(Point *a, Point *b, LSEG *s, POLYGON *poly, int start)\n{\n\t/* point a is on s, b is not */\n\tLSEG\t\tt;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\n#define POINTEQ(pt1, pt2)\t(FPeq((pt1)->x, (pt2)->x) && FPeq((pt1)->y, (pt2)->y))\n\tif (POINTEQ(a, s->p))\n\t{\n\t\tif (on_ps_internal(s->p + 1, &t))\n\t\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\telse if (POINTEQ(a, s->p + 1))\n\t{\n\t\tif (on_ps_internal(s->p, &t))\n\t\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p + 1, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\n\treturn true;\t\t\t\t/* may be not true, but that will check later */\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic bool\ntouched_lseg_inside_poly(Point *a, Point *b, LSEG *s, POLYGON *poly, int start)\n{\n\t/* point a is on s, b is not */\n\tLSEG\t\tt;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\n#define POINTEQ(pt1, pt2)\t(FPeq((pt1)->x, (pt2)->x) && FPeq((pt1)->y, (pt2)->y))\n\tif (POINTEQ(a, s->p))\n\t{\n\t\tif (on_ps_internal(s->p + 1, &t))\n\t\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\telse if (POINTEQ(a, s->p + 1))\n\t{\n\t\tif (on_ps_internal(s->p, &t))\n\t\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p + 1, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\n\treturn true;\t\t\t\t/* may be not true, but that will check later */\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_ps_internal",
          "args": [
            "t.p + 1",
            "&s"
          ],
          "line": 3884
        },
        "resolved": true,
        "details": {
          "function_name": "on_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3152-3157",
          "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "touched_lseg_inside_poly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3818-3848",
    "snippet": "static bool\ntouched_lseg_inside_poly(Point *a, Point *b, LSEG *s, POLYGON *poly, int start)\n{\n\t/* point a is on s, b is not */\n\tLSEG\t\tt;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\n#define POINTEQ(pt1, pt2)\t(FPeq((pt1)->x, (pt2)->x) && FPeq((pt1)->y, (pt2)->y))\n\tif (POINTEQ(a, s->p))\n\t{\n\t\tif (on_ps_internal(s->p + 1, &t))\n\t\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\telse if (POINTEQ(a, s->p + 1))\n\t{\n\t\tif (on_ps_internal(s->p, &t))\n\t\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p + 1, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\n\treturn true;\t\t\t\t/* may be not true, but that will check later */\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
      "static bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lseg_inside_poly",
          "args": [
            "b",
            "s->p + 1",
            "poly",
            "start"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_inside_poly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3855-3920",
          "snippet": "static bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic bool\nlseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start)\n{\n\tLSEG\t\ts,\n\t\t\t\tt;\n\tint\t\t\ti;\n\tbool\t\tres = true,\n\t\t\t\tintersection = false;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\ts.p[0] = poly->p[(start == 0) ? (poly->npts - 1) : (start - 1)];\n\n\tfor (i = start; i < poly->npts && res; i++)\n\t{\n\t\tPoint\t   *interpt;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\ts.p[1] = poly->p[i];\n\n\t\tif (on_ps_internal(t.p, &s))\n\t\t{\n\t\t\tif (on_ps_internal(t.p + 1, &s))\n\t\t\t\treturn true;\t/* t is contained by s */\n\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p, t.p + 1, &s, poly, i + 1);\n\t\t}\n\t\telse if (on_ps_internal(t.p + 1, &s))\n\t\t{\n\t\t\t/* Y-cross */\n\t\t\tres = touched_lseg_inside_poly(t.p + 1, t.p, &s, poly, i + 1);\n\t\t}\n\t\telse if ((interpt = lseg_interpt_internal(&t, &s)) != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * segments are X-crossing, go to check each subsegment\n\t\t\t */\n\n\t\t\tintersection = true;\n\t\t\tres = lseg_inside_poly(t.p, interpt, poly, i + 1);\n\t\t\tif (res)\n\t\t\t\tres = lseg_inside_poly(t.p + 1, interpt, poly, i + 1);\n\t\t\tpfree(interpt);\n\t\t}\n\n\t\ts.p[0] = s.p[1];\n\t}\n\n\tif (res && !intersection)\n\t{\n\t\tPoint\t\tp;\n\n\t\t/*\n\t\t * if X-intersection wasn't found  then check central point of tested\n\t\t * segment. In opposite case we already check all subsegments\n\t\t */\n\t\tp.x = (t.p[0].x + t.p[1].x) / 2.0;\n\t\tp.y = (t.p[0].y + t.p[1].y) / 2.0;\n\n\t\tres = point_inside(&p, poly->npts, poly->p);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_ps_internal",
          "args": [
            "s->p + 1",
            "&t"
          ],
          "line": 3842
        },
        "resolved": true,
        "details": {
          "function_name": "on_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3152-3157",
          "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "POINTEQ",
          "args": [
            "a",
            "s->p + 1"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POINTEQ",
          "args": [
            "a",
            "s->p"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic bool lseg_inside_poly(Point *a, Point *b, POLYGON *poly, int start);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic bool\ntouched_lseg_inside_poly(Point *a, Point *b, LSEG *s, POLYGON *poly, int start)\n{\n\t/* point a is on s, b is not */\n\tLSEG\t\tt;\n\n\tt.p[0] = *a;\n\tt.p[1] = *b;\n\n#define POINTEQ(pt1, pt2)\t(FPeq((pt1)->x, (pt2)->x) && FPeq((pt1)->y, (pt2)->y))\n\tif (POINTEQ(a, s->p))\n\t{\n\t\tif (on_ps_internal(s->p + 1, &t))\n\t\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\telse if (POINTEQ(a, s->p + 1))\n\t{\n\t\tif (on_ps_internal(s->p, &t))\n\t\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p, poly, start);\n\t}\n\telse if (on_ps_internal(s->p + 1, &t))\n\t{\n\t\treturn lseg_inside_poly(b, s->p + 1, poly, start);\n\t}\n\n\treturn true;\t\t\t\t/* may be not true, but that will check later */\n}"
  },
  {
    "function_name": "poly_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3742-3805",
    "snippet": "Datum\npoly_overlap(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\t/* Quick check by bounding box */\n\tresult = (polya->npts > 0 && polyb->npts > 0 &&\n\t\t\t  box_ov(&polya->boundbox, &polyb->boundbox)) ? true : false;\n\n\t/*\n\t * Brute-force algorithm - try to find intersected edges, if so then\n\t * polygons are overlapped else check is one polygon inside other or not\n\t * by testing single point of them.\n\t */\n\tif (result)\n\t{\n\t\tint\t\t\tia,\n\t\t\t\t\tib;\n\t\tLSEG\t\tsa,\n\t\t\t\t\tsb;\n\n\t\t/* Init first of polya's edge with last point */\n\t\tsa.p[0] = polya->p[polya->npts - 1];\n\t\tresult = false;\n\n\t\tfor (ia = 0; ia < polya->npts && result == false; ia++)\n\t\t{\n\t\t\t/* Second point of polya's edge is a current one */\n\t\t\tsa.p[1] = polya->p[ia];\n\n\t\t\t/* Init first of polyb's edge with last point */\n\t\t\tsb.p[0] = polyb->p[polyb->npts - 1];\n\n\t\t\tfor (ib = 0; ib < polyb->npts && result == false; ib++)\n\t\t\t{\n\t\t\t\tsb.p[1] = polyb->p[ib];\n\t\t\t\tresult = lseg_intersect_internal(&sa, &sb);\n\t\t\t\tsb.p[0] = sb.p[1];\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * move current endpoint to the first point of next edge\n\t\t\t */\n\t\t\tsa.p[0] = sa.p[1];\n\t\t}\n\n\t\tif (result == false)\n\t\t{\n\t\t\tresult = (point_inside(polya->p, polyb->npts, polyb->p)\n\t\t\t\t\t  ||\n\t\t\t\t\t  point_inside(polyb->p, polya->npts, polya->p));\n\t\t}\n\t}\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_inside",
          "args": [
            "polyb->p",
            "polya->npts",
            "polya->p"
          ],
          "line": 3794
        },
        "resolved": true,
        "details": {
          "function_name": "point_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5258-5304",
          "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static int\tpoint_inside(Point *p, int npts, Point *plist);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseg_intersect_internal",
          "args": [
            "&sa",
            "&sb"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_intersect_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2058-2073",
          "snippet": "static bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "box_ov",
          "args": [
            "&polya->boundbox",
            "&polyb->boundbox"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "box_ov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "525-532",
          "snippet": "static bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool box_ov(BOX *box1, BOX *box2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\npoly_overlap(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\t/* Quick check by bounding box */\n\tresult = (polya->npts > 0 && polyb->npts > 0 &&\n\t\t\t  box_ov(&polya->boundbox, &polyb->boundbox)) ? true : false;\n\n\t/*\n\t * Brute-force algorithm - try to find intersected edges, if so then\n\t * polygons are overlapped else check is one polygon inside other or not\n\t * by testing single point of them.\n\t */\n\tif (result)\n\t{\n\t\tint\t\t\tia,\n\t\t\t\t\tib;\n\t\tLSEG\t\tsa,\n\t\t\t\t\tsb;\n\n\t\t/* Init first of polya's edge with last point */\n\t\tsa.p[0] = polya->p[polya->npts - 1];\n\t\tresult = false;\n\n\t\tfor (ia = 0; ia < polya->npts && result == false; ia++)\n\t\t{\n\t\t\t/* Second point of polya's edge is a current one */\n\t\t\tsa.p[1] = polya->p[ia];\n\n\t\t\t/* Init first of polyb's edge with last point */\n\t\t\tsb.p[0] = polyb->p[polyb->npts - 1];\n\n\t\t\tfor (ib = 0; ib < polyb->npts && result == false; ib++)\n\t\t\t{\n\t\t\t\tsb.p[1] = polyb->p[ib];\n\t\t\t\tresult = lseg_intersect_internal(&sa, &sb);\n\t\t\t\tsb.p[0] = sb.p[1];\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * move current endpoint to the first point of next edge\n\t\t\t */\n\t\t\tsa.p[0] = sa.p[1];\n\t\t}\n\n\t\tif (result == false)\n\t\t{\n\t\t\tresult = (point_inside(polya->p, polyb->npts, polyb->p)\n\t\t\t\t\t  ||\n\t\t\t\t\t  point_inside(polyb->p, polya->npts, polya->p));\n\t\t}\n\t}\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3718-3737",
    "snippet": "Datum\npoly_same(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tif (polya->npts != polyb->npts)\n\t\tresult = false;\n\telse\n\t\tresult = plist_same(polya->npts, polya->p, polyb->p);\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_same",
          "args": [
            "polya->npts",
            "polya->p",
            "polyb->p"
          ],
          "line": 3728
        },
        "resolved": true,
        "details": {
          "function_name": "plist_same",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5371-5428",
          "snippet": "static bool\nplist_same(int npts, Point *p1, Point *p2)\n{\n\tint\t\t\ti,\n\t\t\t\tii,\n\t\t\t\tj;\n\n\t/* find match for first point */\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif ((FPeq(p2[i].x, p1[0].x))\n\t\t\t&& (FPeq(p2[i].y, p1[0].y)))\n\t\t{\n\n\t\t\t/* match found? then look forward through remaining points */\n\t\t\tfor (ii = 1, j = i + 1; ii < npts; ii++, j++)\n\t\t\t{\n\t\t\t\tif (j >= npts)\n\t\t\t\t\tj = 0;\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed forward match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after forward match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\n\t\t\t/* match not found forwards? then look backwards */\n\t\t\tfor (ii = 1, j = i - 1; ii < npts; ii++, j--)\n\t\t\t{\n\t\t\t\tif (j < 0)\n\t\t\t\t\tj = (npts - 1);\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed reverse match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after reverse match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool plist_same(int npts, Point *p1, Point *p2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nplist_same(int npts, Point *p1, Point *p2)\n{\n\tint\t\t\ti,\n\t\t\t\tii,\n\t\t\t\tj;\n\n\t/* find match for first point */\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif ((FPeq(p2[i].x, p1[0].x))\n\t\t\t&& (FPeq(p2[i].y, p1[0].y)))\n\t\t{\n\n\t\t\t/* match found? then look forward through remaining points */\n\t\t\tfor (ii = 1, j = i + 1; ii < npts; ii++, j++)\n\t\t\t{\n\t\t\t\tif (j >= npts)\n\t\t\t\t\tj = 0;\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed forward match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after forward match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\n\t\t\t/* match not found forwards? then look backwards */\n\t\t\tfor (ii = 1, j = i - 1; ii < npts; ii++, j--)\n\t\t\t{\n\t\t\t\tif (j < 0)\n\t\t\t\t\tj = (npts - 1);\n\t\t\t\tif ((!FPeq(p2[j].x, p1[ii].x))\n\t\t\t\t\t|| (!FPeq(p2[j].y, p1[ii].y)))\n\t\t\t\t{\n#ifdef GEODEBUG\n\t\t\t\t\tprintf(\"plist_same- %d failed reverse match with %d\\n\", j, ii);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef GEODEBUG\n\t\t\tprintf(\"plist_same- ii = %d/%d after reverse match\\n\", ii, npts);\n#endif\n\t\t\tif (ii == npts)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_same(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tif (polya->npts != polyb->npts)\n\t\tresult = false;\n\telse\n\t\tresult = plist_same(polya->npts, polya->p, polyb->p);\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_overabove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3692-3708",
    "snippet": "Datum\npoly_overabove(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.y >= polyb->boundbox.low.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npoly_overabove(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.y >= polyb->boundbox.low.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_above",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3669-3685",
    "snippet": "Datum\npoly_above(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.y > polyb->boundbox.high.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npoly_above(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.y > polyb->boundbox.high.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_overbelow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3646-3662",
    "snippet": "Datum\npoly_overbelow(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.y <= polyb->boundbox.high.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npoly_overbelow(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.y <= polyb->boundbox.high.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_below",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3623-3639",
    "snippet": "Datum\npoly_below(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.y < polyb->boundbox.low.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npoly_below(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.y < polyb->boundbox.low.y;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_overright",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3600-3616",
    "snippet": "Datum\npoly_overright(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.x >= polyb->boundbox.low.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_overright(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.x >= polyb->boundbox.low.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3577-3593",
    "snippet": "Datum\npoly_right(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.x > polyb->boundbox.high.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_right(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.low.x > polyb->boundbox.high.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_overleft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3554-3570",
    "snippet": "Datum\npoly_overleft(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.x <= polyb->boundbox.high.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_overleft(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.x <= polyb->boundbox.high.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3531-3547",
    "snippet": "Datum\npoly_left(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.x < polyb->boundbox.low.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polyb",
            "1"
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "polya",
            "0"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npoly_left(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *polya = PG_GETARG_POLYGON_P(0);\n\tPOLYGON    *polyb = PG_GETARG_POLYGON_P(1);\n\tbool\t\tresult;\n\n\tresult = polya->boundbox.high.x < polyb->boundbox.low.x;\n\n\t/*\n\t * Avoid leaking memory for toasted inputs ... needed for rtree indexes\n\t */\n\tPG_FREE_IF_COPY(polya, 0);\n\tPG_FREE_IF_COPY(polyb, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "poly_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3508-3523",
    "snippet": "Datum\npoly_send(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tStringInfoData buf;\n\tint32\t\ti;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, poly->npts);\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpq_sendfloat8(&buf, poly->p[i].x);\n\t\tpq_sendfloat8(&buf, poly->p[i].y);\n\t}\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "poly->p[i].y"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "poly->p[i].x"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "poly->npts"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_send(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tStringInfoData buf;\n\tint32\t\ti;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, poly->npts);\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpq_sendfloat8(&buf, poly->p[i].x);\n\t\tpq_sendfloat8(&buf, poly->p[i].y);\n\t}\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "poly_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3473-3503",
    "snippet": "Datum\npoly_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tPOLYGON    *poly;\n\tint32\t\tnpts;\n\tint32\t\ti;\n\tint\t\t\tsize;\n\n\tnpts = pq_getmsgint(buf, sizeof(int32));\n\tif (npts <= 0 || npts >= (int32) ((INT_MAX - offsetof(POLYGON, p)) / sizeof(Point)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of points in external \\\"polygon\\\" value\")));\n\n\tsize = offsetof(POLYGON, p) + sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpoly->p[i].x = pq_getmsgfloat8(buf);\n\t\tpoly->p[i].y = pq_getmsgfloat8(buf);\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POLYGON_P",
          "args": [
            "poly"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bound_box",
          "args": [
            "poly"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "make_bound_box",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3375-3406",
          "snippet": "static void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "poly",
            "size"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "size"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of points in external \\\"polygon\\\" value\"))"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid number of points in external \\\"polygon\\\" value\""
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(INT_MAX - offsetof(POLYGON, p)) / sizeof(Point)"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int32)"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tPOLYGON    *poly;\n\tint32\t\tnpts;\n\tint32\t\ti;\n\tint\t\t\tsize;\n\n\tnpts = pq_getmsgint(buf, sizeof(int32));\n\tif (npts <= 0 || npts >= (int32) ((INT_MAX - offsetof(POLYGON, p)) / sizeof(Point)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of points in external \\\"polygon\\\" value\")));\n\n\tsize = offsetof(POLYGON, p) + sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpoly->p[i].x = pq_getmsgfloat8(buf);\n\t\tpoly->p[i].y = pq_getmsgfloat8(buf);\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}"
  },
  {
    "function_name": "poly_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3457-3463",
    "snippet": "Datum\npoly_out(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_CLOSED, poly->npts, poly->p));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "path_encode(PATH_CLOSED, poly->npts, poly->p)"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_encode",
          "args": [
            "PATH_CLOSED",
            "poly->npts",
            "poly->p"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "path_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "268-311",
          "snippet": "static char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_out(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_CLOSED, poly->npts, poly->p));\n}"
  },
  {
    "function_name": "poly_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3416-3451",
    "snippet": "Datum\npoly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tbase_size;\n\tbool\t\tisopen;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"polygon\", str)));\n\n\tbase_size = sizeof(poly->p[0]) * npts;\n\tsize = offsetof(POLYGON, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tpath_decode(str, false, npts, &(poly->p[0]), &isopen, NULL, \"polygon\", str);\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POLYGON_P",
          "args": [
            "poly"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bound_box",
          "args": [
            "poly"
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "make_bound_box",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3375-3406",
          "snippet": "static void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_decode",
          "args": [
            "str",
            "false",
            "npts",
            "&(poly->p[0])",
            "&isopen",
            "NULL",
            "\"polygon\"",
            "str"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "path_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "192-266",
          "snippet": "static void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "poly",
            "size"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "size"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\"))"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many points requested\""
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"polygon\", str))"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_count",
          "args": [
            "str",
            "','"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "pair_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "320-331",
          "snippet": "static int\npair_count(char *s, char delim)\n{\n\tint\t\t\tndelim = 0;\n\n\twhile ((s = strchr(s, delim)) != NULL)\n\t{\n\t\tndelim++;\n\t\ts++;\n\t}\n\treturn (ndelim % 2) ? ((ndelim + 1) / 2) : -1;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tpair_count(char *s, char delim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic int\tpair_count(char *s, char delim);\n\nstatic int\npair_count(char *s, char delim)\n{\n\tint\t\t\tndelim = 0;\n\n\twhile ((s = strchr(s, delim)) != NULL)\n\t{\n\t\tndelim++;\n\t\ts++;\n\t}\n\treturn (ndelim % 2) ? ((ndelim + 1) / 2) : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\npoly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tbase_size;\n\tbool\t\tisopen;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"polygon\", str)));\n\n\tbase_size = sizeof(poly->p[0]) * npts;\n\tsize = offsetof(POLYGON, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(poly->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpoly = (POLYGON *) palloc0(size);\t/* zero any holes */\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tpath_decode(str, false, npts, &(poly->p[0]), &isopen, NULL, \"polygon\", str);\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}"
  },
  {
    "function_name": "make_bound_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3375-3406",
    "snippet": "static void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static BOX *box_construct(double x1, double x2, double y1, double y2);",
      "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\"))"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot create bounding box for empty polygon\""
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "box_fill",
          "args": [
            "&(poly->boundbox)",
            "x1",
            "x2",
            "y1",
            "y2"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "box_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "454-479",
          "snippet": "static BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic Point *point_construct(double x, double y);\n\nstatic BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic void\nmake_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}"
  },
  {
    "function_name": "inter_lb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3327-3362",
    "snippet": "Datum\ninter_lb(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tLSEG\t\tbseg;\n\tPoint\t\tp1,\n\t\t\t\tp2;\n\n\t/* pairwise check lseg intersections */\n\tp1.x = box->low.x;\n\tp1.y = box->low.y;\n\tp2.x = box->low.x;\n\tp2.y = box->high.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\tp1.x = box->high.x;\n\tp1.y = box->high.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\tp2.x = box->high.x;\n\tp2.y = box->low.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\tp1.x = box->low.x;\n\tp1.y = box->low.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\n\t/* if we dropped through, no intersection */\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_interpt_sl",
          "args": [
            "&bseg",
            "line"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&bseg",
            "&p1",
            "&p2"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ninter_lb(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tLSEG\t\tbseg;\n\tPoint\t\tp1,\n\t\t\t\tp2;\n\n\t/* pairwise check lseg intersections */\n\tp1.x = box->low.x;\n\tp1.y = box->low.y;\n\tp2.x = box->low.x;\n\tp2.y = box->high.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\tp1.x = box->high.x;\n\tp1.y = box->high.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\tp2.x = box->high.x;\n\tp2.y = box->low.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\tp1.x = box->low.x;\n\tp1.y = box->low.y;\n\tstatlseg_construct(&bseg, &p1, &p2);\n\tif (has_interpt_sl(&bseg, line))\n\t\tPG_RETURN_BOOL(true);\n\n\t/* if we dropped through, no intersection */\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "inter_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3272-3322",
    "snippet": "Datum\ninter_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tBOX\t\t\tlbox;\n\tLSEG\t\tbseg;\n\tPoint\t\tpoint;\n\n\tlbox.low.x = Min(lseg->p[0].x, lseg->p[1].x);\n\tlbox.low.y = Min(lseg->p[0].y, lseg->p[1].y);\n\tlbox.high.x = Max(lseg->p[0].x, lseg->p[1].x);\n\tlbox.high.y = Max(lseg->p[0].y, lseg->p[1].y);\n\n\t/* nothing close to overlap? then not going to intersect */\n\tif (!box_ov(&lbox, box))\n\t\tPG_RETURN_BOOL(false);\n\n\t/* an endpoint of segment is inside box? then clearly intersects */\n\tif (DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))) ||\n\t\tDatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))))\n\t\tPG_RETURN_BOOL(true);\n\n\t/* pairwise check lseg intersections */\n\tpoint.x = box->low.x;\n\tpoint.y = box->high.y;\n\tstatlseg_construct(&bseg, &box->low, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\tstatlseg_construct(&bseg, &box->high, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\tpoint.x = box->high.x;\n\tpoint.y = box->low.y;\n\tstatlseg_construct(&bseg, &box->low, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\tstatlseg_construct(&bseg, &box->high, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\t/* if we dropped through, no two segs intersected */\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_intersect_internal",
          "args": [
            "&bseg",
            "lseg"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_intersect_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2058-2073",
          "snippet": "static bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&bseg",
            "&box->high",
            "&point"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pb",
            "PointPGetDatum(&lseg->p[1])",
            "BoxPGetDatum(box)"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&lseg->p[1]"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pb",
            "PointPGetDatum(&lseg->p[0])",
            "BoxPGetDatum(box)"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&lseg->p[0]"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ov",
          "args": [
            "&lbox",
            "box"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "box_ov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "525-532",
          "snippet": "static bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool box_ov(BOX *box1, BOX *box2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "lseg->p[0].y",
            "lseg->p[1].y"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "lseg->p[0].x",
            "lseg->p[1].x"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "lseg->p[0].y",
            "lseg->p[1].y"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "lseg->p[0].x",
            "lseg->p[1].x"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ninter_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tBOX\t\t\tlbox;\n\tLSEG\t\tbseg;\n\tPoint\t\tpoint;\n\n\tlbox.low.x = Min(lseg->p[0].x, lseg->p[1].x);\n\tlbox.low.y = Min(lseg->p[0].y, lseg->p[1].y);\n\tlbox.high.x = Max(lseg->p[0].x, lseg->p[1].x);\n\tlbox.high.y = Max(lseg->p[0].y, lseg->p[1].y);\n\n\t/* nothing close to overlap? then not going to intersect */\n\tif (!box_ov(&lbox, box))\n\t\tPG_RETURN_BOOL(false);\n\n\t/* an endpoint of segment is inside box? then clearly intersects */\n\tif (DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))) ||\n\t\tDatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))))\n\t\tPG_RETURN_BOOL(true);\n\n\t/* pairwise check lseg intersections */\n\tpoint.x = box->low.x;\n\tpoint.y = box->high.y;\n\tstatlseg_construct(&bseg, &box->low, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\tstatlseg_construct(&bseg, &box->high, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\tpoint.x = box->high.x;\n\tpoint.y = box->low.y;\n\tstatlseg_construct(&bseg, &box->low, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\tstatlseg_construct(&bseg, &box->high, &point);\n\tif (lseg_intersect_internal(&bseg, lseg))\n\t\tPG_RETURN_BOOL(true);\n\n\t/* if we dropped through, no two segs intersected */\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "inter_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3253-3260",
    "snippet": "Datum\ninter_sl(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(has_interpt_sl(lseg, line));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "has_interpt_sl(lseg, line)"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_interpt_sl",
          "args": [
            "lseg",
            "line"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ninter_sl(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(has_interpt_sl(lseg, line));\n}"
  },
  {
    "function_name": "on_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3234-3246",
    "snippet": "Datum\non_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))) &&\n\t\t\t\t   DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))) &&\n\t\t\t\t   DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box)))"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pb",
            "PointPGetDatum(&lseg->p[1])",
            "BoxPGetDatum(box)"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&lseg->p[1]"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pb",
            "PointPGetDatum(&lseg->p[0])",
            "BoxPGetDatum(box)"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&lseg->p[0]"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\non_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))) &&\n\t\t\t\t   DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tBoxPGetDatum(box))));\n}"
  },
  {
    "function_name": "on_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3220-3232",
    "snippet": "Datum\non_sl(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(DatumGetBool(DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))) &&\n\t\t\t\t   DatumGetBool(DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "DatumGetBool(DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))) &&\n\t\t\t\t   DatumGetBool(DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line)))"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pl",
            "PointPGetDatum(&lseg->p[1])",
            "LinePGetDatum(line)"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "line"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&lseg->p[1]"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pl",
            "PointPGetDatum(&lseg->p[0])",
            "LinePGetDatum(line)"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "line"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&lseg->p[0]"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\non_sl(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(DatumGetBool(DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))) &&\n\t\t\t\t   DatumGetBool(DirectFunctionCall2(on_pl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&lseg->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLinePGetDatum(line))));\n}"
  },
  {
    "function_name": "on_ppath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3190-3218",
    "snippet": "Datum\non_ppath(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tPATH\t   *path = PG_GETARG_PATH_P(1);\n\tint\t\t\ti,\n\t\t\t\tn;\n\tdouble\t\ta,\n\t\t\t\tb;\n\n\t/*-- OPEN --*/\n\tif (!path->closed)\n\t{\n\t\tn = path->npts - 1;\n\t\ta = point_dt(pt, &path->p[0]);\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tb = point_dt(pt, &path->p[i + 1]);\n\t\t\tif (FPeq(a + b,\n\t\t\t\t\t point_dt(&path->p[i], &path->p[i + 1])))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\ta = b;\n\t\t}\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\t/*-- CLOSED --*/\n\tPG_RETURN_BOOL(point_inside(pt, path->npts, path->p) != 0);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "point_inside(pt, path->npts, path->p) != 0"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_inside",
          "args": [
            "pt",
            "path->npts",
            "path->p"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "point_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5258-5304",
          "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static int\tpoint_inside(Point *p, int npts, Point *plist);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "a + b",
            "point_dt(&path->p[i], &path->p[i + 1])"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&path->p[i]",
            "&path->p[i + 1]"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nDatum\non_ppath(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tPATH\t   *path = PG_GETARG_PATH_P(1);\n\tint\t\t\ti,\n\t\t\t\tn;\n\tdouble\t\ta,\n\t\t\t\tb;\n\n\t/*-- OPEN --*/\n\tif (!path->closed)\n\t{\n\t\tn = path->npts - 1;\n\t\ta = point_dt(pt, &path->p[0]);\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tb = point_dt(pt, &path->p[i + 1]);\n\t\t\tif (FPeq(a + b,\n\t\t\t\t\t point_dt(&path->p[i], &path->p[i + 1])))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\ta = b;\n\t\t}\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\t/*-- CLOSED --*/\n\tPG_RETURN_BOOL(point_inside(pt, path->npts, path->p) != 0);\n}"
  },
  {
    "function_name": "box_contain_pt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3169-3177",
    "snippet": "Datum\nbox_contain_pt(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *pt = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(pt->x <= box->high.x && pt->x >= box->low.x &&\n\t\t\t\t   pt->y <= box->high.y && pt->y >= box->low.y);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "pt->x <= box->high.x && pt->x >= box->low.x &&\n\t\t\t\t   pt->y <= box->high.y && pt->y >= box->low.y"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_contain_pt(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *pt = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(pt->x <= box->high.x && pt->x >= box->low.x &&\n\t\t\t\t   pt->y <= box->high.y && pt->y >= box->low.y);\n}"
  },
  {
    "function_name": "on_pb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3159-3167",
    "snippet": "Datum\non_pb(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(pt->x <= box->high.x && pt->x >= box->low.x &&\n\t\t\t\t   pt->y <= box->high.y && pt->y >= box->low.y);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "pt->x <= box->high.x && pt->x >= box->low.x &&\n\t\t\t\t   pt->y <= box->high.y && pt->y >= box->low.y"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\non_pb(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(pt->x <= box->high.x && pt->x >= box->low.x &&\n\t\t\t\t   pt->y <= box->high.y && pt->y >= box->low.y);\n}"
  },
  {
    "function_name": "on_ps_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3152-3157",
    "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1])",
            "point_dt(&lseg->p[0], &lseg->p[1])"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&lseg->p[0]",
            "&lseg->p[1]"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
  },
  {
    "function_name": "on_ps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3143-3150",
    "snippet": "Datum\non_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(on_ps_internal(pt, lseg));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "on_ps_internal(pt, lseg)"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_ps_internal",
          "args": [
            "pt",
            "lseg"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "on_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3152-3157",
          "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\non_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(on_ps_internal(pt, lseg));\n}"
  },
  {
    "function_name": "on_pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3129-3136",
    "snippet": "Datum\non_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(FPzero(line->A * pt->x + line->B * pt->y + line->C));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPzero(line->A * pt->x + line->B * pt->y + line->C)"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->A * pt->x + line->B * pt->y + line->C"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\non_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(FPzero(line->A * pt->x + line->B * pt->y + line->C));\n}"
  },
  {
    "function_name": "close_lb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3105-3119",
    "snippet": "Datum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\"))"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"close_lb\\\" not implemented\""
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "close_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3048-3103",
    "snippet": "Datum\nclose_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tPoint\t\tpoint;\n\tLSEG\t\tbseg,\n\t\t\t\tseg;\n\tdouble\t\tdist,\n\t\t\t\td;\n\n\t/* segment intersects box? then just return closest point to center */\n\tif (DatumGetBool(DirectFunctionCall2(inter_sb,\n\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))))\n\t{\n\t\tbox_cn(&point, box);\n\t\tPG_RETURN_DATUM(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(lseg)));\n\t}\n\n\t/* pairwise check lseg distances */\n\tpoint.x = box->low.x;\n\tpoint.y = box->high.y;\n\tstatlseg_construct(&bseg, &box->low, &point);\n\tdist = lseg_dt(lseg, &bseg);\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = lseg_dt(lseg, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&bseg, &seg, sizeof(bseg));\n\t}\n\n\tpoint.x = box->high.x;\n\tpoint.y = box->low.y;\n\tstatlseg_construct(&seg, &box->low, &point);\n\tif ((d = lseg_dt(lseg, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&bseg, &seg, sizeof(bseg));\n\t}\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = lseg_dt(lseg, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&bseg, &seg, sizeof(bseg));\n\t}\n\n\t/* OK, we now have the closest line segment on the box boundary */\n\tPG_RETURN_DATUM(DirectFunctionCall2(close_lseg,\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(&bseg)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(close_lseg,\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(&bseg))"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_lseg",
            "LsegPGetDatum(lseg)",
            "LsegPGetDatum(&bseg)"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "&bseg"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "lseg"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bseg",
            "&seg",
            "sizeof(bseg)"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_dt",
          "args": [
            "lseg",
            "&seg"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2221-2240",
          "snippet": "static double\nlseg_dt(LSEG *l1, LSEG *l2)\n{\n\tdouble\t\tresult,\n\t\t\t\td;\n\n\tif (lseg_intersect_internal(l1, l2))\n\t\treturn 0.0;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tresult = d;\n\td = dist_ps_internal(&l1->p[1], l2);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[0], l1);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[1], l1);\n\tresult = Min(result, d);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic double\nlseg_dt(LSEG *l1, LSEG *l2)\n{\n\tdouble\t\tresult,\n\t\t\t\td;\n\n\tif (lseg_intersect_internal(l1, l2))\n\t\treturn 0.0;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tresult = d;\n\td = dist_ps_internal(&l1->p[1], l2);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[0], l1);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[1], l1);\n\tresult = Min(result, d);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&seg",
            "&box->high",
            "&point"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bseg",
            "&seg",
            "sizeof(bseg)"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bseg",
            "&seg",
            "sizeof(bseg)"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(lseg))"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_ps",
            "PointPGetDatum(&point)",
            "LsegPGetDatum(lseg)"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "lseg"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&point"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_cn",
          "args": [
            "&point",
            "box"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "box_cn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "819-824",
          "snippet": "static void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(inter_sb,\n\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "inter_sb",
            "LsegPGetDatum(lseg)",
            "BoxPGetDatum(box)"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "lseg"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nclose_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tPoint\t\tpoint;\n\tLSEG\t\tbseg,\n\t\t\t\tseg;\n\tdouble\t\tdist,\n\t\t\t\td;\n\n\t/* segment intersects box? then just return closest point to center */\n\tif (DatumGetBool(DirectFunctionCall2(inter_sb,\n\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))))\n\t{\n\t\tbox_cn(&point, box);\n\t\tPG_RETURN_DATUM(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(lseg)));\n\t}\n\n\t/* pairwise check lseg distances */\n\tpoint.x = box->low.x;\n\tpoint.y = box->high.y;\n\tstatlseg_construct(&bseg, &box->low, &point);\n\tdist = lseg_dt(lseg, &bseg);\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = lseg_dt(lseg, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&bseg, &seg, sizeof(bseg));\n\t}\n\n\tpoint.x = box->high.x;\n\tpoint.y = box->low.y;\n\tstatlseg_construct(&seg, &box->low, &point);\n\tif ((d = lseg_dt(lseg, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&bseg, &seg, sizeof(bseg));\n\t}\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = lseg_dt(lseg, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&bseg, &seg, sizeof(bseg));\n\t}\n\n\t/* OK, we now have the closest line segment on the box boundary */\n\tPG_RETURN_DATUM(DirectFunctionCall2(close_lseg,\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(&bseg)));\n}"
  },
  {
    "function_name": "close_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "3022-3043",
    "snippet": "Datum\nclose_ls(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result;\n\tfloat8\t\td1,\n\t\t\t\td2;\n\n\tresult = interpt_sl(lseg, line);\n\tif (result)\n\t\tPG_RETURN_POINT_P(result);\n\n\td1 = dist_pl_internal(&lseg->p[0], line);\n\td2 = dist_pl_internal(&lseg->p[1], line);\n\tif (d1 < d2)\n\t\tresult = point_copy(&lseg->p[0]);\n\telse\n\t\tresult = point_copy(&lseg->p[1]);\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_copy",
          "args": [
            "&lseg->p[1]"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "point_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1794-1807",
          "snippet": "static Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dist_pl_internal",
          "args": [
            "&lseg->p[1]",
            "line"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "dist_pl_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2346-2351",
          "snippet": "static double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpt_sl",
          "args": [
            "lseg",
            "line"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nclose_ls(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result;\n\tfloat8\t\td1,\n\t\t\t\td2;\n\n\tresult = interpt_sl(lseg, line);\n\tif (result)\n\t\tPG_RETURN_POINT_P(result);\n\n\td1 = dist_pl_internal(&lseg->p[0], line);\n\td2 = dist_pl_internal(&lseg->p[1], line);\n\tif (d1 < d2)\n\t\tresult = point_copy(&lseg->p[0]);\n\telse\n\t\tresult = point_copy(&lseg->p[1]);\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "close_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2988-3017",
    "snippet": "Datum\nclose_sl(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\tPoint\t   *result;\n\tfloat8\t\td1,\n\t\t\t\td2;\n\n\tresult = interpt_sl(lseg, line);\n\tif (result)\n\t\tPG_RETURN_POINT_P(result);\n\n\td1 = dist_pl_internal(&lseg->p[0], line);\n\td2 = dist_pl_internal(&lseg->p[1], line);\n\tif (d1 < d2)\n\t\tresult = point_copy(&lseg->p[0]);\n\telse\n\t\tresult = point_copy(&lseg->p[1]);\n\n\tPG_RETURN_POINT_P(result);\n#endif\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_sl\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_sl\\\" not implemented\"))"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"close_sl\\\" not implemented\""
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_copy",
          "args": [
            "&lseg->p[1]"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "point_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1794-1807",
          "snippet": "static Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dist_pl_internal",
          "args": [
            "&lseg->p[1]",
            "line"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "dist_pl_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2346-2351",
          "snippet": "static double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpt_sl",
          "args": [
            "lseg",
            "line"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nclose_sl(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\tPoint\t   *result;\n\tfloat8\t\td1,\n\t\t\t\td2;\n\n\tresult = interpt_sl(lseg, line);\n\tif (result)\n\t\tPG_RETURN_POINT_P(result);\n\n\td1 = dist_pl_internal(&lseg->p[0], line);\n\td2 = dist_pl_internal(&lseg->p[1], line);\n\tif (d1 < d2)\n\t\tresult = point_copy(&lseg->p[0]);\n\telse\n\t\tresult = point_copy(&lseg->p[1]);\n\n\tPG_RETURN_POINT_P(result);\n#endif\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_sl\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "close_pb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2929-2977",
    "snippet": "Datum\nclose_pb(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tLSEG\t\tlseg,\n\t\t\t\tseg;\n\tPoint\t\tpoint;\n\tdouble\t\tdist,\n\t\t\t\td;\n\n\tif (DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))))\n\t\tPG_RETURN_POINT_P(pt);\n\n\t/* pairwise check lseg distances */\n\tpoint.x = box->low.x;\n\tpoint.y = box->high.y;\n\tstatlseg_construct(&lseg, &box->low, &point);\n\tdist = dist_ps_internal(pt, &lseg);\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = dist_ps_internal(pt, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&lseg, &seg, sizeof(lseg));\n\t}\n\n\tpoint.x = box->high.x;\n\tpoint.y = box->low.y;\n\tstatlseg_construct(&seg, &box->low, &point);\n\tif ((d = dist_ps_internal(pt, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&lseg, &seg, sizeof(lseg));\n\t}\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = dist_ps_internal(pt, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&lseg, &seg, sizeof(lseg));\n\t}\n\n\tPG_RETURN_DATUM(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\tPointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(&lseg)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\tPointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(&lseg))"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_ps",
            "PointPGetDatum(pt)",
            "LsegPGetDatum(&lseg)"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "&lseg"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "pt"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lseg",
            "&seg",
            "sizeof(lseg)"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ps_internal",
          "args": [
            "pt",
            "&seg"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2365-2416",
          "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&seg",
            "&box->high",
            "&point"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lseg",
            "&seg",
            "sizeof(lseg)"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lseg",
            "&seg",
            "sizeof(lseg)"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "pt"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "on_pb",
            "PointPGetDatum(pt)",
            "BoxPGetDatum(box)"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "pt"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nclose_pb(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tLSEG\t\tlseg,\n\t\t\t\tseg;\n\tPoint\t\tpoint;\n\tdouble\t\tdist,\n\t\t\t\td;\n\n\tif (DatumGetBool(DirectFunctionCall2(on_pb,\n\t\t\t\t\t\t\t\t\t\t PointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))))\n\t\tPG_RETURN_POINT_P(pt);\n\n\t/* pairwise check lseg distances */\n\tpoint.x = box->low.x;\n\tpoint.y = box->high.y;\n\tstatlseg_construct(&lseg, &box->low, &point);\n\tdist = dist_ps_internal(pt, &lseg);\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = dist_ps_internal(pt, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&lseg, &seg, sizeof(lseg));\n\t}\n\n\tpoint.x = box->high.x;\n\tpoint.y = box->low.y;\n\tstatlseg_construct(&seg, &box->low, &point);\n\tif ((d = dist_ps_internal(pt, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&lseg, &seg, sizeof(lseg));\n\t}\n\n\tstatlseg_construct(&seg, &box->high, &point);\n\tif ((d = dist_ps_internal(pt, &seg)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&lseg, &seg, sizeof(lseg));\n\t}\n\n\tPG_RETURN_DATUM(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\tPointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(&lseg)));\n}"
  },
  {
    "function_name": "close_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2878-2924",
    "snippet": "Datum\nclose_lseg(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result = NULL;\n\tPoint\t\tpoint;\n\tdouble\t\tdist;\n\tdouble\t\td;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tdist = d;\n\tmemcpy(&point, &l1->p[0], sizeof(Point));\n\n\tif ((d = dist_ps_internal(&l1->p[1], l2)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&point, &l1->p[1], sizeof(Point));\n\t}\n\n\tif (dist_ps_internal(&l2->p[0], l1) < dist)\n\t{\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&l2->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l1)));\n\t\tmemcpy(&point, result, sizeof(Point));\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l2)));\n\t}\n\n\tif (dist_ps_internal(&l2->p[1], l1) < dist)\n\t{\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&l2->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l1)));\n\t\tmemcpy(&point, result, sizeof(Point));\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l2)));\n\t}\n\n\tif (result == NULL)\n\t\tresult = point_copy(&point);\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_copy",
          "args": [
            "&point"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "point_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1794-1807",
          "snippet": "static Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l2))"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_ps",
            "PointPGetDatum(&point)",
            "LsegPGetDatum(l2)"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "l2"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&point"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&point",
            "result",
            "sizeof(Point)"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&l2->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l1))"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_ps",
            "PointPGetDatum(&l2->p[1])",
            "LsegPGetDatum(l1)"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "l1"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&l2->p[1]"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ps_internal",
          "args": [
            "&l2->p[1]",
            "l1"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2365-2416",
          "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l2))"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_ps",
            "PointPGetDatum(&point)",
            "LsegPGetDatum(l2)"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "l2"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&point"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&point",
            "result",
            "sizeof(Point)"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&l2->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l1))"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_ps",
            "PointPGetDatum(&l2->p[0])",
            "LsegPGetDatum(l1)"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "l1"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "&l2->p[0]"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&point",
            "&l1->p[1]",
            "sizeof(Point)"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&point",
            "&l1->p[0]",
            "sizeof(Point)"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nclose_lseg(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result = NULL;\n\tPoint\t\tpoint;\n\tdouble\t\tdist;\n\tdouble\t\td;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tdist = d;\n\tmemcpy(&point, &l1->p[0], sizeof(Point));\n\n\tif ((d = dist_ps_internal(&l1->p[1], l2)) < dist)\n\t{\n\t\tdist = d;\n\t\tmemcpy(&point, &l1->p[1], sizeof(Point));\n\t}\n\n\tif (dist_ps_internal(&l2->p[0], l1) < dist)\n\t{\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&l2->p[0]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l1)));\n\t\tmemcpy(&point, result, sizeof(Point));\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l2)));\n\t}\n\n\tif (dist_ps_internal(&l2->p[1], l1) < dist)\n\t{\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&l2->p[1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l1)));\n\t\tmemcpy(&point, result, sizeof(Point));\n\t\tresult = DatumGetPointP(DirectFunctionCall2(close_ps,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPointPGetDatum(&point),\n\t\t\t\t\t\t\t\t\t\t\t\t\tLsegPGetDatum(l2)));\n\t}\n\n\tif (result == NULL)\n\t\tresult = point_copy(&point);\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "close_ps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2756-2872",
    "snippet": "Datum\nclose_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result = NULL;\n\tLINE\t   *tmp;\n\tdouble\t\tinvm;\n\tint\t\t\txh,\n\t\t\t\tyh;\n\n#ifdef GEODEBUG\n\tprintf(\"close_sp:pt->x %f pt->y %f\\nlseg(0).x %f lseg(0).y %f  lseg(1).x %f lseg(1).y %f\\n\",\n\t\t   pt->x, pt->y, lseg->p[0].x, lseg->p[0].y,\n\t\t   lseg->p[1].x, lseg->p[1].y);\n#endif\n\n\t/* xh (or yh) is the index of upper x( or y) end point of lseg */\n\t/* !xh (or !yh) is the index of lower x( or y) end point of lseg */\n\txh = lseg->p[0].x < lseg->p[1].x;\n\tyh = lseg->p[0].y < lseg->p[1].y;\n\n\tif (FPeq(lseg->p[0].x, lseg->p[1].x))\t/* vertical? */\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps- segment is vertical\\n\");\n#endif\n\t\t/* first check if point is below or above the entire lseg. */\n\t\tif (pt->y < lseg->p[!yh].y)\n\t\t\tresult = point_copy(&lseg->p[!yh]); /* below the lseg */\n\t\telse if (pt->y > lseg->p[yh].y)\n\t\t\tresult = point_copy(&lseg->p[yh]);\t/* above the lseg */\n\t\tif (result != NULL)\n\t\t\tPG_RETURN_POINT_P(result);\n\n\t\t/* point lines along (to left or right) of the vertical lseg. */\n\n\t\tresult = (Point *) palloc(sizeof(Point));\n\t\tresult->x = lseg->p[0].x;\n\t\tresult->y = pt->y;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\telse if (FPeq(lseg->p[0].y, lseg->p[1].y))\t/* horizontal? */\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps- segment is horizontal\\n\");\n#endif\n\t\t/* first check if point is left or right of the entire lseg. */\n\t\tif (pt->x < lseg->p[!xh].x)\n\t\t\tresult = point_copy(&lseg->p[!xh]); /* left of the lseg */\n\t\telse if (pt->x > lseg->p[xh].x)\n\t\t\tresult = point_copy(&lseg->p[xh]);\t/* right of the lseg */\n\t\tif (result != NULL)\n\t\t\tPG_RETURN_POINT_P(result);\n\n\t\t/* point lines along (at top or below) the horiz. lseg. */\n\t\tresult = (Point *) palloc(sizeof(Point));\n\t\tresult->x = pt->x;\n\t\tresult->y = lseg->p[0].y;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\n\t/*\n\t * vert. and horiz. cases are down, now check if the closest point is one\n\t * of the end points or someplace on the lseg.\n\t */\n\n\tinvm = -1.0 / point_sl(&(lseg->p[0]), &(lseg->p[1]));\n\ttmp = line_construct_pm(&lseg->p[!yh], invm);\t/* lower edge of the\n\t\t\t\t\t\t\t\t\t\t\t\t\t * \"band\" */\n\tif (pt->y < (tmp->A * pt->x + tmp->C))\n\t{\t\t\t\t\t\t\t/* we are below the lower edge */\n\t\tresult = point_copy(&lseg->p[!yh]); /* below the lseg, take lower end\n\t\t\t\t\t\t\t\t\t\t\t * pt */\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps below: tmp A %f  B %f   C %f\\n\",\n\t\t\t   tmp->A, tmp->B, tmp->C);\n#endif\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\ttmp = line_construct_pm(&lseg->p[yh], invm);\t/* upper edge of the\n\t\t\t\t\t\t\t\t\t\t\t\t\t * \"band\" */\n\tif (pt->y > (tmp->A * pt->x + tmp->C))\n\t{\t\t\t\t\t\t\t/* we are below the lower edge */\n\t\tresult = point_copy(&lseg->p[yh]);\t/* above the lseg, take higher end\n\t\t\t\t\t\t\t\t\t\t\t * pt */\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps above: tmp A %f  B %f   C %f\\n\",\n\t\t\t   tmp->A, tmp->B, tmp->C);\n#endif\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\n\t/*\n\t * at this point the \"normal\" from point will hit lseg. The closest point\n\t * will be somewhere on the lseg\n\t */\n\ttmp = line_construct_pm(pt, invm);\n#ifdef GEODEBUG\n\tprintf(\"close_ps- tmp A %f  B %f   C %f\\n\",\n\t\t   tmp->A, tmp->B, tmp->C);\n#endif\n\tresult = interpt_sl(lseg, tmp);\n\n\t/*\n\t * ordinarily we should always find an intersection point, but that could\n\t * fail in the presence of NaN coordinates, and perhaps even from simple\n\t * roundoff issues.  Return a SQL NULL if so.\n\t */\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\n#ifdef GEODEBUG\n\tprintf(\"close_ps- result.x %f  result.y %f\\n\", result->x, result->y);\n#endif\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_ps- result.x %f  result.y %f\\n\"",
            "result->x",
            "result->y"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpt_sl",
          "args": [
            "lseg",
            "tmp"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_ps- tmp A %f  B %f   C %f\\n\"",
            "tmp->A",
            "tmp->B",
            "tmp->C"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_construct_pm",
          "args": [
            "pt",
            "invm"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1009-1030",
          "snippet": "static LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_ps above: tmp A %f  B %f   C %f\\n\"",
            "tmp->A",
            "tmp->B",
            "tmp->C"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_copy",
          "args": [
            "&lseg->p[yh]"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "point_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1794-1807",
          "snippet": "static Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_ps below: tmp A %f  B %f   C %f\\n\"",
            "tmp->A",
            "tmp->B",
            "tmp->C"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_sl",
          "args": [
            "&(lseg->p[0])",
            "&(lseg->p[1])"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "point_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1924-1930",
          "snippet": "double\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_ps- segment is horizontal\\n\""
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "lseg->p[0].y",
            "lseg->p[1].y"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_ps- segment is vertical\\n\""
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "lseg->p[0].x",
            "lseg->p[1].x"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"close_sp:pt->x %f pt->y %f\\nlseg(0).x %f lseg(0).y %f  lseg(1).x %f lseg(1).y %f\\n\"",
            "pt->x",
            "pt->y",
            "lseg->p[0].x",
            "lseg->p[0].y",
            "lseg->p[1].x",
            "lseg->p[1].y"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nclose_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result = NULL;\n\tLINE\t   *tmp;\n\tdouble\t\tinvm;\n\tint\t\t\txh,\n\t\t\t\tyh;\n\n#ifdef GEODEBUG\n\tprintf(\"close_sp:pt->x %f pt->y %f\\nlseg(0).x %f lseg(0).y %f  lseg(1).x %f lseg(1).y %f\\n\",\n\t\t   pt->x, pt->y, lseg->p[0].x, lseg->p[0].y,\n\t\t   lseg->p[1].x, lseg->p[1].y);\n#endif\n\n\t/* xh (or yh) is the index of upper x( or y) end point of lseg */\n\t/* !xh (or !yh) is the index of lower x( or y) end point of lseg */\n\txh = lseg->p[0].x < lseg->p[1].x;\n\tyh = lseg->p[0].y < lseg->p[1].y;\n\n\tif (FPeq(lseg->p[0].x, lseg->p[1].x))\t/* vertical? */\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps- segment is vertical\\n\");\n#endif\n\t\t/* first check if point is below or above the entire lseg. */\n\t\tif (pt->y < lseg->p[!yh].y)\n\t\t\tresult = point_copy(&lseg->p[!yh]); /* below the lseg */\n\t\telse if (pt->y > lseg->p[yh].y)\n\t\t\tresult = point_copy(&lseg->p[yh]);\t/* above the lseg */\n\t\tif (result != NULL)\n\t\t\tPG_RETURN_POINT_P(result);\n\n\t\t/* point lines along (to left or right) of the vertical lseg. */\n\n\t\tresult = (Point *) palloc(sizeof(Point));\n\t\tresult->x = lseg->p[0].x;\n\t\tresult->y = pt->y;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\telse if (FPeq(lseg->p[0].y, lseg->p[1].y))\t/* horizontal? */\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps- segment is horizontal\\n\");\n#endif\n\t\t/* first check if point is left or right of the entire lseg. */\n\t\tif (pt->x < lseg->p[!xh].x)\n\t\t\tresult = point_copy(&lseg->p[!xh]); /* left of the lseg */\n\t\telse if (pt->x > lseg->p[xh].x)\n\t\t\tresult = point_copy(&lseg->p[xh]);\t/* right of the lseg */\n\t\tif (result != NULL)\n\t\t\tPG_RETURN_POINT_P(result);\n\n\t\t/* point lines along (at top or below) the horiz. lseg. */\n\t\tresult = (Point *) palloc(sizeof(Point));\n\t\tresult->x = pt->x;\n\t\tresult->y = lseg->p[0].y;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\n\t/*\n\t * vert. and horiz. cases are down, now check if the closest point is one\n\t * of the end points or someplace on the lseg.\n\t */\n\n\tinvm = -1.0 / point_sl(&(lseg->p[0]), &(lseg->p[1]));\n\ttmp = line_construct_pm(&lseg->p[!yh], invm);\t/* lower edge of the\n\t\t\t\t\t\t\t\t\t\t\t\t\t * \"band\" */\n\tif (pt->y < (tmp->A * pt->x + tmp->C))\n\t{\t\t\t\t\t\t\t/* we are below the lower edge */\n\t\tresult = point_copy(&lseg->p[!yh]); /* below the lseg, take lower end\n\t\t\t\t\t\t\t\t\t\t\t * pt */\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps below: tmp A %f  B %f   C %f\\n\",\n\t\t\t   tmp->A, tmp->B, tmp->C);\n#endif\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\ttmp = line_construct_pm(&lseg->p[yh], invm);\t/* upper edge of the\n\t\t\t\t\t\t\t\t\t\t\t\t\t * \"band\" */\n\tif (pt->y > (tmp->A * pt->x + tmp->C))\n\t{\t\t\t\t\t\t\t/* we are below the lower edge */\n\t\tresult = point_copy(&lseg->p[yh]);\t/* above the lseg, take higher end\n\t\t\t\t\t\t\t\t\t\t\t * pt */\n#ifdef GEODEBUG\n\t\tprintf(\"close_ps above: tmp A %f  B %f   C %f\\n\",\n\t\t\t   tmp->A, tmp->B, tmp->C);\n#endif\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\n\t/*\n\t * at this point the \"normal\" from point will hit lseg. The closest point\n\t * will be somewhere on the lseg\n\t */\n\ttmp = line_construct_pm(pt, invm);\n#ifdef GEODEBUG\n\tprintf(\"close_ps- tmp A %f  B %f   C %f\\n\",\n\t\t   tmp->A, tmp->B, tmp->C);\n#endif\n\tresult = interpt_sl(lseg, tmp);\n\n\t/*\n\t * ordinarily we should always find an intersection point, but that could\n\t * fail in the presence of NaN coordinates, and perhaps even from simple\n\t * roundoff issues.  Return a SQL NULL if so.\n\t */\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\n#ifdef GEODEBUG\n\tprintf(\"close_ps- result.x %f  result.y %f\\n\", result->x, result->y);\n#endif\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "close_pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2712-2743",
    "snippet": "Datum\nclose_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\tPoint\t   *result;\n\tLINE\t   *tmp;\n\tdouble\t\tinvm;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tif (FPzero(line->B))\t\t/* vertical? */\n\t{\n\t\tresult->x = line->C;\n\t\tresult->y = pt->y;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\tif (FPzero(line->A))\t\t/* horizontal? */\n\t{\n\t\tresult->x = pt->x;\n\t\tresult->y = line->C;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\t/* drop a perpendicular and find the intersection point */\n\n\t/* invert and flip the sign on the slope to get a perpendicular */\n\tinvm = line->B / line->A;\n\ttmp = line_construct_pm(pt, invm);\n\tresult = line_interpt_internal(tmp, line);\n\tAssert(result != NULL);\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result != NULL"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_interpt_internal",
          "args": [
            "tmp",
            "line"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "line_interpt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1216-1257",
          "snippet": "static Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *point_construct(double x, double y);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "line_construct_pm",
          "args": [
            "pt",
            "invm"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1009-1030",
          "snippet": "static LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->A"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->B"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\tPoint\t   *result;\n\tLINE\t   *tmp;\n\tdouble\t\tinvm;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tif (FPzero(line->B))\t\t/* vertical? */\n\t{\n\t\tresult->x = line->C;\n\t\tresult->y = pt->y;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\tif (FPzero(line->A))\t\t/* horizontal? */\n\t{\n\t\tresult->x = pt->x;\n\t\tresult->y = line->C;\n\t\tPG_RETURN_POINT_P(result);\n\t}\n\t/* drop a perpendicular and find the intersection point */\n\n\t/* invert and flip the sign on the slope to get a perpendicular */\n\tinvm = line->B / line->A;\n\ttmp = line_construct_pm(pt, invm);\n\tresult = line_interpt_internal(tmp, line);\n\tAssert(result != NULL);\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "has_interpt_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2692-2701",
    "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "interpt_sl",
          "args": [
            "lseg",
            "line"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "interpt_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2659-2689",
    "snippet": "static Point *\ninterpt_sl(LSEG *lseg, LINE *line)\n{\n\tLINE\t\ttmp;\n\tPoint\t   *p;\n\n\tline_construct_pts(&tmp, &lseg->p[0], &lseg->p[1]);\n\tp = line_interpt_internal(&tmp, line);\n#ifdef GEODEBUG\n\tprintf(\"interpt_sl- segment is (%.*g %.*g) (%.*g %.*g)\\n\",\n\t\t   DBL_DIG, lseg->p[0].x, DBL_DIG, lseg->p[0].y, DBL_DIG, lseg->p[1].x, DBL_DIG, lseg->p[1].y);\n\tprintf(\"interpt_sl- segment becomes line A=%.*g B=%.*g C=%.*g\\n\",\n\t\t   DBL_DIG, tmp.A, DBL_DIG, tmp.B, DBL_DIG, tmp.C);\n#endif\n\tif (PointerIsValid(p))\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"interpt_sl- intersection point is (%.*g %.*g)\\n\", DBL_DIG, p->x, DBL_DIG, p->y);\n#endif\n\t\tif (on_ps_internal(p, lseg))\n\t\t{\n#ifdef GEODEBUG\n\t\t\tprintf(\"interpt_sl- intersection point is on segment\\n\");\n#endif\n\t\t}\n\t\telse\n\t\t\tp = NULL;\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"interpt_sl- intersection point is on segment\\n\""
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_ps_internal",
          "args": [
            "p",
            "lseg"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "on_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3152-3157",
          "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"interpt_sl- intersection point is (%.*g %.*g)\\n\"",
            "DBL_DIG",
            "p->x",
            "DBL_DIG",
            "p->y"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "p"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"interpt_sl- segment becomes line A=%.*g B=%.*g C=%.*g\\n\"",
            "DBL_DIG",
            "tmp.A",
            "DBL_DIG",
            "tmp.B",
            "DBL_DIG",
            "tmp.C"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"interpt_sl- segment is (%.*g %.*g) (%.*g %.*g)\\n\"",
            "DBL_DIG",
            "lseg->p[0].x",
            "DBL_DIG",
            "lseg->p[0].y",
            "DBL_DIG",
            "lseg->p[1].x",
            "DBL_DIG",
            "lseg->p[1].y"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_interpt_internal",
          "args": [
            "&tmp",
            "line"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "line_interpt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1216-1257",
          "snippet": "static Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *point_construct(double x, double y);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "line_construct_pts",
          "args": [
            "&tmp",
            "&lseg->p[0]",
            "&lseg->p[1]"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1035-1072",
          "snippet": "static void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic Point *\ninterpt_sl(LSEG *lseg, LINE *line)\n{\n\tLINE\t\ttmp;\n\tPoint\t   *p;\n\n\tline_construct_pts(&tmp, &lseg->p[0], &lseg->p[1]);\n\tp = line_interpt_internal(&tmp, line);\n#ifdef GEODEBUG\n\tprintf(\"interpt_sl- segment is (%.*g %.*g) (%.*g %.*g)\\n\",\n\t\t   DBL_DIG, lseg->p[0].x, DBL_DIG, lseg->p[0].y, DBL_DIG, lseg->p[1].x, DBL_DIG, lseg->p[1].y);\n\tprintf(\"interpt_sl- segment becomes line A=%.*g B=%.*g C=%.*g\\n\",\n\t\t   DBL_DIG, tmp.A, DBL_DIG, tmp.B, DBL_DIG, tmp.C);\n#endif\n\tif (PointerIsValid(p))\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"interpt_sl- intersection point is (%.*g %.*g)\\n\", DBL_DIG, p->x, DBL_DIG, p->y);\n#endif\n\t\tif (on_ps_internal(p, lseg))\n\t\t{\n#ifdef GEODEBUG\n\t\t\tprintf(\"interpt_sl- intersection point is on segment\\n\");\n#endif\n\t\t}\n\t\telse\n\t\t\tp = NULL;\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "dist_ppoly_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2606-2648",
    "snippet": "static double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dist_ppoly_internal- segment %d distance is %f\\n\"",
            "(i + 1)",
            "d"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ps_internal",
          "args": [
            "pt",
            "&seg"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2365-2416",
          "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dist_ppoly_internal- segment 0/n distance is %f\\n\"",
            "result"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dist_ppoly_internal- point inside of polygon\\n\""
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_inside",
          "args": [
            "pt",
            "poly->npts",
            "poly->p"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "point_inside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "5258-5304",
          "snippet": "static int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define POINT_ON_POLYGON INT_MAX"
          ],
          "globals_used": [
            "static int\tpoint_inside(Point *p, int npts, Point *plist);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define POINT_ON_POLYGON INT_MAX\n\nstatic int\tpoint_inside(Point *p, int npts, Point *plist);\nstatic Point *point_construct(double x, double y);\n\nstatic int\npoint_inside(Point *p, int npts, Point *plist)\n{\n\tdouble\t\tx0,\n\t\t\t\ty0;\n\tdouble\t\tprev_x,\n\t\t\t\tprev_y;\n\tint\t\t\ti = 0;\n\tdouble\t\tx,\n\t\t\t\ty;\n\tint\t\t\tcross,\n\t\t\t\ttotal_cross = 0;\n\n\tif (npts <= 0)\n\t\treturn 0;\n\n\t/* compute first polygon point relative to single point */\n\tx0 = plist[0].x - p->x;\n\ty0 = plist[0].y - p->y;\n\n\tprev_x = x0;\n\tprev_y = y0;\n\t/* loop over polygon points and aggregate total_cross */\n\tfor (i = 1; i < npts; i++)\n\t{\n\t\t/* compute next polygon point relative to single point */\n\t\tx = plist[i].x - p->x;\n\t\ty = plist[i].y - p->y;\n\n\t\t/* compute previous to current point crossing */\n\t\tif ((cross = lseg_crossing(x, y, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\t\treturn 2;\n\t\ttotal_cross += cross;\n\n\t\tprev_x = x;\n\t\tprev_y = y;\n\t}\n\n\t/* now do the first point */\n\tif ((cross = lseg_crossing(x0, y0, prev_x, prev_y)) == POINT_ON_POLYGON)\n\t\treturn 2;\n\ttotal_cross += cross;\n\n\tif (total_cross != 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "dist_polyp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2594-2604",
    "snippet": "Datum\ndist_polyp(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tfloat8\t\tresult;\n\n\tresult = dist_ppoly_internal(point, poly);\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ppoly_internal",
          "args": [
            "point",
            "poly"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ppoly_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2606-2648",
          "snippet": "static double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "0"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\ndist_polyp(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tfloat8\t\tresult;\n\n\tresult = dist_ppoly_internal(point, poly);\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_ppoly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2582-2592",
    "snippet": "Datum\ndist_ppoly(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *point = PG_GETARG_POINT_P(0);\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(1);\n\tfloat8\t\tresult;\n\n\tresult = dist_ppoly_internal(point, poly);\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ppoly_internal",
          "args": [
            "point",
            "poly"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ppoly_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2606-2648",
          "snippet": "static double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\ndist_ppoly(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *point = PG_GETARG_POINT_P(0);\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(1);\n\tfloat8\t\tresult;\n\n\tresult = dist_ppoly_internal(point, poly);\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_cpoly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2562-2577",
    "snippet": "Datum\ndist_cpoly(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(1);\n\tfloat8\t\tresult;\n\n\t/* calculate distance to center, and subtract radius */\n\tresult = dist_ppoly_internal(&circle->center, poly);\n\n\tresult -= circle->radius;\n\tif (result < 0)\n\t\tresult = 0;\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double circle_ar(CIRCLE *circle);",
      "static CIRCLE *circle_copy(CIRCLE *circle);",
      "static void make_bound_box(POLYGON *poly);",
      "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ppoly_internal",
          "args": [
            "&circle->center",
            "poly"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ppoly_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2606-2648",
          "snippet": "static double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_bound_box(POLYGON *poly);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ppoly_internal(Point *pt, POLYGON *poly);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void make_bound_box(POLYGON *poly);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nstatic double\ndist_ppoly_internal(Point *pt, POLYGON *poly)\n{\n\tfloat8\t\tresult;\n\tfloat8\t\td;\n\tint\t\t\ti;\n\tLSEG\t\tseg;\n\n\tif (point_inside(pt, poly->npts, poly->p) != 0)\n\t{\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- point inside of polygon\\n\");\n#endif\n\t\treturn 0.0;\n\t}\n\n\t/* initialize distance with segment between first and last points */\n\tseg.p[0].x = poly->p[0].x;\n\tseg.p[0].y = poly->p[0].y;\n\tseg.p[1].x = poly->p[poly->npts - 1].x;\n\tseg.p[1].y = poly->p[poly->npts - 1].y;\n\tresult = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\tprintf(\"dist_ppoly_internal- segment 0/n distance is %f\\n\", result);\n#endif\n\n\t/* check distances for other segments */\n\tfor (i = 0; (i < poly->npts - 1); i++)\n\t{\n\t\tseg.p[0].x = poly->p[i].x;\n\t\tseg.p[0].y = poly->p[i].y;\n\t\tseg.p[1].x = poly->p[i + 1].x;\n\t\tseg.p[1].y = poly->p[i + 1].y;\n\t\td = dist_ps_internal(pt, &seg);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ppoly_internal- segment %d distance is %f\\n\", (i + 1), d);\n#endif\n\t\tif (d < result)\n\t\t\tresult = d;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POLYGON_P",
          "args": [
            "1"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CIRCLE_P",
          "args": [
            "0"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double circle_ar(CIRCLE *circle);\nstatic CIRCLE *circle_copy(CIRCLE *circle);\nstatic void make_bound_box(POLYGON *poly);\nstatic double dist_ppoly_internal(Point *pt, POLYGON *poly);\n\nDatum\ndist_cpoly(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(1);\n\tfloat8\t\tresult;\n\n\t/* calculate distance to center, and subtract radius */\n\tresult = dist_ppoly_internal(&circle->center, poly);\n\n\tresult -= circle->radius;\n\tif (result < 0)\n\t\tresult = 0;\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_lb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2543-2557",
    "snippet": "Datum\ndist_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* need to think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"dist_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"dist_lb\\\" not implemented\"))"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"dist_lb\\\" not implemented\""
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\ndist_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* need to think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"dist_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "dist_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2522-2538",
    "snippet": "Datum\ndist_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tPoint\t   *tmp;\n\tDatum\t\tresult;\n\n\ttmp = DatumGetPointP(DirectFunctionCall2(close_sb,\n\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box)));\n\tresult = DirectFunctionCall2(dist_pb,\n\t\t\t\t\t\t\t\t PointPGetDatum(tmp),\n\t\t\t\t\t\t\t\t BoxPGetDatum(box));\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "dist_pb",
            "PointPGetDatum(tmp)",
            "BoxPGetDatum(box)"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "tmp"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(close_sb,\n\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box))"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_sb",
            "LsegPGetDatum(lseg)",
            "BoxPGetDatum(box)"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "lseg"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ndist_sb(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tPoint\t   *tmp;\n\tDatum\t\tresult;\n\n\ttmp = DatumGetPointP(DirectFunctionCall2(close_sb,\n\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(lseg),\n\t\t\t\t\t\t\t\t\t\t\t BoxPGetDatum(box)));\n\tresult = DirectFunctionCall2(dist_pb,\n\t\t\t\t\t\t\t\t PointPGetDatum(tmp),\n\t\t\t\t\t\t\t\t BoxPGetDatum(box));\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "dist_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2497-2517",
    "snippet": "Datum\ndist_sl(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\tfloat8\t\tresult,\n\t\t\t\td2;\n\n\tif (has_interpt_sl(lseg, line))\n\t\tresult = 0.0;\n\telse\n\t{\n\t\tresult = dist_pl_internal(&lseg->p[0], line);\n\t\td2 = dist_pl_internal(&lseg->p[1], line);\n\t\t/* XXX shouldn't we take the min not max? */\n\t\tif (d2 > result)\n\t\t\tresult = d2;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_pl_internal",
          "args": [
            "&lseg->p[1]",
            "line"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "dist_pl_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2346-2351",
          "snippet": "static double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_interpt_sl",
          "args": [
            "lseg",
            "line"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ndist_sl(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\tfloat8\t\tresult,\n\t\t\t\td2;\n\n\tif (has_interpt_sl(lseg, line))\n\t\tresult = 0.0;\n\telse\n\t{\n\t\tresult = dist_pl_internal(&lseg->p[0], line);\n\t\td2 = dist_pl_internal(&lseg->p[1], line);\n\t\t/* XXX shouldn't we take the min not max? */\n\t\tif (d2 > result)\n\t\t\tresult = d2;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_pb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2478-2492",
    "snippet": "Datum\ndist_pb(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tfloat8\t\tresult;\n\tPoint\t   *near;\n\n\tnear = DatumGetPointP(DirectFunctionCall2(close_pb,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\t\t  BoxPGetDatum(box)));\n\tresult = point_dt(near, pt);\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "near",
            "pt"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointP",
          "args": [
            "DirectFunctionCall2(close_pb,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\t\t  BoxPGetDatum(box))"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "close_pb",
            "PointPGetDatum(pt)",
            "BoxPGetDatum(box)"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoxPGetDatum",
          "args": [
            "box"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointPGetDatum",
          "args": [
            "pt"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\ndist_pb(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n\tfloat8\t\tresult;\n\tPoint\t   *near;\n\n\tnear = DatumGetPointP(DirectFunctionCall2(close_pb,\n\t\t\t\t\t\t\t\t\t\t\t  PointPGetDatum(pt),\n\t\t\t\t\t\t\t\t\t\t\t  BoxPGetDatum(box)));\n\tresult = point_dt(near, pt);\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_ppath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2421-2473",
    "snippet": "Datum\ndist_ppath(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tPATH\t   *path = PG_GETARG_PATH_P(1);\n\tfloat8\t\tresult = 0.0;\t/* keep compiler quiet */\n\tbool\t\thave_min = false;\n\tfloat8\t\ttmp;\n\tint\t\t\ti;\n\tLSEG\t\tlseg;\n\n\tswitch (path->npts)\n\t{\n\t\tcase 0:\n\t\t\t/* no points in path? then result is undefined... */\n\t\t\tPG_RETURN_NULL();\n\t\tcase 1:\n\t\t\t/* one point in path? then get distance between two points... */\n\t\t\tresult = point_dt(pt, &path->p[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure the path makes sense... */\n\t\t\tAssert(path->npts > 1);\n\n\t\t\t/*\n\t\t\t * the distance from a point to a path is the smallest distance\n\t\t\t * from the point to any of its constituent segments.\n\t\t\t */\n\t\t\tfor (i = 0; i < path->npts; i++)\n\t\t\t{\n\t\t\t\tint\t\t\tiprev;\n\n\t\t\t\tif (i > 0)\n\t\t\t\t\tiprev = i - 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!path->closed)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tiprev = path->npts - 1; /* include the closure segment */\n\t\t\t\t}\n\n\t\t\t\tstatlseg_construct(&lseg, &path->p[iprev], &path->p[i]);\n\t\t\t\ttmp = dist_ps_internal(pt, &lseg);\n\t\t\t\tif (!have_min || tmp < result)\n\t\t\t\t{\n\t\t\t\t\tresult = tmp;\n\t\t\t\t\thave_min = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ps_internal",
          "args": [
            "pt",
            "&lseg"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2365-2416",
          "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&lseg",
            "&path->p[iprev]",
            "&path->p[i]"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "path->npts > 1"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "pt",
            "&path->p[0]"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ndist_ppath(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tPATH\t   *path = PG_GETARG_PATH_P(1);\n\tfloat8\t\tresult = 0.0;\t/* keep compiler quiet */\n\tbool\t\thave_min = false;\n\tfloat8\t\ttmp;\n\tint\t\t\ti;\n\tLSEG\t\tlseg;\n\n\tswitch (path->npts)\n\t{\n\t\tcase 0:\n\t\t\t/* no points in path? then result is undefined... */\n\t\t\tPG_RETURN_NULL();\n\t\tcase 1:\n\t\t\t/* one point in path? then get distance between two points... */\n\t\t\tresult = point_dt(pt, &path->p[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure the path makes sense... */\n\t\t\tAssert(path->npts > 1);\n\n\t\t\t/*\n\t\t\t * the distance from a point to a path is the smallest distance\n\t\t\t * from the point to any of its constituent segments.\n\t\t\t */\n\t\t\tfor (i = 0; i < path->npts; i++)\n\t\t\t{\n\t\t\t\tint\t\t\tiprev;\n\n\t\t\t\tif (i > 0)\n\t\t\t\t\tiprev = i - 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!path->closed)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tiprev = path->npts - 1; /* include the closure segment */\n\t\t\t\t}\n\n\t\t\t\tstatlseg_construct(&lseg, &path->p[iprev], &path->p[i]);\n\t\t\t\ttmp = dist_ps_internal(pt, &lseg);\n\t\t\t\tif (!have_min || tmp < result)\n\t\t\t\t{\n\t\t\t\t\tresult = tmp;\n\t\t\t\t\thave_min = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "dist_ps_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2365-2416",
    "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LINE *line_construct_pm(Point *pt, double m);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "pt",
            "&lseg->p[1]"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\"",
            "result",
            "ip->x",
            "ip->y"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpt_sl",
          "args": [
            "lseg",
            "ln"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\"",
            "ln->A",
            "ln->B",
            "ln->C",
            "pt->x",
            "pt->y",
            "m"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_construct_pm",
          "args": [
            "pt",
            "m"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1009-1030",
          "snippet": "static LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "dist_ps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2356-2363",
    "snippet": "Datum\ndist_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_FLOAT8(dist_ps_internal(pt, lseg));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "dist_ps_internal(pt, lseg)"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ps_internal",
          "args": [
            "pt",
            "lseg"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2365-2416",
          "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\ndist_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_FLOAT8(dist_ps_internal(pt, lseg));\n}"
  },
  {
    "function_name": "dist_pl_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2346-2351",
    "snippet": "static double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "(line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B)"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "line->A",
            "line->B"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}"
  },
  {
    "function_name": "dist_pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2337-2344",
    "snippet": "Datum\ndist_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_FLOAT8(dist_pl_internal(pt, line));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "dist_pl_internal(pt, line)"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_pl_internal",
          "args": [
            "pt",
            "line"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "dist_pl_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2346-2351",
          "snippet": "static double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\ndist_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_FLOAT8(dist_pl_internal(pt, line));\n}"
  },
  {
    "function_name": "lseg_interpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2308-2320",
    "snippet": "Datum\nlseg_interpt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result;\n\n\tresult = lseg_interpt_internal(l1, l2);\n\tif (!PointerIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "result"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_interpt_internal",
          "args": [
            "l1",
            "l2"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_interpt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2257-2303",
          "snippet": "static Point *\nlseg_interpt_internal(LSEG *l1, LSEG *l2)\n{\n\tPoint\t   *result;\n\tLINE\t\ttmp1,\n\t\t\t\ttmp2;\n\n\t/*\n\t * Find the intersection of the appropriate lines, if any.\n\t */\n\tline_construct_pts(&tmp1, &l1->p[0], &l1->p[1]);\n\tline_construct_pts(&tmp2, &l2->p[0], &l2->p[1]);\n\tresult = line_interpt_internal(&tmp1, &tmp2);\n\tif (!PointerIsValid(result))\n\t\treturn NULL;\n\n\t/*\n\t * If the line intersection point isn't within l1 (or equivalently l2),\n\t * there is no valid segment intersection point at all.\n\t */\n\tif (!on_ps_internal(result, l1) ||\n\t\t!on_ps_internal(result, l2))\n\t{\n\t\tpfree(result);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If there is an intersection, then check explicitly for matching\n\t * endpoints since there may be rounding effects with annoying lsb\n\t * residue. - tgl 1997-07-09\n\t */\n\tif ((FPeq(l1->p[0].x, l2->p[0].x) && FPeq(l1->p[0].y, l2->p[0].y)) ||\n\t\t(FPeq(l1->p[0].x, l2->p[1].x) && FPeq(l1->p[0].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[0].x;\n\t\tresult->y = l1->p[0].y;\n\t}\n\telse if ((FPeq(l1->p[1].x, l2->p[0].x) && FPeq(l1->p[1].y, l2->p[0].y)) ||\n\t\t\t (FPeq(l1->p[1].x, l2->p[1].x) && FPeq(l1->p[1].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[1].x;\n\t\tresult->y = l1->p[1].y;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *point_construct(double x, double y);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nlseg_interpt_internal(LSEG *l1, LSEG *l2)\n{\n\tPoint\t   *result;\n\tLINE\t\ttmp1,\n\t\t\t\ttmp2;\n\n\t/*\n\t * Find the intersection of the appropriate lines, if any.\n\t */\n\tline_construct_pts(&tmp1, &l1->p[0], &l1->p[1]);\n\tline_construct_pts(&tmp2, &l2->p[0], &l2->p[1]);\n\tresult = line_interpt_internal(&tmp1, &tmp2);\n\tif (!PointerIsValid(result))\n\t\treturn NULL;\n\n\t/*\n\t * If the line intersection point isn't within l1 (or equivalently l2),\n\t * there is no valid segment intersection point at all.\n\t */\n\tif (!on_ps_internal(result, l1) ||\n\t\t!on_ps_internal(result, l2))\n\t{\n\t\tpfree(result);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If there is an intersection, then check explicitly for matching\n\t * endpoints since there may be rounding effects with annoying lsb\n\t * residue. - tgl 1997-07-09\n\t */\n\tif ((FPeq(l1->p[0].x, l2->p[0].x) && FPeq(l1->p[0].y, l2->p[0].y)) ||\n\t\t(FPeq(l1->p[0].x, l2->p[1].x) && FPeq(l1->p[0].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[0].x;\n\t\tresult->y = l1->p[0].y;\n\t}\n\telse if ((FPeq(l1->p[1].x, l2->p[0].x) && FPeq(l1->p[1].y, l2->p[0].y)) ||\n\t\t\t (FPeq(l1->p[1].x, l2->p[1].x) && FPeq(l1->p[1].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[1].x;\n\t\tresult->y = l1->p[1].y;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_interpt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result;\n\n\tresult = lseg_interpt_internal(l1, l2);\n\tif (!PointerIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "lseg_interpt_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2257-2303",
    "snippet": "static Point *\nlseg_interpt_internal(LSEG *l1, LSEG *l2)\n{\n\tPoint\t   *result;\n\tLINE\t\ttmp1,\n\t\t\t\ttmp2;\n\n\t/*\n\t * Find the intersection of the appropriate lines, if any.\n\t */\n\tline_construct_pts(&tmp1, &l1->p[0], &l1->p[1]);\n\tline_construct_pts(&tmp2, &l2->p[0], &l2->p[1]);\n\tresult = line_interpt_internal(&tmp1, &tmp2);\n\tif (!PointerIsValid(result))\n\t\treturn NULL;\n\n\t/*\n\t * If the line intersection point isn't within l1 (or equivalently l2),\n\t * there is no valid segment intersection point at all.\n\t */\n\tif (!on_ps_internal(result, l1) ||\n\t\t!on_ps_internal(result, l2))\n\t{\n\t\tpfree(result);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If there is an intersection, then check explicitly for matching\n\t * endpoints since there may be rounding effects with annoying lsb\n\t * residue. - tgl 1997-07-09\n\t */\n\tif ((FPeq(l1->p[0].x, l2->p[0].x) && FPeq(l1->p[0].y, l2->p[0].y)) ||\n\t\t(FPeq(l1->p[0].x, l2->p[1].x) && FPeq(l1->p[0].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[0].x;\n\t\tresult->y = l1->p[0].y;\n\t}\n\telse if ((FPeq(l1->p[1].x, l2->p[0].x) && FPeq(l1->p[1].y, l2->p[0].y)) ||\n\t\t\t (FPeq(l1->p[1].x, l2->p[1].x) && FPeq(l1->p[1].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[1].x;\n\t\tresult->y = l1->p[1].y;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *point_construct(double x, double y);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].y",
            "l2->p[1].y"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].x",
            "l2->p[1].x"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].y",
            "l2->p[0].y"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].x",
            "l2->p[0].x"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].y",
            "l2->p[1].y"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].x",
            "l2->p[1].x"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].y",
            "l2->p[0].y"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].x",
            "l2->p[0].x"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "result"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_ps_internal",
          "args": [
            "result",
            "l2"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "on_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3152-3157",
          "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "result"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_interpt_internal",
          "args": [
            "&tmp1",
            "&tmp2"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "line_interpt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1216-1257",
          "snippet": "static Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *point_construct(double x, double y);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "line_construct_pts",
          "args": [
            "&tmp2",
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1035-1072",
          "snippet": "static void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nlseg_interpt_internal(LSEG *l1, LSEG *l2)\n{\n\tPoint\t   *result;\n\tLINE\t\ttmp1,\n\t\t\t\ttmp2;\n\n\t/*\n\t * Find the intersection of the appropriate lines, if any.\n\t */\n\tline_construct_pts(&tmp1, &l1->p[0], &l1->p[1]);\n\tline_construct_pts(&tmp2, &l2->p[0], &l2->p[1]);\n\tresult = line_interpt_internal(&tmp1, &tmp2);\n\tif (!PointerIsValid(result))\n\t\treturn NULL;\n\n\t/*\n\t * If the line intersection point isn't within l1 (or equivalently l2),\n\t * there is no valid segment intersection point at all.\n\t */\n\tif (!on_ps_internal(result, l1) ||\n\t\t!on_ps_internal(result, l2))\n\t{\n\t\tpfree(result);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If there is an intersection, then check explicitly for matching\n\t * endpoints since there may be rounding effects with annoying lsb\n\t * residue. - tgl 1997-07-09\n\t */\n\tif ((FPeq(l1->p[0].x, l2->p[0].x) && FPeq(l1->p[0].y, l2->p[0].y)) ||\n\t\t(FPeq(l1->p[0].x, l2->p[1].x) && FPeq(l1->p[0].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[0].x;\n\t\tresult->y = l1->p[0].y;\n\t}\n\telse if ((FPeq(l1->p[1].x, l2->p[0].x) && FPeq(l1->p[1].y, l2->p[0].y)) ||\n\t\t\t (FPeq(l1->p[1].x, l2->p[1].x) && FPeq(l1->p[1].y, l2->p[1].y)))\n\t{\n\t\tresult->x = l1->p[1].x;\n\t\tresult->y = l1->p[1].y;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "lseg_center",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2243-2255",
    "snippet": "Datum\nlseg_center(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (lseg->p[0].x + lseg->p[1].x) / 2.0;\n\tresult->y = (lseg->p[0].y + lseg->p[1].y) / 2.0;\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nlseg_center(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (lseg->p[0].x + lseg->p[1].x) / 2.0;\n\tresult->y = (lseg->p[0].y + lseg->p[1].y) / 2.0;\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "lseg_dt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2221-2240",
    "snippet": "static double\nlseg_dt(LSEG *l1, LSEG *l2)\n{\n\tdouble\t\tresult,\n\t\t\t\td;\n\n\tif (lseg_intersect_internal(l1, l2))\n\t\treturn 0.0;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tresult = d;\n\td = dist_ps_internal(&l1->p[1], l2);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[0], l1);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[1], l1);\n\tresult = Min(result, d);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "result",
            "d"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_ps_internal",
          "args": [
            "&l2->p[1]",
            "l1"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "dist_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2365-2416",
          "snippet": "static double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LINE *line_construct_pm(Point *pt, double m);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic double\ndist_ps_internal(Point *pt, LSEG *lseg)\n{\n\tdouble\t\tm;\t\t\t\t/* slope of perp. */\n\tLINE\t   *ln;\n\tdouble\t\tresult,\n\t\t\t\ttmpdist;\n\tPoint\t   *ip;\n\n\t/*\n\t * Construct a line perpendicular to the input segment and through the\n\t * input point\n\t */\n\tif (lseg->p[1].x == lseg->p[0].x)\n\t\tm = 0;\n\telse if (lseg->p[1].y == lseg->p[0].y)\n\t\tm = (double) DBL_MAX;\t/* slope is infinite */\n\telse\n\t\tm = (lseg->p[0].x - lseg->p[1].x) / (lseg->p[1].y - lseg->p[0].y);\n\tln = line_construct_pm(pt, m);\n\n#ifdef GEODEBUG\n\tprintf(\"dist_ps- line is A=%g B=%g C=%g from (point) slope (%f,%f) %g\\n\",\n\t\t   ln->A, ln->B, ln->C, pt->x, pt->y, m);\n#endif\n\n\t/*\n\t * Calculate distance to the line segment or to the nearest endpoint of\n\t * the segment.\n\t */\n\n\t/* intersection is on the line segment? */\n\tif ((ip = interpt_sl(lseg, ln)) != NULL)\n\t{\n\t\t/* yes, so use distance to the intersection point */\n\t\tresult = point_dt(pt, ip);\n#ifdef GEODEBUG\n\t\tprintf(\"dist_ps- distance is %f to intersection point is (%f,%f)\\n\",\n\t\t\t   result, ip->x, ip->y);\n#endif\n\t}\n\telse\n\t{\n\t\t/* no, so use distance to the nearer endpoint */\n\t\tresult = point_dt(pt, &lseg->p[0]);\n\t\ttmpdist = point_dt(pt, &lseg->p[1]);\n\t\tif (tmpdist < result)\n\t\t\tresult = tmpdist;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "result",
            "d"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "result",
            "d"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_intersect_internal",
          "args": [
            "l1",
            "l2"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_intersect_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2058-2073",
          "snippet": "static bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic double\nlseg_dt(LSEG *l1, LSEG *l2)\n{\n\tdouble\t\tresult,\n\t\t\t\td;\n\n\tif (lseg_intersect_internal(l1, l2))\n\t\treturn 0.0;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tresult = d;\n\td = dist_ps_internal(&l1->p[1], l2);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[0], l1);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[1], l1);\n\tresult = Min(result, d);\n\n\treturn result;\n}"
  },
  {
    "function_name": "lseg_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2207-2214",
    "snippet": "Datum\nlseg_distance(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_FLOAT8(lseg_dt(l1, l2));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "lseg_dt(l1, l2)"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_dt",
          "args": [
            "l1",
            "l2"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2221-2240",
          "snippet": "static double\nlseg_dt(LSEG *l1, LSEG *l2)\n{\n\tdouble\t\tresult,\n\t\t\t\td;\n\n\tif (lseg_intersect_internal(l1, l2))\n\t\treturn 0.0;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tresult = d;\n\td = dist_ps_internal(&l1->p[1], l2);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[0], l1);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[1], l1);\n\tresult = Min(result, d);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic double\nlseg_dt(LSEG *l1, LSEG *l2)\n{\n\tdouble\t\tresult,\n\t\t\t\td;\n\n\tif (lseg_intersect_internal(l1, l2))\n\t\treturn 0.0;\n\n\td = dist_ps_internal(&l1->p[0], l2);\n\tresult = d;\n\td = dist_ps_internal(&l1->p[1], l2);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[0], l1);\n\tresult = Min(result, d);\n\td = dist_ps_internal(&l2->p[1], l1);\n\tresult = Min(result, d);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_distance(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_FLOAT8(lseg_dt(l1, l2));\n}"
  },
  {
    "function_name": "lseg_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2187-2195",
    "snippet": "Datum\nlseg_ge(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPge(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1]))"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "point_dt(&l1->p[0], &l1->p[1])",
            "point_dt(&l2->p[0], &l2->p[1])"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_ge(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPge(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}"
  },
  {
    "function_name": "lseg_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2177-2185",
    "snippet": "Datum\nlseg_gt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPgt(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1]))"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "point_dt(&l1->p[0], &l1->p[1])",
            "point_dt(&l2->p[0], &l2->p[1])"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_gt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPgt(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}"
  },
  {
    "function_name": "lseg_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2167-2175",
    "snippet": "Datum\nlseg_le(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPle(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1]))"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "point_dt(&l1->p[0], &l1->p[1])",
            "point_dt(&l2->p[0], &l2->p[1])"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_le(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPle(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}"
  },
  {
    "function_name": "lseg_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2157-2165",
    "snippet": "Datum\nlseg_lt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPlt(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1]))"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "point_dt(&l1->p[0], &l1->p[1])",
            "point_dt(&l2->p[0], &l2->p[1])"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_lt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPlt(point_dt(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_dt(&l2->p[0], &l2->p[1])));\n}"
  },
  {
    "function_name": "lseg_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2145-2155",
    "snippet": "Datum\nlseg_ne(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(!FPeq(l1->p[0].x, l2->p[0].x) ||\n\t\t\t\t   !FPeq(l1->p[0].y, l2->p[0].y) ||\n\t\t\t\t   !FPeq(l1->p[1].x, l2->p[1].x) ||\n\t\t\t\t   !FPeq(l1->p[1].y, l2->p[1].y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *point_construct(double x, double y);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!FPeq(l1->p[0].x, l2->p[0].x) ||\n\t\t\t\t   !FPeq(l1->p[0].y, l2->p[0].y) ||\n\t\t\t\t   !FPeq(l1->p[1].x, l2->p[1].x) ||\n\t\t\t\t   !FPeq(l1->p[1].y, l2->p[1].y)"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].y",
            "l2->p[1].y"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].x",
            "l2->p[1].x"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].y",
            "l2->p[0].y"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].x",
            "l2->p[0].x"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_ne(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(!FPeq(l1->p[0].x, l2->p[0].x) ||\n\t\t\t\t   !FPeq(l1->p[0].y, l2->p[0].y) ||\n\t\t\t\t   !FPeq(l1->p[1].x, l2->p[1].x) ||\n\t\t\t\t   !FPeq(l1->p[1].y, l2->p[1].y));\n}"
  },
  {
    "function_name": "lseg_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2133-2143",
    "snippet": "Datum\nlseg_eq(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPeq(l1->p[0].x, l2->p[0].x) &&\n\t\t\t\t   FPeq(l1->p[0].y, l2->p[0].y) &&\n\t\t\t\t   FPeq(l1->p[1].x, l2->p[1].x) &&\n\t\t\t\t   FPeq(l1->p[1].y, l2->p[1].y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *point_construct(double x, double y);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(l1->p[0].x, l2->p[0].x) &&\n\t\t\t\t   FPeq(l1->p[0].y, l2->p[0].y) &&\n\t\t\t\t   FPeq(l1->p[1].x, l2->p[1].x) &&\n\t\t\t\t   FPeq(l1->p[1].y, l2->p[1].y)"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].y",
            "l2->p[1].y"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[1].x",
            "l2->p[1].x"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].y",
            "l2->p[0].y"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->p[0].x",
            "l2->p[0].x"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_eq(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPeq(l1->p[0].x, l2->p[0].x) &&\n\t\t\t\t   FPeq(l1->p[0].y, l2->p[0].y) &&\n\t\t\t\t   FPeq(l1->p[1].x, l2->p[1].x) &&\n\t\t\t\t   FPeq(l1->p[1].y, l2->p[1].y));\n}"
  },
  {
    "function_name": "lseg_horizontal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2124-2130",
    "snippet": "Datum\nlseg_horizontal(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_BOOL(FPeq(lseg->p[0].y, lseg->p[1].y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(lseg->p[0].y, lseg->p[1].y)"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "lseg->p[0].y",
            "lseg->p[1].y"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nlseg_horizontal(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_BOOL(FPeq(lseg->p[0].y, lseg->p[1].y));\n}"
  },
  {
    "function_name": "lseg_vertical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2116-2122",
    "snippet": "Datum\nlseg_vertical(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_BOOL(FPeq(lseg->p[0].x, lseg->p[1].x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(lseg->p[0].x, lseg->p[1].x)"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "lseg->p[0].x",
            "lseg->p[1].x"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nlseg_vertical(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_BOOL(FPeq(lseg->p[0].x, lseg->p[1].x));\n}"
  },
  {
    "function_name": "lseg_perp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2094-2114",
    "snippet": "Datum\nlseg_perp(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tdouble\t\tm1,\n\t\t\t\tm2;\n\n\tm1 = point_sl(&(l1->p[0]), &(l1->p[1]));\n\tm2 = point_sl(&(l2->p[0]), &(l2->p[1]));\n\n#ifdef GEODEBUG\n\tprintf(\"lseg_perp- slopes are %g and %g\\n\", m1, m2);\n#endif\n\tif (FPzero(m1))\n\t\tPG_RETURN_BOOL(FPeq(m2, DBL_MAX));\n\telse if (FPzero(m2))\n\t\tPG_RETURN_BOOL(FPeq(m1, DBL_MAX));\n\n\tPG_RETURN_BOOL(FPeq(m1 / m2, -1.0));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(m1 / m2, -1.0)"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "m1 / m2",
            "-1.0"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(m1, DBL_MAX)"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "m1",
            "DBL_MAX"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "m2"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(m2, DBL_MAX)"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "m2",
            "DBL_MAX"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "m1"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"lseg_perp- slopes are %g and %g\\n\"",
            "m1",
            "m2"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_sl",
          "args": [
            "&(l2->p[0])",
            "&(l2->p[1])"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "point_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1924-1930",
          "snippet": "double\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_perp(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tdouble\t\tm1,\n\t\t\t\tm2;\n\n\tm1 = point_sl(&(l1->p[0]), &(l1->p[1]));\n\tm2 = point_sl(&(l2->p[0]), &(l2->p[1]));\n\n#ifdef GEODEBUG\n\tprintf(\"lseg_perp- slopes are %g and %g\\n\", m1, m2);\n#endif\n\tif (FPzero(m1))\n\t\tPG_RETURN_BOOL(FPeq(m2, DBL_MAX));\n\telse if (FPzero(m2))\n\t\tPG_RETURN_BOOL(FPeq(m1, DBL_MAX));\n\n\tPG_RETURN_BOOL(FPeq(m1 / m2, -1.0));\n}"
  },
  {
    "function_name": "lseg_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2075-2083",
    "snippet": "Datum\nlseg_parallel(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPeq(point_sl(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_sl(&l2->p[0], &l2->p[1])));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(point_sl(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_sl(&l2->p[0], &l2->p[1]))"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "point_sl(&l1->p[0], &l1->p[1])",
            "point_sl(&l2->p[0], &l2->p[1])"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_sl",
          "args": [
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "point_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1924-1930",
          "snippet": "double\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_parallel(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(FPeq(point_sl(&l1->p[0], &l1->p[1]),\n\t\t\t\t\t\tpoint_sl(&l2->p[0], &l2->p[1])));\n}"
  },
  {
    "function_name": "lseg_intersect_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2058-2073",
    "snippet": "static bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_ps_internal",
          "args": [
            "interpt",
            "l2"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "on_ps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3152-3157",
          "snippet": "static bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\non_ps_internal(Point *pt, LSEG *lseg)\n{\n\treturn FPeq(point_dt(pt, &lseg->p[0]) + point_dt(pt, &lseg->p[1]),\n\t\t\t\tpoint_dt(&lseg->p[0], &lseg->p[1]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "interpt_sl",
          "args": [
            "l1",
            "&ln"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "has_interpt_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2692-2701",
          "snippet": "static bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic bool\nhas_interpt_sl(LSEG *lseg, LINE *line)\n{\n\tPoint\t   *tmp;\n\n\ttmp = interpt_sl(lseg, line);\n\tif (tmp)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "line_construct_pts",
          "args": [
            "&ln",
            "&l2->p[0]",
            "&l2->p[1]"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1035-1072",
          "snippet": "static void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}"
  },
  {
    "function_name": "lseg_intersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2049-2056",
    "snippet": "Datum\nlseg_intersect(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(lseg_intersect_internal(l1, l2));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "lseg_intersect_internal(l1, l2)"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_intersect_internal",
          "args": [
            "l1",
            "l2"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_intersect_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2058-2073",
          "snippet": "static bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "1"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nlseg_intersect(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_BOOL(lseg_intersect_internal(l1, l2));\n}"
  },
  {
    "function_name": "lseg_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2033-2039",
    "snippet": "Datum\nlseg_length(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_FLOAT8(point_dt(&lseg->p[0], &lseg->p[1]));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "point_dt(&lseg->p[0], &lseg->p[1])"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&lseg->p[0]",
            "&lseg->p[1]"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nlseg_length(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_FLOAT8(point_dt(&lseg->p[0], &lseg->p[1]));\n}"
  },
  {
    "function_name": "statlseg_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2024-2031",
    "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
  },
  {
    "function_name": "lseg_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "2008-2021",
    "snippet": "Datum\nlseg_construct(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\tLSEG\t   *result = (LSEG *) palloc(sizeof(LSEG));\n\n\tresult->p[0].x = pt1->x;\n\tresult->p[0].y = pt1->y;\n\tresult->p[1].x = pt2->x;\n\tresult->p[1].y = pt2->y;\n\n\tPG_RETURN_LSEG_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LSEG_P",
          "args": [
            "result"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LSEG)"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\nlseg_construct(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\tLSEG\t   *result = (LSEG *) palloc(sizeof(LSEG));\n\n\tresult->p[0].x = pt1->x;\n\tresult->p[0].y = pt1->y;\n\tresult->p[1].x = pt2->x;\n\tresult->p[1].y = pt2->y;\n\n\tPG_RETURN_LSEG_P(result);\n}"
  },
  {
    "function_name": "lseg_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1990-2002",
    "snippet": "Datum\nlseg_send(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *ls = PG_GETARG_LSEG_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, ls->p[0].x);\n\tpq_sendfloat8(&buf, ls->p[0].y);\n\tpq_sendfloat8(&buf, ls->p[1].x);\n\tpq_sendfloat8(&buf, ls->p[1].y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "ls->p[1].y"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "ls->p[1].x"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "ls->p[0].y"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "ls->p[0].x"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\nlseg_send(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *ls = PG_GETARG_LSEG_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, ls->p[0].x);\n\tpq_sendfloat8(&buf, ls->p[0].y);\n\tpq_sendfloat8(&buf, ls->p[1].x);\n\tpq_sendfloat8(&buf, ls->p[1].y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "lseg_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1971-1985",
    "snippet": "Datum\nlseg_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tLSEG\t   *lseg;\n\n\tlseg = (LSEG *) palloc(sizeof(LSEG));\n\n\tlseg->p[0].x = pq_getmsgfloat8(buf);\n\tlseg->p[0].y = pq_getmsgfloat8(buf);\n\tlseg->p[1].x = pq_getmsgfloat8(buf);\n\tlseg->p[1].y = pq_getmsgfloat8(buf);\n\n\tPG_RETURN_LSEG_P(lseg);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LSEG_P",
          "args": [
            "lseg"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LSEG)"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nlseg_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tLSEG\t   *lseg;\n\n\tlseg = (LSEG *) palloc(sizeof(LSEG));\n\n\tlseg->p[0].x = pq_getmsgfloat8(buf);\n\tlseg->p[0].y = pq_getmsgfloat8(buf);\n\tlseg->p[1].x = pq_getmsgfloat8(buf);\n\tlseg->p[1].y = pq_getmsgfloat8(buf);\n\n\tPG_RETURN_LSEG_P(lseg);\n}"
  },
  {
    "function_name": "lseg_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1960-1966",
    "snippet": "Datum\nlseg_out(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *ls = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_OPEN, 2, (Point *) &(ls->p[0])));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "path_encode(PATH_OPEN, 2, (Point *) &(ls->p[0]))"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_encode",
          "args": [
            "PATH_OPEN",
            "2",
            "(Point *) &(ls->p[0])"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "path_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "268-311",
          "snippet": "static char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LSEG_P",
          "args": [
            "0"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\nlseg_out(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *ls = PG_GETARG_LSEG_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_OPEN, 2, (Point *) &(ls->p[0])));\n}"
  },
  {
    "function_name": "lseg_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1948-1957",
    "snippet": "Datum\nlseg_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tLSEG\t   *lseg = (LSEG *) palloc(sizeof(LSEG));\n\tbool\t\tisopen;\n\n\tpath_decode(str, true, 2, &(lseg->p[0]), &isopen, NULL, \"lseg\", str);\n\tPG_RETURN_LSEG_P(lseg);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LSEG_P",
          "args": [
            "lseg"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_decode",
          "args": [
            "str",
            "true",
            "2",
            "&(lseg->p[0])",
            "&isopen",
            "NULL",
            "\"lseg\"",
            "str"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "path_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "192-266",
          "snippet": "static void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LSEG)"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nlseg_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tLSEG\t   *lseg = (LSEG *) palloc(sizeof(LSEG));\n\tbool\t\tisopen;\n\n\tpath_decode(str, true, 2, &(lseg->p[0]), &isopen, NULL, \"lseg\", str);\n\tPG_RETURN_LSEG_P(lseg);\n}"
  },
  {
    "function_name": "point_sl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1924-1930",
    "snippet": "double\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}"
  },
  {
    "function_name": "point_slope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1914-1921",
    "snippet": "Datum\npoint_slope(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_FLOAT8(point_sl(pt1, pt2));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "point_sl(pt1, pt2)"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_sl",
          "args": [
            "pt1",
            "pt2"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "point_sl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1924-1930",
          "snippet": "double\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_sl(Point *pt1, Point *pt2)\n{\n\treturn (FPeq(pt1->x, pt2->x)\n\t\t\t? (double) DBL_MAX\n\t\t\t: (pt1->y - pt2->y) / (pt1->x - pt2->x));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_slope(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_FLOAT8(point_sl(pt1, pt2));\n}"
  },
  {
    "function_name": "point_dt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1904-1912",
    "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "pt1->x - pt2->x",
            "pt1->y - pt2->y"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\"",
            "pt1->x",
            "pt1->y",
            "pt2->x",
            "pt2->y",
            "HYPOT(pt1->x - pt2->x, pt1->y - pt2->y)"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "pt1->x - pt2->x",
            "pt1->y - pt2->y"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
  },
  {
    "function_name": "point_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1895-1902",
    "snippet": "Datum\npoint_distance(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_FLOAT8(HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "HYPOT(pt1->x - pt2->x, pt1->y - pt2->y)"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "pt1->x - pt2->x",
            "pt1->y - pt2->y"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_distance(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_FLOAT8(HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n}"
  },
  {
    "function_name": "point_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1882-1889",
    "snippet": "Datum\npoint_ne(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPne(pt1->x, pt2->x) || FPne(pt1->y, pt2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPne(pt1->x, pt2->x) || FPne(pt1->y, pt2->y)"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPne",
          "args": [
            "pt1->y",
            "pt2->y"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPne",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_ne(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPne(pt1->x, pt2->x) || FPne(pt1->y, pt2->y));\n}"
  },
  {
    "function_name": "point_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1873-1880",
    "snippet": "Datum\npoint_eq(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPeq(pt1->x, pt2->x) && FPeq(pt1->y, pt2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(pt1->x, pt2->x) && FPeq(pt1->y, pt2->y)"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->y",
            "pt2->y"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_eq(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPeq(pt1->x, pt2->x) && FPeq(pt1->y, pt2->y));\n}"
  },
  {
    "function_name": "point_horiz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1864-1871",
    "snippet": "Datum\npoint_horiz(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPeq(pt1->y, pt2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(pt1->y, pt2->y)"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->y",
            "pt2->y"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_horiz(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPeq(pt1->y, pt2->y));\n}"
  },
  {
    "function_name": "point_vert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1855-1862",
    "snippet": "Datum\npoint_vert(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPeq(pt1->x, pt2->x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(pt1->x, pt2->x)"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_vert(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPeq(pt1->x, pt2->x));\n}"
  },
  {
    "function_name": "point_below",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1846-1853",
    "snippet": "Datum\npoint_below(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPlt(pt1->y, pt2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(pt1->y, pt2->y)"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "pt1->y",
            "pt2->y"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_below(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPlt(pt1->y, pt2->y));\n}"
  },
  {
    "function_name": "point_above",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1837-1844",
    "snippet": "Datum\npoint_above(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPgt(pt1->y, pt2->y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(pt1->y, pt2->y)"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "pt1->y",
            "pt2->y"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_above(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPgt(pt1->y, pt2->y));\n}"
  },
  {
    "function_name": "point_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1828-1835",
    "snippet": "Datum\npoint_right(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPgt(pt1->x, pt2->x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(pt1->x, pt2->x)"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_right(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPgt(pt1->x, pt2->x));\n}"
  },
  {
    "function_name": "point_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1819-1826",
    "snippet": "Datum\npoint_left(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPlt(pt1->x, pt2->x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(pt1->x, pt2->x)"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\npoint_left(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\n\tPG_RETURN_BOOL(FPlt(pt1->x, pt2->x));\n}"
  },
  {
    "function_name": "point_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1794-1807",
    "snippet": "static Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "pt"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic Point *\npoint_copy(Point *pt)\n{\n\tPoint\t   *result;\n\n\tif (!PointerIsValid(pt))\n\t\treturn NULL;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = pt->x;\n\tresult->y = pt->y;\n\treturn result;\n}"
  },
  {
    "function_name": "point_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1783-1791",
    "snippet": "static Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nstatic Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}"
  },
  {
    "function_name": "point_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1770-1780",
    "snippet": "Datum\npoint_send(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, pt->x);\n\tpq_sendfloat8(&buf, pt->y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "pt->y"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "pt->x"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nDatum\npoint_send(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, pt->x);\n\tpq_sendfloat8(&buf, pt->y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "point_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1755-1765",
    "snippet": "Datum\npoint_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tPoint\t   *point;\n\n\tpoint = (Point *) palloc(sizeof(Point));\n\tpoint->x = pq_getmsgfloat8(buf);\n\tpoint->y = pq_getmsgfloat8(buf);\n\tPG_RETURN_POINT_P(point);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "point"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npoint_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tPoint\t   *point;\n\n\tpoint = (Point *) palloc(sizeof(Point));\n\tpoint->x = pq_getmsgfloat8(buf);\n\tpoint->y = pq_getmsgfloat8(buf);\n\tPG_RETURN_POINT_P(point);\n}"
  },
  {
    "function_name": "point_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1744-1750",
    "snippet": "Datum\npoint_out(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_NONE, 1, pt));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "path_encode(PATH_NONE, 1, pt)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_encode",
          "args": [
            "PATH_NONE",
            "1",
            "pt"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "path_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "268-311",
          "snippet": "static char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nDatum\npoint_out(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_NONE, 1, pt));\n}"
  },
  {
    "function_name": "point_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1734-1742",
    "snippet": "Datum\npoint_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPoint\t   *point = (Point *) palloc(sizeof(Point));\n\n\tpair_decode(str, &point->x, &point->y, NULL, \"point\", str);\n\tPG_RETURN_POINT_P(point);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "point"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_decode",
          "args": [
            "str",
            "&point->x",
            "&point->y",
            "NULL",
            "\"point\"",
            "str"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "pair_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "139-179",
          "snippet": "static void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nDatum\npoint_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPoint\t   *point = (Point *) palloc(sizeof(Point));\n\n\tpair_decode(str, &point->x, &point->y, NULL, \"point\", str);\n\tPG_RETURN_POINT_P(point);\n}"
  },
  {
    "function_name": "path_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1695-1719",
    "snippet": "Datum\npath_length(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tfloat8\t\tresult = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!path->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = path->npts - 1; /* include the closure segment */\n\t\t}\n\n\t\tresult += point_dt(&path->p[iprev], &path->p[i]);\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_dt",
          "args": [
            "&path->p[iprev]",
            "&path->p[i]"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "point_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1904-1912",
          "snippet": "double\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\ndouble\npoint_dt(Point *pt1, Point *pt2)\n{\n#ifdef GEODEBUG\n\tprintf(\"point_dt- segment (%f,%f),(%f,%f) length is %f\\n\",\n\t\t   pt1->x, pt1->y, pt2->x, pt2->y, HYPOT(pt1->x - pt2->x, pt1->y - pt2->y));\n#endif\n\treturn HYPOT(pt1->x - pt2->x, pt1->y - pt2->y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_length(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tfloat8\t\tresult = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!path->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = path->npts - 1; /* include the closure segment */\n\t\t}\n\n\t\tresult += point_dt(&path->p[iprev], &path->p[i]);\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "path_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1631-1688",
    "snippet": "Datum\npath_distance(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\tfloat8\t\tmin = 0.0;\t\t/* initialize to keep compiler quiet */\n\tbool\t\thave_min = false;\n\tfloat8\t\ttmp;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tLSEG\t\tseg1,\n\t\t\t\tseg2;\n\n\tfor (i = 0; i < p1->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!p1->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = p1->npts - 1;\t/* include the closure segment */\n\t\t}\n\n\t\tfor (j = 0; j < p2->npts; j++)\n\t\t{\n\t\t\tint\t\t\tjprev;\n\n\t\t\tif (j > 0)\n\t\t\t\tjprev = j - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!p2->closed)\n\t\t\t\t\tcontinue;\n\t\t\t\tjprev = p2->npts - 1;\t/* include the closure segment */\n\t\t\t}\n\n\t\t\tstatlseg_construct(&seg1, &p1->p[iprev], &p1->p[i]);\n\t\t\tstatlseg_construct(&seg2, &p2->p[jprev], &p2->p[j]);\n\n\t\t\ttmp = DatumGetFloat8(DirectFunctionCall2(lseg_distance,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(&seg1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(&seg2)));\n\t\t\tif (!have_min || tmp < min)\n\t\t\t{\n\t\t\t\tmin = tmp;\n\t\t\t\thave_min = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!have_min)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(min);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "min"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "DirectFunctionCall2(lseg_distance,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(&seg1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(&seg2))"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "lseg_distance",
            "LsegPGetDatum(&seg1)",
            "LsegPGetDatum(&seg2)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "&seg2"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LsegPGetDatum",
          "args": [
            "&seg1"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&seg2",
            "&p2->p[jprev]",
            "&p2->p[j]"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\n\nDatum\npath_distance(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\tfloat8\t\tmin = 0.0;\t\t/* initialize to keep compiler quiet */\n\tbool\t\thave_min = false;\n\tfloat8\t\ttmp;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tLSEG\t\tseg1,\n\t\t\t\tseg2;\n\n\tfor (i = 0; i < p1->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!p1->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = p1->npts - 1;\t/* include the closure segment */\n\t\t}\n\n\t\tfor (j = 0; j < p2->npts; j++)\n\t\t{\n\t\t\tint\t\t\tjprev;\n\n\t\t\tif (j > 0)\n\t\t\t\tjprev = j - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!p2->closed)\n\t\t\t\t\tcontinue;\n\t\t\t\tjprev = p2->npts - 1;\t/* include the closure segment */\n\t\t\t}\n\n\t\t\tstatlseg_construct(&seg1, &p1->p[iprev], &p1->p[i]);\n\t\t\tstatlseg_construct(&seg2, &p2->p[jprev], &p2->p[j]);\n\n\t\t\ttmp = DatumGetFloat8(DirectFunctionCall2(lseg_distance,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(&seg1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LsegPGetDatum(&seg2)));\n\t\t\tif (!have_min || tmp < min)\n\t\t\t{\n\t\t\t\tmin = tmp;\n\t\t\t\thave_min = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!have_min)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_FLOAT8(min);\n}"
  },
  {
    "function_name": "path_inter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1553-1625",
    "snippet": "Datum\npath_inter(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\tBOX\t\t\tb1,\n\t\t\t\tb2;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tLSEG\t\tseg1,\n\t\t\t\tseg2;\n\n\tif (p1->npts <= 0 || p2->npts <= 0)\n\t\tPG_RETURN_BOOL(false);\n\n\tb1.high.x = b1.low.x = p1->p[0].x;\n\tb1.high.y = b1.low.y = p1->p[0].y;\n\tfor (i = 1; i < p1->npts; i++)\n\t{\n\t\tb1.high.x = Max(p1->p[i].x, b1.high.x);\n\t\tb1.high.y = Max(p1->p[i].y, b1.high.y);\n\t\tb1.low.x = Min(p1->p[i].x, b1.low.x);\n\t\tb1.low.y = Min(p1->p[i].y, b1.low.y);\n\t}\n\tb2.high.x = b2.low.x = p2->p[0].x;\n\tb2.high.y = b2.low.y = p2->p[0].y;\n\tfor (i = 1; i < p2->npts; i++)\n\t{\n\t\tb2.high.x = Max(p2->p[i].x, b2.high.x);\n\t\tb2.high.y = Max(p2->p[i].y, b2.high.y);\n\t\tb2.low.x = Min(p2->p[i].x, b2.low.x);\n\t\tb2.low.y = Min(p2->p[i].y, b2.low.y);\n\t}\n\tif (!box_ov(&b1, &b2))\n\t\tPG_RETURN_BOOL(false);\n\n\t/* pairwise check lseg intersections */\n\tfor (i = 0; i < p1->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!p1->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = p1->npts - 1;\t/* include the closure segment */\n\t\t}\n\n\t\tfor (j = 0; j < p2->npts; j++)\n\t\t{\n\t\t\tint\t\t\tjprev;\n\n\t\t\tif (j > 0)\n\t\t\t\tjprev = j - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!p2->closed)\n\t\t\t\t\tcontinue;\n\t\t\t\tjprev = p2->npts - 1;\t/* include the closure segment */\n\t\t\t}\n\n\t\t\tstatlseg_construct(&seg1, &p1->p[iprev], &p1->p[i]);\n\t\t\tstatlseg_construct(&seg2, &p2->p[jprev], &p2->p[j]);\n\t\t\tif (lseg_intersect_internal(&seg1, &seg2))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t}\n\t}\n\n\t/* if we dropped through, no two segs intersected */\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static bool plist_same(int npts, Point *p1, Point *p2);",
      "static Point *point_construct(double x, double y);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseg_intersect_internal",
          "args": [
            "&seg1",
            "&seg2"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "lseg_intersect_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2058-2073",
          "snippet": "static bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic bool\nlseg_intersect_internal(LSEG *l1, LSEG *l2)\n{\n\tLINE\t\tln;\n\tPoint\t   *interpt;\n\tbool\t\tretval;\n\n\tline_construct_pts(&ln, &l2->p[0], &l2->p[1]);\n\tinterpt = interpt_sl(l1, &ln);\n\n\tif (interpt != NULL && on_ps_internal(interpt, l2))\n\t\tretval = true;\t\t\t/* interpt on l1 and l2 */\n\telse\n\t\tretval = false;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "&seg2",
            "&p2->p[jprev]",
            "&p2->p[j]"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ov",
          "args": [
            "&b1",
            "&b2"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "box_ov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "525-532",
          "snippet": "static bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool box_ov(BOX *box1, BOX *box2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "p2->p[i].y",
            "b2.low.y"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "p2->p[i].x",
            "b2.low.x"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "p2->p[i].y",
            "b2.high.y"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "p2->p[i].x",
            "b2.high.x"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "p1->p[i].y",
            "b1.low.y"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "p1->p[i].x",
            "b1.low.x"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "p1->p[i].y",
            "b1.high.y"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "p1->p[i].x",
            "b1.high.x"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic bool plist_same(int npts, Point *p1, Point *p2);\nstatic Point *point_construct(double x, double y);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\npath_inter(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\tBOX\t\t\tb1,\n\t\t\t\tb2;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tLSEG\t\tseg1,\n\t\t\t\tseg2;\n\n\tif (p1->npts <= 0 || p2->npts <= 0)\n\t\tPG_RETURN_BOOL(false);\n\n\tb1.high.x = b1.low.x = p1->p[0].x;\n\tb1.high.y = b1.low.y = p1->p[0].y;\n\tfor (i = 1; i < p1->npts; i++)\n\t{\n\t\tb1.high.x = Max(p1->p[i].x, b1.high.x);\n\t\tb1.high.y = Max(p1->p[i].y, b1.high.y);\n\t\tb1.low.x = Min(p1->p[i].x, b1.low.x);\n\t\tb1.low.y = Min(p1->p[i].y, b1.low.y);\n\t}\n\tb2.high.x = b2.low.x = p2->p[0].x;\n\tb2.high.y = b2.low.y = p2->p[0].y;\n\tfor (i = 1; i < p2->npts; i++)\n\t{\n\t\tb2.high.x = Max(p2->p[i].x, b2.high.x);\n\t\tb2.high.y = Max(p2->p[i].y, b2.high.y);\n\t\tb2.low.x = Min(p2->p[i].x, b2.low.x);\n\t\tb2.low.y = Min(p2->p[i].y, b2.low.y);\n\t}\n\tif (!box_ov(&b1, &b2))\n\t\tPG_RETURN_BOOL(false);\n\n\t/* pairwise check lseg intersections */\n\tfor (i = 0; i < p1->npts; i++)\n\t{\n\t\tint\t\t\tiprev;\n\n\t\tif (i > 0)\n\t\t\tiprev = i - 1;\n\t\telse\n\t\t{\n\t\t\tif (!p1->closed)\n\t\t\t\tcontinue;\n\t\t\tiprev = p1->npts - 1;\t/* include the closure segment */\n\t\t}\n\n\t\tfor (j = 0; j < p2->npts; j++)\n\t\t{\n\t\t\tint\t\t\tjprev;\n\n\t\t\tif (j > 0)\n\t\t\t\tjprev = j - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!p2->closed)\n\t\t\t\t\tcontinue;\n\t\t\t\tjprev = p2->npts - 1;\t/* include the closure segment */\n\t\t\t}\n\n\t\t\tstatlseg_construct(&seg1, &p1->p[iprev], &p1->p[i]);\n\t\t\tstatlseg_construct(&seg2, &p2->p[jprev], &p2->p[j]);\n\t\t\tif (lseg_intersect_internal(&seg1, &seg2))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t}\n\t}\n\n\t/* if we dropped through, no two segs intersected */\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "path_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1537-1545",
    "snippet": "Datum\npath_open(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\n\tpath->closed = false;\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P_COPY",
          "args": [
            "0"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_open(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\n\tpath->closed = false;\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1527-1535",
    "snippet": "Datum\npath_close(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\n\tpath->closed = true;\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P_COPY",
          "args": [
            "0"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_close(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\n\tpath->closed = true;\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_npoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1518-1524",
    "snippet": "Datum\npath_npoints(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_INT32(path->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "path->npts"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_npoints(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_INT32(path->npts);\n}"
  },
  {
    "function_name": "path_isopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1510-1516",
    "snippet": "Datum\npath_isopen(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_BOOL(!path->closed);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!path->closed"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_isopen(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_BOOL(!path->closed);\n}"
  },
  {
    "function_name": "path_isclosed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1502-1508",
    "snippet": "Datum\npath_isclosed(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_BOOL(path->closed);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "path->closed"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_isclosed(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_BOOL(path->closed);\n}"
  },
  {
    "function_name": "path_n_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1489-1496",
    "snippet": "Datum\npath_n_ge(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts >= p2->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "p1->npts >= p2->npts"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\n\nDatum\npath_n_ge(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts >= p2->npts);\n}"
  },
  {
    "function_name": "path_n_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1480-1487",
    "snippet": "Datum\npath_n_le(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts <= p2->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "p1->npts <= p2->npts"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\n\nDatum\npath_n_le(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts <= p2->npts);\n}"
  },
  {
    "function_name": "path_n_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1471-1478",
    "snippet": "Datum\npath_n_eq(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts == p2->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "p1->npts == p2->npts"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\n\nDatum\npath_n_eq(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts == p2->npts);\n}"
  },
  {
    "function_name": "path_n_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1462-1469",
    "snippet": "Datum\npath_n_gt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts > p2->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "p1->npts > p2->npts"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\n\nDatum\npath_n_gt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts > p2->npts);\n}"
  },
  {
    "function_name": "path_n_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1453-1460",
    "snippet": "Datum\npath_n_lt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts < p2->npts);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool plist_same(int npts, Point *p1, Point *p2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "p1->npts < p2->npts"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "1"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool plist_same(int npts, Point *p1, Point *p2);\n\nDatum\npath_n_lt(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *p1 = PG_GETARG_PATH_P(0);\n\tPATH\t   *p2 = PG_GETARG_PATH_P(1);\n\n\tPG_RETURN_BOOL(p1->npts < p2->npts);\n}"
  },
  {
    "function_name": "path_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1426-1442",
    "snippet": "Datum\npath_send(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tStringInfoData buf;\n\tint32\t\ti;\n\n\tpq_begintypsend(&buf);\n\tpq_sendbyte(&buf, path->closed ? 1 : 0);\n\tpq_sendint32(&buf, path->npts);\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpq_sendfloat8(&buf, path->p[i].x);\n\t\tpq_sendfloat8(&buf, path->p[i].y);\n\t}\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "path->p[i].y"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "path->p[i].x"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "path->npts"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "path->closed ? 1 : 0"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_send(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tStringInfoData buf;\n\tint32\t\ti;\n\n\tpq_begintypsend(&buf);\n\tpq_sendbyte(&buf, path->closed ? 1 : 0);\n\tpq_sendint32(&buf, path->npts);\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpq_sendfloat8(&buf, path->p[i].x);\n\t\tpq_sendfloat8(&buf, path->p[i].y);\n\t}\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "path_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1388-1421",
    "snippet": "Datum\npath_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tPATH\t   *path;\n\tint\t\t\tclosed;\n\tint32\t\tnpts;\n\tint32\t\ti;\n\tint\t\t\tsize;\n\n\tclosed = pq_getmsgbyte(buf);\n\tnpts = pq_getmsgint(buf, sizeof(int32));\n\tif (npts <= 0 || npts >= (int32) ((INT_MAX - offsetof(PATH, p)) / sizeof(Point)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of points in external \\\"path\\\" value\")));\n\n\tsize = offsetof(PATH, p) + sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tpath->closed = (closed ? 1 : 0);\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpath->p[i].x = pq_getmsgfloat8(buf);\n\t\tpath->p[i].y = pq_getmsgfloat8(buf);\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "path",
            "size"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of points in external \\\"path\\\" value\"))"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid number of points in external \\\"path\\\" value\""
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(INT_MAX - offsetof(PATH, p)) / sizeof(Point)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int32)"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tPATH\t   *path;\n\tint\t\t\tclosed;\n\tint32\t\tnpts;\n\tint32\t\ti;\n\tint\t\t\tsize;\n\n\tclosed = pq_getmsgbyte(buf);\n\tnpts = pq_getmsgint(buf, sizeof(int32));\n\tif (npts <= 0 || npts >= (int32) ((INT_MAX - offsetof(PATH, p)) / sizeof(Point)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of points in external \\\"path\\\" value\")));\n\n\tsize = offsetof(PATH, p) + sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tpath->closed = (closed ? 1 : 0);\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpath->p[i].x = pq_getmsgfloat8(buf);\n\t\tpath->p[i].y = pq_getmsgfloat8(buf);\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1374-1380",
    "snippet": "Datum\npath_out(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(path->closed ? PATH_CLOSED : PATH_OPEN, path->npts, path->p));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "path_encode(path->closed ? PATH_CLOSED : PATH_OPEN, path->npts, path->p)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_encode",
          "args": [
            "path->closed ? PATH_CLOSED : PATH_OPEN",
            "path->npts",
            "path->p"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "path_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "268-311",
          "snippet": "static char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nDatum\npath_out(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(path->closed ? PATH_CLOSED : PATH_OPEN, path->npts, path->p));\n}"
  },
  {
    "function_name": "path_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1305-1371",
    "snippet": "Datum\npath_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tbool\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tbase_size;\n\tint\t\t\tdepth = 0;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"path\", str)));\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n\t/* skip single leading paren */\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\n\tbase_size = sizeof(path->p[0]) * npts;\n\tsize = offsetof(PATH, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\n\tpath_decode(s, true, npts, &(path->p[0]), &isopen, &s, \"path\", str);\n\n\tif (depth >= 1)\n\t{\n\t\tif (*s++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"path\", str)));\n\t\twhile (isspace((unsigned char) *s))\n\t\t\ts++;\n\t}\n\tif (*s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"path\", str)));\n\n\tpath->closed = (!isopen);\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tPG_RETURN_PATH_P(path);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RDELIM\t\t\t')'",
      "#define LDELIM\t\t\t'('"
    ],
    "globals_used": [
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_PATH_P",
          "args": [
            "path"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"path\", str))"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"path\"",
            "str"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"path\", str))"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_decode",
          "args": [
            "s",
            "true",
            "npts",
            "&(path->p[0])",
            "&isopen",
            "&s",
            "\"path\"",
            "str"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "path_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "192-266",
          "snippet": "static void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "path",
            "size"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "size"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\"))"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "LDELIM"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"path\", str))"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_count",
          "args": [
            "str",
            "','"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "pair_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "320-331",
          "snippet": "static int\npair_count(char *s, char delim)\n{\n\tint\t\t\tndelim = 0;\n\n\twhile ((s = strchr(s, delim)) != NULL)\n\t{\n\t\tndelim++;\n\t\ts++;\n\t}\n\treturn (ndelim % 2) ? ((ndelim + 1) / 2) : -1;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tpair_count(char *s, char delim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic int\tpair_count(char *s, char delim);\n\nstatic int\npair_count(char *s, char delim)\n{\n\tint\t\t\tndelim = 0;\n\n\twhile ((s = strchr(s, delim)) != NULL)\n\t{\n\t\tndelim++;\n\t\ts++;\n\t}\n\treturn (ndelim % 2) ? ((ndelim + 1) / 2) : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nDatum\npath_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tbool\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tbase_size;\n\tint\t\t\tdepth = 0;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"path\", str)));\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n\t/* skip single leading paren */\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\n\tbase_size = sizeof(path->p[0]) * npts;\n\tsize = offsetof(PATH, p) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\n\tpath_decode(s, true, npts, &(path->p[0]), &isopen, &s, \"path\", str);\n\n\tif (depth >= 1)\n\t{\n\t\tif (*s++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"path\", str)));\n\t\twhile (isspace((unsigned char) *s))\n\t\t\ts++;\n\t}\n\tif (*s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"path\", str)));\n\n\tpath->closed = (!isopen);\n\t/* prevent instability in unused pad bytes */\n\tpath->dummy = 0;\n\n\tPG_RETURN_PATH_P(path);\n}"
  },
  {
    "function_name": "path_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1282-1302",
    "snippet": "Datum\npath_area(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tdouble\t\tarea = 0.0;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tif (!path->closed)\n\t\tPG_RETURN_NULL();\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tj = (i + 1) % path->npts;\n\t\tarea += path->p[i].x * path->p[j].y;\n\t\tarea -= path->p[i].y * path->p[j].x;\n\t}\n\n\tarea *= 0.5;\n\tPG_RETURN_FLOAT8(area < 0.0 ? -area : area);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "area < 0.0 ? -area : area"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_PATH_P",
          "args": [
            "0"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nDatum\npath_area(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tdouble\t\tarea = 0.0;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tif (!path->closed)\n\t\tPG_RETURN_NULL();\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tj = (i + 1) % path->npts;\n\t\tarea += path->p[i].x * path->p[j].y;\n\t\tarea -= path->p[i].y * path->p[j].x;\n\t}\n\n\tarea *= 0.5;\n\tPG_RETURN_FLOAT8(area < 0.0 ? -area : area);\n}"
  },
  {
    "function_name": "line_interpt_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1216-1257",
    "snippet": "static Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *point_construct(double x, double y);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"line_interpt- lines intersect at (%.*g,%.*g)\\n\"",
            "DBL_DIG",
            "x",
            "DBL_DIG",
            "y"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\"",
            "DBL_DIG",
            "l1->A",
            "DBL_DIG",
            "l1->B",
            "DBL_DIG",
            "l1->C",
            "DBL_DIG",
            "l2->A",
            "DBL_DIG",
            "l2->B",
            "DBL_DIG",
            "l2->C"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point_construct",
          "args": [
            "x",
            "y"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "point_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1783-1791",
          "snippet": "static Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nstatic Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->B"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l1->B"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "line_parallel",
            "LinePGetDatum(l1)",
            "LinePGetDatum(l2)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "l2"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "l1"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}"
  },
  {
    "function_name": "line_interpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1197-1209",
    "snippet": "Datum\nline_interpt(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\tPoint\t   *result;\n\n\tresult = line_interpt_internal(l1, l2);\n\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_interpt_internal",
          "args": [
            "l1",
            "l2"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "line_interpt_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1216-1257",
          "snippet": "static Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
            "static double lseg_dt(LSEG *l1, LSEG *l2);",
            "static Point *point_construct(double x, double y);",
            "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
            "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *point_construct(double x, double y);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nstatic Point *\nline_interpt_internal(LINE *l1, LINE *l2)\n{\n\tPoint\t   *result;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\t/*\n\t * NOTE: if the lines are identical then we will find they are parallel\n\t * and report \"no intersection\".  This is a little weird, but since\n\t * there's no *unique* intersection, maybe it's appropriate behavior.\n\t */\n\tif (DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))))\n\t\treturn NULL;\n\n\tif (FPzero(l1->B))\t\t\t/* l1 vertical? */\n\t{\n\t\tx = l1->C;\n\t\ty = (l2->A * x + l2->C);\n\t}\n\telse if (FPzero(l2->B))\t\t/* l2 vertical? */\n\t{\n\t\tx = l2->C;\n\t\ty = (l1->A * x + l1->C);\n\t}\n\telse\n\t{\n\t\tx = (l1->C - l2->C) / (l2->A - l1->A);\n\t\ty = (l1->A * x + l1->C);\n\t}\n\tresult = point_construct(x, y);\n\n#ifdef GEODEBUG\n\tprintf(\"line_interpt- lines are A=%.*g, B=%.*g, C=%.*g, A=%.*g, B=%.*g, C=%.*g\\n\",\n\t\t   DBL_DIG, l1->A, DBL_DIG, l1->B, DBL_DIG, l1->C, DBL_DIG, l2->A, DBL_DIG, l2->B, DBL_DIG, l2->C);\n\tprintf(\"line_interpt- lines intersect at (%.*g,%.*g)\\n\", DBL_DIG, x, DBL_DIG, y);\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nline_interpt(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\tPoint\t   *result;\n\n\tresult = line_interpt_internal(l1, l2);\n\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "line_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1175-1192",
    "snippet": "Datum\nline_distance(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\tfloat8\t\tresult;\n\tPoint\t   *tmp;\n\n\tif (!DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t  LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t  LinePGetDatum(l2))))\n\t\tPG_RETURN_FLOAT8(0.0);\n\tif (FPzero(l1->B))\t\t\t/* vertical? */\n\t\tPG_RETURN_FLOAT8(fabs(l1->C - l2->C));\n\ttmp = point_construct(0.0, l1->C);\n\tresult = dist_pl_internal(tmp, l2);\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist_pl_internal",
          "args": [
            "tmp",
            "l2"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "dist_pl_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2346-2351",
          "snippet": "static double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic double\ndist_pl_internal(Point *pt, LINE *line)\n{\n\treturn fabs((line->A * pt->x + line->B * pt->y + line->C) /\n\t\t\t\tHYPOT(line->A, line->B));\n}"
        }
      },
      {
        "call_info": {
          "callee": "point_construct",
          "args": [
            "0.0",
            "l1->C"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "point_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1783-1791",
          "snippet": "static Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\n\nstatic Point *\npoint_construct(double x, double y)\n{\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tresult->x = x;\n\tresult->y = y;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "fabs(l1->C - l2->C)"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "l1->C - l2->C"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l1->B"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t  LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t  LinePGetDatum(l2))"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "line_parallel",
            "LinePGetDatum(l1)",
            "LinePGetDatum(l2)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "l2"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "l1"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nline_distance(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\tfloat8\t\tresult;\n\tPoint\t   *tmp;\n\n\tif (!DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t  LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t  LinePGetDatum(l2))))\n\t\tPG_RETURN_FLOAT8(0.0);\n\tif (FPzero(l1->B))\t\t\t/* vertical? */\n\t\tPG_RETURN_FLOAT8(fabs(l1->C - l2->C));\n\ttmp = point_construct(0.0, l1->C);\n\tresult = dist_pl_internal(tmp, l2);\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "line_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1146-1165",
    "snippet": "Datum\nline_eq(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\tdouble\t\tk;\n\n\tif (!FPzero(l2->A))\n\t\tk = l1->A / l2->A;\n\telse if (!FPzero(l2->B))\n\t\tk = l1->B / l2->B;\n\telse if (!FPzero(l2->C))\n\t\tk = l1->C / l2->C;\n\telse\n\t\tk = 1.0;\n\n\tPG_RETURN_BOOL(FPeq(l1->A, k * l2->A) &&\n\t\t\t\t   FPeq(l1->B, k * l2->B) &&\n\t\t\t\t   FPeq(l1->C, k * l2->C));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(l1->A, k * l2->A) &&\n\t\t\t\t   FPeq(l1->B, k * l2->B) &&\n\t\t\t\t   FPeq(l1->C, k * l2->C)"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->C",
            "k * l2->C"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->B",
            "k * l2->B"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l1->A",
            "k * l2->A"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->C"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->B"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->A"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nline_eq(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\tdouble\t\tk;\n\n\tif (!FPzero(l2->A))\n\t\tk = l1->A / l2->A;\n\telse if (!FPzero(l2->B))\n\t\tk = l1->B / l2->B;\n\telse if (!FPzero(l2->C))\n\t\tk = l1->C / l2->C;\n\telse\n\t\tk = 1.0;\n\n\tPG_RETURN_BOOL(FPeq(l1->A, k * l2->A) &&\n\t\t\t\t   FPeq(l1->B, k * l2->B) &&\n\t\t\t\t   FPeq(l1->C, k * l2->C));\n}"
  },
  {
    "function_name": "line_horizontal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1138-1144",
    "snippet": "Datum\nline_horizontal(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\n\tPG_RETURN_BOOL(FPzero(line->A));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPzero(line->A)"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->A"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nline_horizontal(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\n\tPG_RETURN_BOOL(FPzero(line->A));\n}"
  },
  {
    "function_name": "line_vertical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1130-1136",
    "snippet": "Datum\nline_vertical(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\n\tPG_RETURN_BOOL(FPzero(line->B));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPzero(line->B)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->B"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nline_vertical(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\n\tPG_RETURN_BOOL(FPzero(line->B));\n}"
  },
  {
    "function_name": "line_perp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1116-1128",
    "snippet": "Datum\nline_perp(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tif (FPzero(l1->A))\n\t\tPG_RETURN_BOOL(FPzero(l2->B));\n\telse if (FPzero(l1->B))\n\t\tPG_RETURN_BOOL(FPzero(l2->A));\n\n\tPG_RETURN_BOOL(FPeq(((l1->A * l2->B) / (l1->B * l2->A)), -1.0));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(((l1->A * l2->B) / (l1->B * l2->A)), -1.0)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "((l1->A * l2->B) / (l1->B * l2->A))",
            "-1.0"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPzero(l2->A)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->A"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l1->B"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPzero(l2->B)"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->B"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l1->A"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nline_perp(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tif (FPzero(l1->A))\n\t\tPG_RETURN_BOOL(FPzero(l2->B));\n\telse if (FPzero(l1->B))\n\t\tPG_RETURN_BOOL(FPzero(l2->A));\n\n\tPG_RETURN_BOOL(FPeq(((l1->A * l2->B) / (l1->B * l2->A)), -1.0));\n}"
  },
  {
    "function_name": "line_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1104-1114",
    "snippet": "Datum\nline_parallel(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tif (FPzero(l1->B))\n\t\tPG_RETURN_BOOL(FPzero(l2->B));\n\n\tPG_RETURN_BOOL(FPeq(l2->A, l1->A * (l2->B / l1->B)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(l2->A, l1->A * (l2->B / l1->B))"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "l2->A",
            "l1->A * (l2->B / l1->B)"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPzero(l2->B)"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l2->B"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "l1->B"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nline_parallel(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tif (FPzero(l1->B))\n\t\tPG_RETURN_BOOL(FPzero(l2->B));\n\n\tPG_RETURN_BOOL(FPeq(l2->A, l1->A * (l2->B / l1->B)));\n}"
  },
  {
    "function_name": "line_intersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1093-1102",
    "snippet": "Datum\nline_intersect(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(!DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lseg_intersect_internal(LSEG *l1, LSEG *l2);",
      "static double lseg_dt(LSEG *l1, LSEG *l2);",
      "static Point *line_interpt_internal(LINE *l1, LINE *l2);",
      "static Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2)))"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "line_parallel",
            "LinePGetDatum(l1)",
            "LinePGetDatum(l2)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "l2"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LinePGetDatum",
          "args": [
            "l1"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "1"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool lseg_intersect_internal(LSEG *l1, LSEG *l2);\nstatic double lseg_dt(LSEG *l1, LSEG *l2);\nstatic Point *line_interpt_internal(LINE *l1, LINE *l2);\nstatic Point *lseg_interpt_internal(LSEG *l1, LSEG *l2);\n\nDatum\nline_intersect(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_BOOL(!DatumGetBool(DirectFunctionCall2(line_parallel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t LinePGetDatum(l2))));\n}"
  },
  {
    "function_name": "line_construct_pp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1077-1086",
    "snippet": "Datum\nline_construct_pp(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tline_construct_pts(result, pt1, pt2);\n\tPG_RETURN_LINE_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LINE_P",
          "args": [
            "result"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_construct_pts",
          "args": [
            "result",
            "pt1",
            "pt2"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1035-1072",
          "snippet": "static void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LINE)"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "1"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINT_P",
          "args": [
            "0"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\n\nDatum\nline_construct_pp(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *pt2 = PG_GETARG_POINT_P(1);\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tline_construct_pts(result, pt1, pt2);\n\tPG_RETURN_LINE_P(result);\n}"
  },
  {
    "function_name": "line_construct_pts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1035-1072",
    "snippet": "static void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
      "static Point *point_construct(double x, double y);",
      "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\"",
            "DBL_DIG",
            "(pt2->x - pt1->x)",
            "DBL_DIG",
            "(pt2->y - pt1->y)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"line_construct_pts- line is horizontal\\n\""
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->y",
            "pt2->y"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"line_construct_pts- line is vertical\\n\""
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "pt1->x",
            "pt2->x"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}"
  },
  {
    "function_name": "line_construct_pm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "1009-1030",
    "snippet": "static LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LINE *line_construct_pm(Point *pt, double m);",
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LINE)"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic LINE *line_construct_pm(Point *pt, double m);\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic LINE *\nline_construct_pm(Point *pt, double m)\n{\n\tLINE\t   *result = (LINE *) palloc(sizeof(LINE));\n\n\tif (m == DBL_MAX)\n\t{\n\t\t/* vertical - use \"x = C\" */\n\t\tresult->A = -1;\n\t\tresult->B = 0;\n\t\tresult->C = pt->x;\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tresult->A = m;\n\t\tresult->B = -1.0;\n\t\tresult->C = pt->y - m * pt->x;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "line_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "987-998",
    "snippet": "Datum\nline_send(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, line->A);\n\tpq_sendfloat8(&buf, line->B);\n\tpq_sendfloat8(&buf, line->C);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "line->C"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "line->B"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "line->A"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nline_send(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, line->A);\n\tpq_sendfloat8(&buf, line->B);\n\tpq_sendfloat8(&buf, line->C);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "line_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "969-982",
    "snippet": "Datum\nline_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tLINE\t   *line;\n\n\tline = (LINE *) palloc(sizeof(LINE));\n\n\tline->A = pq_getmsgfloat8(buf);\n\tline->B = pq_getmsgfloat8(buf);\n\tline->C = pq_getmsgfloat8(buf);\n\n\tPG_RETURN_LINE_P(line);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LINE_P",
          "args": [
            "line"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LINE)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nline_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tLINE\t   *line;\n\n\tline = (LINE *) palloc(sizeof(LINE));\n\n\tline->A = pq_getmsgfloat8(buf);\n\tline->B = pq_getmsgfloat8(buf);\n\tline->C = pq_getmsgfloat8(buf);\n\n\tPG_RETURN_LINE_P(line);\n}"
  },
  {
    "function_name": "line_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "955-964",
    "snippet": "Datum\nline_out(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tchar\t   *astr = float8out_internal(line->A);\n\tchar\t   *bstr = float8out_internal(line->B);\n\tchar\t   *cstr = float8out_internal(line->C);\n\n\tPG_RETURN_CSTRING(psprintf(\"{%s,%s,%s}\", astr, bstr, cstr));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "psprintf(\"{%s,%s,%s}\", astr, bstr, cstr)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"{%s,%s,%s}\"",
            "astr",
            "bstr",
            "cstr"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8out_internal",
          "args": [
            "line->C"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "float8out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "592-620",
          "snippet": "char *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\textra_float_digits = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\textra_float_digits = 0;\n\nchar *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_LINE_P",
          "args": [
            "0"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nline_out(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tchar\t   *astr = float8out_internal(line->A);\n\tchar\t   *bstr = float8out_internal(line->B);\n\tchar\t   *cstr = float8out_internal(line->C);\n\n\tPG_RETURN_CSTRING(psprintf(\"{%s,%s,%s}\", astr, bstr, cstr));\n}"
  },
  {
    "function_name": "line_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "917-952",
    "snippet": "Datum\nline_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tLINE\t   *line = (LINE *) palloc(sizeof(LINE));\n\tLSEG\t\tlseg;\n\tbool\t\tisopen;\n\tchar\t   *s;\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s == '{')\n\t{\n\t\tif (!line_decode(s + 1, str, line))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"line\", str)));\n\t\tif (FPzero(line->A) && FPzero(line->B))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid line specification: A and B cannot both be zero\")));\n\t}\n\telse\n\t{\n\t\tpath_decode(s, true, 2, &(lseg.p[0]), &isopen, NULL, \"line\", str);\n\t\tif (FPeq(lseg.p[0].x, lseg.p[1].x) && FPeq(lseg.p[0].y, lseg.p[1].y))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid line specification: must be two distinct points\")));\n\t\tline_construct_pts(line, &lseg.p[0], &lseg.p[1]);\n\t}\n\n\tPG_RETURN_LINE_P(line);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool on_ps_internal(Point *pt, LSEG *lseg);",
      "static Point *point_construct(double x, double y);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);",
      "static double dist_ps_internal(Point *pt, LSEG *lseg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LINE_P",
          "args": [
            "line"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_construct_pts",
          "args": [
            "line",
            "&lseg.p[0]",
            "&lseg.p[1]"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "line_construct_pts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "1035-1072",
          "snippet": "static void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic void\nline_construct_pts(LINE *line, Point *pt1, Point *pt2)\n{\n\tif (FPeq(pt1->x, pt2->x))\n\t{\t\t\t\t\t\t\t/* vertical */\n\t\t/* use \"x = C\" */\n\t\tline->A = -1;\n\t\tline->B = 0;\n\t\tline->C = pt1->x;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is vertical\\n\");\n#endif\n\t}\n\telse if (FPeq(pt1->y, pt2->y))\n\t{\t\t\t\t\t\t\t/* horizontal */\n\t\t/* use \"y = C\" */\n\t\tline->A = 0;\n\t\tline->B = -1;\n\t\tline->C = pt1->y;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is horizontal\\n\");\n#endif\n\t}\n\telse\n\t{\n\t\t/* use \"mx - y + yinter = 0\" */\n\t\tline->A = (pt2->y - pt1->y) / (pt2->x - pt1->x);\n\t\tline->B = -1.0;\n\t\tline->C = pt1->y - line->A * pt1->x;\n\t\t/* on some platforms, the preceding expression tends to produce -0 */\n\t\tif (line->C == 0.0)\n\t\t\tline->C = 0.0;\n#ifdef GEODEBUG\n\t\tprintf(\"line_construct_pts- line is neither vertical nor horizontal (diffs x=%.*g, y=%.*g\\n\",\n\t\t\t   DBL_DIG, (pt2->x - pt1->x), DBL_DIG, (pt2->y - pt1->y));\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid line specification: must be two distinct points\"))"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid line specification: must be two distinct points\""
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "lseg.p[0].y",
            "lseg.p[1].y"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "lseg.p[0].x",
            "lseg.p[1].x"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_decode",
          "args": [
            "s",
            "true",
            "2",
            "&(lseg.p[0])",
            "&isopen",
            "NULL",
            "\"line\"",
            "str"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "path_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "192-266",
          "snippet": "static void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid line specification: A and B cannot both be zero\"))"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->B"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPzero",
          "args": [
            "line->A"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"line\", str))"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_decode",
          "args": [
            "s + 1",
            "str",
            "line"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "line_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "897-915",
          "snippet": "static bool\nline_decode(char *s, const char *str, LINE *line)\n{\n\t/* s was already advanced over leading '{' */\n\tline->A = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->B = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->C = single_decode(s, &s, \"line\", str);\n\tif (*s++ != '}')\n\t\treturn false;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s != '\\0')\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DELIM\t\t\t','"
          ],
          "globals_used": [
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define DELIM\t\t\t','\n\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic bool\nline_decode(char *s, const char *str, LINE *line)\n{\n\t/* s was already advanced over leading '{' */\n\tline->A = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->B = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->C = single_decode(s, &s, \"line\", str);\n\tif (*s++ != '}')\n\t\treturn false;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s != '\\0')\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LINE)"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nDatum\nline_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tLINE\t   *line = (LINE *) palloc(sizeof(LINE));\n\tLSEG\t\tlseg;\n\tbool\t\tisopen;\n\tchar\t   *s;\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s == '{')\n\t{\n\t\tif (!line_decode(s + 1, str, line))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"line\", str)));\n\t\tif (FPzero(line->A) && FPzero(line->B))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid line specification: A and B cannot both be zero\")));\n\t}\n\telse\n\t{\n\t\tpath_decode(s, true, 2, &(lseg.p[0]), &isopen, NULL, \"line\", str);\n\t\tif (FPeq(lseg.p[0].x, lseg.p[1].x) && FPeq(lseg.p[0].y, lseg.p[1].y))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid line specification: must be two distinct points\")));\n\t\tline_construct_pts(line, &lseg.p[0], &lseg.p[1]);\n\t}\n\n\tPG_RETURN_LINE_P(line);\n}"
  },
  {
    "function_name": "line_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "897-915",
    "snippet": "static bool\nline_decode(char *s, const char *str, LINE *line)\n{\n\t/* s was already advanced over leading '{' */\n\tline->A = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->B = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->C = single_decode(s, &s, \"line\", str);\n\tif (*s++ != '}')\n\t\treturn false;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s != '\\0')\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DELIM\t\t\t','"
    ],
    "globals_used": [
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static Point *interpt_sl(LSEG *lseg, LINE *line);",
      "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
      "static double dist_pl_internal(Point *pt, LINE *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "single_decode",
          "args": [
            "s",
            "&s",
            "\"line\"",
            "str"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "single_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "123-128",
          "snippet": "static double\nsingle_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string)\n{\n\treturn float8in_internal(num, endptr_p, type_name, orig_string);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic double\nsingle_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string)\n{\n\treturn float8in_internal(num, endptr_p, type_name, orig_string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define DELIM\t\t\t','\n\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nstatic bool\nline_decode(char *s, const char *str, LINE *line)\n{\n\t/* s was already advanced over leading '{' */\n\tline->A = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->B = single_decode(s, &s, \"line\", str);\n\tif (*s++ != DELIM)\n\t\treturn false;\n\tline->C = single_decode(s, &s, \"line\", str);\n\tif (*s++ != '}')\n\t\treturn false;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (*s != '\\0')\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "box_diagonal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "880-889",
    "snippet": "Datum\nbox_diagonal(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tLSEG\t   *result = (LSEG *) palloc(sizeof(LSEG));\n\n\tstatlseg_construct(result, &box->high, &box->low);\n\n\tPG_RETURN_LSEG_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_LSEG_P",
          "args": [
            "result"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statlseg_construct",
          "args": [
            "result",
            "&box->high",
            "&box->low"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "statlseg_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "2024-2031",
          "snippet": "static void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void line_construct_pts(LINE *line, Point *pt1, Point *pt2);",
            "static bool on_ps_internal(Point *pt, LSEG *lseg);",
            "static Point *point_construct(double x, double y);",
            "static void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);",
            "static double dist_ps_internal(Point *pt, LSEG *lseg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void line_construct_pts(LINE *line, Point *pt1, Point *pt2);\nstatic bool on_ps_internal(Point *pt, LSEG *lseg);\nstatic Point *point_construct(double x, double y);\nstatic void statlseg_construct(LSEG *lseg, Point *pt1, Point *pt2);\nstatic double dist_ps_internal(Point *pt, LSEG *lseg);\n\nstatic void\nstatlseg_construct(LSEG *lseg, Point *pt1, Point *pt2)\n{\n\tlseg->p[0].x = pt1->x;\n\tlseg->p[0].y = pt1->y;\n\tlseg->p[1].x = pt2->x;\n\tlseg->p[1].y = pt2->y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(LSEG)"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_diagonal(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tLSEG\t   *result = (LSEG *) palloc(sizeof(LSEG));\n\n\tstatlseg_construct(result, &box->high, &box->low);\n\n\tPG_RETURN_LSEG_P(result);\n}"
  },
  {
    "function_name": "box_intersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "855-873",
    "snippet": "Datum\nbox_intersect(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\tBOX\t\t   *result;\n\n\tif (!box_ov(box1, box2))\n\t\tPG_RETURN_NULL();\n\n\tresult = (BOX *) palloc(sizeof(BOX));\n\n\tresult->high.x = Min(box1->high.x, box2->high.x);\n\tresult->low.x = Max(box1->low.x, box2->low.x);\n\tresult->high.y = Min(box1->high.y, box2->high.y);\n\tresult->low.y = Max(box1->low.y, box2->low.y);\n\n\tPG_RETURN_BOX_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "result"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "box1->low.y",
            "box2->low.y"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "box1->high.y",
            "box2->high.y"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "box1->low.x",
            "box2->low.x"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "box1->high.x",
            "box2->high.x"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ov",
          "args": [
            "box1",
            "box2"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "box_ov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "525-532",
          "snippet": "static bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool box_ov(BOX *box1, BOX *box2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_intersect(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\tBOX\t\t   *result;\n\n\tif (!box_ov(box1, box2))\n\t\tPG_RETURN_NULL();\n\n\tresult = (BOX *) palloc(sizeof(BOX));\n\n\tresult->high.x = Min(box1->high.x, box2->high.x);\n\tresult->low.x = Max(box1->low.x, box2->low.x);\n\tresult->high.y = Min(box1->high.y, box2->high.y);\n\tresult->low.y = Max(box1->low.y, box2->low.y);\n\n\tPG_RETURN_BOX_P(result);\n}"
  },
  {
    "function_name": "box_ht",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "840-844",
    "snippet": "static double\nbox_ht(BOX *box)\n{\n\treturn box->high.y - box->low.y;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ht(BOX *box)\n{\n\treturn box->high.y - box->low.y;\n}"
  },
  {
    "function_name": "box_wd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "830-834",
    "snippet": "static double\nbox_wd(BOX *box)\n{\n\treturn box->high.x - box->low.x;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_wd(BOX *box)\n{\n\treturn box->high.x - box->low.x;\n}"
  },
  {
    "function_name": "box_cn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "819-824",
    "snippet": "static void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}"
  },
  {
    "function_name": "box_ar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "810-814",
    "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "box_ht",
          "args": [
            "box"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "box_ht",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "840-844",
          "snippet": "static double\nbox_ht(BOX *box)\n{\n\treturn box->high.y - box->low.y;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ht(BOX *box)\n{\n\treturn box->high.y - box->low.y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "box_wd",
          "args": [
            "box"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "box_wd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "830-834",
          "snippet": "static double\nbox_wd(BOX *box)\n{\n\treturn box->high.x - box->low.x;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_wd(BOX *box)\n{\n\treturn box->high.x - box->low.x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
  },
  {
    "function_name": "box_center",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "796-805",
    "snippet": "Datum\nbox_center(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tbox_cn(result, box);\n\n\tPG_RETURN_POINT_P(result);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINT_P",
          "args": [
            "result"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_cn",
          "args": [
            "result",
            "box"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "box_cn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "819-824",
          "snippet": "static void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Point)"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_center(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tPoint\t   *result = (Point *) palloc(sizeof(Point));\n\n\tbox_cn(result, box);\n\n\tPG_RETURN_POINT_P(result);\n}"
  },
  {
    "function_name": "box_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "779-791",
    "snippet": "Datum\nbox_distance(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\tPoint\t\ta,\n\t\t\t\tb;\n\n\tbox_cn(&a, box1);\n\tbox_cn(&b, box2);\n\n\tPG_RETURN_FLOAT8(HYPOT(a.x - b.x, a.y - b.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "HYPOT(a.x - b.x, a.y - b.y)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HYPOT",
          "args": [
            "a.x - b.x",
            "a.y - b.y"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_cn",
          "args": [
            "&b",
            "box2"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "box_cn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "819-824",
          "snippet": "static void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static Point *point_construct(double x, double y);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic void\nbox_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_distance(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\tPoint\t\ta,\n\t\t\t\tb;\n\n\tbox_cn(&a, box1);\n\tbox_cn(&b, box2);\n\n\tPG_RETURN_FLOAT8(HYPOT(a.x - b.x, a.y - b.y));\n}"
  },
  {
    "function_name": "box_height",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "767-773",
    "snippet": "Datum\nbox_height(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_FLOAT8(box->high.y - box->low.y);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "box->high.y - box->low.y"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_height(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_FLOAT8(box->high.y - box->low.y);\n}"
  },
  {
    "function_name": "box_width",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "755-761",
    "snippet": "Datum\nbox_width(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_FLOAT8(box->high.x - box->low.x);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "box->high.x - box->low.x"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_width(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_FLOAT8(box->high.x - box->low.x);\n}"
  },
  {
    "function_name": "box_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "743-749",
    "snippet": "Datum\nbox_area(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_FLOAT8(box_ar(box));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "box_ar(box)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ar",
          "args": [
            "box"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "box_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "810-814",
          "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_area(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_FLOAT8(box_ar(box));\n}"
  },
  {
    "function_name": "box_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "727-734",
    "snippet": "Datum\nbox_ge(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box_ar(box1), box_ar(box2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(box_ar(box1), box_ar(box2))"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box_ar(box1)",
            "box_ar(box2)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ar",
          "args": [
            "box2"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "box_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "810-814",
          "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_ge(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box_ar(box1), box_ar(box2)));\n}"
  },
  {
    "function_name": "box_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "718-725",
    "snippet": "Datum\nbox_le(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box_ar(box1), box_ar(box2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(box_ar(box1), box_ar(box2))"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box_ar(box1)",
            "box_ar(box2)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ar",
          "args": [
            "box2"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "box_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "810-814",
          "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_le(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box_ar(box1), box_ar(box2)));\n}"
  },
  {
    "function_name": "box_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "709-716",
    "snippet": "Datum\nbox_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPeq(box_ar(box1), box_ar(box2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(box_ar(box1), box_ar(box2))"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "box_ar(box1)",
            "box_ar(box2)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ar",
          "args": [
            "box2"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "box_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "810-814",
          "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPeq(box_ar(box1), box_ar(box2)));\n}"
  },
  {
    "function_name": "box_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "700-707",
    "snippet": "Datum\nbox_gt(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box_ar(box1), box_ar(box2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(box_ar(box1), box_ar(box2))"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "box_ar(box1)",
            "box_ar(box2)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ar",
          "args": [
            "box2"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "box_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "810-814",
          "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_gt(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box_ar(box1), box_ar(box2)));\n}"
  },
  {
    "function_name": "box_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "691-698",
    "snippet": "Datum\nbox_lt(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPlt(box_ar(box1), box_ar(box2)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(box_ar(box1), box_ar(box2))"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "box_ar(box1)",
            "box_ar(box2)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ar",
          "args": [
            "box2"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "box_ar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "810-814",
          "snippet": "static double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nstatic double\nbox_ar(BOX *box)\n{\n\treturn box_wd(box) * box_ht(box);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_lt(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPlt(box_ar(box1), box_ar(box2)));\n}"
  },
  {
    "function_name": "box_above_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "678-685",
    "snippet": "Datum\nbox_above_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->low.y, box2->high.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(box1->low.y, box2->high.y)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->low.y",
            "box2->high.y"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_above_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->low.y, box2->high.y));\n}"
  },
  {
    "function_name": "box_below_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "669-676",
    "snippet": "Datum\nbox_below_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.y, box2->low.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(box1->high.y, box2->low.y)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->high.y",
            "box2->low.y"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_below_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.y, box2->low.y));\n}"
  },
  {
    "function_name": "box_contain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "648-658",
    "snippet": "Datum\nbox_contain(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPle(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPge(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPle(box1->low.y, box2->low.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPle(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPge(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPle(box1->low.y, box2->low.y)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->low.y",
            "box2->low.y"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->high.y",
            "box2->high.y"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->low.x",
            "box2->low.x"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->high.x",
            "box2->high.x"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_contain(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPle(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPge(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPle(box1->low.y, box2->low.y));\n}"
  },
  {
    "function_name": "box_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "634-644",
    "snippet": "Datum\nbox_contained(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPge(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPle(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPge(box1->low.y, box2->low.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPge(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPle(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPge(box1->low.y, box2->low.y)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->low.y",
            "box2->low.y"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->high.y",
            "box2->high.y"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->low.x",
            "box2->low.x"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->high.x",
            "box2->high.x"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_contained(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPge(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPle(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPge(box1->low.y, box2->low.y));\n}"
  },
  {
    "function_name": "box_overabove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "623-630",
    "snippet": "Datum\nbox_overabove(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->low.y, box2->low.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(box1->low.y, box2->low.y)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->low.y",
            "box2->low.y"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_overabove(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->low.y, box2->low.y));\n}"
  },
  {
    "function_name": "box_above",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "611-618",
    "snippet": "Datum\nbox_above(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box1->low.y, box2->high.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(box1->low.y, box2->high.y)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "box1->low.y",
            "box2->high.y"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_above(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box1->low.y, box2->high.y));\n}"
  },
  {
    "function_name": "box_overbelow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "600-607",
    "snippet": "Datum\nbox_overbelow(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.y, box2->high.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(box1->high.y, box2->high.y)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->high.y",
            "box2->high.y"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_overbelow(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.y, box2->high.y));\n}"
  },
  {
    "function_name": "box_below",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "588-595",
    "snippet": "Datum\nbox_below(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPlt(box1->high.y, box2->low.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(box1->high.y, box2->low.y)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "box1->high.y",
            "box2->low.y"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_below(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPlt(box1->high.y, box2->low.y));\n}"
  },
  {
    "function_name": "box_overright",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "577-584",
    "snippet": "Datum\nbox_overright(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->low.x, box2->low.x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPge(box1->low.x, box2->low.x)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPge",
          "args": [
            "box1->low.x",
            "box2->low.x"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_overright(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box1->low.x, box2->low.x));\n}"
  },
  {
    "function_name": "box_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "562-569",
    "snippet": "Datum\nbox_right(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box1->low.x, box2->high.x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPgt(box1->low.x, box2->high.x)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPgt",
          "args": [
            "box1->low.x",
            "box2->high.x"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_right(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPgt(box1->low.x, box2->high.x));\n}"
  },
  {
    "function_name": "box_overleft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "551-558",
    "snippet": "Datum\nbox_overleft(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.x, box2->high.x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPle(box1->high.x, box2->high.x)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->high.x",
            "box2->high.x"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_overleft(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.x, box2->high.x));\n}"
  },
  {
    "function_name": "box_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "536-543",
    "snippet": "Datum\nbox_left(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPlt(box1->high.x, box2->low.x));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPlt(box1->high.x, box2->low.x)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPlt",
          "args": [
            "box1->high.x",
            "box2->low.x"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_left(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPlt(box1->high.x, box2->low.x));\n}"
  },
  {
    "function_name": "box_ov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "525-532",
    "snippet": "static bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box2->low.y",
            "box1->high.y"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->low.y",
            "box2->high.y"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box2->low.x",
            "box1->high.x"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPle",
          "args": [
            "box1->low.x",
            "box2->high.x"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}"
  },
  {
    "function_name": "box_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "516-523",
    "snippet": "Datum\nbox_overlap(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(box_ov(box1, box2));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "box_ov(box1, box2)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "box_ov",
          "args": [
            "box1",
            "box2"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "box_ov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "525-532",
          "snippet": "static bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool box_ov(BOX *box1, BOX *box2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nstatic bool\nbox_ov(BOX *box1, BOX *box2)\n{\n\treturn (FPle(box1->low.x, box2->high.x) &&\n\t\t\tFPle(box2->low.x, box1->high.x) &&\n\t\t\tFPle(box1->low.y, box2->high.y) &&\n\t\t\tFPle(box2->low.y, box1->high.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\n\nDatum\nbox_overlap(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(box_ov(box1, box2));\n}"
  },
  {
    "function_name": "box_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "502-512",
    "snippet": "Datum\nbox_same(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPeq(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPeq(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPeq(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPeq(box1->low.y, box2->low.y));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool box_ov(BOX *box1, BOX *box2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "FPeq(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPeq(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPeq(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPeq(box1->low.y, box2->low.y)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "box1->low.y",
            "box2->low.y"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "box1->high.y",
            "box2->high.y"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "box1->low.x",
            "box2->low.x"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPeq",
          "args": [
            "box1->high.x",
            "box2->high.x"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "1"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic bool box_ov(BOX *box1, BOX *box2);\nstatic Point *point_construct(double x, double y);\n\nDatum\nbox_same(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPeq(box1->high.x, box2->high.x) &&\n\t\t\t\t   FPeq(box1->low.x, box2->low.x) &&\n\t\t\t\t   FPeq(box1->high.y, box2->high.y) &&\n\t\t\t\t   FPeq(box1->low.y, box2->low.y));\n}"
  },
  {
    "function_name": "box_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "484-492",
    "snippet": "BOX *\nbox_copy(BOX *box)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\tmemcpy((char *) result, (char *) box, sizeof(BOX));\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) result",
            "(char *) box",
            "sizeof(BOX)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nBOX *\nbox_copy(BOX *box)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\tmemcpy((char *) result, (char *) box, sizeof(BOX));\n\n\treturn result;\n}"
  },
  {
    "function_name": "box_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "454-479",
    "snippet": "static BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static BOX *box_construct(double x1, double x2, double y1, double y2);",
      "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
      "static Point *point_construct(double x, double y);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic Point *point_construct(double x, double y);\n\nstatic BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "box_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "443-449",
    "snippet": "static BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static BOX *box_construct(double x1, double x2, double y1, double y2);",
      "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "box_fill",
          "args": [
            "result",
            "x1",
            "x2",
            "y1",
            "y2"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "box_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "454-479",
          "snippet": "static BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BOX *box_construct(double x1, double x2, double y1, double y2);",
            "static BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);",
            "static Point *point_construct(double x, double y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\nstatic Point *point_construct(double x, double y);\n\nstatic BOX *\nbox_fill(BOX *result, double x1, double x2, double y1, double y2)\n{\n\tif (x1 > x2)\n\t{\n\t\tresult->high.x = x1;\n\t\tresult->low.x = x2;\n\t}\n\telse\n\t{\n\t\tresult->high.x = x2;\n\t\tresult->low.x = x1;\n\t}\n\tif (y1 > y2)\n\t{\n\t\tresult->high.y = y1;\n\t\tresult->low.y = y2;\n\t}\n\telse\n\t{\n\t\tresult->high.y = y2;\n\t\tresult->low.y = y1;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic BOX *box_construct(double x1, double x2, double y1, double y2);\nstatic BOX *box_fill(BOX *result, double x1, double x2, double y1, double y2);\n\nstatic BOX *\nbox_construct(double x1, double x2, double y1, double y2)\n{\n\tBOX\t\t   *result = (BOX *) palloc(sizeof(BOX));\n\n\treturn box_fill(result, x1, x2, y1, y2);\n}"
  },
  {
    "function_name": "box_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "426-438",
    "snippet": "Datum\nbox_send(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, box->high.x);\n\tpq_sendfloat8(&buf, box->high.y);\n\tpq_sendfloat8(&buf, box->low.x);\n\tpq_sendfloat8(&buf, box->low.y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "box->low.y"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "box->low.x"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "box->high.y"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendfloat8",
          "args": [
            "&buf",
            "box->high.x"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_send(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, box->high.x);\n\tpq_sendfloat8(&buf, box->high.y);\n\tpq_sendfloat8(&buf, box->low.x);\n\tpq_sendfloat8(&buf, box->low.y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "box_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "391-421",
    "snippet": "Datum\nbox_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tBOX\t\t   *box;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\tbox = (BOX *) palloc(sizeof(BOX));\n\n\tbox->high.x = pq_getmsgfloat8(buf);\n\tbox->high.y = pq_getmsgfloat8(buf);\n\tbox->low.x = pq_getmsgfloat8(buf);\n\tbox->low.y = pq_getmsgfloat8(buf);\n\n\t/* reorder corners if necessary... */\n\tif (box->high.x < box->low.x)\n\t{\n\t\tx = box->high.x;\n\t\tbox->high.x = box->low.x;\n\t\tbox->low.x = x;\n\t}\n\tif (box->high.y < box->low.y)\n\t{\n\t\ty = box->high.y;\n\t\tbox->high.y = box->low.y;\n\t\tbox->low.y = y;\n\t}\n\n\tPG_RETURN_BOX_P(box);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgfloat8",
          "args": [
            "buf"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tBOX\t\t   *box;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\tbox = (BOX *) palloc(sizeof(BOX));\n\n\tbox->high.x = pq_getmsgfloat8(buf);\n\tbox->high.y = pq_getmsgfloat8(buf);\n\tbox->low.x = pq_getmsgfloat8(buf);\n\tbox->low.y = pq_getmsgfloat8(buf);\n\n\t/* reorder corners if necessary... */\n\tif (box->high.x < box->low.x)\n\t{\n\t\tx = box->high.x;\n\t\tbox->high.x = box->low.x;\n\t\tbox->low.x = x;\n\t}\n\tif (box->high.y < box->low.y)\n\t{\n\t\ty = box->high.y;\n\t\tbox->high.y = box->low.y;\n\t\tbox->low.y = y;\n\t}\n\n\tPG_RETURN_BOX_P(box);\n}"
  },
  {
    "function_name": "box_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "380-386",
    "snippet": "Datum\nbox_out(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_NONE, 2, &(box->high)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "path_encode(PATH_NONE, 2, &(box->high))"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_encode",
          "args": [
            "PATH_NONE",
            "2",
            "&(box->high)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "path_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "268-311",
          "snippet": "static char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static Point *point_copy(Point *pt);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOX_P",
          "args": [
            "0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_out(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\n\tPG_RETURN_CSTRING(path_encode(PATH_NONE, 2, &(box->high)));\n}"
  },
  {
    "function_name": "box_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "350-376",
    "snippet": "Datum\nbox_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tBOX\t\t   *box = (BOX *) palloc(sizeof(BOX));\n\tbool\t\tisopen;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\tpath_decode(str, false, 2, &(box->high), &isopen, NULL, \"box\", str);\n\n\t/* reorder corners if necessary... */\n\tif (box->high.x < box->low.x)\n\t{\n\t\tx = box->high.x;\n\t\tbox->high.x = box->low.x;\n\t\tbox->low.x = x;\n\t}\n\tif (box->high.y < box->low.y)\n\t{\n\t\ty = box->high.y;\n\t\tbox->high.y = box->low.y;\n\t\tbox->low.y = y;\n\t}\n\n\tPG_RETURN_BOX_P(box);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double box_ht(BOX *box);",
      "static double box_wd(BOX *box);",
      "static Point *point_construct(double x, double y);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static double box_ar(BOX *box);",
      "static void box_cn(Point *center, BOX *box);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOX_P",
          "args": [
            "box"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_decode",
          "args": [
            "str",
            "false",
            "2",
            "&(box->high)",
            "&isopen",
            "NULL",
            "\"box\"",
            "str"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "path_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "192-266",
          "snippet": "static void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RDELIM_EP\t\t']'",
            "#define LDELIM_EP\t\t'['",
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(BOX)"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\n\nDatum\nbox_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tBOX\t\t   *box = (BOX *) palloc(sizeof(BOX));\n\tbool\t\tisopen;\n\tdouble\t\tx,\n\t\t\t\ty;\n\n\tpath_decode(str, false, 2, &(box->high), &isopen, NULL, \"box\", str);\n\n\t/* reorder corners if necessary... */\n\tif (box->high.x < box->low.x)\n\t{\n\t\tx = box->high.x;\n\t\tbox->high.x = box->low.x;\n\t\tbox->low.x = x;\n\t}\n\tif (box->high.y < box->low.y)\n\t{\n\t\ty = box->high.y;\n\t\tbox->high.y = box->low.y;\n\t\tbox->low.y = y;\n\t}\n\n\tPG_RETURN_BOX_P(box);\n}"
  },
  {
    "function_name": "pair_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "320-331",
    "snippet": "static int\npair_count(char *s, char delim)\n{\n\tint\t\t\tndelim = 0;\n\n\twhile ((s = strchr(s, delim)) != NULL)\n\t{\n\t\tndelim++;\n\t\ts++;\n\t}\n\treturn (ndelim % 2) ? ((ndelim + 1) / 2) : -1;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tpair_count(char *s, char delim);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "delim"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic int\tpair_count(char *s, char delim);\n\nstatic int\npair_count(char *s, char delim)\n{\n\tint\t\t\tndelim = 0;\n\n\twhile ((s = strchr(s, delim)) != NULL)\n\t{\n\t\tndelim++;\n\t\ts++;\n\t}\n\treturn (ndelim % 2) ? ((ndelim + 1) / 2) : -1;\n}"
  },
  {
    "function_name": "path_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "268-311",
    "snippet": "static char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RDELIM_EP\t\t']'",
      "#define LDELIM_EP\t\t'['",
      "#define DELIM\t\t\t','",
      "#define RDELIM\t\t\t')'",
      "#define LDELIM\t\t\t'('"
    ],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static Point *point_copy(Point *pt);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static char *path_encode(enum path_delim path_delim, int npts, Point *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "RDELIM_EP"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "RDELIM"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "RDELIM"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_encode",
          "args": [
            "pt->x",
            "pt->y",
            "&str"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "pair_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "181-190",
          "snippet": "static void\npair_encode(float8 x, float8 y, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\tchar\t   *ystr = float8out_internal(y);\n\n\tappendStringInfo(str, \"%s,%s\", xstr, ystr);\n\tpfree(xstr);\n\tpfree(ystr);\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nstatic void\npair_encode(float8 x, float8 y, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\tchar\t   *ystr = float8out_internal(y);\n\n\tappendStringInfo(str, \"%s,%s\", xstr, ystr);\n\tpfree(xstr);\n\tpfree(ystr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "LDELIM"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "DELIM"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "LDELIM_EP"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "LDELIM"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic Point *point_copy(Point *pt);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic char *path_encode(enum path_delim path_delim, int npts, Point *pt);\n\nstatic char *\npath_encode(enum path_delim path_delim, int npts, Point *pt)\n{\n\tStringInfoData str;\n\tint\t\t\ti;\n\n\tinitStringInfo(&str);\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, LDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, LDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, DELIM);\n\t\tappendStringInfoChar(&str, LDELIM);\n\t\tpair_encode(pt->x, pt->y, &str);\n\t\tappendStringInfoChar(&str, RDELIM);\n\t\tpt++;\n\t}\n\n\tswitch (path_delim)\n\t{\n\t\tcase PATH_CLOSED:\n\t\t\tappendStringInfoChar(&str, RDELIM);\n\t\t\tbreak;\n\t\tcase PATH_OPEN:\n\t\t\tappendStringInfoChar(&str, RDELIM_EP);\n\t\t\tbreak;\n\t\tcase PATH_NONE:\n\t\t\tbreak;\n\t}\n\n\treturn str.data;\n}"
  },
  {
    "function_name": "path_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "192-266",
    "snippet": "static void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RDELIM_EP\t\t']'",
      "#define LDELIM_EP\t\t'['",
      "#define DELIM\t\t\t','",
      "#define RDELIM\t\t\t')'",
      "#define LDELIM\t\t\t'('"
    ],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "type_name",
            "orig_string"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pair_decode",
          "args": [
            "str",
            "&(p->x)",
            "&(p->y)",
            "&str",
            "type_name",
            "orig_string"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "pair_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "139-179",
          "snippet": "static void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DELIM\t\t\t','",
            "#define RDELIM\t\t\t')'",
            "#define LDELIM\t\t\t'('"
          ],
          "globals_used": [
            "static Point *point_construct(double x, double y);",
            "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
            "static void single_encode(float8 x, StringInfo str);",
            "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
            "static void pair_encode(float8 x, float8 y, StringInfo str);",
            "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "LDELIM"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define RDELIM_EP\t\t']'\n#define LDELIM_EP\t\t'['\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npath_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tint\t\t\tdepth = 0;\n\tchar\t   *cp;\n\tint\t\t\ti;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((*isopen = (*str == LDELIM_EP)))\n\t{\n\t\t/* no open delimiter allowed? */\n\t\tif (!opentype)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\tdepth++;\n\t\tstr++;\n\t}\n\telse if (*str == LDELIM)\n\t{\n\t\tcp = (str + 1);\n\t\twhile (isspace((unsigned char) *cp))\n\t\t\tcp++;\n\t\tif (*cp == LDELIM)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t\telse if (strrchr(str, LDELIM) == str)\n\t\t{\n\t\t\tdepth++;\n\t\t\tstr = cp;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npts; i++)\n\t{\n\t\tpair_decode(str, &(p->x), &(p->y), &str, type_name, orig_string);\n\t\tif (*str == DELIM)\n\t\t\tstr++;\n\t\tp++;\n\t}\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\twhile (depth > 0)\n\t{\n\t\tif ((*str == RDELIM)\n\t\t\t|| ((*str == RDELIM_EP) && (*isopen) && (depth == 1)))\n\t\t{\n\t\t\tdepth--;\n\t\t\tstr++;\n\t\t\twhile (isspace((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
  },
  {
    "function_name": "pair_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "181-190",
    "snippet": "static void\npair_encode(float8 x, float8 y, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\tchar\t   *ystr = float8out_internal(y);\n\n\tappendStringInfo(str, \"%s,%s\", xstr, ystr);\n\tpfree(xstr);\n\tpfree(ystr);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ystr"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "str",
            "\"%s,%s\"",
            "xstr",
            "ystr"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8out_internal",
          "args": [
            "y"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "float8out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "592-620",
          "snippet": "char *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\textra_float_digits = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\textra_float_digits = 0;\n\nchar *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Point *point_construct(double x, double y);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nstatic void\npair_encode(float8 x, float8 y, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\tchar\t   *ystr = float8out_internal(y);\n\n\tappendStringInfo(str, \"%s,%s\", xstr, ystr);\n\tpfree(xstr);\n\tpfree(ystr);\n}"
  },
  {
    "function_name": "pair_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "139-179",
    "snippet": "static void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DELIM\t\t\t','",
      "#define RDELIM\t\t\t')'",
      "#define LDELIM\t\t\t'('"
    ],
    "globals_used": [
      "static Point *point_construct(double x, double y);",
      "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);",
      "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "type_name",
            "orig_string"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8in_internal",
          "args": [
            "str",
            "&str",
            "type_name",
            "orig_string"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "float8in_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "440-571",
          "snippet": "double\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\n#define DELIM\t\t\t','\n#define RDELIM\t\t\t')'\n#define LDELIM\t\t\t'('\n\nstatic Point *point_construct(double x, double y);\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic void\npair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string)\n{\n\tbool\t\thas_delim;\n\n\twhile (isspace((unsigned char) *str))\n\t\tstr++;\n\tif ((has_delim = (*str == LDELIM)))\n\t\tstr++;\n\n\t*x = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (*str++ != DELIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\t*y = float8in_internal(str, &str, type_name, orig_string);\n\n\tif (has_delim)\n\t{\n\t\tif (*str++ != RDELIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t\twhile (isspace((unsigned char) *str))\n\t\t\tstr++;\n\t}\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = str;\n\telse if (*str != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n}"
  },
  {
    "function_name": "single_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "130-137",
    "snippet": "static void\nsingle_encode(float8 x, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\n\tappendStringInfoString(str, xstr);\n\tpfree(xstr);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void single_encode(float8 x, StringInfo str);",
      "static void pair_encode(float8 x, float8 y, StringInfo str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "xstr"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "str",
            "xstr"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float8out_internal",
          "args": [
            "x"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "float8out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "592-620",
          "snippet": "char *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\textra_float_digits = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\textra_float_digits = 0;\n\nchar *\nfloat8out_internal(double num)\n{\n\tchar\t   *ascii;\n\n\tif (isnan(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tswitch (is_infinite(num))\n\t{\n\t\tcase 1:\n\t\t\tascii = pstrdup(\"Infinity\");\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tascii = pstrdup(\"-Infinity\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\t\t\t\tif (ndig < 1)\n\t\t\t\t\tndig = 1;\n\n\t\t\t\tascii = psprintf(\"%.*g\", ndig, num);\n\t\t\t}\n\t}\n\n\treturn ascii;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic void single_encode(float8 x, StringInfo str);\nstatic void pair_encode(float8 x, float8 y, StringInfo str);\n\nstatic void\nsingle_encode(float8 x, StringInfo str)\n{\n\tchar\t   *xstr = float8out_internal(x);\n\n\tappendStringInfoString(str, xstr);\n\tpfree(xstr);\n}"
  },
  {
    "function_name": "single_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
    "lines": "123-128",
    "snippet": "static double\nsingle_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string)\n{\n\treturn float8in_internal(num, endptr_p, type_name, orig_string);\n}",
    "includes": [
      "#include \"utils/geo_decls.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <ctype.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);",
      "static void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);",
      "static void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "float8in_internal",
          "args": [
            "num",
            "endptr_p",
            "type_name",
            "orig_string"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "float8in_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "440-571",
          "snippet": "double\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nfloat8in_internal(char *num, char **endptr_p,\n\t\t\t\t  const char *type_name, const char *orig_string)\n{\n\tdouble\t\tval;\n\tchar\t   *endptr;\n\n\t/* skip leading whitespace */\n\twhile (*num != '\\0' && isspace((unsigned char) *num))\n\t\tnum++;\n\n\t/*\n\t * Check for an empty-string input to begin with, to avoid the vagaries of\n\t * strtod() on different platforms.\n\t */\n\tif (*num == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\terrno = 0;\n\tval = strtod(num, &endptr);\n\n\t/* did we not see anything that looks like a double? */\n\tif (endptr == num || errno != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,\n\t\t * but not all platforms support all of these (and some accept them\n\t\t * but set ERANGE anyway...)  Therefore, we check for these inputs\n\t\t * ourselves if strtod() fails.\n\t\t *\n\t\t * Note: C99 also requires hexadecimal input as well as some extended\n\t\t * forms of NaN, but we consider these forms unportable and don't try\n\t\t * to support them.  You can use 'em if your strtod() takes 'em.\n\t\t */\n\t\tif (pg_strncasecmp(num, \"NaN\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_nan();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"Infinity\", 8) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 8;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-Infinity\", 9) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 9;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"inf\", 3) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 3;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"+inf\", 4) == 0)\n\t\t{\n\t\t\tval = get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (pg_strncasecmp(num, \"-inf\", 4) == 0)\n\t\t{\n\t\t\tval = -get_float8_infinity();\n\t\t\tendptr = num + 4;\n\t\t}\n\t\telse if (save_errno == ERANGE)\n\t\t{\n\t\t\t/*\n\t\t\t * Some platforms return ERANGE for denormalized numbers (those\n\t\t\t * that are not zero, but are too close to zero to have full\n\t\t\t * precision).  We'd prefer not to throw error for that, so try to\n\t\t\t * detect whether it's a \"real\" out-of-range condition by checking\n\t\t\t * to see if the result is zero or huge.\n\t\t\t *\n\t\t\t * On error, we intentionally complain about double precision not\n\t\t\t * the given type name, and we print only the part of the string\n\t\t\t * that is the current number.\n\t\t\t */\n\t\t\tif (val == 0.0 || val >= HUGE_VAL || val <= -HUGE_VAL)\n\t\t\t{\n\t\t\t\tchar\t   *errnumber = pstrdup(num);\n\n\t\t\t\terrnumber[endptr - num] = '\\0';\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"\\\"%s\\\" is out of range for type double precision\",\n\t\t\t\t\t\t\t\terrnumber)));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\ttype_name, orig_string)));\n\t}\n#ifdef HAVE_BUGGY_SOLARIS_STRTOD\n\telse\n\t{\n\t\t/*\n\t\t * Many versions of Solaris have a bug wherein strtod sets endptr to\n\t\t * point one byte beyond the end of the string when given \"inf\" or\n\t\t * \"infinity\".\n\t\t */\n\t\tif (endptr != num && endptr[-1] == '\\0')\n\t\t\tendptr--;\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_BUGGY_SOLARIS_STRTOD */\n\n\t/* skip trailing whitespace */\n\twhile (*endptr != '\\0' && isspace((unsigned char) *endptr))\n\t\tendptr++;\n\n\t/* report stopping point if wanted, else complain if not end of string */\n\tif (endptr_p)\n\t\t*endptr_p = endptr;\n\telse if (*endptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\ttype_name, orig_string)));\n\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double single_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string);\nstatic void pair_decode(char *str, double *x, double *y, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\nstatic void path_decode(char *str, bool opentype, int npts, Point *p,\n\t\t\tbool *isopen, char **endptr_p,\n\t\t\tconst char *type_name, const char *orig_string);\n\nstatic double\nsingle_decode(char *num, char **endptr_p,\n\t\t\t  const char *type_name, const char *orig_string)\n{\n\treturn float8in_internal(num, endptr_p, type_name, orig_string);\n}"
  }
]