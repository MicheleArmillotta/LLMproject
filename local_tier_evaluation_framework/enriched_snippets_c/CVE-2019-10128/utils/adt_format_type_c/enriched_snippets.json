[
  {
    "function_name": "oidvectortypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "431-469",
    "snippet": "Datum\noidvectortypes(PG_FUNCTION_ARGS)\n{\n\toidvector  *oidArray = (oidvector *) PG_GETARG_POINTER(0);\n\tchar\t   *result;\n\tint\t\t\tnumargs = oidArray->dim1;\n\tint\t\t\tnum;\n\tsize_t\t\ttotal;\n\tsize_t\t\tleft;\n\n\ttotal = 20 * numargs + 1;\n\tresult = palloc(total);\n\tresult[0] = '\\0';\n\tleft = total - 1;\n\n\tfor (num = 0; num < numargs; num++)\n\t{\n\t\tchar\t   *typename = format_type_extended(oidArray->values[num], -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tFORMAT_TYPE_ALLOW_INVALID);\n\t\tsize_t\t\tslen = strlen(typename);\n\n\t\tif (left < (slen + 2))\n\t\t{\n\t\t\ttotal += slen + 2;\n\t\t\tresult = repalloc(result, total);\n\t\t\tleft += slen + 2;\n\t\t}\n\n\t\tif (num > 0)\n\t\t{\n\t\t\tstrcat(result, \", \");\n\t\t\tleft -= 2;\n\t\t}\n\t\tstrcat(result, typename);\n\t\tleft -= slen;\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(result)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "result"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "result",
            "typename"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "225-243",
          "snippet": "int\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "result",
            "total"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "typename"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_extended",
          "args": [
            "oidArray->values[num]",
            "-1",
            "FORMAT_TYPE_ALLOW_INVALID"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "109-319",
          "snippet": "char *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nchar *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "total"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectortypes(PG_FUNCTION_ARGS)\n{\n\toidvector  *oidArray = (oidvector *) PG_GETARG_POINTER(0);\n\tchar\t   *result;\n\tint\t\t\tnumargs = oidArray->dim1;\n\tint\t\t\tnum;\n\tsize_t\t\ttotal;\n\tsize_t\t\tleft;\n\n\ttotal = 20 * numargs + 1;\n\tresult = palloc(total);\n\tresult[0] = '\\0';\n\tleft = total - 1;\n\n\tfor (num = 0; num < numargs; num++)\n\t{\n\t\tchar\t   *typename = format_type_extended(oidArray->values[num], -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tFORMAT_TYPE_ALLOW_INVALID);\n\t\tsize_t\t\tslen = strlen(typename);\n\n\t\tif (left < (slen + 2))\n\t\t{\n\t\t\ttotal += slen + 2;\n\t\t\tresult = repalloc(result, total);\n\t\t\tleft += slen + 2;\n\t\t}\n\n\t\tif (num > 0)\n\t\t{\n\t\t\tstrcat(result, \", \");\n\t\t\tleft -= 2;\n\t\t}\n\t\tstrcat(result, typename);\n\t\tleft -= slen;\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}"
  },
  {
    "function_name": "type_maximum_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "396-425",
    "snippet": "int32\ntype_maximum_size(Oid type_oid, int32 typemod)\n{\n\tif (typemod < 0)\n\t\treturn -1;\n\n\tswitch (type_oid)\n\t{\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\t\t/* typemod includes varlena header */\n\n\t\t\t/* typemod is in characters not bytes */\n\t\t\treturn (typemod - VARHDRSZ) *\n\t\t\t\tpg_encoding_max_length(GetDatabaseEncoding())\n\t\t\t\t+ VARHDRSZ;\n\n\t\tcase NUMERICOID:\n\t\t\treturn numeric_maximum_size(typemod);\n\n\t\tcase VARBITOID:\n\t\tcase BITOID:\n\t\t\t/* typemod is the (max) number of bits */\n\t\t\treturn (typemod + (BITS_PER_BYTE - 1)) / BITS_PER_BYTE\n\t\t\t\t+ 2 * sizeof(int32);\n\t}\n\n\t/* Unknown type, or unlimited-width type such as 'text' */\n\treturn -1;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numeric_maximum_size",
          "args": [
            "typemod"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_maximum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numeric.c",
          "lines": "690-722",
          "snippet": "int32\nnumeric_maximum_size(int32 typmod)\n{\n\tint\t\t\tprecision;\n\tint\t\t\tnumeric_digits;\n\n\tif (typmod < (int32) (VARHDRSZ))\n\t\treturn -1;\n\n\t/* precision (ie, max # of digits) is in upper bits of typmod */\n\tprecision = ((typmod - VARHDRSZ) >> 16) & 0xffff;\n\n\t/*\n\t * This formula computes the maximum number of NumericDigits we could need\n\t * in order to store the specified number of decimal digits. Because the\n\t * weight is stored as a number of NumericDigits rather than a number of\n\t * decimal digits, it's possible that the first NumericDigit will contain\n\t * only a single decimal digit.  Thus, the first two decimal digits can\n\t * require two NumericDigits to store, but it isn't until we reach\n\t * DEC_DIGITS + 2 decimal digits that we potentially need a third\n\t * NumericDigit.\n\t */\n\tnumeric_digits = (precision + 2 * (DEC_DIGITS - 1)) / DEC_DIGITS;\n\n\t/*\n\t * In most cases, the size of a numeric will be smaller than the value\n\t * computed below, because the varlena header will typically get toasted\n\t * down to a single byte before being stored on disk, and it may also be\n\t * possible to use a short numeric header.  But our job here is to compute\n\t * the worst case.\n\t */\n\treturn NUMERIC_HDRSZ + (numeric_digits * sizeof(NumericDigit));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUMERIC_HDRSZ\t(VARHDRSZ + sizeof(uint16) + sizeof(int16))",
            "#define DEC_DIGITS\t4\t\t\t/* decimal digits per NBASE digit */",
            "#define DEC_DIGITS\t2\t\t\t/* decimal digits per NBASE digit */",
            "#define DEC_DIGITS\t1\t\t\t/* decimal digits per NBASE digit */"
          ],
          "globals_used": [
            "static void apply_typmod(NumericVar *var, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"funcapi.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUMERIC_HDRSZ\t(VARHDRSZ + sizeof(uint16) + sizeof(int16))\n#define DEC_DIGITS\t4\t\t\t/* decimal digits per NBASE digit */\n#define DEC_DIGITS\t2\t\t\t/* decimal digits per NBASE digit */\n#define DEC_DIGITS\t1\t\t\t/* decimal digits per NBASE digit */\n\nstatic void apply_typmod(NumericVar *var, int32 typmod);\n\nint32\nnumeric_maximum_size(int32 typmod)\n{\n\tint\t\t\tprecision;\n\tint\t\t\tnumeric_digits;\n\n\tif (typmod < (int32) (VARHDRSZ))\n\t\treturn -1;\n\n\t/* precision (ie, max # of digits) is in upper bits of typmod */\n\tprecision = ((typmod - VARHDRSZ) >> 16) & 0xffff;\n\n\t/*\n\t * This formula computes the maximum number of NumericDigits we could need\n\t * in order to store the specified number of decimal digits. Because the\n\t * weight is stored as a number of NumericDigits rather than a number of\n\t * decimal digits, it's possible that the first NumericDigit will contain\n\t * only a single decimal digit.  Thus, the first two decimal digits can\n\t * require two NumericDigits to store, but it isn't until we reach\n\t * DEC_DIGITS + 2 decimal digits that we potentially need a third\n\t * NumericDigit.\n\t */\n\tnumeric_digits = (precision + 2 * (DEC_DIGITS - 1)) / DEC_DIGITS;\n\n\t/*\n\t * In most cases, the size of a numeric will be smaller than the value\n\t * computed below, because the varlena header will typically get toasted\n\t * down to a single byte before being stored on disk, and it may also be\n\t * possible to use a short numeric header.  But our job here is to compute\n\t * the worst case.\n\t */\n\treturn NUMERIC_HDRSZ + (numeric_digits * sizeof(NumericDigit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_max_length",
          "args": [
            "GetDatabaseEncoding()"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1819-1825",
          "snippet": "int\npg_encoding_max_length(int encoding)\n{\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\treturn pg_wchar_table[encoding].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_encoding_max_length(int encoding)\n{\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\treturn pg_wchar_table[encoding].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nint32\ntype_maximum_size(Oid type_oid, int32 typemod)\n{\n\tif (typemod < 0)\n\t\treturn -1;\n\n\tswitch (type_oid)\n\t{\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\t\t/* typemod includes varlena header */\n\n\t\t\t/* typemod is in characters not bytes */\n\t\t\treturn (typemod - VARHDRSZ) *\n\t\t\t\tpg_encoding_max_length(GetDatabaseEncoding())\n\t\t\t\t+ VARHDRSZ;\n\n\t\tcase NUMERICOID:\n\t\t\treturn numeric_maximum_size(typemod);\n\n\t\tcase VARBITOID:\n\t\tcase BITOID:\n\t\t\t/* typemod is the (max) number of bits */\n\t\t\treturn (typemod + (BITS_PER_BYTE - 1)) / BITS_PER_BYTE\n\t\t\t\t+ 2 * sizeof(int32);\n\t}\n\n\t/* Unknown type, or unlimited-width type such as 'text' */\n\treturn -1;\n}"
  },
  {
    "function_name": "printTypmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "355-379",
    "snippet": "static char *\nprintTypmod(const char *typname, int32 typmod, Oid typmodout)\n{\n\tchar\t   *res;\n\n\t/* Shouldn't be called if typmod is -1 */\n\tAssert(typmod >= 0);\n\n\tif (typmodout == InvalidOid)\n\t{\n\t\t/* Default behavior: just print the integer typmod with parens */\n\t\tres = psprintf(\"%s(%d)\", typname, (int) typmod);\n\t}\n\telse\n\t{\n\t\t/* Use the type-specific typmodout procedure */\n\t\tchar\t   *tmstr;\n\n\t\ttmstr = DatumGetCString(OidFunctionCall1(typmodout,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(typmod)));\n\t\tres = psprintf(\"%s%s\", typname, tmstr);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s\"",
            "typname",
            "tmstr"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "OidFunctionCall1(typmodout,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(typmod))"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidFunctionCall1",
          "args": [
            "typmodout",
            "Int32GetDatum(typmod)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "typmod"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s(%d)\"",
            "typname",
            "(int) typmod"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typmod >= 0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nstatic char *\nprintTypmod(const char *typname, int32 typmod, Oid typmodout)\n{\n\tchar\t   *res;\n\n\t/* Shouldn't be called if typmod is -1 */\n\tAssert(typmod >= 0);\n\n\tif (typmodout == InvalidOid)\n\t{\n\t\t/* Default behavior: just print the integer typmod with parens */\n\t\tres = psprintf(\"%s(%d)\", typname, (int) typmod);\n\t}\n\telse\n\t{\n\t\t/* Use the type-specific typmodout procedure */\n\t\tchar\t   *tmstr;\n\n\t\ttmstr = DatumGetCString(OidFunctionCall1(typmodout,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(typmod)));\n\t\tres = psprintf(\"%s%s\", typname, tmstr);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "format_type_with_typemod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "346-350",
    "snippet": "char *\nformat_type_with_typemod(Oid type_oid, int32 typemod)\n{\n\treturn format_type_extended(type_oid, typemod, FORMAT_TYPE_TYPEMOD_GIVEN);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_type_extended",
          "args": [
            "type_oid",
            "typemod",
            "FORMAT_TYPE_TYPEMOD_GIVEN"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "109-319",
          "snippet": "char *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nchar *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_with_typemod(Oid type_oid, int32 typemod)\n{\n\treturn format_type_extended(type_oid, typemod, FORMAT_TYPE_TYPEMOD_GIVEN);\n}"
  },
  {
    "function_name": "format_type_be_qualified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "337-341",
    "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_type_extended",
          "args": [
            "type_oid",
            "-1",
            "FORMAT_TYPE_FORCE_QUALIFY"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "109-319",
          "snippet": "char *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nchar *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
  },
  {
    "function_name": "format_type_be",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "327-331",
    "snippet": "char *\nformat_type_be(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_type_extended",
          "args": [
            "type_oid",
            "-1",
            "0"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "109-319",
          "snippet": "char *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nchar *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, 0);\n}"
  },
  {
    "function_name": "format_type_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "109-319",
    "snippet": "char *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s[]\"",
            "buf"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printTypmod",
          "args": [
            "buf",
            "typemod",
            "typeform->typmodout"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "printTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "355-379",
          "snippet": "static char *\nprintTypmod(const char *typname, int32 typmod, Oid typmodout)\n{\n\tchar\t   *res;\n\n\t/* Shouldn't be called if typmod is -1 */\n\tAssert(typmod >= 0);\n\n\tif (typmodout == InvalidOid)\n\t{\n\t\t/* Default behavior: just print the integer typmod with parens */\n\t\tres = psprintf(\"%s(%d)\", typname, (int) typmod);\n\t}\n\telse\n\t{\n\t\t/* Use the type-specific typmodout procedure */\n\t\tchar\t   *tmstr;\n\n\t\ttmstr = DatumGetCString(OidFunctionCall1(typmodout,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(typmod)));\n\t\tres = psprintf(\"%s%s\", typname, tmstr);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nstatic char *\nprintTypmod(const char *typname, int32 typmod, Oid typmodout)\n{\n\tchar\t   *res;\n\n\t/* Shouldn't be called if typmod is -1 */\n\tAssert(typmod >= 0);\n\n\tif (typmodout == InvalidOid)\n\t{\n\t\t/* Default behavior: just print the integer typmod with parens */\n\t\tres = psprintf(\"%s(%d)\", typname, (int) typmod);\n\t}\n\telse\n\t{\n\t\t/* Use the type-specific typmodout procedure */\n\t\tchar\t   *tmstr;\n\n\t\ttmstr = DatumGetCString(OidFunctionCall1(typmodout,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(typmod)));\n\t\tres = psprintf(\"%s%s\", typname, tmstr);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "nspname",
            "typname"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "typeform->typname"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name_or_temp",
          "args": [
            "typeform->typnamespace"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TypeIsVisible",
          "args": [
            "type_oid"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"character varying\""
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for type %u\"",
            "type_oid"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(array_base_type)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "array_base_type"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "type_oid"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nchar *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}"
  },
  {
    "function_name": "format_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
    "lines": "60-85",
    "snippet": "Datum\nformat_type(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttype_oid;\n\tint32\t\ttypemod;\n\tchar\t   *result;\n\tbits16\t\tflags = FORMAT_TYPE_ALLOW_INVALID;\n\n\t/* Since this function is not strict, we must test for null args */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\ttype_oid = PG_GETARG_OID(0);\n\n\tif (PG_ARGISNULL(1))\n\t\ttypemod = -1;\n\telse\n\t{\n\t\ttypemod = PG_GETARG_INT32(1);\n\t\tflags |= FORMAT_TYPE_TYPEMOD_GIVEN;\n\t}\n\n\tresult = format_type_extended(type_oid, typemod, flags);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(result)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "result"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_extended",
          "args": [
            "type_oid",
            "typemod",
            "flags"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "109-319",
          "snippet": "char *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *printTypmod(const char *typname, int32 typmod, Oid typmodout);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *printTypmod(const char *typname, int32 typmod, Oid typmodout);\n\nchar *\nformat_type_extended(Oid type_oid, int32 typemod, bits16 flags)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_type typeform;\n\tOid\t\t\tarray_base_type;\n\tbool\t\tis_array;\n\tchar\t   *buf;\n\tbool\t\twith_typemod;\n\n\tif (type_oid == InvalidOid && (flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\treturn pstrdup(\"-\");\n\n\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_oid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\treturn pstrdup(\"???\");\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t}\n\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\n\t/*\n\t * Check if it's a regular (variable length) array type.  Fixed-length\n\t * array types such as \"name\" shouldn't get deconstructed.  As of Postgres\n\t * 8.1, rather than checking typlen we check the toast property, and don't\n\t * deconstruct \"plain storage\" array types --- this is because we don't\n\t * want to show oidvector as oid[].\n\t */\n\tarray_base_type = typeform->typelem;\n\n\tif (array_base_type != InvalidOid && typeform->typstorage != 'p')\n\t{\n\t\t/* Switch our attention to the array element type */\n\t\tReleaseSysCache(tuple);\n\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t{\n\t\t\tif ((flags & FORMAT_TYPE_ALLOW_INVALID) != 0)\n\t\t\t\treturn pstrdup(\"???[]\");\n\t\t\telse\n\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", type_oid);\n\t\t}\n\t\ttypeform = (Form_pg_type) GETSTRUCT(tuple);\n\t\ttype_oid = array_base_type;\n\t\tis_array = true;\n\t}\n\telse\n\t\tis_array = false;\n\n\twith_typemod = (flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0 && (typemod >= 0);\n\n\t/*\n\t * See if we want to special-case the output for certain built-in types.\n\t * Note that these special cases should all correspond to special\n\t * productions in gram.y, to ensure that the type name will be taken as a\n\t * system type, not a user type of the same name.\n\t *\n\t * If we do not provide a special-case output here, the type name will be\n\t * handled the same way as a user type name --- in particular, it will be\n\t * double-quoted if it matches any lexer keyword.  This behavior is\n\t * essential for some cases, such as types \"bit\" and \"char\".\n\t */\n\tbuf = NULL;\t\t\t\t\t/* flag for no special case */\n\n\tswitch (type_oid)\n\t{\n\t\tcase BITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bit with typmod -1 is not the same as BIT, which means\n\t\t\t\t * BIT(1) per SQL spec.  Report it as the quoted typename so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit\");\n\t\t\tbreak;\n\n\t\tcase BOOLOID:\n\t\t\tbuf = pstrdup(\"boolean\");\n\t\t\tbreak;\n\n\t\tcase BPCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character\", typemod, typeform->typmodout);\n\t\t\telse if ((flags & FORMAT_TYPE_TYPEMOD_GIVEN) != 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * bpchar with typmod -1 is not the same as CHARACTER, which\n\t\t\t\t * means CHARACTER(1) per SQL spec.  Report it as bpchar so\n\t\t\t\t * that parser will not assign a bogus typmod.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character\");\n\t\t\tbreak;\n\n\t\tcase FLOAT4OID:\n\t\t\tbuf = pstrdup(\"real\");\n\t\t\tbreak;\n\n\t\tcase FLOAT8OID:\n\t\t\tbuf = pstrdup(\"double precision\");\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\t\tbuf = pstrdup(\"smallint\");\n\t\t\tbreak;\n\n\t\tcase INT4OID:\n\t\t\tbuf = pstrdup(\"integer\");\n\t\t\tbreak;\n\n\t\tcase INT8OID:\n\t\t\tbuf = pstrdup(\"bigint\");\n\t\t\tbreak;\n\n\t\tcase NUMERICOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"numeric\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"numeric\");\n\t\t\tbreak;\n\n\t\tcase INTERVALOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"interval\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"interval\");\n\t\t\tbreak;\n\n\t\tcase TIMEOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMETZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"time\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"time with time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp without time zone\");\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"timestamp\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"timestamp with time zone\");\n\t\t\tbreak;\n\n\t\tcase VARBITOID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"bit varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"bit varying\");\n\t\t\tbreak;\n\n\t\tcase VARCHAROID:\n\t\t\tif (with_typemod)\n\t\t\t\tbuf = printTypmod(\"character varying\", typemod, typeform->typmodout);\n\t\t\telse\n\t\t\t\tbuf = pstrdup(\"character varying\");\n\t\t\tbreak;\n\t}\n\n\tif (buf == NULL)\n\t{\n\t\t/*\n\t\t * Default handling: report the name as it appears in the catalog.\n\t\t * Here, we must qualify the name if it is not visible in the search\n\t\t * path or if caller requests it; and we must double-quote it if it's\n\t\t * not a standard identifier or if it matches any keyword.\n\t\t */\n\t\tchar\t   *nspname;\n\t\tchar\t   *typname;\n\n\t\tif ((flags & FORMAT_TYPE_FORCE_QUALIFY) == 0 &&\n\t\t\tTypeIsVisible(type_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name_or_temp(typeform->typnamespace);\n\n\t\ttypname = NameStr(typeform->typname);\n\n\t\tbuf = quote_qualified_identifier(nspname, typname);\n\n\t\tif (with_typemod)\n\t\t\tbuf = printTypmod(buf, typemod, typeform->typmodout);\n\t}\n\n\tif (is_array)\n\t\tbuf = psprintf(\"%s[]\", buf);\n\n\tReleaseSysCache(tuple);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nformat_type(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttype_oid;\n\tint32\t\ttypemod;\n\tchar\t   *result;\n\tbits16\t\tflags = FORMAT_TYPE_ALLOW_INVALID;\n\n\t/* Since this function is not strict, we must test for null args */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\ttype_oid = PG_GETARG_OID(0);\n\n\tif (PG_ARGISNULL(1))\n\t\ttypemod = -1;\n\telse\n\t{\n\t\ttypemod = PG_GETARG_INT32(1);\n\t\tflags |= FORMAT_TYPE_TYPEMOD_GIVEN;\n\t}\n\n\tresult = format_type_extended(type_oid, typemod, flags);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}"
  }
]