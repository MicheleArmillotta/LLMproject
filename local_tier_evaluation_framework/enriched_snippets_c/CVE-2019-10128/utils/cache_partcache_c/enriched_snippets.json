[
  {
    "function_name": "qsort_partition_rbound_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "994-1004",
    "snippet": "static int32\nqsort_partition_rbound_cmp(const void *a, const void *b, void *arg)\n{\n\tPartitionRangeBound *b1 = (*(PartitionRangeBound *const *) a);\n\tPartitionRangeBound *b2 = (*(PartitionRangeBound *const *) b);\n\tPartitionKey key = (PartitionKey) arg;\n\n\treturn partition_rbound_cmp(key->partnatts, key->partsupfunc,\n\t\t\t\t\t\t\t\tkey->partcollation, b1->datums, b1->kind,\n\t\t\t\t\t\t\t\tb1->lower, b2);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 qsort_partition_hbound_cmp(const void *a, const void *b);",
      "static int32 qsort_partition_list_value_cmp(const void *a, const void *b,\n\t\t\t\t\t\t\t   void *arg);",
      "static int32 qsort_partition_rbound_cmp(const void *a, const void *b,\n\t\t\t\t\t\t   void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "partition_rbound_cmp",
          "args": [
            "key->partnatts",
            "key->partsupfunc",
            "key->partcollation",
            "b1->datums",
            "b1->kind",
            "b1->lower",
            "b2"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32 qsort_partition_hbound_cmp(const void *a, const void *b);\nstatic int32 qsort_partition_list_value_cmp(const void *a, const void *b,\n\t\t\t\t\t\t\t   void *arg);\nstatic int32 qsort_partition_rbound_cmp(const void *a, const void *b,\n\t\t\t\t\t\t   void *arg);\n\nstatic int32\nqsort_partition_rbound_cmp(const void *a, const void *b, void *arg)\n{\n\tPartitionRangeBound *b1 = (*(PartitionRangeBound *const *) a);\n\tPartitionRangeBound *b2 = (*(PartitionRangeBound *const *) b);\n\tPartitionKey key = (PartitionKey) arg;\n\n\treturn partition_rbound_cmp(key->partnatts, key->partsupfunc,\n\t\t\t\t\t\t\t\tkey->partcollation, b1->datums, b1->kind,\n\t\t\t\t\t\t\t\tb1->lower, b2);\n}"
  },
  {
    "function_name": "qsort_partition_list_value_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "981-991",
    "snippet": "static int32\nqsort_partition_list_value_cmp(const void *a, const void *b, void *arg)\n{\n\tDatum\t\tval1 = (*(const PartitionListValue **) a)->value,\n\t\t\t\tval2 = (*(const PartitionListValue **) b)->value;\n\tPartitionKey key = (PartitionKey) arg;\n\n\treturn DatumGetInt32(FunctionCall2Coll(&key->partsupfunc[0],\n\t\t\t\t\t\t\t\t\t\t   key->partcollation[0],\n\t\t\t\t\t\t\t\t\t\t   val1, val2));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 qsort_partition_hbound_cmp(const void *a, const void *b);",
      "static int32 qsort_partition_list_value_cmp(const void *a, const void *b,\n\t\t\t\t\t\t\t   void *arg);",
      "static int32 qsort_partition_rbound_cmp(const void *a, const void *b,\n\t\t\t\t\t\t   void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCall2Coll(&key->partsupfunc[0],\n\t\t\t\t\t\t\t\t\t\t   key->partcollation[0],\n\t\t\t\t\t\t\t\t\t\t   val1, val2)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&key->partsupfunc[0]",
            "key->partcollation[0]",
            "val1",
            "val2"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32 qsort_partition_hbound_cmp(const void *a, const void *b);\nstatic int32 qsort_partition_list_value_cmp(const void *a, const void *b,\n\t\t\t\t\t\t\t   void *arg);\nstatic int32 qsort_partition_rbound_cmp(const void *a, const void *b,\n\t\t\t\t\t\t   void *arg);\n\nstatic int32\nqsort_partition_list_value_cmp(const void *a, const void *b, void *arg)\n{\n\tDatum\t\tval1 = (*(const PartitionListValue **) a)->value,\n\t\t\t\tval2 = (*(const PartitionListValue **) b)->value;\n\tPartitionKey key = (PartitionKey) arg;\n\n\treturn DatumGetInt32(FunctionCall2Coll(&key->partsupfunc[0],\n\t\t\t\t\t\t\t\t\t\t   key->partcollation[0],\n\t\t\t\t\t\t\t\t\t\t   val1, val2));\n}"
  },
  {
    "function_name": "qsort_partition_hbound_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "966-974",
    "snippet": "static int32\nqsort_partition_hbound_cmp(const void *a, const void *b)\n{\n\tPartitionHashBound *h1 = (*(PartitionHashBound *const *) a);\n\tPartitionHashBound *h2 = (*(PartitionHashBound *const *) b);\n\n\treturn partition_hbound_cmp(h1->modulus, h1->remainder,\n\t\t\t\t\t\t\t\th2->modulus, h2->remainder);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 qsort_partition_hbound_cmp(const void *a, const void *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "partition_hbound_cmp",
          "args": [
            "h1->modulus",
            "h1->remainder",
            "h2->modulus",
            "h2->remainder"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32 qsort_partition_hbound_cmp(const void *a, const void *b);\n\nstatic int32\nqsort_partition_hbound_cmp(const void *a, const void *b)\n{\n\tPartitionHashBound *h1 = (*(PartitionHashBound *const *) a);\n\tPartitionHashBound *h2 = (*(PartitionHashBound *const *) b);\n\n\treturn partition_hbound_cmp(h1->modulus, h1->remainder,\n\t\t\t\t\t\t\t\th2->modulus, h2->remainder);\n}"
  },
  {
    "function_name": "generate_partition_qual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "865-959",
    "snippet": "static List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *generate_partition_qual(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "parent",
            "NoLock"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "result"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rel->rd_partcheckcxt"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "rel->rd_partcheckcxt",
            "RelationGetRelationName(rel)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CacheMemoryContext",
            "\"partition constraint\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_partcheck == NIL"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_partcheckcxt == NULL"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected whole-row reference found in partition key\""
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_partition_varattnos",
          "args": [
            "result",
            "1",
            "rel",
            "parent",
            "&found_whole_row"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_concat",
          "args": [
            "generate_partition_qual(parent)",
            "my_qual"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generate_partition_qual",
          "args": [
            "parent"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "generate_partition_qual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "865-959",
          "snippet": "static List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_qual_from_partbound",
          "args": [
            "rel",
            "parent",
            "bound"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "PartitionBoundSpec",
            "stringToNode(TextDatumGetCString(boundDatum))"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "TextDatumGetCString(boundDatum)"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "boundDatum"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "RELOID",
            "tuple",
            "Anum_pg_class_relpartbound",
            "&isnull"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "RelationGetRelid(rel)"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "get_partition_parent(RelationGetRelid(rel))",
            "AccessShareLock"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_partition_parent",
          "args": [
            "RelationGetRelid(rel)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "rel->rd_partcheck"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nstatic List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}"
  },
  {
    "function_name": "get_partition_qual_relid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "827-853",
    "snippet": "Expr *\nget_partition_qual_relid(Oid relid)\n{\n\tExpr\t   *result = NULL;\n\n\t/* Do the work only if this relation exists and is a partition. */\n\tif (get_rel_relispartition(relid))\n\t{\n\t\tRelation\trel = relation_open(relid, AccessShareLock);\n\t\tList\t   *and_args;\n\n\t\tand_args = generate_partition_qual(rel);\n\n\t\t/* Convert implicit-AND list format to boolean expression */\n\t\tif (and_args == NIL)\n\t\t\tresult = NULL;\n\t\telse if (list_length(and_args) > 1)\n\t\t\tresult = makeBoolExpr(AND_EXPR, and_args, -1);\n\t\telse\n\t\t\tresult = linitial(and_args);\n\n\t\t/* Keep the lock, to allow safe deparsing against the rel by caller. */\n\t\trelation_close(rel, NoLock);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *generate_partition_qual(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "NoLock"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "and_args"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeBoolExpr",
          "args": [
            "AND_EXPR",
            "and_args",
            "-1"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "and_args"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generate_partition_qual",
          "args": [
            "rel"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "generate_partition_qual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "865-959",
          "snippet": "static List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_inherits.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *generate_partition_qual(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nstatic List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "relid",
            "AccessShareLock"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rel_relispartition",
          "args": [
            "relid"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "get_rel_relispartition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1828-1845",
          "snippet": "bool\nget_rel_relispartition(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tbool\t\tresult;\n\n\t\tresult = reltup->relispartition;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_rel_relispartition(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tbool\t\tresult;\n\n\t\tresult = reltup->relispartition;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nExpr *\nget_partition_qual_relid(Oid relid)\n{\n\tExpr\t   *result = NULL;\n\n\t/* Do the work only if this relation exists and is a partition. */\n\tif (get_rel_relispartition(relid))\n\t{\n\t\tRelation\trel = relation_open(relid, AccessShareLock);\n\t\tList\t   *and_args;\n\n\t\tand_args = generate_partition_qual(rel);\n\n\t\t/* Convert implicit-AND list format to boolean expression */\n\t\tif (and_args == NIL)\n\t\t\tresult = NULL;\n\t\telse if (list_length(and_args) > 1)\n\t\t\tresult = makeBoolExpr(AND_EXPR, and_args, -1);\n\t\telse\n\t\t\tresult = linitial(and_args);\n\n\t\t/* Keep the lock, to allow safe deparsing against the rel by caller. */\n\t\trelation_close(rel, NoLock);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "RelationGetPartitionQual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "805-813",
    "snippet": "List *\nRelationGetPartitionQual(Relation rel)\n{\n\t/* Quick exit */\n\tif (!rel->rd_rel->relispartition)\n\t\treturn NIL;\n\n\treturn generate_partition_qual(rel);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *generate_partition_qual(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generate_partition_qual",
          "args": [
            "rel"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "generate_partition_qual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "865-959",
          "snippet": "static List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_inherits.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *generate_partition_qual(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nstatic List *\ngenerate_partition_qual(Relation rel)\n{\n\tHeapTuple\ttuple;\n\tMemoryContext oldcxt;\n\tDatum\t\tboundDatum;\n\tbool\t\tisnull;\n\tList\t   *my_qual = NIL,\n\t\t\t   *result = NIL;\n\tRelation\tparent;\n\tbool\t\tfound_whole_row;\n\n\t/* Guard against stack overflow due to overly deep partition tree */\n\tcheck_stack_depth();\n\n\t/* If we already cached the result, just return a copy */\n\tif (rel->rd_partcheckvalid)\n\t\treturn copyObject(rel->rd_partcheck);\n\n\t/* Grab at least an AccessShareLock on the parent table */\n\tparent = relation_open(get_partition_parent(RelationGetRelid(rel)),\n\t\t\t\t\t\t   AccessShareLock);\n\n\t/* Get pg_class.relpartbound */\n\ttuple = SearchSysCache1(RELOID, RelationGetRelid(rel));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for relation %u\",\n\t\t\t RelationGetRelid(rel));\n\n\tboundDatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t Anum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t &isnull);\n\tif (!isnull)\n\t{\n\t\tPartitionBoundSpec *bound;\n\n\t\tbound = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t stringToNode(TextDatumGetCString(boundDatum)));\n\n\t\tmy_qual = get_qual_from_partbound(rel, parent, bound);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Add the parent's quals to the list (if any) */\n\tif (parent->rd_rel->relispartition)\n\t\tresult = list_concat(generate_partition_qual(parent), my_qual);\n\telse\n\t\tresult = my_qual;\n\n\t/*\n\t * Change Vars to have partition's attnos instead of the parent's. We do\n\t * this after we concatenate the parent's quals, because we want every Var\n\t * in it to bear this relation's attnos. It's safe to assume varno = 1\n\t * here.\n\t */\n\tresult = map_partition_varattnos(result, 1, rel, parent,\n\t\t\t\t\t\t\t\t\t &found_whole_row);\n\t/* There can never be a whole-row reference here */\n\tif (found_whole_row)\n\t\telog(ERROR, \"unexpected whole-row reference found in partition key\");\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(rel->rd_partcheckcxt == NULL);\n\tAssert(rel->rd_partcheck == NIL);\n\n\t/*\n\t * Save a copy in the relcache.  The order of these operations is fairly\n\t * critical to avoid memory leaks and ensure that we don't leave a corrupt\n\t * relcache entry if we fail partway through copyObject.\n\t *\n\t * If, as is definitely possible, the partcheck list is NIL, then we do\n\t * not need to make a context to hold it.\n\t */\n\tif (result != NIL)\n\t{\n\t\trel->rd_partcheckcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"partition constraint\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(rel->rd_partcheckcxt,\n\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\t\toldcxt = MemoryContextSwitchTo(rel->rd_partcheckcxt);\n\t\trel->rd_partcheck = copyObject(result);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t\trel->rd_partcheck = NIL;\n\trel->rd_partcheckvalid = true;\n\n\t/* Keep the parent locked until commit */\n\trelation_close(parent, NoLock);\n\n\t/* Return the working copy to the caller */\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nList *\nRelationGetPartitionQual(Relation rel)\n{\n\t/* Quick exit */\n\tif (!rel->rd_rel->relispartition)\n\t\treturn NIL;\n\n\treturn generate_partition_qual(rel);\n}"
  },
  {
    "function_name": "RelationBuildPartitionDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "266-798",
    "snippet": "void\nRelationBuildPartitionDesc(Relation rel)\n{\n\tList\t   *inhoids,\n\t\t\t   *partoids;\n\tOid\t\t   *oids = NULL;\n\tList\t   *boundspecs = NIL;\n\tListCell   *cell;\n\tint\t\t\ti,\n\t\t\t\tnparts;\n\tPartitionKey key = RelationGetPartitionKey(rel);\n\tPartitionDesc result;\n\tMemoryContext oldcxt;\n\n\tint\t\t\tndatums = 0;\n\tint\t\t\tdefault_index = -1;\n\n\t/* Hash partitioning specific */\n\tPartitionHashBound **hbounds = NULL;\n\n\t/* List partitioning specific */\n\tPartitionListValue **all_values = NULL;\n\tint\t\t\tnull_index = -1;\n\n\t/* Range partitioning specific */\n\tPartitionRangeBound **rbounds = NULL;\n\n\t/* Get partition oids from pg_inherits */\n\tinhoids = find_inheritance_children(RelationGetRelid(rel), NoLock);\n\n\t/* Collect bound spec nodes in a list */\n\ti = 0;\n\tpartoids = NIL;\n\tforeach(cell, inhoids)\n\t{\n\t\tOid\t\t\tinhrelid = lfirst_oid(cell);\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *boundspec;\n\n\t\ttuple = SearchSysCache1(RELOID, inhrelid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", inhrelid);\n\n\t\tdatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\tAnum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null relpartbound for relation %u\", inhrelid);\n\t\tboundspec = (Node *) stringToNode(TextDatumGetCString(datum));\n\n\t\t/*\n\t\t * Sanity check: If the PartitionBoundSpec says this is the default\n\t\t * partition, its OID should correspond to whatever's stored in\n\t\t * pg_partitioned_table.partdefid; if not, the catalog is corrupt.\n\t\t */\n\t\tif (castNode(PartitionBoundSpec, boundspec)->is_default)\n\t\t{\n\t\t\tOid\t\t\tpartdefid;\n\n\t\t\tpartdefid = get_default_partition_oid(RelationGetRelid(rel));\n\t\t\tif (partdefid != inhrelid)\n\t\t\t\telog(ERROR, \"expected partdefid %u, but got %u\",\n\t\t\t\t\t inhrelid, partdefid);\n\t\t}\n\n\t\tboundspecs = lappend(boundspecs, boundspec);\n\t\tpartoids = lappend_oid(partoids, inhrelid);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\tnparts = list_length(partoids);\n\n\tif (nparts > 0)\n\t{\n\t\toids = (Oid *) palloc(nparts * sizeof(Oid));\n\t\ti = 0;\n\t\tforeach(cell, partoids)\n\t\t\toids[i++] = lfirst_oid(cell);\n\n\t\t/* Convert from node to the internal representation */\n\t\tif (key->strategy == PARTITION_STRATEGY_HASH)\n\t\t{\n\t\t\tndatums = nparts;\n\t\t\thbounds = (PartitionHashBound **)\n\t\t\t\tpalloc(nparts * sizeof(PartitionHashBound *));\n\n\t\t\ti = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_HASH)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\thbounds[i] = (PartitionHashBound *)\n\t\t\t\t\tpalloc(sizeof(PartitionHashBound));\n\n\t\t\t\thbounds[i]->modulus = spec->modulus;\n\t\t\t\thbounds[i]->remainder = spec->remainder;\n\t\t\t\thbounds[i]->index = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort(hbounds, nparts, sizeof(PartitionHashBound *),\n\t\t\t\t  qsort_partition_hbound_cmp);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_LIST)\n\t\t{\n\t\t\tList\t   *non_null_values = NIL;\n\n\t\t\t/*\n\t\t\t * Create a unified list of non-null values across all partitions.\n\t\t\t */\n\t\t\ti = 0;\n\t\t\tnull_index = -1;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tListCell   *c;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_LIST)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the list of non-null\n\t\t\t\t * datums for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach(c, spec->listdatums)\n\t\t\t\t{\n\t\t\t\t\tConst\t   *val = castNode(Const, lfirst(c));\n\t\t\t\t\tPartitionListValue *list_value = NULL;\n\n\t\t\t\t\tif (!val->constisnull)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist_value = (PartitionListValue *)\n\t\t\t\t\t\t\tpalloc0(sizeof(PartitionListValue));\n\t\t\t\t\t\tlist_value->index = i;\n\t\t\t\t\t\tlist_value->value = val->constvalue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Never put a null into the values array, flag\n\t\t\t\t\t\t * instead for the code further down below where we\n\t\t\t\t\t\t * construct the actual relcache struct.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t\t\telog(ERROR, \"found null more than once\");\n\t\t\t\t\t\tnull_index = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (list_value)\n\t\t\t\t\t\tnon_null_values = lappend(non_null_values,\n\t\t\t\t\t\t\t\t\t\t\t\t  list_value);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tndatums = list_length(non_null_values);\n\n\t\t\t/*\n\t\t\t * Collect all list values in one array. Alongside the value, we\n\t\t\t * also save the index of partition the value comes from.\n\t\t\t */\n\t\t\tall_values = (PartitionListValue **) palloc(ndatums *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionListValue *));\n\t\t\ti = 0;\n\t\t\tforeach(cell, non_null_values)\n\t\t\t{\n\t\t\t\tPartitionListValue *src = lfirst(cell);\n\n\t\t\t\tall_values[i] = (PartitionListValue *)\n\t\t\t\t\tpalloc(sizeof(PartitionListValue));\n\t\t\t\tall_values[i]->value = src->value;\n\t\t\t\tall_values[i]->index = src->index;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tqsort_arg(all_values, ndatums, sizeof(PartitionListValue *),\n\t\t\t\t\t  qsort_partition_list_value_cmp, (void *) key);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_RANGE)\n\t\t{\n\t\t\tint\t\t\tk;\n\t\t\tPartitionRangeBound **all_bounds,\n\t\t\t\t\t   *prev;\n\n\t\t\tall_bounds = (PartitionRangeBound **) palloc0(2 * nparts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(PartitionRangeBound *));\n\n\t\t\t/*\n\t\t\t * Create a unified list of range bounds across all the\n\t\t\t * partitions.\n\t\t\t */\n\t\t\ti = ndatums = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tPartitionRangeBound *lower,\n\t\t\t\t\t\t   *upper;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_RANGE)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the allbounds array\n\t\t\t\t * for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlower = make_one_partition_rbound(key, i, spec->lowerdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  true);\n\t\t\t\tupper = make_one_partition_rbound(key, i, spec->upperdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tall_bounds[ndatums++] = lower;\n\t\t\t\tall_bounds[ndatums++] = upper;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2));\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort_arg(all_bounds, ndatums,\n\t\t\t\t\t  sizeof(PartitionRangeBound *),\n\t\t\t\t\t  qsort_partition_rbound_cmp,\n\t\t\t\t\t  (void *) key);\n\n\t\t\t/* Save distinct bounds from all_bounds into rbounds. */\n\t\t\trbounds = (PartitionRangeBound **)\n\t\t\t\tpalloc(ndatums * sizeof(PartitionRangeBound *));\n\t\t\tk = 0;\n\t\t\tprev = NULL;\n\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t{\n\t\t\t\tPartitionRangeBound *cur = all_bounds[i];\n\t\t\t\tbool\t\tis_distinct = false;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\t/* Is the current bound distinct from the previous one? */\n\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t{\n\t\t\t\t\tDatum\t\tcmpval;\n\n\t\t\t\t\tif (prev == NULL || cur->kind[j] != prev->kind[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the bounds are both MINVALUE or MAXVALUE, stop now\n\t\t\t\t\t * and treat them as equal, since any values after this\n\t\t\t\t\t * point must be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (cur->kind[j] != PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcmpval = FunctionCall2Coll(&key->partsupfunc[j],\n\t\t\t\t\t\t\t\t\t\t\t   key->partcollation[j],\n\t\t\t\t\t\t\t\t\t\t\t   cur->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t   prev->datums[j]);\n\t\t\t\t\tif (DatumGetInt32(cmpval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Only if the bound is distinct save it into a temporary\n\t\t\t\t * array i.e. rbounds which is later copied into boundinfo\n\t\t\t\t * datums array.\n\t\t\t\t */\n\t\t\t\tif (is_distinct)\n\t\t\t\t\trbounds[k++] = all_bounds[i];\n\n\t\t\t\tprev = cur;\n\t\t\t}\n\n\t\t\t/* Update ndatums to hold the count of distinct datums. */\n\t\t\tndatums = k;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t (int) key->strategy);\n\t}\n\n\t/* Assert we aren't about to leak any old data structure */\n\tAssert(rel->rd_pdcxt == NULL);\n\tAssert(rel->rd_partdesc == NULL);\n\n\t/*\n\t * Now build the actual relcache partition descriptor.  Note that the\n\t * order of operations here is fairly critical.  If we fail partway\n\t * through this code, we won't have leaked memory because the rd_pdcxt is\n\t * attached to the relcache entry immediately, so it'll be freed whenever\n\t * the entry is rebuilt or destroyed.  However, we don't assign to\n\t * rd_partdesc until the cached data structure is fully complete and\n\t * valid, so that no other code might try to use it.\n\t */\n\trel->rd_pdcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t  \"partition descriptor\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(rel->rd_pdcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\toldcxt = MemoryContextSwitchTo(rel->rd_pdcxt);\n\n\tresult = (PartitionDescData *) palloc0(sizeof(PartitionDescData));\n\tresult->nparts = nparts;\n\tif (nparts > 0)\n\t{\n\t\tPartitionBoundInfo boundinfo;\n\t\tint\t\t   *mapping;\n\t\tint\t\t\tnext_index = 0;\n\n\t\tresult->oids = (Oid *) palloc0(nparts * sizeof(Oid));\n\n\t\tboundinfo = (PartitionBoundInfoData *)\n\t\t\tpalloc0(sizeof(PartitionBoundInfoData));\n\t\tboundinfo->strategy = key->strategy;\n\t\tboundinfo->default_index = -1;\n\t\tboundinfo->ndatums = ndatums;\n\t\tboundinfo->null_index = -1;\n\t\tboundinfo->datums = (Datum **) palloc0(ndatums * sizeof(Datum *));\n\n\t\t/* Initialize mapping array with invalid values */\n\t\tmapping = (int *) palloc(sizeof(int) * nparts);\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tmapping[i] = -1;\n\n\t\tswitch (key->strategy)\n\t\t{\n\t\t\tcase PARTITION_STRATEGY_HASH:\n\t\t\t\t{\n\t\t\t\t\t/* Moduli are stored in ascending order */\n\t\t\t\t\tint\t\t\tgreatest_modulus = hbounds[ndatums - 1]->modulus;\n\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(greatest_modulus *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < greatest_modulus; i++)\n\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\n\t\t\t\t\tfor (i = 0; i < nparts; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tmodulus = hbounds[i]->modulus;\n\t\t\t\t\t\tint\t\t\tremainder = hbounds[i]->remainder;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(2 *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = Int32GetDatum(modulus);\n\t\t\t\t\t\tboundinfo->datums[i][1] = Int32GetDatum(remainder);\n\n\t\t\t\t\t\twhile (remainder < greatest_modulus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* overlap? */\n\t\t\t\t\t\t\tAssert(boundinfo->indexes[remainder] == -1);\n\t\t\t\t\t\t\tboundinfo->indexes[remainder] = i;\n\t\t\t\t\t\t\tremainder += modulus;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmapping[hbounds[i]->index] = i;\n\t\t\t\t\t\tpfree(hbounds[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpfree(hbounds);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_LIST:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(ndatums * sizeof(int));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy values.  Indexes of individual values are mapped\n\t\t\t\t\t * to canonical values so that they match for any two list\n\t\t\t\t\t * partitioned tables with same number of partitions and\n\t\t\t\t\t * same lists per partition.  One way to canonicalize is\n\t\t\t\t\t * to assign the index in all_values[] of the smallest\n\t\t\t\t\t * value of each partition, as the index of all of the\n\t\t\t\t\t * partition's values.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(sizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = datumCopy(all_values[i]->value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttypbyval[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttyplen[0]);\n\n\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\tif (mapping[all_values[i]->index] == -1)\n\t\t\t\t\t\t\tmapping[all_values[i]->index] = next_index++;\n\n\t\t\t\t\t\tboundinfo->indexes[i] = mapping[all_values[i]->index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If null-accepting partition has no mapped index yet,\n\t\t\t\t\t * assign one.  This could happen if such partition\n\t\t\t\t\t * accepts only null and hence not covered in the above\n\t\t\t\t\t * loop which only handled non-null values.\n\t\t\t\t\t */\n\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(null_index >= 0);\n\t\t\t\t\t\tif (mapping[null_index] == -1)\n\t\t\t\t\t\t\tmapping[null_index] = next_index++;\n\t\t\t\t\t\tboundinfo->null_index = mapping[null_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The default partition accepts any value not\n\t\t\t\t\t\t * specified in the lists of other partitions, hence\n\t\t\t\t\t\t * it should not get mapped index while assigning\n\t\t\t\t\t\t * those for non-null datums.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tAssert(default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All partition must now have a valid mapping */\n\t\t\t\t\tAssert(next_index == nparts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_RANGE:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->kind = (PartitionRangeDatumKind **)\n\t\t\t\t\t\tpalloc(ndatums *\n\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind *));\n\t\t\t\t\tboundinfo->indexes = (int *) palloc((ndatums + 1) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tj;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(key->partnatts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->kind[i] = (PartitionRangeDatumKind *)\n\t\t\t\t\t\t\tpalloc(key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind));\n\t\t\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rbounds[i]->kind[j] == PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\t\t\tboundinfo->datums[i][j] =\n\t\t\t\t\t\t\t\t\tdatumCopy(rbounds[i]->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttypbyval[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttyplen[j]);\n\t\t\t\t\t\t\tboundinfo->kind[i][j] = rbounds[i]->kind[j];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There is no mapping for invalid indexes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Any lower bounds in the rbounds array have invalid\n\t\t\t\t\t\t * indexes assigned, because the values between the\n\t\t\t\t\t\t * previous bound (if there is one) and this (lower)\n\t\t\t\t\t\t * bound are not part of the range of any existing\n\t\t\t\t\t\t * partition.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (rbounds[i]->lower)\n\t\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\torig_index = rbounds[i]->index;\n\n\t\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\t\tif (mapping[orig_index] == -1)\n\t\t\t\t\t\t\t\tmapping[orig_index] = next_index++;\n\n\t\t\t\t\t\t\tboundinfo->indexes[i] = mapping[orig_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(default_index >= 0 && mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t\t (int) key->strategy);\n\t\t}\n\n\t\tresult->boundinfo = boundinfo;\n\n\t\t/*\n\t\t * Now assign OIDs from the original array into mapped indexes of the\n\t\t * result array.  Order of OIDs in the former is defined by the\n\t\t * catalog scan that retrieved them, whereas that in the latter is\n\t\t * defined by canonicalized representation of the partition bounds.\n\t\t */\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tresult->oids[mapping[i]] = oids[i];\n\t\tpfree(mapping);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\trel->rd_partdesc = result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *generate_partition_qual(Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "mapping"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected partition strategy: %d\"",
            "(int) key->strategy"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "default_index >= 0 && mapping[default_index] == -1"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "rbounds[i]->datums[j]",
            "key->parttypbyval[j]",
            "key->parttyplen[j]"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind)"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "next_index == nparts"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "null_index >= 0"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "boundinfo->indexes[remainder] == -1"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "remainder"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "modulus"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rel->rd_pdcxt"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "rel->rd_pdcxt",
            "RelationGetRelationName(rel)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CacheMemoryContext",
            "\"partition descriptor\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_partdesc == NULL"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_pdcxt == NULL"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "cmpval"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&key->partsupfunc[j]",
            "key->partcollation[j]",
            "cur->datums[j]",
            "prev->datums[j]"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "all_bounds",
            "ndatums",
            "sizeof(PartitionRangeBound *)",
            "qsort_partition_rbound_cmp",
            "(void *) key"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_one_partition_rbound",
          "args": [
            "key",
            "i",
            "spec->upperdatums",
            "false"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_one_partition_rbound",
          "args": [
            "key",
            "i",
            "spec->lowerdatums",
            "true"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "PartitionBoundSpec",
            "lfirst(cell)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "cell"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "boundspecs"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "all_values",
            "ndatums",
            "sizeof(PartitionListValue *)",
            "qsort_partition_list_value_cmp",
            "(void *) key"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "cell"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "non_null_values"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "non_null_values"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "non_null_values",
            "list_value"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "Const",
            "lfirst(c)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "c"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "c",
            "spec->listdatums"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "PartitionBoundSpec",
            "lfirst(cell)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "cell"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "boundspecs"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "hbounds",
            "nparts",
            "sizeof(PartitionHashBound *)",
            "qsort_partition_hbound_cmp"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "PartitionBoundSpec",
            "lfirst(cell)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "cell"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "boundspecs"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "partoids"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "partoids"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend_oid",
          "args": [
            "partoids",
            "inhrelid"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "boundspecs",
            "boundspec"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_default_partition_oid",
          "args": [
            "RelationGetRelid(rel)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "PartitionBoundSpec",
            "boundspec"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "TextDatumGetCString(datum)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "datum"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "RELOID",
            "tuple",
            "Anum_pg_class_relpartbound",
            "&isnull"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "inhrelid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "inhoids"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_inheritance_children",
          "args": [
            "RelationGetRelid(rel)",
            "NoLock"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetPartitionKey",
          "args": [
            "rel"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nvoid\nRelationBuildPartitionDesc(Relation rel)\n{\n\tList\t   *inhoids,\n\t\t\t   *partoids;\n\tOid\t\t   *oids = NULL;\n\tList\t   *boundspecs = NIL;\n\tListCell   *cell;\n\tint\t\t\ti,\n\t\t\t\tnparts;\n\tPartitionKey key = RelationGetPartitionKey(rel);\n\tPartitionDesc result;\n\tMemoryContext oldcxt;\n\n\tint\t\t\tndatums = 0;\n\tint\t\t\tdefault_index = -1;\n\n\t/* Hash partitioning specific */\n\tPartitionHashBound **hbounds = NULL;\n\n\t/* List partitioning specific */\n\tPartitionListValue **all_values = NULL;\n\tint\t\t\tnull_index = -1;\n\n\t/* Range partitioning specific */\n\tPartitionRangeBound **rbounds = NULL;\n\n\t/* Get partition oids from pg_inherits */\n\tinhoids = find_inheritance_children(RelationGetRelid(rel), NoLock);\n\n\t/* Collect bound spec nodes in a list */\n\ti = 0;\n\tpartoids = NIL;\n\tforeach(cell, inhoids)\n\t{\n\t\tOid\t\t\tinhrelid = lfirst_oid(cell);\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *boundspec;\n\n\t\ttuple = SearchSysCache1(RELOID, inhrelid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", inhrelid);\n\n\t\tdatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\tAnum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null relpartbound for relation %u\", inhrelid);\n\t\tboundspec = (Node *) stringToNode(TextDatumGetCString(datum));\n\n\t\t/*\n\t\t * Sanity check: If the PartitionBoundSpec says this is the default\n\t\t * partition, its OID should correspond to whatever's stored in\n\t\t * pg_partitioned_table.partdefid; if not, the catalog is corrupt.\n\t\t */\n\t\tif (castNode(PartitionBoundSpec, boundspec)->is_default)\n\t\t{\n\t\t\tOid\t\t\tpartdefid;\n\n\t\t\tpartdefid = get_default_partition_oid(RelationGetRelid(rel));\n\t\t\tif (partdefid != inhrelid)\n\t\t\t\telog(ERROR, \"expected partdefid %u, but got %u\",\n\t\t\t\t\t inhrelid, partdefid);\n\t\t}\n\n\t\tboundspecs = lappend(boundspecs, boundspec);\n\t\tpartoids = lappend_oid(partoids, inhrelid);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\tnparts = list_length(partoids);\n\n\tif (nparts > 0)\n\t{\n\t\toids = (Oid *) palloc(nparts * sizeof(Oid));\n\t\ti = 0;\n\t\tforeach(cell, partoids)\n\t\t\toids[i++] = lfirst_oid(cell);\n\n\t\t/* Convert from node to the internal representation */\n\t\tif (key->strategy == PARTITION_STRATEGY_HASH)\n\t\t{\n\t\t\tndatums = nparts;\n\t\t\thbounds = (PartitionHashBound **)\n\t\t\t\tpalloc(nparts * sizeof(PartitionHashBound *));\n\n\t\t\ti = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_HASH)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\thbounds[i] = (PartitionHashBound *)\n\t\t\t\t\tpalloc(sizeof(PartitionHashBound));\n\n\t\t\t\thbounds[i]->modulus = spec->modulus;\n\t\t\t\thbounds[i]->remainder = spec->remainder;\n\t\t\t\thbounds[i]->index = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort(hbounds, nparts, sizeof(PartitionHashBound *),\n\t\t\t\t  qsort_partition_hbound_cmp);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_LIST)\n\t\t{\n\t\t\tList\t   *non_null_values = NIL;\n\n\t\t\t/*\n\t\t\t * Create a unified list of non-null values across all partitions.\n\t\t\t */\n\t\t\ti = 0;\n\t\t\tnull_index = -1;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tListCell   *c;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_LIST)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the list of non-null\n\t\t\t\t * datums for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach(c, spec->listdatums)\n\t\t\t\t{\n\t\t\t\t\tConst\t   *val = castNode(Const, lfirst(c));\n\t\t\t\t\tPartitionListValue *list_value = NULL;\n\n\t\t\t\t\tif (!val->constisnull)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist_value = (PartitionListValue *)\n\t\t\t\t\t\t\tpalloc0(sizeof(PartitionListValue));\n\t\t\t\t\t\tlist_value->index = i;\n\t\t\t\t\t\tlist_value->value = val->constvalue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Never put a null into the values array, flag\n\t\t\t\t\t\t * instead for the code further down below where we\n\t\t\t\t\t\t * construct the actual relcache struct.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t\t\telog(ERROR, \"found null more than once\");\n\t\t\t\t\t\tnull_index = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (list_value)\n\t\t\t\t\t\tnon_null_values = lappend(non_null_values,\n\t\t\t\t\t\t\t\t\t\t\t\t  list_value);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tndatums = list_length(non_null_values);\n\n\t\t\t/*\n\t\t\t * Collect all list values in one array. Alongside the value, we\n\t\t\t * also save the index of partition the value comes from.\n\t\t\t */\n\t\t\tall_values = (PartitionListValue **) palloc(ndatums *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionListValue *));\n\t\t\ti = 0;\n\t\t\tforeach(cell, non_null_values)\n\t\t\t{\n\t\t\t\tPartitionListValue *src = lfirst(cell);\n\n\t\t\t\tall_values[i] = (PartitionListValue *)\n\t\t\t\t\tpalloc(sizeof(PartitionListValue));\n\t\t\t\tall_values[i]->value = src->value;\n\t\t\t\tall_values[i]->index = src->index;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tqsort_arg(all_values, ndatums, sizeof(PartitionListValue *),\n\t\t\t\t\t  qsort_partition_list_value_cmp, (void *) key);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_RANGE)\n\t\t{\n\t\t\tint\t\t\tk;\n\t\t\tPartitionRangeBound **all_bounds,\n\t\t\t\t\t   *prev;\n\n\t\t\tall_bounds = (PartitionRangeBound **) palloc0(2 * nparts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(PartitionRangeBound *));\n\n\t\t\t/*\n\t\t\t * Create a unified list of range bounds across all the\n\t\t\t * partitions.\n\t\t\t */\n\t\t\ti = ndatums = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tPartitionRangeBound *lower,\n\t\t\t\t\t\t   *upper;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_RANGE)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the allbounds array\n\t\t\t\t * for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlower = make_one_partition_rbound(key, i, spec->lowerdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  true);\n\t\t\t\tupper = make_one_partition_rbound(key, i, spec->upperdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tall_bounds[ndatums++] = lower;\n\t\t\t\tall_bounds[ndatums++] = upper;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2));\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort_arg(all_bounds, ndatums,\n\t\t\t\t\t  sizeof(PartitionRangeBound *),\n\t\t\t\t\t  qsort_partition_rbound_cmp,\n\t\t\t\t\t  (void *) key);\n\n\t\t\t/* Save distinct bounds from all_bounds into rbounds. */\n\t\t\trbounds = (PartitionRangeBound **)\n\t\t\t\tpalloc(ndatums * sizeof(PartitionRangeBound *));\n\t\t\tk = 0;\n\t\t\tprev = NULL;\n\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t{\n\t\t\t\tPartitionRangeBound *cur = all_bounds[i];\n\t\t\t\tbool\t\tis_distinct = false;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\t/* Is the current bound distinct from the previous one? */\n\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t{\n\t\t\t\t\tDatum\t\tcmpval;\n\n\t\t\t\t\tif (prev == NULL || cur->kind[j] != prev->kind[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the bounds are both MINVALUE or MAXVALUE, stop now\n\t\t\t\t\t * and treat them as equal, since any values after this\n\t\t\t\t\t * point must be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (cur->kind[j] != PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcmpval = FunctionCall2Coll(&key->partsupfunc[j],\n\t\t\t\t\t\t\t\t\t\t\t   key->partcollation[j],\n\t\t\t\t\t\t\t\t\t\t\t   cur->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t   prev->datums[j]);\n\t\t\t\t\tif (DatumGetInt32(cmpval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Only if the bound is distinct save it into a temporary\n\t\t\t\t * array i.e. rbounds which is later copied into boundinfo\n\t\t\t\t * datums array.\n\t\t\t\t */\n\t\t\t\tif (is_distinct)\n\t\t\t\t\trbounds[k++] = all_bounds[i];\n\n\t\t\t\tprev = cur;\n\t\t\t}\n\n\t\t\t/* Update ndatums to hold the count of distinct datums. */\n\t\t\tndatums = k;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t (int) key->strategy);\n\t}\n\n\t/* Assert we aren't about to leak any old data structure */\n\tAssert(rel->rd_pdcxt == NULL);\n\tAssert(rel->rd_partdesc == NULL);\n\n\t/*\n\t * Now build the actual relcache partition descriptor.  Note that the\n\t * order of operations here is fairly critical.  If we fail partway\n\t * through this code, we won't have leaked memory because the rd_pdcxt is\n\t * attached to the relcache entry immediately, so it'll be freed whenever\n\t * the entry is rebuilt or destroyed.  However, we don't assign to\n\t * rd_partdesc until the cached data structure is fully complete and\n\t * valid, so that no other code might try to use it.\n\t */\n\trel->rd_pdcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t  \"partition descriptor\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(rel->rd_pdcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\toldcxt = MemoryContextSwitchTo(rel->rd_pdcxt);\n\n\tresult = (PartitionDescData *) palloc0(sizeof(PartitionDescData));\n\tresult->nparts = nparts;\n\tif (nparts > 0)\n\t{\n\t\tPartitionBoundInfo boundinfo;\n\t\tint\t\t   *mapping;\n\t\tint\t\t\tnext_index = 0;\n\n\t\tresult->oids = (Oid *) palloc0(nparts * sizeof(Oid));\n\n\t\tboundinfo = (PartitionBoundInfoData *)\n\t\t\tpalloc0(sizeof(PartitionBoundInfoData));\n\t\tboundinfo->strategy = key->strategy;\n\t\tboundinfo->default_index = -1;\n\t\tboundinfo->ndatums = ndatums;\n\t\tboundinfo->null_index = -1;\n\t\tboundinfo->datums = (Datum **) palloc0(ndatums * sizeof(Datum *));\n\n\t\t/* Initialize mapping array with invalid values */\n\t\tmapping = (int *) palloc(sizeof(int) * nparts);\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tmapping[i] = -1;\n\n\t\tswitch (key->strategy)\n\t\t{\n\t\t\tcase PARTITION_STRATEGY_HASH:\n\t\t\t\t{\n\t\t\t\t\t/* Moduli are stored in ascending order */\n\t\t\t\t\tint\t\t\tgreatest_modulus = hbounds[ndatums - 1]->modulus;\n\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(greatest_modulus *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < greatest_modulus; i++)\n\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\n\t\t\t\t\tfor (i = 0; i < nparts; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tmodulus = hbounds[i]->modulus;\n\t\t\t\t\t\tint\t\t\tremainder = hbounds[i]->remainder;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(2 *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = Int32GetDatum(modulus);\n\t\t\t\t\t\tboundinfo->datums[i][1] = Int32GetDatum(remainder);\n\n\t\t\t\t\t\twhile (remainder < greatest_modulus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* overlap? */\n\t\t\t\t\t\t\tAssert(boundinfo->indexes[remainder] == -1);\n\t\t\t\t\t\t\tboundinfo->indexes[remainder] = i;\n\t\t\t\t\t\t\tremainder += modulus;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmapping[hbounds[i]->index] = i;\n\t\t\t\t\t\tpfree(hbounds[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpfree(hbounds);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_LIST:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(ndatums * sizeof(int));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy values.  Indexes of individual values are mapped\n\t\t\t\t\t * to canonical values so that they match for any two list\n\t\t\t\t\t * partitioned tables with same number of partitions and\n\t\t\t\t\t * same lists per partition.  One way to canonicalize is\n\t\t\t\t\t * to assign the index in all_values[] of the smallest\n\t\t\t\t\t * value of each partition, as the index of all of the\n\t\t\t\t\t * partition's values.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(sizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = datumCopy(all_values[i]->value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttypbyval[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttyplen[0]);\n\n\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\tif (mapping[all_values[i]->index] == -1)\n\t\t\t\t\t\t\tmapping[all_values[i]->index] = next_index++;\n\n\t\t\t\t\t\tboundinfo->indexes[i] = mapping[all_values[i]->index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If null-accepting partition has no mapped index yet,\n\t\t\t\t\t * assign one.  This could happen if such partition\n\t\t\t\t\t * accepts only null and hence not covered in the above\n\t\t\t\t\t * loop which only handled non-null values.\n\t\t\t\t\t */\n\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(null_index >= 0);\n\t\t\t\t\t\tif (mapping[null_index] == -1)\n\t\t\t\t\t\t\tmapping[null_index] = next_index++;\n\t\t\t\t\t\tboundinfo->null_index = mapping[null_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The default partition accepts any value not\n\t\t\t\t\t\t * specified in the lists of other partitions, hence\n\t\t\t\t\t\t * it should not get mapped index while assigning\n\t\t\t\t\t\t * those for non-null datums.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tAssert(default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All partition must now have a valid mapping */\n\t\t\t\t\tAssert(next_index == nparts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_RANGE:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->kind = (PartitionRangeDatumKind **)\n\t\t\t\t\t\tpalloc(ndatums *\n\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind *));\n\t\t\t\t\tboundinfo->indexes = (int *) palloc((ndatums + 1) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tj;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(key->partnatts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->kind[i] = (PartitionRangeDatumKind *)\n\t\t\t\t\t\t\tpalloc(key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind));\n\t\t\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rbounds[i]->kind[j] == PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\t\t\tboundinfo->datums[i][j] =\n\t\t\t\t\t\t\t\t\tdatumCopy(rbounds[i]->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttypbyval[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttyplen[j]);\n\t\t\t\t\t\t\tboundinfo->kind[i][j] = rbounds[i]->kind[j];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There is no mapping for invalid indexes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Any lower bounds in the rbounds array have invalid\n\t\t\t\t\t\t * indexes assigned, because the values between the\n\t\t\t\t\t\t * previous bound (if there is one) and this (lower)\n\t\t\t\t\t\t * bound are not part of the range of any existing\n\t\t\t\t\t\t * partition.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (rbounds[i]->lower)\n\t\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\torig_index = rbounds[i]->index;\n\n\t\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\t\tif (mapping[orig_index] == -1)\n\t\t\t\t\t\t\t\tmapping[orig_index] = next_index++;\n\n\t\t\t\t\t\t\tboundinfo->indexes[i] = mapping[orig_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(default_index >= 0 && mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t\t (int) key->strategy);\n\t\t}\n\n\t\tresult->boundinfo = boundinfo;\n\n\t\t/*\n\t\t * Now assign OIDs from the original array into mapped indexes of the\n\t\t * result array.  Order of OIDs in the former is defined by the\n\t\t * catalog scan that retrieved them, whereas that in the latter is\n\t\t * defined by canonicalized representation of the partition bounds.\n\t\t */\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tresult->oids[mapping[i]] = oids[i];\n\t\tpfree(mapping);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\trel->rd_partdesc = result;\n}"
  },
  {
    "function_name": "RelationBuildPartitionKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
    "lines": "63-254",
    "snippet": "void\nRelationBuildPartitionKey(Relation relation)\n{\n\tForm_pg_partitioned_table form;\n\tHeapTuple\ttuple;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\tPartitionKey key;\n\tAttrNumber *attrs;\n\toidvector  *opclass;\n\toidvector  *collation;\n\tListCell   *partexprs_item;\n\tDatum\t\tdatum;\n\tMemoryContext partkeycxt,\n\t\t\t\toldcxt;\n\tint16\t\tprocnum;\n\n\ttuple = SearchSysCache1(PARTRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * The following happens when we have created our pg_class entry but not\n\t * the pg_partitioned_table entry yet.\n\t */\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn;\n\n\tpartkeycxt = AllocSetContextCreate(CurTransactionContext,\n\t\t\t\t\t\t\t\t\t   \"partition key\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(partkeycxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\tkey = (PartitionKey) MemoryContextAllocZero(partkeycxt,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionKeyData));\n\n\t/* Fixed-length attributes */\n\tform = (Form_pg_partitioned_table) GETSTRUCT(tuple);\n\tkey->strategy = form->partstrat;\n\tkey->partnatts = form->partnatts;\n\n\t/*\n\t * We can rely on the first variable-length attribute being mapped to the\n\t * relevant field of the catalog's C struct, because all previous\n\t * attributes are non-nullable and fixed-length.\n\t */\n\tattrs = form->partattrs.values;\n\n\t/* But use the hard way to retrieve further variable-length attributes */\n\t/* Operator class */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partclass, &isnull);\n\tAssert(!isnull);\n\topclass = (oidvector *) DatumGetPointer(datum);\n\n\t/* Collation */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partcollation, &isnull);\n\tAssert(!isnull);\n\tcollation = (oidvector *) DatumGetPointer(datum);\n\n\t/* Expressions */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partexprs, &isnull);\n\tif (!isnull)\n\t{\n\t\tchar\t   *exprString;\n\t\tNode\t   *expr;\n\n\t\texprString = TextDatumGetCString(datum);\n\t\texpr = stringToNode(exprString);\n\t\tpfree(exprString);\n\n\t\t/*\n\t\t * Run the expressions through const-simplification since the planner\n\t\t * will be comparing them to similarly-processed qual clause operands,\n\t\t * and may fail to detect valid matches without this step; fix\n\t\t * opfuncids while at it.  We don't need to bother with\n\t\t * canonicalize_qual() though, because partition expressions should be\n\t\t * in canonical form already (ie, no need for OR-merging or constant\n\t\t * elimination).\n\t\t */\n\t\texpr = eval_const_expressions(NULL, expr);\n\t\tfix_opfuncids(expr);\n\n\t\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\t\tkey->partexprs = (List *) copyObject(expr);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/* Allocate assorted arrays in the partkeycxt, which we'll fill below */\n\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\tkey->partattrs = (AttrNumber *) palloc0(key->partnatts * sizeof(AttrNumber));\n\tkey->partopfamily = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partopcintype = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partsupfunc = (FmgrInfo *) palloc0(key->partnatts * sizeof(FmgrInfo));\n\n\tkey->partcollation = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypid = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypmod = (int32 *) palloc0(key->partnatts * sizeof(int32));\n\tkey->parttyplen = (int16 *) palloc0(key->partnatts * sizeof(int16));\n\tkey->parttypbyval = (bool *) palloc0(key->partnatts * sizeof(bool));\n\tkey->parttypalign = (char *) palloc0(key->partnatts * sizeof(char));\n\tkey->parttypcoll = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* determine support function number to search for */\n\tprocnum = (key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\tHASHEXTENDED_PROC : BTORDER_PROC;\n\n\t/* Copy partattrs and fill other per-attribute info */\n\tmemcpy(key->partattrs, attrs, key->partnatts * sizeof(int16));\n\tpartexprs_item = list_head(key->partexprs);\n\tfor (i = 0; i < key->partnatts; i++)\n\t{\n\t\tAttrNumber\tattno = key->partattrs[i];\n\t\tHeapTuple\topclasstup;\n\t\tForm_pg_opclass opclassform;\n\t\tOid\t\t\tfuncid;\n\n\t\t/* Collect opfamily information */\n\t\topclasstup = SearchSysCache1(CLAOID,\n\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(opclass->values[i]));\n\t\tif (!HeapTupleIsValid(opclasstup))\n\t\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass->values[i]);\n\n\t\topclassform = (Form_pg_opclass) GETSTRUCT(opclasstup);\n\t\tkey->partopfamily[i] = opclassform->opcfamily;\n\t\tkey->partopcintype[i] = opclassform->opcintype;\n\n\t\t/* Get a support function for the specified opfamily and datatypes */\n\t\tfuncid = get_opfamily_proc(opclassform->opcfamily,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   procnum);\n\t\tif (!OidIsValid(funcid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype))));\n\n\t\tfmgr_info_cxt(funcid, &key->partsupfunc[i], partkeycxt);\n\n\t\t/* Collation */\n\t\tkey->partcollation[i] = collation->values[i];\n\n\t\t/* Collect type information */\n\t\tif (attno != 0)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(relation->rd_att, attno - 1);\n\n\t\t\tkey->parttypid[i] = att->atttypid;\n\t\t\tkey->parttypmod[i] = att->atttypmod;\n\t\t\tkey->parttypcoll[i] = att->attcollation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (partexprs_item == NULL)\n\t\t\t\telog(ERROR, \"wrong number of partition key expressions\");\n\n\t\t\tkey->parttypid[i] = exprType(lfirst(partexprs_item));\n\t\t\tkey->parttypmod[i] = exprTypmod(lfirst(partexprs_item));\n\t\t\tkey->parttypcoll[i] = exprCollation(lfirst(partexprs_item));\n\n\t\t\tpartexprs_item = lnext(partexprs_item);\n\t\t}\n\t\tget_typlenbyvalalign(key->parttypid[i],\n\t\t\t\t\t\t\t &key->parttyplen[i],\n\t\t\t\t\t\t\t &key->parttypbyval[i],\n\t\t\t\t\t\t\t &key->parttypalign[i]);\n\n\t\tReleaseSysCache(opclasstup);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(relation->rd_partkeycxt == NULL);\n\tAssert(relation->rd_partkey == NULL);\n\n\t/*\n\t * Success --- reparent our context and make the relcache point to the\n\t * newly constructed key\n\t */\n\tMemoryContextSetParent(partkeycxt, CacheMemoryContext);\n\trelation->rd_partkeycxt = partkeycxt;\n\trelation->rd_partkey = key;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/planner.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_inherits.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "partkeycxt",
            "CacheMemoryContext"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_partkey == NULL"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_partkeycxt == NULL"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "key->parttypid[i]",
            "&key->parttyplen[i]",
            "&key->parttypbyval[i]",
            "&key->parttypalign[i]"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "partexprs_item"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprCollation",
          "args": [
            "lfirst(partexprs_item)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "partexprs_item"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprTypmod",
          "args": [
            "lfirst(partexprs_item)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "partexprs_item"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "lfirst(partexprs_item)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "partexprs_item"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"wrong number of partition key expressions\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "attno - 1"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "funcid",
            "&key->partsupfunc[i]",
            "partkeycxt"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype)))"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\"",
            "NameStr(opclassform->opcname)",
            "(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\"",
            "procnum",
            "format_type_be(opclassform->opcintype)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "opclassform->opcintype"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "opclassform->opcname"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_OBJECT_DEFINITION"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "funcid"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opfamily_proc",
          "args": [
            "opclassform->opcfamily",
            "opclassform->opcintype",
            "opclassform->opcintype",
            "procnum"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "743-761",
          "snippet": "Oid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "opclasstup"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "opclasstup"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "CLAOID",
            "ObjectIdGetDatum(opclass->values[i])"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "opclass->values[i]"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "key->partexprs"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key->partattrs",
            "attrs",
            "key->partnatts * sizeof(int16)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "key->partnatts * sizeof(Oid)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "partkeycxt"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "expr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "partkeycxt"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_opfuncids",
          "args": [
            "expr"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eval_const_expressions",
          "args": [
            "NULL",
            "expr"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "exprString"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "exprString"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "datum"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PARTRELID",
            "tuple",
            "Anum_pg_partitioned_table_partexprs",
            "&isnull"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "partkeycxt",
            "sizeof(PartitionKeyData)"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "partkeycxt",
            "RelationGetRelationName(relation)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurTransactionContext",
            "\"partition key\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nRelationBuildPartitionKey(Relation relation)\n{\n\tForm_pg_partitioned_table form;\n\tHeapTuple\ttuple;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\tPartitionKey key;\n\tAttrNumber *attrs;\n\toidvector  *opclass;\n\toidvector  *collation;\n\tListCell   *partexprs_item;\n\tDatum\t\tdatum;\n\tMemoryContext partkeycxt,\n\t\t\t\toldcxt;\n\tint16\t\tprocnum;\n\n\ttuple = SearchSysCache1(PARTRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * The following happens when we have created our pg_class entry but not\n\t * the pg_partitioned_table entry yet.\n\t */\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn;\n\n\tpartkeycxt = AllocSetContextCreate(CurTransactionContext,\n\t\t\t\t\t\t\t\t\t   \"partition key\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(partkeycxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\tkey = (PartitionKey) MemoryContextAllocZero(partkeycxt,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionKeyData));\n\n\t/* Fixed-length attributes */\n\tform = (Form_pg_partitioned_table) GETSTRUCT(tuple);\n\tkey->strategy = form->partstrat;\n\tkey->partnatts = form->partnatts;\n\n\t/*\n\t * We can rely on the first variable-length attribute being mapped to the\n\t * relevant field of the catalog's C struct, because all previous\n\t * attributes are non-nullable and fixed-length.\n\t */\n\tattrs = form->partattrs.values;\n\n\t/* But use the hard way to retrieve further variable-length attributes */\n\t/* Operator class */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partclass, &isnull);\n\tAssert(!isnull);\n\topclass = (oidvector *) DatumGetPointer(datum);\n\n\t/* Collation */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partcollation, &isnull);\n\tAssert(!isnull);\n\tcollation = (oidvector *) DatumGetPointer(datum);\n\n\t/* Expressions */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partexprs, &isnull);\n\tif (!isnull)\n\t{\n\t\tchar\t   *exprString;\n\t\tNode\t   *expr;\n\n\t\texprString = TextDatumGetCString(datum);\n\t\texpr = stringToNode(exprString);\n\t\tpfree(exprString);\n\n\t\t/*\n\t\t * Run the expressions through const-simplification since the planner\n\t\t * will be comparing them to similarly-processed qual clause operands,\n\t\t * and may fail to detect valid matches without this step; fix\n\t\t * opfuncids while at it.  We don't need to bother with\n\t\t * canonicalize_qual() though, because partition expressions should be\n\t\t * in canonical form already (ie, no need for OR-merging or constant\n\t\t * elimination).\n\t\t */\n\t\texpr = eval_const_expressions(NULL, expr);\n\t\tfix_opfuncids(expr);\n\n\t\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\t\tkey->partexprs = (List *) copyObject(expr);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/* Allocate assorted arrays in the partkeycxt, which we'll fill below */\n\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\tkey->partattrs = (AttrNumber *) palloc0(key->partnatts * sizeof(AttrNumber));\n\tkey->partopfamily = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partopcintype = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partsupfunc = (FmgrInfo *) palloc0(key->partnatts * sizeof(FmgrInfo));\n\n\tkey->partcollation = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypid = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypmod = (int32 *) palloc0(key->partnatts * sizeof(int32));\n\tkey->parttyplen = (int16 *) palloc0(key->partnatts * sizeof(int16));\n\tkey->parttypbyval = (bool *) palloc0(key->partnatts * sizeof(bool));\n\tkey->parttypalign = (char *) palloc0(key->partnatts * sizeof(char));\n\tkey->parttypcoll = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* determine support function number to search for */\n\tprocnum = (key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\tHASHEXTENDED_PROC : BTORDER_PROC;\n\n\t/* Copy partattrs and fill other per-attribute info */\n\tmemcpy(key->partattrs, attrs, key->partnatts * sizeof(int16));\n\tpartexprs_item = list_head(key->partexprs);\n\tfor (i = 0; i < key->partnatts; i++)\n\t{\n\t\tAttrNumber\tattno = key->partattrs[i];\n\t\tHeapTuple\topclasstup;\n\t\tForm_pg_opclass opclassform;\n\t\tOid\t\t\tfuncid;\n\n\t\t/* Collect opfamily information */\n\t\topclasstup = SearchSysCache1(CLAOID,\n\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(opclass->values[i]));\n\t\tif (!HeapTupleIsValid(opclasstup))\n\t\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass->values[i]);\n\n\t\topclassform = (Form_pg_opclass) GETSTRUCT(opclasstup);\n\t\tkey->partopfamily[i] = opclassform->opcfamily;\n\t\tkey->partopcintype[i] = opclassform->opcintype;\n\n\t\t/* Get a support function for the specified opfamily and datatypes */\n\t\tfuncid = get_opfamily_proc(opclassform->opcfamily,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   procnum);\n\t\tif (!OidIsValid(funcid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype))));\n\n\t\tfmgr_info_cxt(funcid, &key->partsupfunc[i], partkeycxt);\n\n\t\t/* Collation */\n\t\tkey->partcollation[i] = collation->values[i];\n\n\t\t/* Collect type information */\n\t\tif (attno != 0)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(relation->rd_att, attno - 1);\n\n\t\t\tkey->parttypid[i] = att->atttypid;\n\t\t\tkey->parttypmod[i] = att->atttypmod;\n\t\t\tkey->parttypcoll[i] = att->attcollation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (partexprs_item == NULL)\n\t\t\t\telog(ERROR, \"wrong number of partition key expressions\");\n\n\t\t\tkey->parttypid[i] = exprType(lfirst(partexprs_item));\n\t\t\tkey->parttypmod[i] = exprTypmod(lfirst(partexprs_item));\n\t\t\tkey->parttypcoll[i] = exprCollation(lfirst(partexprs_item));\n\n\t\t\tpartexprs_item = lnext(partexprs_item);\n\t\t}\n\t\tget_typlenbyvalalign(key->parttypid[i],\n\t\t\t\t\t\t\t &key->parttyplen[i],\n\t\t\t\t\t\t\t &key->parttypbyval[i],\n\t\t\t\t\t\t\t &key->parttypalign[i]);\n\n\t\tReleaseSysCache(opclasstup);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(relation->rd_partkeycxt == NULL);\n\tAssert(relation->rd_partkey == NULL);\n\n\t/*\n\t * Success --- reparent our context and make the relcache point to the\n\t * newly constructed key\n\t */\n\tMemoryContextSetParent(partkeycxt, CacheMemoryContext);\n\trelation->rd_partkeycxt = partkeycxt;\n\trelation->rd_partkey = key;\n}"
  }
]