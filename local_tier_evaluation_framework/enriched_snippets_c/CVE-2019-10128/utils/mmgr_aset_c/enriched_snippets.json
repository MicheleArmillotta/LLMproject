[
  {
    "function_name": "AllocSetCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "1379-1482",
    "snippet": "static void\nAllocSetCheck(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tconst char *name = set->header.name;\n\tAllocBlock\tprevblock;\n\tAllocBlock\tblock;\n\n\tfor (prevblock = NULL, block = set->blocks;\n\t\t block != NULL;\n\t\t prevblock = block, block = block->next)\n\t{\n\t\tchar\t   *bpoz = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tlong\t\tblk_used = block->freeptr - bpoz;\n\t\tlong\t\tblk_data = 0;\n\t\tlong\t\tnchunks = 0;\n\n\t\t/*\n\t\t * Empty block - empty can be keeper-block only\n\t\t */\n\t\tif (!blk_used)\n\t\t{\n\t\t\tif (set->keeper != block)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: empty block %p\",\n\t\t\t\t\t name, block);\n\t\t}\n\n\t\t/*\n\t\t * Check block header fields\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->prev != prevblock ||\n\t\t\tblock->freeptr < bpoz ||\n\t\t\tblock->freeptr > block->endptr)\n\t\t\telog(WARNING, \"problem in alloc set %s: corrupt header in block %p\",\n\t\t\t\t name, block);\n\n\t\t/*\n\t\t * Chunk walker\n\t\t */\n\t\twhile (bpoz < block->freeptr)\n\t\t{\n\t\t\tAllocChunk\tchunk = (AllocChunk) bpoz;\n\t\t\tSize\t\tchsize,\n\t\t\t\t\t\tdsize;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tchsize = chunk->size;\t/* aligned chunk size */\n\t\t\tdsize = chunk->requested_size;\t/* real data */\n\n\t\t\t/*\n\t\t\t * Check chunk size\n\t\t\t */\n\t\t\tif (dsize > chsize)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: req size > alloc size for chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\t\t\tif (chsize < (1 << ALLOC_MINBITS))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad size %zu for chunk %p in block %p\",\n\t\t\t\t\t name, chsize, chunk, block);\n\n\t\t\t/* single-chunk block? */\n\t\t\tif (chsize > set->allocChunkLimit &&\n\t\t\t\tchsize + ALLOC_CHUNKHDRSZ != blk_used)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad single-chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, check for correct aset pointer. (If it's\n\t\t\t * free, the aset is the freelist pointer, which we can't check as\n\t\t\t * easily...)  Note this is an incomplete test, since palloc(0)\n\t\t\t * produces an allocated chunk with requested_size == 0.\n\t\t\t */\n\t\t\tif (dsize > 0 && chunk->aset != (void *) set)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bogus aset link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for overwrite of padding space in an allocated chunk.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set && dsize < chsize &&\n\t\t\t\t!sentinel_ok(chunk, ALLOC_CHUNKHDRSZ + dsize))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tblk_data += chsize;\n\t\t\tnchunks++;\n\n\t\t\tbpoz += ALLOC_CHUNKHDRSZ + chsize;\n\t\t}\n\n\t\tif ((blk_data + (nchunks * ALLOC_CHUNKHDRSZ)) != blk_used)\n\t\t\telog(WARNING, \"problem in alloc set %s: found inconsistent memory block %p\",\n\t\t\t\t name, block);\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
      "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))",
      "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void AllocSetFree(MemoryContext context, void *pointer);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"problem in alloc set %s: found inconsistent memory block %p\"",
            "name",
            "block"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "chunk",
            "ALLOC_CHUNKHDRSZ + dsize"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetCheck(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tconst char *name = set->header.name;\n\tAllocBlock\tprevblock;\n\tAllocBlock\tblock;\n\n\tfor (prevblock = NULL, block = set->blocks;\n\t\t block != NULL;\n\t\t prevblock = block, block = block->next)\n\t{\n\t\tchar\t   *bpoz = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tlong\t\tblk_used = block->freeptr - bpoz;\n\t\tlong\t\tblk_data = 0;\n\t\tlong\t\tnchunks = 0;\n\n\t\t/*\n\t\t * Empty block - empty can be keeper-block only\n\t\t */\n\t\tif (!blk_used)\n\t\t{\n\t\t\tif (set->keeper != block)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: empty block %p\",\n\t\t\t\t\t name, block);\n\t\t}\n\n\t\t/*\n\t\t * Check block header fields\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->prev != prevblock ||\n\t\t\tblock->freeptr < bpoz ||\n\t\t\tblock->freeptr > block->endptr)\n\t\t\telog(WARNING, \"problem in alloc set %s: corrupt header in block %p\",\n\t\t\t\t name, block);\n\n\t\t/*\n\t\t * Chunk walker\n\t\t */\n\t\twhile (bpoz < block->freeptr)\n\t\t{\n\t\t\tAllocChunk\tchunk = (AllocChunk) bpoz;\n\t\t\tSize\t\tchsize,\n\t\t\t\t\t\tdsize;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tchsize = chunk->size;\t/* aligned chunk size */\n\t\t\tdsize = chunk->requested_size;\t/* real data */\n\n\t\t\t/*\n\t\t\t * Check chunk size\n\t\t\t */\n\t\t\tif (dsize > chsize)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: req size > alloc size for chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\t\t\tif (chsize < (1 << ALLOC_MINBITS))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad size %zu for chunk %p in block %p\",\n\t\t\t\t\t name, chsize, chunk, block);\n\n\t\t\t/* single-chunk block? */\n\t\t\tif (chsize > set->allocChunkLimit &&\n\t\t\t\tchsize + ALLOC_CHUNKHDRSZ != blk_used)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad single-chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, check for correct aset pointer. (If it's\n\t\t\t * free, the aset is the freelist pointer, which we can't check as\n\t\t\t * easily...)  Note this is an incomplete test, since palloc(0)\n\t\t\t * produces an allocated chunk with requested_size == 0.\n\t\t\t */\n\t\t\tif (dsize > 0 && chunk->aset != (void *) set)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bogus aset link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for overwrite of padding space in an allocated chunk.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set && dsize < chsize &&\n\t\t\t\t!sentinel_ok(chunk, ALLOC_CHUNKHDRSZ + dsize))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tblk_data += chsize;\n\t\t\tnchunks++;\n\n\t\t\tbpoz += ALLOC_CHUNKHDRSZ + chsize;\n\t\t}\n\n\t\tif ((blk_data + (nchunks * ALLOC_CHUNKHDRSZ)) != blk_used)\n\t\t\telog(WARNING, \"problem in alloc set %s: found inconsistent memory block %p\",\n\t\t\t\t name, block);\n\t}\n}"
  },
  {
    "function_name": "AllocSetStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "1314-1366",
    "snippet": "static void\nAllocSetStats(MemoryContext context,\n\t\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t  MemoryContextCounters *totals)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tSize\t\tnblocks = 0;\n\tSize\t\tfreechunks = 0;\n\tSize\t\ttotalspace;\n\tSize\t\tfreespace = 0;\n\tAllocBlock\tblock;\n\tint\t\t\tfidx;\n\n\t/* Include context header in totalspace */\n\ttotalspace = MAXALIGN(sizeof(AllocSetContext));\n\n\tfor (block = set->blocks; block != NULL; block = block->next)\n\t{\n\t\tnblocks++;\n\t\ttotalspace += block->endptr - ((char *) block);\n\t\tfreespace += block->endptr - block->freeptr;\n\t}\n\tfor (fidx = 0; fidx < ALLOCSET_NUM_FREELISTS; fidx++)\n\t{\n\t\tAllocChunk\tchunk;\n\n\t\tfor (chunk = set->freelist[fidx]; chunk != NULL;\n\t\t\t chunk = (AllocChunk) chunk->aset)\n\t\t{\n\t\t\tfreechunks++;\n\t\t\tfreespace += chunk->size + ALLOC_CHUNKHDRSZ;\n\t\t}\n\t}\n\n\tif (printfunc)\n\t{\n\t\tchar\t\tstats_string[200];\n\n\t\tsnprintf(stats_string, sizeof(stats_string),\n\t\t\t\t \"%zu total in %zd blocks; %zu free (%zd chunks); %zu used\",\n\t\t\t\t totalspace, nblocks, freespace, freechunks,\n\t\t\t\t totalspace - freespace);\n\t\tprintfunc(context, passthru, stats_string);\n\t}\n\n\tif (totals)\n\t{\n\t\ttotals->nblocks += nblocks;\n\t\ttotals->freechunks += freechunks;\n\t\ttotals->totalspace += totalspace;\n\t\ttotals->freespace += freespace;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
      "#define ALLOCSET_NUM_FREELISTS\t11"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static bool AllocSetIsEmpty(MemoryContext context);",
      "static void AllocSetStats(MemoryContext context,\n\t\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t  MemoryContextCounters *totals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printfunc",
          "args": [
            "context",
            "passthru",
            "stats_string"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "stats_string",
            "sizeof(stats_string)",
            "\"%zu total in %zd blocks; %zu free (%zd chunks); %zu used\"",
            "totalspace",
            "nblocks",
            "freespace",
            "freechunks",
            "totalspace - freespace"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(AllocSetContext)"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOCSET_NUM_FREELISTS\t11\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\nstatic void AllocSetStats(MemoryContext context,\n\t\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t  MemoryContextCounters *totals);\n\nstatic void\nAllocSetStats(MemoryContext context,\n\t\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t  MemoryContextCounters *totals)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tSize\t\tnblocks = 0;\n\tSize\t\tfreechunks = 0;\n\tSize\t\ttotalspace;\n\tSize\t\tfreespace = 0;\n\tAllocBlock\tblock;\n\tint\t\t\tfidx;\n\n\t/* Include context header in totalspace */\n\ttotalspace = MAXALIGN(sizeof(AllocSetContext));\n\n\tfor (block = set->blocks; block != NULL; block = block->next)\n\t{\n\t\tnblocks++;\n\t\ttotalspace += block->endptr - ((char *) block);\n\t\tfreespace += block->endptr - block->freeptr;\n\t}\n\tfor (fidx = 0; fidx < ALLOCSET_NUM_FREELISTS; fidx++)\n\t{\n\t\tAllocChunk\tchunk;\n\n\t\tfor (chunk = set->freelist[fidx]; chunk != NULL;\n\t\t\t chunk = (AllocChunk) chunk->aset)\n\t\t{\n\t\t\tfreechunks++;\n\t\t\tfreespace += chunk->size + ALLOC_CHUNKHDRSZ;\n\t\t}\n\t}\n\n\tif (printfunc)\n\t{\n\t\tchar\t\tstats_string[200];\n\n\t\tsnprintf(stats_string, sizeof(stats_string),\n\t\t\t\t \"%zu total in %zd blocks; %zu free (%zd chunks); %zu used\",\n\t\t\t\t totalspace, nblocks, freespace, freechunks,\n\t\t\t\t totalspace - freespace);\n\t\tprintfunc(context, passthru, stats_string);\n\t}\n\n\tif (totals)\n\t{\n\t\ttotals->nblocks += nblocks;\n\t\ttotals->freechunks += freechunks;\n\t\ttotals->totalspace += totalspace;\n\t\ttotals->freespace += freespace;\n\t}\n}"
  },
  {
    "function_name": "AllocSetIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "1292-1304",
    "snippet": "static bool\nAllocSetIsEmpty(MemoryContext context)\n{\n\t/*\n\t * For now, we say \"empty\" only if the context is new or just reset. We\n\t * could examine the freelists to determine if all space has been freed,\n\t * but it's not really worth the trouble for present uses of this\n\t * functionality.\n\t */\n\tif (context->isReset)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic bool\nAllocSetIsEmpty(MemoryContext context)\n{\n\t/*\n\t * For now, we say \"empty\" only if the context is new or just reset. We\n\t * could examine the freelists to determine if all space has been freed,\n\t * but it's not really worth the trouble for present uses of this\n\t * functionality.\n\t */\n\tif (context->isReset)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "AllocSetGetChunkSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "1276-1286",
    "snippet": "static Size\nAllocSetGetChunkSpace(MemoryContext context, void *pointer)\n{\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\tSize\t\tresult;\n\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\tresult = chunk->size + ALLOC_CHUNKHDRSZ;\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\treturn result;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void AllocSetFree(MemoryContext context, void *pointer);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic Size\nAllocSetGetChunkSpace(MemoryContext context, void *pointer)\n{\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\tSize\t\tresult;\n\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\tresult = chunk->size + ALLOC_CHUNKHDRSZ;\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\treturn result;\n}"
  },
  {
    "function_name": "AllocSetRealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "1067-1269",
    "snippet": "static void *\nAllocSetRealloc(MemoryContext context, void *pointer, Size size)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\tSize\t\toldsize;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\toldsize = chunk->size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < oldsize)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t set->header.name, chunk);\n#endif\n\n\t/*\n\t * Chunk sizes are aligned to power of 2 in AllocSetAlloc(). Maybe the\n\t * allocated area already is >= the new size.  (In particular, we always\n\t * fall out here if the requested size is a decrease.)\n\t */\n\tif (oldsize >= size)\n\t{\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tSize\t\toldrequest = chunk->requested_size;\n\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* We can only fill the extra space if we know the prior request */\n\t\tif (size > oldrequest)\n\t\t\trandomize_mem((char *) pointer + oldrequest,\n\t\t\t\t\t\t  size - oldrequest);\n#endif\n\n\t\tchunk->requested_size = size;\n\n\t\t/*\n\t\t * If this is an increase, mark any newly-available part UNDEFINED.\n\t\t * Otherwise, mark the obsolete part NOACCESS.\n\t\t */\n\t\tif (size > oldrequest)\n\t\t\tVALGRIND_MAKE_MEM_UNDEFINED((char *) pointer + oldrequest,\n\t\t\t\t\t\t\t\t\t\tsize - oldrequest);\n\t\telse\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) pointer + size,\n\t\t\t\t\t\t\t\t\t   oldsize - size);\n\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < oldsize)\n\t\t\tset_sentinel(pointer, size);\n#else\t\t\t\t\t\t\t/* !MEMORY_CONTEXT_CHECKING */\n\n\t\t/*\n\t\t * We don't have the information to determine whether we're growing\n\t\t * the old request or shrinking it, so we conservatively mark the\n\t\t * entire new allocation DEFINED.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(pointer, oldsize);\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, size);\n#endif\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn pointer;\n\t}\n\n\tif (oldsize > set->allocChunkLimit)\n\t{\n\t\t/*\n\t\t * The chunk must have been allocated as a single-chunk block.  Use\n\t\t * realloc() to make the containing block bigger with minimum space\n\t\t * wastage.\n\t\t */\n\t\tAllocBlock\tblock = (AllocBlock) (((char *) chunk) - ALLOC_BLOCKHDRSZ);\n\t\tSize\t\tchksize;\n\t\tSize\t\tblksize;\n\n\t\t/*\n\t\t * Try to verify that we have a sane block pointer: it should\n\t\t * reference the correct aset, and freeptr and endptr should point\n\t\t * just past the chunk.\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->freeptr != block->endptr ||\n\t\t\tblock->freeptr != ((char *) block) +\n\t\t\t(chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ))\n\t\t\telog(ERROR, \"could not find block containing chunk %p\", chunk);\n\n\t\t/* Do the realloc */\n\t\tchksize = MAXALIGN(size);\n\t\tblksize = chksize + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\tblock = (AllocBlock) realloc(block, blksize);\n\t\tif (block == NULL)\n\t\t{\n\t\t\t/* Disallow external access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\t/* Update pointers since block has likely been moved */\n\t\tchunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);\n\t\tpointer = AllocChunkGetPointer(chunk);\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block;\n\t\telse\n\t\t\tset->blocks = block;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block;\n\t\tchunk->size = chksize;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* We can only fill the extra space if we know the prior request */\n\t\trandomize_mem((char *) pointer + chunk->requested_size,\n\t\t\t\t\t  size - chunk->requested_size);\n#endif\n\n\t\t/*\n\t\t * realloc() (or randomize_mem()) will have left the newly-allocated\n\t\t * part UNDEFINED, but we may need to adjust trailing bytes from the\n\t\t * old allocation.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_UNDEFINED((char *) pointer + chunk->requested_size,\n\t\t\t\t\t\t\t\t\toldsize - chunk->requested_size);\n\n\t\tchunk->requested_size = size;\n\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk->size)\n\t\t\tset_sentinel(pointer, size);\n#else\t\t\t\t\t\t\t/* !MEMORY_CONTEXT_CHECKING */\n\n\t\t/*\n\t\t * We don't know how much of the old chunk size was the actual\n\t\t * allocation; it could have been as small as one byte.  We have to be\n\t\t * conservative and just mark the entire old portion DEFINED.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);\n#endif\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) pointer + size, chksize - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn pointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Small-chunk case.  We just do this by brute force, ie, allocate a\n\t\t * new chunk and copy the data.  Since we know the existing data isn't\n\t\t * huge, this won't involve any great memcpy expense, so it's not\n\t\t * worth being smarter.  (At one time we tried to avoid memcpy when it\n\t\t * was possible to enlarge the chunk in-place, but that turns out to\n\t\t * misbehave unpleasantly for repeated cycles of\n\t\t * palloc/repalloc/pfree: the eventually freed chunks go into the\n\t\t * wrong freelist for the next initial palloc request, and so we leak\n\t\t * memory indefinitely.  See pgsql-hackers archives for 2007-08-11.)\n\t\t */\n\t\tAllocPointer newPointer;\n\n\t\t/* allocate new chunk */\n\t\tnewPointer = AllocSetAlloc((MemoryContext) set, size);\n\n\t\t/* leave immediately if request was not completed */\n\t\tif (newPointer == NULL)\n\t\t{\n\t\t\t/* Disallow external access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * AllocSetAlloc() may have returned a region that is still NOACCESS.\n\t\t * Change it to UNDEFINED for the moment; memcpy() will then transfer\n\t\t * definedness from the old allocation to the new.  If we know the old\n\t\t * allocation, copy just that much.  Otherwise, make the entire old\n\t\t * chunk defined to avoid errors as we copy the currently-NOACCESS\n\t\t * trailing bytes.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_UNDEFINED(newPointer, size);\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\toldsize = chunk->requested_size;\n#else\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);\n#endif\n\n\t\t/* transfer existing data (certain to fit) */\n\t\tmemcpy(newPointer, pointer, oldsize);\n\n\t\t/* free old chunk */\n\t\tAllocSetFree((MemoryContext) set, pointer);\n\n\t\treturn newPointer;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
      "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void AllocSetFree(MemoryContext context, void *pointer);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AllocSetFree",
          "args": [
            "(MemoryContext) set",
            "pointer"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "AllocSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
          "lines": "986-1053",
          "snippet": "static void\nAllocSetFree(MemoryContext context, void *pointer)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\tAllocFreeInfo(set, chunk);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t set->header.name, chunk);\n#endif\n\n\tif (chunk->size > set->allocChunkLimit)\n\t{\n\t\t/*\n\t\t * Big chunks are certain to have been allocated as single-chunk\n\t\t * blocks.  Just unlink that block and return it to malloc().\n\t\t */\n\t\tAllocBlock\tblock = (AllocBlock) (((char *) chunk) - ALLOC_BLOCKHDRSZ);\n\n\t\t/*\n\t\t * Try to verify that we have a sane block pointer: it should\n\t\t * reference the correct aset, and freeptr and endptr should point\n\t\t * just past the chunk.\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->freeptr != block->endptr ||\n\t\t\tblock->freeptr != ((char *) block) +\n\t\t\t(chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ))\n\t\t\telog(ERROR, \"could not find block containing chunk %p\", chunk);\n\n\t\t/* OK, remove block from aset's list and free it */\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block->next;\n\t\telse\n\t\t\tset->blocks = block->next;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block->prev;\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\t\tfree(block);\n\t}\n\telse\n\t{\n\t\t/* Normal case, put the chunk into appropriate freelist */\n\t\tint\t\t\tfidx = AllocSetFreeIndex(chunk->size);\n\n\t\tchunk->aset = (void *) set->freelist[fidx];\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(pointer, chunk->size);\n#endif\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t/* Reset requested_size to 0 in chunks that are on freelist */\n\t\tchunk->requested_size = 0;\n#endif\n\t\tset->freelist[fidx] = chunk;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
            "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
            "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))"
          ],
          "globals_used": [
            "static void *AllocSetAlloc(MemoryContext context, Size size);",
            "static void AllocSetFree(MemoryContext context, void *pointer);",
            "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
            "static void AllocSetReset(MemoryContext context);",
            "static void AllocSetDelete(MemoryContext context);",
            "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
            "static bool AllocSetIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetFree(MemoryContext context, void *pointer)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\tAllocFreeInfo(set, chunk);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t set->header.name, chunk);\n#endif\n\n\tif (chunk->size > set->allocChunkLimit)\n\t{\n\t\t/*\n\t\t * Big chunks are certain to have been allocated as single-chunk\n\t\t * blocks.  Just unlink that block and return it to malloc().\n\t\t */\n\t\tAllocBlock\tblock = (AllocBlock) (((char *) chunk) - ALLOC_BLOCKHDRSZ);\n\n\t\t/*\n\t\t * Try to verify that we have a sane block pointer: it should\n\t\t * reference the correct aset, and freeptr and endptr should point\n\t\t * just past the chunk.\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->freeptr != block->endptr ||\n\t\t\tblock->freeptr != ((char *) block) +\n\t\t\t(chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ))\n\t\t\telog(ERROR, \"could not find block containing chunk %p\", chunk);\n\n\t\t/* OK, remove block from aset's list and free it */\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block->next;\n\t\telse\n\t\t\tset->blocks = block->next;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block->prev;\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\t\tfree(block);\n\t}\n\telse\n\t{\n\t\t/* Normal case, put the chunk into appropriate freelist */\n\t\tint\t\t\tfidx = AllocSetFreeIndex(chunk->size);\n\n\t\tchunk->aset = (void *) set->freelist[fidx];\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(pointer, chunk->size);\n#endif\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t/* Reset requested_size to 0 in chunks that are on freelist */\n\t\tchunk->requested_size = 0;\n#endif\n\t\tset->freelist[fidx] = chunk;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newPointer",
            "pointer",
            "oldsize"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "pointer",
            "oldsize"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "newPointer",
            "size"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetAlloc",
          "args": [
            "(MemoryContext) set",
            "size"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "AllocSetAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
          "lines": "713-980",
          "snippet": "static void *\nAllocSetAlloc(MemoryContext context, Size size)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock;\n\tAllocChunk\tchunk;\n\tint\t\t\tfidx;\n\tSize\t\tchunk_size;\n\tSize\t\tblksize;\n\n\tAssertArg(AllocSetIsValid(set));\n\n\t/*\n\t * If requested size exceeds maximum for chunks, allocate an entire block\n\t * for this request.\n\t */\n\tif (size > set->allocChunkLimit)\n\t{\n\t\tchunk_size = MAXALIGN(size);\n\t\tblksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\tblock = (AllocBlock) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\t\tblock->aset = set;\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);\n\t\tchunk->aset = set;\n\t\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\t/*\n\t\t * Stick the new block underneath the active allocation block, if any,\n\t\t * so that we don't lose the use of the space remaining therein.\n\t\t */\n\t\tif (set->blocks != NULL)\n\t\t{\n\t\t\tblock->prev = set->blocks;\n\t\t\tblock->next = set->blocks->next;\n\t\t\tif (block->next)\n\t\t\t\tblock->next->prev = block;\n\t\t\tset->blocks->next = block;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock->prev = NULL;\n\t\t\tblock->next = NULL;\n\t\t\tset->blocks = block;\n\t\t}\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Request is small enough to be treated as a chunk.  Look in the\n\t * corresponding free list to see if there is a free chunk we could reuse.\n\t * If one is found, remove it from the free list, make it again a member\n\t * of the alloc set and return its data address.\n\t */\n\tfidx = AllocSetFreeIndex(size);\n\tchunk = set->freelist[fidx];\n\tif (chunk != NULL)\n\t{\n\t\tAssert(chunk->size >= size);\n\n\t\tset->freelist[fidx] = (AllocChunk) chunk->aset;\n\n\t\tchunk->aset = (void *) set;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk->size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk->size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Choose the actual chunk size to allocate.\n\t */\n\tchunk_size = (1 << ALLOC_MINBITS) << fidx;\n\tAssert(chunk_size >= size);\n\n\t/*\n\t * If there is enough room in the active allocation block, we will put the\n\t * chunk into that block.  Else must start a new one.\n\t */\n\tif ((block = set->blocks) != NULL)\n\t{\n\t\tSize\t\tavailspace = block->endptr - block->freeptr;\n\n\t\tif (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))\n\t\t{\n\t\t\t/*\n\t\t\t * The existing active (top) block does not have enough room for\n\t\t\t * the requested allocation, but it might still have a useful\n\t\t\t * amount of space in it.  Once we push it down in the block list,\n\t\t\t * we'll never try to allocate more space from it. So, before we\n\t\t\t * do that, carve up its free space into chunks that we can put on\n\t\t\t * the set's freelists.\n\t\t\t *\n\t\t\t * Because we can only get here when there's less than\n\t\t\t * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate\n\t\t\t * more than ALLOCSET_NUM_FREELISTS-1 times.\n\t\t\t */\n\t\t\twhile (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))\n\t\t\t{\n\t\t\t\tSize\t\tavailchunk = availspace - ALLOC_CHUNKHDRSZ;\n\t\t\t\tint\t\t\ta_fidx = AllocSetFreeIndex(availchunk);\n\n\t\t\t\t/*\n\t\t\t\t * In most cases, we'll get back the index of the next larger\n\t\t\t\t * freelist than the one we need to put this chunk on.  The\n\t\t\t\t * exception is when availchunk is exactly a power of 2.\n\t\t\t\t */\n\t\t\t\tif (availchunk != ((Size) 1 << (a_fidx + ALLOC_MINBITS)))\n\t\t\t\t{\n\t\t\t\t\ta_fidx--;\n\t\t\t\t\tAssert(a_fidx >= 0);\n\t\t\t\t\tavailchunk = ((Size) 1 << (a_fidx + ALLOC_MINBITS));\n\t\t\t\t}\n\n\t\t\t\tchunk = (AllocChunk) (block->freeptr);\n\n\t\t\t\t/* Prepare to initialize the chunk header. */\n\t\t\t\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tblock->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);\n\t\t\t\tavailspace -= (availchunk + ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tchunk->size = availchunk;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t\t\tchunk->requested_size = 0;\t/* mark it free */\n#endif\n\t\t\t\tchunk->aset = (void *) set->freelist[a_fidx];\n\t\t\t\tset->freelist[a_fidx] = chunk;\n\t\t\t}\n\n\t\t\t/* Mark that we need to create a new block */\n\t\t\tblock = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Time to create a new regular (multi-chunk) block?\n\t */\n\tif (block == NULL)\n\t{\n\t\tSize\t\trequired_size;\n\n\t\t/*\n\t\t * The first such block has size initBlockSize, and we double the\n\t\t * space in each succeeding block, but not more than maxBlockSize.\n\t\t */\n\t\tblksize = set->nextBlockSize;\n\t\tset->nextBlockSize <<= 1;\n\t\tif (set->nextBlockSize > set->maxBlockSize)\n\t\t\tset->nextBlockSize = set->maxBlockSize;\n\n\t\t/*\n\t\t * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more\n\t\t * space... but try to keep it a power of 2.\n\t\t */\n\t\trequired_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\twhile (blksize < required_size)\n\t\t\tblksize <<= 1;\n\n\t\t/* Try to allocate it */\n\t\tblock = (AllocBlock) malloc(blksize);\n\n\t\t/*\n\t\t * We could be asking for pretty big blocks here, so cope if malloc\n\t\t * fails.  But give up if there's less than a meg or so available...\n\t\t */\n\t\twhile (block == NULL && blksize > 1024 * 1024)\n\t\t{\n\t\t\tblksize >>= 1;\n\t\t\tif (blksize < required_size)\n\t\t\t\tbreak;\n\t\t\tblock = (AllocBlock) malloc(blksize);\n\t\t}\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->aset = set;\n\t\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - ALLOC_BLOCKHDRSZ);\n\n\t\tblock->prev = NULL;\n\t\tblock->next = set->blocks;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block;\n\t\tset->blocks = block;\n\t}\n\n\t/*\n\t * OK, do the allocation\n\t */\n\tchunk = (AllocChunk) (block->freeptr);\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\tblock->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->aset = (void *) set;\n\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\tAllocAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\treturn AllocChunkGetPointer(chunk);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
            "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
            "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))",
            "#define ALLOC_CHUNK_LIMIT\t(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))",
            "#define ALLOCSET_NUM_FREELISTS\t11",
            "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
          ],
          "globals_used": [
            "static void *AllocSetAlloc(MemoryContext context, Size size);",
            "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
            "static void AllocSetReset(MemoryContext context);",
            "static void AllocSetDelete(MemoryContext context);",
            "static bool AllocSetIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n#define ALLOC_CHUNK_LIMIT\t(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))\n#define ALLOCSET_NUM_FREELISTS\t11\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void *\nAllocSetAlloc(MemoryContext context, Size size)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock;\n\tAllocChunk\tchunk;\n\tint\t\t\tfidx;\n\tSize\t\tchunk_size;\n\tSize\t\tblksize;\n\n\tAssertArg(AllocSetIsValid(set));\n\n\t/*\n\t * If requested size exceeds maximum for chunks, allocate an entire block\n\t * for this request.\n\t */\n\tif (size > set->allocChunkLimit)\n\t{\n\t\tchunk_size = MAXALIGN(size);\n\t\tblksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\tblock = (AllocBlock) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\t\tblock->aset = set;\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);\n\t\tchunk->aset = set;\n\t\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\t/*\n\t\t * Stick the new block underneath the active allocation block, if any,\n\t\t * so that we don't lose the use of the space remaining therein.\n\t\t */\n\t\tif (set->blocks != NULL)\n\t\t{\n\t\t\tblock->prev = set->blocks;\n\t\t\tblock->next = set->blocks->next;\n\t\t\tif (block->next)\n\t\t\t\tblock->next->prev = block;\n\t\t\tset->blocks->next = block;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock->prev = NULL;\n\t\t\tblock->next = NULL;\n\t\t\tset->blocks = block;\n\t\t}\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Request is small enough to be treated as a chunk.  Look in the\n\t * corresponding free list to see if there is a free chunk we could reuse.\n\t * If one is found, remove it from the free list, make it again a member\n\t * of the alloc set and return its data address.\n\t */\n\tfidx = AllocSetFreeIndex(size);\n\tchunk = set->freelist[fidx];\n\tif (chunk != NULL)\n\t{\n\t\tAssert(chunk->size >= size);\n\n\t\tset->freelist[fidx] = (AllocChunk) chunk->aset;\n\n\t\tchunk->aset = (void *) set;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk->size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk->size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Choose the actual chunk size to allocate.\n\t */\n\tchunk_size = (1 << ALLOC_MINBITS) << fidx;\n\tAssert(chunk_size >= size);\n\n\t/*\n\t * If there is enough room in the active allocation block, we will put the\n\t * chunk into that block.  Else must start a new one.\n\t */\n\tif ((block = set->blocks) != NULL)\n\t{\n\t\tSize\t\tavailspace = block->endptr - block->freeptr;\n\n\t\tif (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))\n\t\t{\n\t\t\t/*\n\t\t\t * The existing active (top) block does not have enough room for\n\t\t\t * the requested allocation, but it might still have a useful\n\t\t\t * amount of space in it.  Once we push it down in the block list,\n\t\t\t * we'll never try to allocate more space from it. So, before we\n\t\t\t * do that, carve up its free space into chunks that we can put on\n\t\t\t * the set's freelists.\n\t\t\t *\n\t\t\t * Because we can only get here when there's less than\n\t\t\t * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate\n\t\t\t * more than ALLOCSET_NUM_FREELISTS-1 times.\n\t\t\t */\n\t\t\twhile (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))\n\t\t\t{\n\t\t\t\tSize\t\tavailchunk = availspace - ALLOC_CHUNKHDRSZ;\n\t\t\t\tint\t\t\ta_fidx = AllocSetFreeIndex(availchunk);\n\n\t\t\t\t/*\n\t\t\t\t * In most cases, we'll get back the index of the next larger\n\t\t\t\t * freelist than the one we need to put this chunk on.  The\n\t\t\t\t * exception is when availchunk is exactly a power of 2.\n\t\t\t\t */\n\t\t\t\tif (availchunk != ((Size) 1 << (a_fidx + ALLOC_MINBITS)))\n\t\t\t\t{\n\t\t\t\t\ta_fidx--;\n\t\t\t\t\tAssert(a_fidx >= 0);\n\t\t\t\t\tavailchunk = ((Size) 1 << (a_fidx + ALLOC_MINBITS));\n\t\t\t\t}\n\n\t\t\t\tchunk = (AllocChunk) (block->freeptr);\n\n\t\t\t\t/* Prepare to initialize the chunk header. */\n\t\t\t\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tblock->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);\n\t\t\t\tavailspace -= (availchunk + ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tchunk->size = availchunk;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t\t\tchunk->requested_size = 0;\t/* mark it free */\n#endif\n\t\t\t\tchunk->aset = (void *) set->freelist[a_fidx];\n\t\t\t\tset->freelist[a_fidx] = chunk;\n\t\t\t}\n\n\t\t\t/* Mark that we need to create a new block */\n\t\t\tblock = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Time to create a new regular (multi-chunk) block?\n\t */\n\tif (block == NULL)\n\t{\n\t\tSize\t\trequired_size;\n\n\t\t/*\n\t\t * The first such block has size initBlockSize, and we double the\n\t\t * space in each succeeding block, but not more than maxBlockSize.\n\t\t */\n\t\tblksize = set->nextBlockSize;\n\t\tset->nextBlockSize <<= 1;\n\t\tif (set->nextBlockSize > set->maxBlockSize)\n\t\t\tset->nextBlockSize = set->maxBlockSize;\n\n\t\t/*\n\t\t * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more\n\t\t * space... but try to keep it a power of 2.\n\t\t */\n\t\trequired_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\twhile (blksize < required_size)\n\t\t\tblksize <<= 1;\n\n\t\t/* Try to allocate it */\n\t\tblock = (AllocBlock) malloc(blksize);\n\n\t\t/*\n\t\t * We could be asking for pretty big blocks here, so cope if malloc\n\t\t * fails.  But give up if there's less than a meg or so available...\n\t\t */\n\t\twhile (block == NULL && blksize > 1024 * 1024)\n\t\t{\n\t\t\tblksize >>= 1;\n\t\t\tif (blksize < required_size)\n\t\t\t\tbreak;\n\t\t\tblock = (AllocBlock) malloc(blksize);\n\t\t}\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->aset = set;\n\t\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - ALLOC_BLOCKHDRSZ);\n\n\t\tblock->prev = NULL;\n\t\tblock->next = set->blocks;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block;\n\t\tset->blocks = block;\n\t}\n\n\t/*\n\t * OK, do the allocation\n\t */\n\tchunk = (AllocChunk) (block->freeptr);\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\tblock->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->aset = (void *) set;\n\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\tAllocAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\treturn AllocChunkGetPointer(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) pointer + size",
            "chksize - size"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "pointer",
            "oldsize"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "pointer",
            "size"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "(char *) pointer + chunk->requested_size",
            "oldsize - chunk->requested_size"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randomize_mem",
          "args": [
            "(char *) pointer + chunk->requested_size",
            "size - chunk->requested_size"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/memdebug.c",
          "lines": "74-91",
          "snippet": "void\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}",
          "includes": [
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nvoid\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "((char *) block) + ALLOC_BLOCKHDRSZ"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "block",
            "blksize"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "size"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find block containing chunk %p\"",
            "chunk"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "((char *) chunk) - ALLOC_BLOCKHDRSZ"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "pointer",
            "size"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "pointer",
            "oldsize"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "pointer",
            "size"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) pointer + size",
            "oldsize - size"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "(char *) pointer + oldrequest",
            "size - oldrequest"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "pointer",
            "chunk->requested_size"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void *\nAllocSetRealloc(MemoryContext context, void *pointer, Size size)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\tSize\t\toldsize;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\toldsize = chunk->size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < oldsize)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t set->header.name, chunk);\n#endif\n\n\t/*\n\t * Chunk sizes are aligned to power of 2 in AllocSetAlloc(). Maybe the\n\t * allocated area already is >= the new size.  (In particular, we always\n\t * fall out here if the requested size is a decrease.)\n\t */\n\tif (oldsize >= size)\n\t{\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tSize\t\toldrequest = chunk->requested_size;\n\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* We can only fill the extra space if we know the prior request */\n\t\tif (size > oldrequest)\n\t\t\trandomize_mem((char *) pointer + oldrequest,\n\t\t\t\t\t\t  size - oldrequest);\n#endif\n\n\t\tchunk->requested_size = size;\n\n\t\t/*\n\t\t * If this is an increase, mark any newly-available part UNDEFINED.\n\t\t * Otherwise, mark the obsolete part NOACCESS.\n\t\t */\n\t\tif (size > oldrequest)\n\t\t\tVALGRIND_MAKE_MEM_UNDEFINED((char *) pointer + oldrequest,\n\t\t\t\t\t\t\t\t\t\tsize - oldrequest);\n\t\telse\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) pointer + size,\n\t\t\t\t\t\t\t\t\t   oldsize - size);\n\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < oldsize)\n\t\t\tset_sentinel(pointer, size);\n#else\t\t\t\t\t\t\t/* !MEMORY_CONTEXT_CHECKING */\n\n\t\t/*\n\t\t * We don't have the information to determine whether we're growing\n\t\t * the old request or shrinking it, so we conservatively mark the\n\t\t * entire new allocation DEFINED.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(pointer, oldsize);\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, size);\n#endif\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn pointer;\n\t}\n\n\tif (oldsize > set->allocChunkLimit)\n\t{\n\t\t/*\n\t\t * The chunk must have been allocated as a single-chunk block.  Use\n\t\t * realloc() to make the containing block bigger with minimum space\n\t\t * wastage.\n\t\t */\n\t\tAllocBlock\tblock = (AllocBlock) (((char *) chunk) - ALLOC_BLOCKHDRSZ);\n\t\tSize\t\tchksize;\n\t\tSize\t\tblksize;\n\n\t\t/*\n\t\t * Try to verify that we have a sane block pointer: it should\n\t\t * reference the correct aset, and freeptr and endptr should point\n\t\t * just past the chunk.\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->freeptr != block->endptr ||\n\t\t\tblock->freeptr != ((char *) block) +\n\t\t\t(chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ))\n\t\t\telog(ERROR, \"could not find block containing chunk %p\", chunk);\n\n\t\t/* Do the realloc */\n\t\tchksize = MAXALIGN(size);\n\t\tblksize = chksize + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\tblock = (AllocBlock) realloc(block, blksize);\n\t\tif (block == NULL)\n\t\t{\n\t\t\t/* Disallow external access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\t/* Update pointers since block has likely been moved */\n\t\tchunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);\n\t\tpointer = AllocChunkGetPointer(chunk);\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block;\n\t\telse\n\t\t\tset->blocks = block;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block;\n\t\tchunk->size = chksize;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* We can only fill the extra space if we know the prior request */\n\t\trandomize_mem((char *) pointer + chunk->requested_size,\n\t\t\t\t\t  size - chunk->requested_size);\n#endif\n\n\t\t/*\n\t\t * realloc() (or randomize_mem()) will have left the newly-allocated\n\t\t * part UNDEFINED, but we may need to adjust trailing bytes from the\n\t\t * old allocation.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_UNDEFINED((char *) pointer + chunk->requested_size,\n\t\t\t\t\t\t\t\t\toldsize - chunk->requested_size);\n\n\t\tchunk->requested_size = size;\n\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk->size)\n\t\t\tset_sentinel(pointer, size);\n#else\t\t\t\t\t\t\t/* !MEMORY_CONTEXT_CHECKING */\n\n\t\t/*\n\t\t * We don't know how much of the old chunk size was the actual\n\t\t * allocation; it could have been as small as one byte.  We have to be\n\t\t * conservative and just mark the entire old portion DEFINED.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);\n#endif\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) pointer + size, chksize - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn pointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Small-chunk case.  We just do this by brute force, ie, allocate a\n\t\t * new chunk and copy the data.  Since we know the existing data isn't\n\t\t * huge, this won't involve any great memcpy expense, so it's not\n\t\t * worth being smarter.  (At one time we tried to avoid memcpy when it\n\t\t * was possible to enlarge the chunk in-place, but that turns out to\n\t\t * misbehave unpleasantly for repeated cycles of\n\t\t * palloc/repalloc/pfree: the eventually freed chunks go into the\n\t\t * wrong freelist for the next initial palloc request, and so we leak\n\t\t * memory indefinitely.  See pgsql-hackers archives for 2007-08-11.)\n\t\t */\n\t\tAllocPointer newPointer;\n\n\t\t/* allocate new chunk */\n\t\tnewPointer = AllocSetAlloc((MemoryContext) set, size);\n\n\t\t/* leave immediately if request was not completed */\n\t\tif (newPointer == NULL)\n\t\t{\n\t\t\t/* Disallow external access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * AllocSetAlloc() may have returned a region that is still NOACCESS.\n\t\t * Change it to UNDEFINED for the moment; memcpy() will then transfer\n\t\t * definedness from the old allocation to the new.  If we know the old\n\t\t * allocation, copy just that much.  Otherwise, make the entire old\n\t\t * chunk defined to avoid errors as we copy the currently-NOACCESS\n\t\t * trailing bytes.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_UNDEFINED(newPointer, size);\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\toldsize = chunk->requested_size;\n#else\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);\n#endif\n\n\t\t/* transfer existing data (certain to fit) */\n\t\tmemcpy(newPointer, pointer, oldsize);\n\n\t\t/* free old chunk */\n\t\tAllocSetFree((MemoryContext) set, pointer);\n\n\t\treturn newPointer;\n\t}\n}"
  },
  {
    "function_name": "AllocSetFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "986-1053",
    "snippet": "static void\nAllocSetFree(MemoryContext context, void *pointer)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\tAllocFreeInfo(set, chunk);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t set->header.name, chunk);\n#endif\n\n\tif (chunk->size > set->allocChunkLimit)\n\t{\n\t\t/*\n\t\t * Big chunks are certain to have been allocated as single-chunk\n\t\t * blocks.  Just unlink that block and return it to malloc().\n\t\t */\n\t\tAllocBlock\tblock = (AllocBlock) (((char *) chunk) - ALLOC_BLOCKHDRSZ);\n\n\t\t/*\n\t\t * Try to verify that we have a sane block pointer: it should\n\t\t * reference the correct aset, and freeptr and endptr should point\n\t\t * just past the chunk.\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->freeptr != block->endptr ||\n\t\t\tblock->freeptr != ((char *) block) +\n\t\t\t(chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ))\n\t\t\telog(ERROR, \"could not find block containing chunk %p\", chunk);\n\n\t\t/* OK, remove block from aset's list and free it */\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block->next;\n\t\telse\n\t\t\tset->blocks = block->next;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block->prev;\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\t\tfree(block);\n\t}\n\telse\n\t{\n\t\t/* Normal case, put the chunk into appropriate freelist */\n\t\tint\t\t\tfidx = AllocSetFreeIndex(chunk->size);\n\n\t\tchunk->aset = (void *) set->freelist[fidx];\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(pointer, chunk->size);\n#endif\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t/* Reset requested_size to 0 in chunks that are on freelist */\n\t\tchunk->requested_size = 0;\n#endif\n\t\tset->freelist[fidx] = chunk;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
      "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void AllocSetFree(MemoryContext context, void *pointer);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "pointer",
            "chunk->size"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetFreeIndex",
          "args": [
            "chunk->size"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "AllocSetFreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
          "lines": "336-365",
          "snippet": "static inline int\nAllocSetFreeIndex(Size size)\n{\n\tint\t\t\tidx;\n\tunsigned int t,\n\t\t\t\ttsize;\n\n\tif (size > (1 << ALLOC_MINBITS))\n\t{\n\t\ttsize = (size - 1) >> ALLOC_MINBITS;\n\n\t\t/*\n\t\t * At this point we need to obtain log2(tsize)+1, ie, the number of\n\t\t * not-all-zero bits at the right.  We used to do this with a\n\t\t * shift-and-count loop, but this function is enough of a hotspot to\n\t\t * justify micro-optimization effort.  The best approach seems to be\n\t\t * to use a lookup table.  Note that this code assumes that\n\t\t * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of\n\t\t * the tsize value.\n\t\t */\n\t\tt = tsize >> 8;\n\t\tidx = t ? LogTable256[t] + 8 : LogTable256[tsize];\n\n\t\tAssert(idx < ALLOCSET_NUM_FREELISTS);\n\t}\n\telse\n\t\tidx = 0;\n\n\treturn idx;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALLOCSET_NUM_FREELISTS\t11",
            "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
          ],
          "globals_used": [
            "static void *AllocSetAlloc(MemoryContext context, Size size);",
            "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
            "static const unsigned char LogTable256[256] =\n{\n\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n\tLT16(5), LT16(6), LT16(6), LT16(7), LT16(7), LT16(7), LT16(7),\n\tLT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCSET_NUM_FREELISTS\t11\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic const unsigned char LogTable256[256] =\n{\n\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n\tLT16(5), LT16(6), LT16(6), LT16(7), LT16(7), LT16(7), LT16(7),\n\tLT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8)\n};\n\nstatic inline int\nAllocSetFreeIndex(Size size)\n{\n\tint\t\t\tidx;\n\tunsigned int t,\n\t\t\t\ttsize;\n\n\tif (size > (1 << ALLOC_MINBITS))\n\t{\n\t\ttsize = (size - 1) >> ALLOC_MINBITS;\n\n\t\t/*\n\t\t * At this point we need to obtain log2(tsize)+1, ie, the number of\n\t\t * not-all-zero bits at the right.  We used to do this with a\n\t\t * shift-and-count loop, but this function is enough of a hotspot to\n\t\t * justify micro-optimization effort.  The best approach seems to be\n\t\t * to use a lookup table.  Note that this code assumes that\n\t\t * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of\n\t\t * the tsize value.\n\t\t */\n\t\tt = tsize >> 8;\n\t\tidx = t ? LogTable256[t] + 8 : LogTable256[tsize];\n\n\t\tAssert(idx < ALLOCSET_NUM_FREELISTS);\n\t}\n\telse\n\t\tidx = 0;\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "block"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "block",
            "block->freeptr - ((char *) block)"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find block containing chunk %p\"",
            "chunk"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "((char *) chunk) - ALLOC_BLOCKHDRSZ"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "pointer",
            "chunk->requested_size"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocFreeInfo",
          "args": [
            "set",
            "chunk"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetFree(MemoryContext context, void *pointer)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocChunk\tchunk = AllocPointerGetChunk(pointer);\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\tAllocFreeInfo(set, chunk);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t set->header.name, chunk);\n#endif\n\n\tif (chunk->size > set->allocChunkLimit)\n\t{\n\t\t/*\n\t\t * Big chunks are certain to have been allocated as single-chunk\n\t\t * blocks.  Just unlink that block and return it to malloc().\n\t\t */\n\t\tAllocBlock\tblock = (AllocBlock) (((char *) chunk) - ALLOC_BLOCKHDRSZ);\n\n\t\t/*\n\t\t * Try to verify that we have a sane block pointer: it should\n\t\t * reference the correct aset, and freeptr and endptr should point\n\t\t * just past the chunk.\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->freeptr != block->endptr ||\n\t\t\tblock->freeptr != ((char *) block) +\n\t\t\t(chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ))\n\t\t\telog(ERROR, \"could not find block containing chunk %p\", chunk);\n\n\t\t/* OK, remove block from aset's list and free it */\n\t\tif (block->prev)\n\t\t\tblock->prev->next = block->next;\n\t\telse\n\t\t\tset->blocks = block->next;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block->prev;\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\t\tfree(block);\n\t}\n\telse\n\t{\n\t\t/* Normal case, put the chunk into appropriate freelist */\n\t\tint\t\t\tfidx = AllocSetFreeIndex(chunk->size);\n\n\t\tchunk->aset = (void *) set->freelist[fidx];\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(pointer, chunk->size);\n#endif\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t/* Reset requested_size to 0 in chunks that are on freelist */\n\t\tchunk->requested_size = 0;\n#endif\n\t\tset->freelist[fidx] = chunk;\n\t}\n}"
  },
  {
    "function_name": "AllocSetAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "713-980",
    "snippet": "static void *\nAllocSetAlloc(MemoryContext context, Size size)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock;\n\tAllocChunk\tchunk;\n\tint\t\t\tfidx;\n\tSize\t\tchunk_size;\n\tSize\t\tblksize;\n\n\tAssertArg(AllocSetIsValid(set));\n\n\t/*\n\t * If requested size exceeds maximum for chunks, allocate an entire block\n\t * for this request.\n\t */\n\tif (size > set->allocChunkLimit)\n\t{\n\t\tchunk_size = MAXALIGN(size);\n\t\tblksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\tblock = (AllocBlock) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\t\tblock->aset = set;\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);\n\t\tchunk->aset = set;\n\t\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\t/*\n\t\t * Stick the new block underneath the active allocation block, if any,\n\t\t * so that we don't lose the use of the space remaining therein.\n\t\t */\n\t\tif (set->blocks != NULL)\n\t\t{\n\t\t\tblock->prev = set->blocks;\n\t\t\tblock->next = set->blocks->next;\n\t\t\tif (block->next)\n\t\t\t\tblock->next->prev = block;\n\t\t\tset->blocks->next = block;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock->prev = NULL;\n\t\t\tblock->next = NULL;\n\t\t\tset->blocks = block;\n\t\t}\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Request is small enough to be treated as a chunk.  Look in the\n\t * corresponding free list to see if there is a free chunk we could reuse.\n\t * If one is found, remove it from the free list, make it again a member\n\t * of the alloc set and return its data address.\n\t */\n\tfidx = AllocSetFreeIndex(size);\n\tchunk = set->freelist[fidx];\n\tif (chunk != NULL)\n\t{\n\t\tAssert(chunk->size >= size);\n\n\t\tset->freelist[fidx] = (AllocChunk) chunk->aset;\n\n\t\tchunk->aset = (void *) set;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk->size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk->size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Choose the actual chunk size to allocate.\n\t */\n\tchunk_size = (1 << ALLOC_MINBITS) << fidx;\n\tAssert(chunk_size >= size);\n\n\t/*\n\t * If there is enough room in the active allocation block, we will put the\n\t * chunk into that block.  Else must start a new one.\n\t */\n\tif ((block = set->blocks) != NULL)\n\t{\n\t\tSize\t\tavailspace = block->endptr - block->freeptr;\n\n\t\tif (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))\n\t\t{\n\t\t\t/*\n\t\t\t * The existing active (top) block does not have enough room for\n\t\t\t * the requested allocation, but it might still have a useful\n\t\t\t * amount of space in it.  Once we push it down in the block list,\n\t\t\t * we'll never try to allocate more space from it. So, before we\n\t\t\t * do that, carve up its free space into chunks that we can put on\n\t\t\t * the set's freelists.\n\t\t\t *\n\t\t\t * Because we can only get here when there's less than\n\t\t\t * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate\n\t\t\t * more than ALLOCSET_NUM_FREELISTS-1 times.\n\t\t\t */\n\t\t\twhile (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))\n\t\t\t{\n\t\t\t\tSize\t\tavailchunk = availspace - ALLOC_CHUNKHDRSZ;\n\t\t\t\tint\t\t\ta_fidx = AllocSetFreeIndex(availchunk);\n\n\t\t\t\t/*\n\t\t\t\t * In most cases, we'll get back the index of the next larger\n\t\t\t\t * freelist than the one we need to put this chunk on.  The\n\t\t\t\t * exception is when availchunk is exactly a power of 2.\n\t\t\t\t */\n\t\t\t\tif (availchunk != ((Size) 1 << (a_fidx + ALLOC_MINBITS)))\n\t\t\t\t{\n\t\t\t\t\ta_fidx--;\n\t\t\t\t\tAssert(a_fidx >= 0);\n\t\t\t\t\tavailchunk = ((Size) 1 << (a_fidx + ALLOC_MINBITS));\n\t\t\t\t}\n\n\t\t\t\tchunk = (AllocChunk) (block->freeptr);\n\n\t\t\t\t/* Prepare to initialize the chunk header. */\n\t\t\t\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tblock->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);\n\t\t\t\tavailspace -= (availchunk + ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tchunk->size = availchunk;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t\t\tchunk->requested_size = 0;\t/* mark it free */\n#endif\n\t\t\t\tchunk->aset = (void *) set->freelist[a_fidx];\n\t\t\t\tset->freelist[a_fidx] = chunk;\n\t\t\t}\n\n\t\t\t/* Mark that we need to create a new block */\n\t\t\tblock = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Time to create a new regular (multi-chunk) block?\n\t */\n\tif (block == NULL)\n\t{\n\t\tSize\t\trequired_size;\n\n\t\t/*\n\t\t * The first such block has size initBlockSize, and we double the\n\t\t * space in each succeeding block, but not more than maxBlockSize.\n\t\t */\n\t\tblksize = set->nextBlockSize;\n\t\tset->nextBlockSize <<= 1;\n\t\tif (set->nextBlockSize > set->maxBlockSize)\n\t\t\tset->nextBlockSize = set->maxBlockSize;\n\n\t\t/*\n\t\t * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more\n\t\t * space... but try to keep it a power of 2.\n\t\t */\n\t\trequired_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\twhile (blksize < required_size)\n\t\t\tblksize <<= 1;\n\n\t\t/* Try to allocate it */\n\t\tblock = (AllocBlock) malloc(blksize);\n\n\t\t/*\n\t\t * We could be asking for pretty big blocks here, so cope if malloc\n\t\t * fails.  But give up if there's less than a meg or so available...\n\t\t */\n\t\twhile (block == NULL && blksize > 1024 * 1024)\n\t\t{\n\t\t\tblksize >>= 1;\n\t\t\tif (blksize < required_size)\n\t\t\t\tbreak;\n\t\t\tblock = (AllocBlock) malloc(blksize);\n\t\t}\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->aset = set;\n\t\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - ALLOC_BLOCKHDRSZ);\n\n\t\tblock->prev = NULL;\n\t\tblock->next = set->blocks;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block;\n\t\tset->blocks = block;\n\t}\n\n\t/*\n\t * OK, do the allocation\n\t */\n\tchunk = (AllocChunk) (block->freeptr);\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\tblock->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->aset = (void *) set;\n\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\tAllocAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\treturn AllocChunkGetPointer(chunk);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
      "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))",
      "#define ALLOC_CHUNK_LIMIT\t(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))",
      "#define ALLOCSET_NUM_FREELISTS\t11",
      "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) AllocChunkGetPointer(chunk) + size",
            "chunk_size - size"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocAllocInfo",
          "args": [
            "set",
            "chunk"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randomize_mem",
          "args": [
            "(char *) AllocChunkGetPointer(chunk)",
            "size"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/memdebug.c",
          "lines": "74-91",
          "snippet": "void\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}",
          "includes": [
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nvoid\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "AllocChunkGetPointer(chunk)",
            "size"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->freeptr <= block->endptr"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "chunk",
            "ALLOC_CHUNKHDRSZ"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "block->freeptr"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "block->freeptr",
            "blksize - ALLOC_BLOCKHDRSZ"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "blksize"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "blksize"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "chunk",
            "ALLOC_CHUNKHDRSZ"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "block->freeptr"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "a_fidx >= 0"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetFreeIndex",
          "args": [
            "availchunk"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "AllocSetFreeIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
          "lines": "336-365",
          "snippet": "static inline int\nAllocSetFreeIndex(Size size)\n{\n\tint\t\t\tidx;\n\tunsigned int t,\n\t\t\t\ttsize;\n\n\tif (size > (1 << ALLOC_MINBITS))\n\t{\n\t\ttsize = (size - 1) >> ALLOC_MINBITS;\n\n\t\t/*\n\t\t * At this point we need to obtain log2(tsize)+1, ie, the number of\n\t\t * not-all-zero bits at the right.  We used to do this with a\n\t\t * shift-and-count loop, but this function is enough of a hotspot to\n\t\t * justify micro-optimization effort.  The best approach seems to be\n\t\t * to use a lookup table.  Note that this code assumes that\n\t\t * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of\n\t\t * the tsize value.\n\t\t */\n\t\tt = tsize >> 8;\n\t\tidx = t ? LogTable256[t] + 8 : LogTable256[tsize];\n\n\t\tAssert(idx < ALLOCSET_NUM_FREELISTS);\n\t}\n\telse\n\t\tidx = 0;\n\n\treturn idx;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALLOCSET_NUM_FREELISTS\t11",
            "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
          ],
          "globals_used": [
            "static void *AllocSetAlloc(MemoryContext context, Size size);",
            "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
            "static const unsigned char LogTable256[256] =\n{\n\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n\tLT16(5), LT16(6), LT16(6), LT16(7), LT16(7), LT16(7), LT16(7),\n\tLT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCSET_NUM_FREELISTS\t11\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic const unsigned char LogTable256[256] =\n{\n\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n\tLT16(5), LT16(6), LT16(6), LT16(7), LT16(7), LT16(7), LT16(7),\n\tLT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8)\n};\n\nstatic inline int\nAllocSetFreeIndex(Size size)\n{\n\tint\t\t\tidx;\n\tunsigned int t,\n\t\t\t\ttsize;\n\n\tif (size > (1 << ALLOC_MINBITS))\n\t{\n\t\ttsize = (size - 1) >> ALLOC_MINBITS;\n\n\t\t/*\n\t\t * At this point we need to obtain log2(tsize)+1, ie, the number of\n\t\t * not-all-zero bits at the right.  We used to do this with a\n\t\t * shift-and-count loop, but this function is enough of a hotspot to\n\t\t * justify micro-optimization effort.  The best approach seems to be\n\t\t * to use a lookup table.  Note that this code assumes that\n\t\t * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of\n\t\t * the tsize value.\n\t\t */\n\t\tt = tsize >> 8;\n\t\tidx = t ? LogTable256[t] + 8 : LogTable256[tsize];\n\n\t\tAssert(idx < ALLOCSET_NUM_FREELISTS);\n\t}\n\telse\n\t\tidx = 0;\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "chunk_size >= size"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) AllocChunkGetPointer(chunk) + size",
            "chunk->size - size"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocAllocInfo",
          "args": [
            "set",
            "chunk"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "AllocChunkGetPointer(chunk)",
            "size"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "chunk->size >= size"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "ALLOCCHUNK_PRIVATE_LEN"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) AllocChunkGetPointer(chunk) + size",
            "chunk_size - size"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocAllocInfo",
          "args": [
            "set",
            "chunk"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "AllocChunkGetPointer(chunk)",
            "size"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "((char *) block) + ALLOC_BLOCKHDRSZ"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "blksize"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "size"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "AllocSetIsValid(set)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetIsValid",
          "args": [
            "set"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n#define ALLOC_CHUNK_LIMIT\t(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))\n#define ALLOCSET_NUM_FREELISTS\t11\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void *\nAllocSetAlloc(MemoryContext context, Size size)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock;\n\tAllocChunk\tchunk;\n\tint\t\t\tfidx;\n\tSize\t\tchunk_size;\n\tSize\t\tblksize;\n\n\tAssertArg(AllocSetIsValid(set));\n\n\t/*\n\t * If requested size exceeds maximum for chunks, allocate an entire block\n\t * for this request.\n\t */\n\tif (size > set->allocChunkLimit)\n\t{\n\t\tchunk_size = MAXALIGN(size);\n\t\tblksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\tblock = (AllocBlock) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\t\tblock->aset = set;\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);\n\t\tchunk->aset = set;\n\t\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\t/*\n\t\t * Stick the new block underneath the active allocation block, if any,\n\t\t * so that we don't lose the use of the space remaining therein.\n\t\t */\n\t\tif (set->blocks != NULL)\n\t\t{\n\t\t\tblock->prev = set->blocks;\n\t\t\tblock->next = set->blocks->next;\n\t\t\tif (block->next)\n\t\t\t\tblock->next->prev = block;\n\t\t\tset->blocks->next = block;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock->prev = NULL;\n\t\t\tblock->next = NULL;\n\t\t\tset->blocks = block;\n\t\t}\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Request is small enough to be treated as a chunk.  Look in the\n\t * corresponding free list to see if there is a free chunk we could reuse.\n\t * If one is found, remove it from the free list, make it again a member\n\t * of the alloc set and return its data address.\n\t */\n\tfidx = AllocSetFreeIndex(size);\n\tchunk = set->freelist[fidx];\n\tif (chunk != NULL)\n\t{\n\t\tAssert(chunk->size >= size);\n\n\t\tset->freelist[fidx] = (AllocChunk) chunk->aset;\n\n\t\tchunk->aset = (void *) set;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk->size)\n\t\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\t\tAllocAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk->size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\treturn AllocChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Choose the actual chunk size to allocate.\n\t */\n\tchunk_size = (1 << ALLOC_MINBITS) << fidx;\n\tAssert(chunk_size >= size);\n\n\t/*\n\t * If there is enough room in the active allocation block, we will put the\n\t * chunk into that block.  Else must start a new one.\n\t */\n\tif ((block = set->blocks) != NULL)\n\t{\n\t\tSize\t\tavailspace = block->endptr - block->freeptr;\n\n\t\tif (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))\n\t\t{\n\t\t\t/*\n\t\t\t * The existing active (top) block does not have enough room for\n\t\t\t * the requested allocation, but it might still have a useful\n\t\t\t * amount of space in it.  Once we push it down in the block list,\n\t\t\t * we'll never try to allocate more space from it. So, before we\n\t\t\t * do that, carve up its free space into chunks that we can put on\n\t\t\t * the set's freelists.\n\t\t\t *\n\t\t\t * Because we can only get here when there's less than\n\t\t\t * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate\n\t\t\t * more than ALLOCSET_NUM_FREELISTS-1 times.\n\t\t\t */\n\t\t\twhile (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))\n\t\t\t{\n\t\t\t\tSize\t\tavailchunk = availspace - ALLOC_CHUNKHDRSZ;\n\t\t\t\tint\t\t\ta_fidx = AllocSetFreeIndex(availchunk);\n\n\t\t\t\t/*\n\t\t\t\t * In most cases, we'll get back the index of the next larger\n\t\t\t\t * freelist than the one we need to put this chunk on.  The\n\t\t\t\t * exception is when availchunk is exactly a power of 2.\n\t\t\t\t */\n\t\t\t\tif (availchunk != ((Size) 1 << (a_fidx + ALLOC_MINBITS)))\n\t\t\t\t{\n\t\t\t\t\ta_fidx--;\n\t\t\t\t\tAssert(a_fidx >= 0);\n\t\t\t\t\tavailchunk = ((Size) 1 << (a_fidx + ALLOC_MINBITS));\n\t\t\t\t}\n\n\t\t\t\tchunk = (AllocChunk) (block->freeptr);\n\n\t\t\t\t/* Prepare to initialize the chunk header. */\n\t\t\t\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tblock->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);\n\t\t\t\tavailspace -= (availchunk + ALLOC_CHUNKHDRSZ);\n\n\t\t\t\tchunk->size = availchunk;\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\t\t\tchunk->requested_size = 0;\t/* mark it free */\n#endif\n\t\t\t\tchunk->aset = (void *) set->freelist[a_fidx];\n\t\t\t\tset->freelist[a_fidx] = chunk;\n\t\t\t}\n\n\t\t\t/* Mark that we need to create a new block */\n\t\t\tblock = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Time to create a new regular (multi-chunk) block?\n\t */\n\tif (block == NULL)\n\t{\n\t\tSize\t\trequired_size;\n\n\t\t/*\n\t\t * The first such block has size initBlockSize, and we double the\n\t\t * space in each succeeding block, but not more than maxBlockSize.\n\t\t */\n\t\tblksize = set->nextBlockSize;\n\t\tset->nextBlockSize <<= 1;\n\t\tif (set->nextBlockSize > set->maxBlockSize)\n\t\t\tset->nextBlockSize = set->maxBlockSize;\n\n\t\t/*\n\t\t * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more\n\t\t * space... but try to keep it a power of 2.\n\t\t */\n\t\trequired_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\t\twhile (blksize < required_size)\n\t\t\tblksize <<= 1;\n\n\t\t/* Try to allocate it */\n\t\tblock = (AllocBlock) malloc(blksize);\n\n\t\t/*\n\t\t * We could be asking for pretty big blocks here, so cope if malloc\n\t\t * fails.  But give up if there's less than a meg or so available...\n\t\t */\n\t\twhile (block == NULL && blksize > 1024 * 1024)\n\t\t{\n\t\t\tblksize >>= 1;\n\t\t\tif (blksize < required_size)\n\t\t\t\tbreak;\n\t\t\tblock = (AllocBlock) malloc(blksize);\n\t\t}\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->aset = set;\n\t\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - ALLOC_BLOCKHDRSZ);\n\n\t\tblock->prev = NULL;\n\t\tblock->next = set->blocks;\n\t\tif (block->next)\n\t\t\tblock->next->prev = block;\n\t\tset->blocks = block;\n\t}\n\n\t/*\n\t * OK, do the allocation\n\t */\n\tchunk = (AllocChunk) (block->freeptr);\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNKHDRSZ);\n\n\tblock->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->aset = (void *) set;\n\tchunk->size = chunk_size;\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(AllocChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) AllocChunkGetPointer(chunk), size);\n#endif\n\n\tAllocAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) AllocChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\treturn AllocChunkGetPointer(chunk);\n}"
  },
  {
    "function_name": "AllocSetDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "626-698",
    "snippet": "static void\nAllocSetDelete(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock = set->blocks;\n\n\tAssertArg(AllocSetIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tAllocSetCheck(context);\n#endif\n\n\t/*\n\t * If the context is a candidate for a freelist, put it into that freelist\n\t * instead of destroying it.\n\t */\n\tif (set->freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[set->freeListIndex];\n\n\t\t/*\n\t\t * Reset the context, if it needs it, so that we aren't hanging on to\n\t\t * more than the initial malloc chunk.\n\t\t */\n\t\tif (!context->isReset)\n\t\t\tMemoryContextResetOnly(context);\n\n\t\t/*\n\t\t * If the freelist is full, just discard what's already in it.  See\n\t\t * comments with context_freelists[].\n\t\t */\n\t\tif (freelist->num_free >= MAX_FREE_CONTEXTS)\n\t\t{\n\t\t\twhile (freelist->first_free != NULL)\n\t\t\t{\n\t\t\t\tAllocSetContext *oldset = freelist->first_free;\n\n\t\t\t\tfreelist->first_free = (AllocSetContext *) oldset->header.nextchild;\n\t\t\t\tfreelist->num_free--;\n\n\t\t\t\t/* All that remains is to free the header/initial block */\n\t\t\t\tfree(oldset);\n\t\t\t}\n\t\t\tAssert(freelist->num_free == 0);\n\t\t}\n\n\t\t/* Now add the just-deleted context to the freelist. */\n\t\tset->header.nextchild = (MemoryContext) freelist->first_free;\n\t\tfreelist->first_free = set;\n\t\tfreelist->num_free++;\n\n\t\treturn;\n\t}\n\n\t/* Free all blocks, except the keeper which is part of context header */\n\twhile (block != NULL)\n\t{\n\t\tAllocBlock\tnext = block->next;\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\n\t\tif (block != set->keeper)\n\t\t\tfree(block);\n\n\t\tblock = next;\n\t}\n\n\t/* Finally, free the context header, including the keeper block */\n\tfree(set);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_FREE_CONTEXTS 100\t/* arbitrary limit on freelist length */"
    ],
    "globals_used": [
      "static AllocSetFreeList context_freelists[2] =\n{\n\t{\n\t\t0, NULL\n\t},\n\t{\n\t\t0, NULL\n\t}\n};",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "set"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "block",
            "block->freeptr - ((char *) block)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "freelist->num_free == 0"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextResetOnly",
          "args": [
            "context"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "154-179",
          "snippet": "void\nMemoryContextResetOnly(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Nothing to do if no pallocs since startup or last reset */\n\tif (!context->isReset)\n\t{\n\t\tMemoryContextCallResetCallbacks(context);\n\n\t\t/*\n\t\t * If context->ident points into the context's memory, it will become\n\t\t * a dangling pointer.  We could prevent that by setting it to NULL\n\t\t * here, but that would break valid coding patterns that keep the\n\t\t * ident elsewhere, e.g. in a parent context.  Another idea is to use\n\t\t * MemoryContextContains(), but we don't require ident strings to be\n\t\t * in separately-palloc'd chunks, so that risks false positives.  So\n\t\t * for now we assume the programmer got it right.\n\t\t */\n\n\t\tcontext->methods->reset(context);\n\t\tcontext->isReset = true;\n\t\tVALGRIND_DESTROY_MEMPOOL(context);\n\t\tVALGRIND_CREATE_MEMPOOL(context, 0, false);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetOnly(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/* Nothing to do if no pallocs since startup or last reset */\n\tif (!context->isReset)\n\t{\n\t\tMemoryContextCallResetCallbacks(context);\n\n\t\t/*\n\t\t * If context->ident points into the context's memory, it will become\n\t\t * a dangling pointer.  We could prevent that by setting it to NULL\n\t\t * here, but that would break valid coding patterns that keep the\n\t\t * ident elsewhere, e.g. in a parent context.  Another idea is to use\n\t\t * MemoryContextContains(), but we don't require ident strings to be\n\t\t * in separately-palloc'd chunks, so that risks false positives.  So\n\t\t * for now we assume the programmer got it right.\n\t\t */\n\n\t\tcontext->methods->reset(context);\n\t\tcontext->isReset = true;\n\t\tVALGRIND_DESTROY_MEMPOOL(context);\n\t\tVALGRIND_CREATE_MEMPOOL(context, 0, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetCheck",
          "args": [
            "context"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "AllocSetCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
          "lines": "1379-1482",
          "snippet": "static void\nAllocSetCheck(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tconst char *name = set->header.name;\n\tAllocBlock\tprevblock;\n\tAllocBlock\tblock;\n\n\tfor (prevblock = NULL, block = set->blocks;\n\t\t block != NULL;\n\t\t prevblock = block, block = block->next)\n\t{\n\t\tchar\t   *bpoz = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tlong\t\tblk_used = block->freeptr - bpoz;\n\t\tlong\t\tblk_data = 0;\n\t\tlong\t\tnchunks = 0;\n\n\t\t/*\n\t\t * Empty block - empty can be keeper-block only\n\t\t */\n\t\tif (!blk_used)\n\t\t{\n\t\t\tif (set->keeper != block)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: empty block %p\",\n\t\t\t\t\t name, block);\n\t\t}\n\n\t\t/*\n\t\t * Check block header fields\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->prev != prevblock ||\n\t\t\tblock->freeptr < bpoz ||\n\t\t\tblock->freeptr > block->endptr)\n\t\t\telog(WARNING, \"problem in alloc set %s: corrupt header in block %p\",\n\t\t\t\t name, block);\n\n\t\t/*\n\t\t * Chunk walker\n\t\t */\n\t\twhile (bpoz < block->freeptr)\n\t\t{\n\t\t\tAllocChunk\tchunk = (AllocChunk) bpoz;\n\t\t\tSize\t\tchsize,\n\t\t\t\t\t\tdsize;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tchsize = chunk->size;\t/* aligned chunk size */\n\t\t\tdsize = chunk->requested_size;\t/* real data */\n\n\t\t\t/*\n\t\t\t * Check chunk size\n\t\t\t */\n\t\t\tif (dsize > chsize)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: req size > alloc size for chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\t\t\tif (chsize < (1 << ALLOC_MINBITS))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad size %zu for chunk %p in block %p\",\n\t\t\t\t\t name, chsize, chunk, block);\n\n\t\t\t/* single-chunk block? */\n\t\t\tif (chsize > set->allocChunkLimit &&\n\t\t\t\tchsize + ALLOC_CHUNKHDRSZ != blk_used)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad single-chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, check for correct aset pointer. (If it's\n\t\t\t * free, the aset is the freelist pointer, which we can't check as\n\t\t\t * easily...)  Note this is an incomplete test, since palloc(0)\n\t\t\t * produces an allocated chunk with requested_size == 0.\n\t\t\t */\n\t\t\tif (dsize > 0 && chunk->aset != (void *) set)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bogus aset link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for overwrite of padding space in an allocated chunk.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set && dsize < chsize &&\n\t\t\t\t!sentinel_ok(chunk, ALLOC_CHUNKHDRSZ + dsize))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tblk_data += chsize;\n\t\t\tnchunks++;\n\n\t\t\tbpoz += ALLOC_CHUNKHDRSZ + chsize;\n\t\t}\n\n\t\tif ((blk_data + (nchunks * ALLOC_CHUNKHDRSZ)) != blk_used)\n\t\t\telog(WARNING, \"problem in alloc set %s: found inconsistent memory block %p\",\n\t\t\t\t name, block);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
            "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
            "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))",
            "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
          ],
          "globals_used": [
            "static void *AllocSetAlloc(MemoryContext context, Size size);",
            "static void AllocSetFree(MemoryContext context, void *pointer);",
            "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
            "static void AllocSetReset(MemoryContext context);",
            "static void AllocSetDelete(MemoryContext context);",
            "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
            "static bool AllocSetIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetCheck(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tconst char *name = set->header.name;\n\tAllocBlock\tprevblock;\n\tAllocBlock\tblock;\n\n\tfor (prevblock = NULL, block = set->blocks;\n\t\t block != NULL;\n\t\t prevblock = block, block = block->next)\n\t{\n\t\tchar\t   *bpoz = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tlong\t\tblk_used = block->freeptr - bpoz;\n\t\tlong\t\tblk_data = 0;\n\t\tlong\t\tnchunks = 0;\n\n\t\t/*\n\t\t * Empty block - empty can be keeper-block only\n\t\t */\n\t\tif (!blk_used)\n\t\t{\n\t\t\tif (set->keeper != block)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: empty block %p\",\n\t\t\t\t\t name, block);\n\t\t}\n\n\t\t/*\n\t\t * Check block header fields\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->prev != prevblock ||\n\t\t\tblock->freeptr < bpoz ||\n\t\t\tblock->freeptr > block->endptr)\n\t\t\telog(WARNING, \"problem in alloc set %s: corrupt header in block %p\",\n\t\t\t\t name, block);\n\n\t\t/*\n\t\t * Chunk walker\n\t\t */\n\t\twhile (bpoz < block->freeptr)\n\t\t{\n\t\t\tAllocChunk\tchunk = (AllocChunk) bpoz;\n\t\t\tSize\t\tchsize,\n\t\t\t\t\t\tdsize;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tchsize = chunk->size;\t/* aligned chunk size */\n\t\t\tdsize = chunk->requested_size;\t/* real data */\n\n\t\t\t/*\n\t\t\t * Check chunk size\n\t\t\t */\n\t\t\tif (dsize > chsize)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: req size > alloc size for chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\t\t\tif (chsize < (1 << ALLOC_MINBITS))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad size %zu for chunk %p in block %p\",\n\t\t\t\t\t name, chsize, chunk, block);\n\n\t\t\t/* single-chunk block? */\n\t\t\tif (chsize > set->allocChunkLimit &&\n\t\t\t\tchsize + ALLOC_CHUNKHDRSZ != blk_used)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad single-chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, check for correct aset pointer. (If it's\n\t\t\t * free, the aset is the freelist pointer, which we can't check as\n\t\t\t * easily...)  Note this is an incomplete test, since palloc(0)\n\t\t\t * produces an allocated chunk with requested_size == 0.\n\t\t\t */\n\t\t\tif (dsize > 0 && chunk->aset != (void *) set)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bogus aset link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for overwrite of padding space in an allocated chunk.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set && dsize < chsize &&\n\t\t\t\t!sentinel_ok(chunk, ALLOC_CHUNKHDRSZ + dsize))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tblk_data += chsize;\n\t\t\tnchunks++;\n\n\t\t\tbpoz += ALLOC_CHUNKHDRSZ + chsize;\n\t\t}\n\n\t\tif ((blk_data + (nchunks * ALLOC_CHUNKHDRSZ)) != blk_used)\n\t\t\telog(WARNING, \"problem in alloc set %s: found inconsistent memory block %p\",\n\t\t\t\t name, block);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "AllocSetIsValid(set)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetIsValid",
          "args": [
            "set"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define MAX_FREE_CONTEXTS 100\t/* arbitrary limit on freelist length */\n\nstatic AllocSetFreeList context_freelists[2] =\n{\n\t{\n\t\t0, NULL\n\t},\n\t{\n\t\t0, NULL\n\t}\n};\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetDelete(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock = set->blocks;\n\n\tAssertArg(AllocSetIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tAllocSetCheck(context);\n#endif\n\n\t/*\n\t * If the context is a candidate for a freelist, put it into that freelist\n\t * instead of destroying it.\n\t */\n\tif (set->freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[set->freeListIndex];\n\n\t\t/*\n\t\t * Reset the context, if it needs it, so that we aren't hanging on to\n\t\t * more than the initial malloc chunk.\n\t\t */\n\t\tif (!context->isReset)\n\t\t\tMemoryContextResetOnly(context);\n\n\t\t/*\n\t\t * If the freelist is full, just discard what's already in it.  See\n\t\t * comments with context_freelists[].\n\t\t */\n\t\tif (freelist->num_free >= MAX_FREE_CONTEXTS)\n\t\t{\n\t\t\twhile (freelist->first_free != NULL)\n\t\t\t{\n\t\t\t\tAllocSetContext *oldset = freelist->first_free;\n\n\t\t\t\tfreelist->first_free = (AllocSetContext *) oldset->header.nextchild;\n\t\t\t\tfreelist->num_free--;\n\n\t\t\t\t/* All that remains is to free the header/initial block */\n\t\t\t\tfree(oldset);\n\t\t\t}\n\t\t\tAssert(freelist->num_free == 0);\n\t\t}\n\n\t\t/* Now add the just-deleted context to the freelist. */\n\t\tset->header.nextchild = (MemoryContext) freelist->first_free;\n\t\tfreelist->first_free = set;\n\t\tfreelist->num_free++;\n\n\t\treturn;\n\t}\n\n\t/* Free all blocks, except the keeper which is part of context header */\n\twhile (block != NULL)\n\t{\n\t\tAllocBlock\tnext = block->next;\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\n\t\tif (block != set->keeper)\n\t\t\tfree(block);\n\n\t\tblock = next;\n\t}\n\n\t/* Finally, free the context header, including the keeper block */\n\tfree(set);\n}"
  },
  {
    "function_name": "AllocSetReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "564-617",
    "snippet": "static void\nAllocSetReset(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock;\n\n\tAssertArg(AllocSetIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tAllocSetCheck(context);\n#endif\n\n\t/* Clear chunk freelists */\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tblock = set->blocks;\n\n\t/* New blocks list will be just the keeper block */\n\tset->blocks = set->keeper;\n\n\twhile (block != NULL)\n\t{\n\t\tAllocBlock\tnext = block->next;\n\n\t\tif (block == set->keeper)\n\t\t{\n\t\t\t/* Reset the block, but don't return it to malloc */\n\t\t\tchar\t   *datastart = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(datastart, block->freeptr - datastart);\n#else\n\t\t\t/* wipe_mem() would have done this */\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS(datastart, block->freeptr - datastart);\n#endif\n\t\t\tblock->freeptr = datastart;\n\t\t\tblock->prev = NULL;\n\t\t\tblock->next = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Normal case, release the block */\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\t\t\tfree(block);\n\t\t}\n\t\tblock = next;\n\t}\n\n\t/* Reset block size allocation sequence, too */\n\tset->nextBlockSize = set->initBlockSize;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static bool AllocSetIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "block"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "block",
            "block->freeptr - ((char *) block)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "datastart",
            "block->freeptr - datastart"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "datastart",
            "block->freeptr - datastart"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSetAligned",
          "args": [
            "set->freelist",
            "0",
            "sizeof(set->freelist)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetCheck",
          "args": [
            "context"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "AllocSetCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
          "lines": "1379-1482",
          "snippet": "static void\nAllocSetCheck(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tconst char *name = set->header.name;\n\tAllocBlock\tprevblock;\n\tAllocBlock\tblock;\n\n\tfor (prevblock = NULL, block = set->blocks;\n\t\t block != NULL;\n\t\t prevblock = block, block = block->next)\n\t{\n\t\tchar\t   *bpoz = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tlong\t\tblk_used = block->freeptr - bpoz;\n\t\tlong\t\tblk_data = 0;\n\t\tlong\t\tnchunks = 0;\n\n\t\t/*\n\t\t * Empty block - empty can be keeper-block only\n\t\t */\n\t\tif (!blk_used)\n\t\t{\n\t\t\tif (set->keeper != block)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: empty block %p\",\n\t\t\t\t\t name, block);\n\t\t}\n\n\t\t/*\n\t\t * Check block header fields\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->prev != prevblock ||\n\t\t\tblock->freeptr < bpoz ||\n\t\t\tblock->freeptr > block->endptr)\n\t\t\telog(WARNING, \"problem in alloc set %s: corrupt header in block %p\",\n\t\t\t\t name, block);\n\n\t\t/*\n\t\t * Chunk walker\n\t\t */\n\t\twhile (bpoz < block->freeptr)\n\t\t{\n\t\t\tAllocChunk\tchunk = (AllocChunk) bpoz;\n\t\t\tSize\t\tchsize,\n\t\t\t\t\t\tdsize;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tchsize = chunk->size;\t/* aligned chunk size */\n\t\t\tdsize = chunk->requested_size;\t/* real data */\n\n\t\t\t/*\n\t\t\t * Check chunk size\n\t\t\t */\n\t\t\tif (dsize > chsize)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: req size > alloc size for chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\t\t\tif (chsize < (1 << ALLOC_MINBITS))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad size %zu for chunk %p in block %p\",\n\t\t\t\t\t name, chsize, chunk, block);\n\n\t\t\t/* single-chunk block? */\n\t\t\tif (chsize > set->allocChunkLimit &&\n\t\t\t\tchsize + ALLOC_CHUNKHDRSZ != blk_used)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad single-chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, check for correct aset pointer. (If it's\n\t\t\t * free, the aset is the freelist pointer, which we can't check as\n\t\t\t * easily...)  Note this is an incomplete test, since palloc(0)\n\t\t\t * produces an allocated chunk with requested_size == 0.\n\t\t\t */\n\t\t\tif (dsize > 0 && chunk->aset != (void *) set)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bogus aset link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for overwrite of padding space in an allocated chunk.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set && dsize < chsize &&\n\t\t\t\t!sentinel_ok(chunk, ALLOC_CHUNKHDRSZ + dsize))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tblk_data += chsize;\n\t\t\tnchunks++;\n\n\t\t\tbpoz += ALLOC_CHUNKHDRSZ + chsize;\n\t\t}\n\n\t\tif ((blk_data + (nchunks * ALLOC_CHUNKHDRSZ)) != blk_used)\n\t\t\telog(WARNING, \"problem in alloc set %s: found inconsistent memory block %p\",\n\t\t\t\t name, block);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)",
            "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
            "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))",
            "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
          ],
          "globals_used": [
            "static void *AllocSetAlloc(MemoryContext context, Size size);",
            "static void AllocSetFree(MemoryContext context, void *pointer);",
            "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
            "static void AllocSetReset(MemoryContext context);",
            "static void AllocSetDelete(MemoryContext context);",
            "static Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);",
            "static bool AllocSetIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCCHUNK_PRIVATE_LEN\toffsetof(AllocChunkData, aset)\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void AllocSetFree(MemoryContext context, void *pointer);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic Size AllocSetGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetCheck(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tconst char *name = set->header.name;\n\tAllocBlock\tprevblock;\n\tAllocBlock\tblock;\n\n\tfor (prevblock = NULL, block = set->blocks;\n\t\t block != NULL;\n\t\t prevblock = block, block = block->next)\n\t{\n\t\tchar\t   *bpoz = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\t\tlong\t\tblk_used = block->freeptr - bpoz;\n\t\tlong\t\tblk_data = 0;\n\t\tlong\t\tnchunks = 0;\n\n\t\t/*\n\t\t * Empty block - empty can be keeper-block only\n\t\t */\n\t\tif (!blk_used)\n\t\t{\n\t\t\tif (set->keeper != block)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: empty block %p\",\n\t\t\t\t\t name, block);\n\t\t}\n\n\t\t/*\n\t\t * Check block header fields\n\t\t */\n\t\tif (block->aset != set ||\n\t\t\tblock->prev != prevblock ||\n\t\t\tblock->freeptr < bpoz ||\n\t\t\tblock->freeptr > block->endptr)\n\t\t\telog(WARNING, \"problem in alloc set %s: corrupt header in block %p\",\n\t\t\t\t name, block);\n\n\t\t/*\n\t\t * Chunk walker\n\t\t */\n\t\twhile (bpoz < block->freeptr)\n\t\t{\n\t\t\tAllocChunk\tchunk = (AllocChunk) bpoz;\n\t\t\tSize\t\tchsize,\n\t\t\t\t\t\tdsize;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tchsize = chunk->size;\t/* aligned chunk size */\n\t\t\tdsize = chunk->requested_size;\t/* real data */\n\n\t\t\t/*\n\t\t\t * Check chunk size\n\t\t\t */\n\t\t\tif (dsize > chsize)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: req size > alloc size for chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\t\t\tif (chsize < (1 << ALLOC_MINBITS))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad size %zu for chunk %p in block %p\",\n\t\t\t\t\t name, chsize, chunk, block);\n\n\t\t\t/* single-chunk block? */\n\t\t\tif (chsize > set->allocChunkLimit &&\n\t\t\t\tchsize + ALLOC_CHUNKHDRSZ != blk_used)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bad single-chunk %p in block %p\",\n\t\t\t\t\t name, chunk, block);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, check for correct aset pointer. (If it's\n\t\t\t * free, the aset is the freelist pointer, which we can't check as\n\t\t\t * easily...)  Note this is an incomplete test, since palloc(0)\n\t\t\t * produces an allocated chunk with requested_size == 0.\n\t\t\t */\n\t\t\tif (dsize > 0 && chunk->aset != (void *) set)\n\t\t\t\telog(WARNING, \"problem in alloc set %s: bogus aset link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for overwrite of padding space in an allocated chunk.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set && dsize < chsize &&\n\t\t\t\t!sentinel_ok(chunk, ALLOC_CHUNKHDRSZ + dsize))\n\t\t\t\telog(WARNING, \"problem in alloc set %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->aset == (void *) set)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, ALLOCCHUNK_PRIVATE_LEN);\n\n\t\t\tblk_data += chsize;\n\t\t\tnchunks++;\n\n\t\t\tbpoz += ALLOC_CHUNKHDRSZ + chsize;\n\t\t}\n\n\t\tif ((blk_data + (nchunks * ALLOC_CHUNKHDRSZ)) != blk_used)\n\t\t\telog(WARNING, \"problem in alloc set %s: found inconsistent memory block %p\",\n\t\t\t\t name, block);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "AllocSetIsValid(set)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetIsValid",
          "args": [
            "set"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\n\nstatic void\nAllocSetReset(MemoryContext context)\n{\n\tAllocSet\tset = (AllocSet) context;\n\tAllocBlock\tblock;\n\n\tAssertArg(AllocSetIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tAllocSetCheck(context);\n#endif\n\n\t/* Clear chunk freelists */\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tblock = set->blocks;\n\n\t/* New blocks list will be just the keeper block */\n\tset->blocks = set->keeper;\n\n\twhile (block != NULL)\n\t{\n\t\tAllocBlock\tnext = block->next;\n\n\t\tif (block == set->keeper)\n\t\t{\n\t\t\t/* Reset the block, but don't return it to malloc */\n\t\t\tchar\t   *datastart = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(datastart, block->freeptr - datastart);\n#else\n\t\t\t/* wipe_mem() would have done this */\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS(datastart, block->freeptr - datastart);\n#endif\n\t\t\tblock->freeptr = datastart;\n\t\t\tblock->prev = NULL;\n\t\t\tblock->next = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Normal case, release the block */\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(block, block->freeptr - ((char *) block));\n#endif\n\t\t\tfree(block);\n\t\t}\n\t\tblock = next;\n\t}\n\n\t/* Reset block size allocation sequence, too */\n\tset->nextBlockSize = set->initBlockSize;\n}"
  },
  {
    "function_name": "AllocSetContextCreateExtended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "389-550",
    "snippet": "MemoryContext\nAllocSetContextCreateExtended(MemoryContext parent,\n\t\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t\t  Size minContextSize,\n\t\t\t\t\t\t\t  Size initBlockSize,\n\t\t\t\t\t\t\t  Size maxBlockSize)\n{\n\tint\t\t\tfreeListIndex;\n\tSize\t\tfirstBlockSize;\n\tAllocSet\tset;\n\tAllocBlock\tblock;\n\n\t/* Assert we padded AllocChunkData properly */\n\tStaticAssertStmt(ALLOC_CHUNKHDRSZ == MAXALIGN(ALLOC_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(AllocChunkData) is not maxaligned\");\n\tStaticAssertStmt(offsetof(AllocChunkData, aset) + sizeof(MemoryContext) ==\n\t\t\t\t\t ALLOC_CHUNKHDRSZ,\n\t\t\t\t\t \"padding calculation in AllocChunkData is wrong\");\n\n\t/*\n\t * First, validate allocation parameters.  Once these were regular runtime\n\t * test and elog's, but in practice Asserts seem sufficient because nobody\n\t * varies their parameters at runtime.  We somewhat arbitrarily enforce a\n\t * minimum 1K block size.\n\t */\n\tAssert(initBlockSize == MAXALIGN(initBlockSize) &&\n\t\t   initBlockSize >= 1024);\n\tAssert(maxBlockSize == MAXALIGN(maxBlockSize) &&\n\t\t   maxBlockSize >= initBlockSize &&\n\t\t   AllocHugeSizeIsValid(maxBlockSize)); /* must be safe to double */\n\tAssert(minContextSize == 0 ||\n\t\t   (minContextSize == MAXALIGN(minContextSize) &&\n\t\t\tminContextSize >= 1024 &&\n\t\t\tminContextSize <= maxBlockSize));\n\n\t/*\n\t * Check whether the parameters match either available freelist.  We do\n\t * not need to demand a match of maxBlockSize.\n\t */\n\tif (minContextSize == ALLOCSET_DEFAULT_MINSIZE &&\n\t\tinitBlockSize == ALLOCSET_DEFAULT_INITSIZE)\n\t\tfreeListIndex = 0;\n\telse if (minContextSize == ALLOCSET_SMALL_MINSIZE &&\n\t\t\t initBlockSize == ALLOCSET_SMALL_INITSIZE)\n\t\tfreeListIndex = 1;\n\telse\n\t\tfreeListIndex = -1;\n\n\t/*\n\t * If a suitable freelist entry exists, just recycle that context.\n\t */\n\tif (freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[freeListIndex];\n\n\t\tif (freelist->first_free != NULL)\n\t\t{\n\t\t\t/* Remove entry from freelist */\n\t\t\tset = freelist->first_free;\n\t\t\tfreelist->first_free = (AllocSet) set->header.nextchild;\n\t\t\tfreelist->num_free--;\n\n\t\t\t/* Update its maxBlockSize; everything else should be OK */\n\t\t\tset->maxBlockSize = maxBlockSize;\n\n\t\t\t/* Reinitialize its header, installing correct name and parent */\n\t\t\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t\t\t&AllocSetMethods,\n\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\tname);\n\n\t\t\treturn (MemoryContext) set;\n\t\t}\n\t}\n\n\t/* Determine size of initial block */\n\tfirstBlockSize = MAXALIGN(sizeof(AllocSetContext)) +\n\t\tALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\tif (minContextSize != 0)\n\t\tfirstBlockSize = Max(firstBlockSize, minContextSize);\n\telse\n\t\tfirstBlockSize = Max(firstBlockSize, initBlockSize);\n\n\t/*\n\t * Allocate the initial block.  Unlike other aset.c blocks, it starts with\n\t * the context header and its block header follows that.\n\t */\n\tset = (AllocSet) malloc(firstBlockSize);\n\tif (set == NULL)\n\t{\n\t\tif (TopMemoryContext)\n\t\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t/*\n\t * Avoid writing code that can fail between here and MemoryContextCreate;\n\t * we'd leak the header/initial block if we ereport in this stretch.\n\t */\n\n\t/* Fill in the initial block's block header */\n\tblock = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));\n\tblock->aset = set;\n\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\tblock->endptr = ((char *) set) + firstBlockSize;\n\tblock->prev = NULL;\n\tblock->next = NULL;\n\n\t/* Mark unallocated space NOACCESS; leave the block header alone. */\n\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr, block->endptr - block->freeptr);\n\n\t/* Remember block as part of block list */\n\tset->blocks = block;\n\t/* Mark block as not to be released at reset time */\n\tset->keeper = block;\n\n\t/* Finish filling in aset-specific parts of the context header */\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tset->initBlockSize = initBlockSize;\n\tset->maxBlockSize = maxBlockSize;\n\tset->nextBlockSize = initBlockSize;\n\tset->freeListIndex = freeListIndex;\n\n\t/*\n\t * Compute the allocation chunk size limit for this context.  It can't be\n\t * more than ALLOC_CHUNK_LIMIT because of the fixed number of freelists.\n\t * If maxBlockSize is small then requests exceeding the maxBlockSize, or\n\t * even a significant fraction of it, should be treated as large chunks\n\t * too.  For the typical case of maxBlockSize a power of 2, the chunk size\n\t * limit will be at most 1/8th maxBlockSize, so that given a stream of\n\t * requests that are all the maximum chunk size we will waste at most\n\t * 1/8th of the allocated space.\n\t *\n\t * We have to have allocChunkLimit a power of two, because the requested\n\t * and actually-allocated sizes of any chunk must be on the same side of\n\t * the limit, else we get confused about whether the chunk is \"big\".\n\t *\n\t * Also, allocChunkLimit must not exceed ALLOCSET_SEPARATE_THRESHOLD.\n\t */\n\tStaticAssertStmt(ALLOC_CHUNK_LIMIT == ALLOCSET_SEPARATE_THRESHOLD,\n\t\t\t\t\t \"ALLOC_CHUNK_LIMIT != ALLOCSET_SEPARATE_THRESHOLD\");\n\n\tset->allocChunkLimit = ALLOC_CHUNK_LIMIT;\n\twhile ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >\n\t\t   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))\n\t\tset->allocChunkLimit >>= 1;\n\n\t/* Finally, do the type-independent part of context creation */\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t&AllocSetMethods,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\treturn (MemoryContext) set;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)",
      "#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))",
      "#define ALLOC_CHUNK_FRACTION\t4",
      "#define ALLOC_CHUNK_LIMIT\t(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))"
    ],
    "globals_used": [
      "static AllocSetFreeList context_freelists[2] =\n{\n\t{\n\t\t0, NULL\n\t},\n\t{\n\t\t0, NULL\n\t}\n};",
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static void AllocSetReset(MemoryContext context);",
      "static void AllocSetDelete(MemoryContext context);",
      "static bool AllocSetIsEmpty(MemoryContext context);",
      "static const MemoryContextMethods AllocSetMethods = {\n\tAllocSetAlloc,\n\tAllocSetFree,\n\tAllocSetRealloc,\n\tAllocSetReset,\n\tAllocSetDelete,\n\tAllocSetGetChunkSpace,\n\tAllocSetIsEmpty,\n\tAllocSetStats\n#ifdef MEMORY_CONTEXT_CHECKING\n\t,AllocSetCheck\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextCreate",
          "args": [
            "(MemoryContext) set",
            "T_AllocSetContext",
            "&AllocSetMethods",
            "parent",
            "name"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "723-761",
          "snippet": "void\nMemoryContextCreate(MemoryContext node,\n\t\t\t\t\tNodeTag tag,\n\t\t\t\t\tconst MemoryContextMethods *methods,\n\t\t\t\t\tMemoryContext parent,\n\t\t\t\t\tconst char *name)\n{\n\t/* Creating new memory contexts is not allowed in a critical section */\n\tAssert(CritSectionCount == 0);\n\n\t/* Initialize all standard fields of memory context header */\n\tnode->type = tag;\n\tnode->isReset = true;\n\tnode->methods = methods;\n\tnode->parent = parent;\n\tnode->firstchild = NULL;\n\tnode->prevchild = NULL;\n\tnode->name = name;\n\tnode->ident = NULL;\n\tnode->reset_cbs = NULL;\n\n\t/* OK to link node into context tree */\n\tif (parent)\n\t{\n\t\tnode->nextchild = parent->firstchild;\n\t\tif (parent->firstchild != NULL)\n\t\t\tparent->firstchild->prevchild = node;\n\t\tparent->firstchild = node;\n\t\t/* inherit allowInCritSection flag from parent */\n\t\tnode->allowInCritSection = parent->allowInCritSection;\n\t}\n\telse\n\t{\n\t\tnode->nextchild = NULL;\n\t\tnode->allowInCritSection = false;\n\t}\n\n\tVALGRIND_CREATE_MEMPOOL(node, 0, false);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextCreate(MemoryContext node,\n\t\t\t\t\tNodeTag tag,\n\t\t\t\t\tconst MemoryContextMethods *methods,\n\t\t\t\t\tMemoryContext parent,\n\t\t\t\t\tconst char *name)\n{\n\t/* Creating new memory contexts is not allowed in a critical section */\n\tAssert(CritSectionCount == 0);\n\n\t/* Initialize all standard fields of memory context header */\n\tnode->type = tag;\n\tnode->isReset = true;\n\tnode->methods = methods;\n\tnode->parent = parent;\n\tnode->firstchild = NULL;\n\tnode->prevchild = NULL;\n\tnode->name = name;\n\tnode->ident = NULL;\n\tnode->reset_cbs = NULL;\n\n\t/* OK to link node into context tree */\n\tif (parent)\n\t{\n\t\tnode->nextchild = parent->firstchild;\n\t\tif (parent->firstchild != NULL)\n\t\t\tparent->firstchild->prevchild = node;\n\t\tparent->firstchild = node;\n\t\t/* inherit allowInCritSection flag from parent */\n\t\tnode->allowInCritSection = parent->allowInCritSection;\n\t}\n\telse\n\t{\n\t\tnode->nextchild = NULL;\n\t\tnode->allowInCritSection = false;\n\t}\n\n\tVALGRIND_CREATE_MEMPOOL(node, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "set->allocChunkLimit + ALLOC_CHUNKHDRSZ"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "ALLOC_CHUNK_LIMIT == ALLOCSET_SEPARATE_THRESHOLD",
            "\"ALLOC_CHUNK_LIMIT != ALLOCSET_SEPARATE_THRESHOLD\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSetAligned",
          "args": [
            "set->freelist",
            "0",
            "sizeof(set->freelist)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "block->freeptr",
            "block->endptr - block->freeptr"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "((char *) set) + MAXALIGN(sizeof(AllocSetContext))"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(AllocSetContext)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name))"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Failed while creating memory context \\\"%s\\\".\"",
            "name"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStats",
          "args": [
            "TopMemoryContext"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "473-478",
          "snippet": "void\nMemoryContextStats(MemoryContext context)\n{\n\t/* A hard-wired limit on the number of children is usually good enough */\n\tMemoryContextStatsDetail(context, 100);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextStats(MemoryContext context)\n{\n\t/* A hard-wired limit on the number of children is usually good enough */\n\tMemoryContextStatsDetail(context, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "firstBlockSize"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "firstBlockSize",
            "initBlockSize"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "firstBlockSize",
            "minContextSize"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(AllocSetContext)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "minContextSize == 0 ||\n\t\t   (minContextSize == MAXALIGN(minContextSize) &&\n\t\t\tminContextSize >= 1024 &&\n\t\t\tminContextSize <= maxBlockSize)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "minContextSize"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "maxBlockSize == MAXALIGN(maxBlockSize) &&\n\t\t   maxBlockSize >= initBlockSize &&\n\t\t   AllocHugeSizeIsValid(maxBlockSize)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocHugeSizeIsValid",
          "args": [
            "maxBlockSize"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "maxBlockSize"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "initBlockSize == MAXALIGN(initBlockSize) &&\n\t\t   initBlockSize >= 1024"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "initBlockSize"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "offsetof(AllocChunkData, aset) + sizeof(MemoryContext) ==\n\t\t\t\t\t ALLOC_CHUNKHDRSZ",
            "\"padding calculation in AllocChunkData is wrong\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "ALLOC_CHUNKHDRSZ == MAXALIGN(ALLOC_CHUNKHDRSZ)",
            "\"sizeof(AllocChunkData) is not maxaligned\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "ALLOC_CHUNKHDRSZ"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOC_CHUNKHDRSZ\tsizeof(struct AllocChunkData)\n#define ALLOC_BLOCKHDRSZ\tMAXALIGN(sizeof(AllocBlockData))\n#define ALLOC_CHUNK_FRACTION\t4\n#define ALLOC_CHUNK_LIMIT\t(1 << (ALLOCSET_NUM_FREELISTS-1+ALLOC_MINBITS))\n\nstatic AllocSetFreeList context_freelists[2] =\n{\n\t{\n\t\t0, NULL\n\t},\n\t{\n\t\t0, NULL\n\t}\n};\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic void AllocSetReset(MemoryContext context);\nstatic void AllocSetDelete(MemoryContext context);\nstatic bool AllocSetIsEmpty(MemoryContext context);\nstatic const MemoryContextMethods AllocSetMethods = {\n\tAllocSetAlloc,\n\tAllocSetFree,\n\tAllocSetRealloc,\n\tAllocSetReset,\n\tAllocSetDelete,\n\tAllocSetGetChunkSpace,\n\tAllocSetIsEmpty,\n\tAllocSetStats\n#ifdef MEMORY_CONTEXT_CHECKING\n\t,AllocSetCheck\n#endif\n};\n\nMemoryContext\nAllocSetContextCreateExtended(MemoryContext parent,\n\t\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t\t  Size minContextSize,\n\t\t\t\t\t\t\t  Size initBlockSize,\n\t\t\t\t\t\t\t  Size maxBlockSize)\n{\n\tint\t\t\tfreeListIndex;\n\tSize\t\tfirstBlockSize;\n\tAllocSet\tset;\n\tAllocBlock\tblock;\n\n\t/* Assert we padded AllocChunkData properly */\n\tStaticAssertStmt(ALLOC_CHUNKHDRSZ == MAXALIGN(ALLOC_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(AllocChunkData) is not maxaligned\");\n\tStaticAssertStmt(offsetof(AllocChunkData, aset) + sizeof(MemoryContext) ==\n\t\t\t\t\t ALLOC_CHUNKHDRSZ,\n\t\t\t\t\t \"padding calculation in AllocChunkData is wrong\");\n\n\t/*\n\t * First, validate allocation parameters.  Once these were regular runtime\n\t * test and elog's, but in practice Asserts seem sufficient because nobody\n\t * varies their parameters at runtime.  We somewhat arbitrarily enforce a\n\t * minimum 1K block size.\n\t */\n\tAssert(initBlockSize == MAXALIGN(initBlockSize) &&\n\t\t   initBlockSize >= 1024);\n\tAssert(maxBlockSize == MAXALIGN(maxBlockSize) &&\n\t\t   maxBlockSize >= initBlockSize &&\n\t\t   AllocHugeSizeIsValid(maxBlockSize)); /* must be safe to double */\n\tAssert(minContextSize == 0 ||\n\t\t   (minContextSize == MAXALIGN(minContextSize) &&\n\t\t\tminContextSize >= 1024 &&\n\t\t\tminContextSize <= maxBlockSize));\n\n\t/*\n\t * Check whether the parameters match either available freelist.  We do\n\t * not need to demand a match of maxBlockSize.\n\t */\n\tif (minContextSize == ALLOCSET_DEFAULT_MINSIZE &&\n\t\tinitBlockSize == ALLOCSET_DEFAULT_INITSIZE)\n\t\tfreeListIndex = 0;\n\telse if (minContextSize == ALLOCSET_SMALL_MINSIZE &&\n\t\t\t initBlockSize == ALLOCSET_SMALL_INITSIZE)\n\t\tfreeListIndex = 1;\n\telse\n\t\tfreeListIndex = -1;\n\n\t/*\n\t * If a suitable freelist entry exists, just recycle that context.\n\t */\n\tif (freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[freeListIndex];\n\n\t\tif (freelist->first_free != NULL)\n\t\t{\n\t\t\t/* Remove entry from freelist */\n\t\t\tset = freelist->first_free;\n\t\t\tfreelist->first_free = (AllocSet) set->header.nextchild;\n\t\t\tfreelist->num_free--;\n\n\t\t\t/* Update its maxBlockSize; everything else should be OK */\n\t\t\tset->maxBlockSize = maxBlockSize;\n\n\t\t\t/* Reinitialize its header, installing correct name and parent */\n\t\t\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t\t\t&AllocSetMethods,\n\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\tname);\n\n\t\t\treturn (MemoryContext) set;\n\t\t}\n\t}\n\n\t/* Determine size of initial block */\n\tfirstBlockSize = MAXALIGN(sizeof(AllocSetContext)) +\n\t\tALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\tif (minContextSize != 0)\n\t\tfirstBlockSize = Max(firstBlockSize, minContextSize);\n\telse\n\t\tfirstBlockSize = Max(firstBlockSize, initBlockSize);\n\n\t/*\n\t * Allocate the initial block.  Unlike other aset.c blocks, it starts with\n\t * the context header and its block header follows that.\n\t */\n\tset = (AllocSet) malloc(firstBlockSize);\n\tif (set == NULL)\n\t{\n\t\tif (TopMemoryContext)\n\t\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t/*\n\t * Avoid writing code that can fail between here and MemoryContextCreate;\n\t * we'd leak the header/initial block if we ereport in this stretch.\n\t */\n\n\t/* Fill in the initial block's block header */\n\tblock = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));\n\tblock->aset = set;\n\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\tblock->endptr = ((char *) set) + firstBlockSize;\n\tblock->prev = NULL;\n\tblock->next = NULL;\n\n\t/* Mark unallocated space NOACCESS; leave the block header alone. */\n\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr, block->endptr - block->freeptr);\n\n\t/* Remember block as part of block list */\n\tset->blocks = block;\n\t/* Mark block as not to be released at reset time */\n\tset->keeper = block;\n\n\t/* Finish filling in aset-specific parts of the context header */\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tset->initBlockSize = initBlockSize;\n\tset->maxBlockSize = maxBlockSize;\n\tset->nextBlockSize = initBlockSize;\n\tset->freeListIndex = freeListIndex;\n\n\t/*\n\t * Compute the allocation chunk size limit for this context.  It can't be\n\t * more than ALLOC_CHUNK_LIMIT because of the fixed number of freelists.\n\t * If maxBlockSize is small then requests exceeding the maxBlockSize, or\n\t * even a significant fraction of it, should be treated as large chunks\n\t * too.  For the typical case of maxBlockSize a power of 2, the chunk size\n\t * limit will be at most 1/8th maxBlockSize, so that given a stream of\n\t * requests that are all the maximum chunk size we will waste at most\n\t * 1/8th of the allocated space.\n\t *\n\t * We have to have allocChunkLimit a power of two, because the requested\n\t * and actually-allocated sizes of any chunk must be on the same side of\n\t * the limit, else we get confused about whether the chunk is \"big\".\n\t *\n\t * Also, allocChunkLimit must not exceed ALLOCSET_SEPARATE_THRESHOLD.\n\t */\n\tStaticAssertStmt(ALLOC_CHUNK_LIMIT == ALLOCSET_SEPARATE_THRESHOLD,\n\t\t\t\t\t \"ALLOC_CHUNK_LIMIT != ALLOCSET_SEPARATE_THRESHOLD\");\n\n\tset->allocChunkLimit = ALLOC_CHUNK_LIMIT;\n\twhile ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >\n\t\t   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))\n\t\tset->allocChunkLimit >>= 1;\n\n\t/* Finally, do the type-independent part of context creation */\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t&AllocSetMethods,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\treturn (MemoryContext) set;\n}"
  },
  {
    "function_name": "AllocSetFreeIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/aset.c",
    "lines": "336-365",
    "snippet": "static inline int\nAllocSetFreeIndex(Size size)\n{\n\tint\t\t\tidx;\n\tunsigned int t,\n\t\t\t\ttsize;\n\n\tif (size > (1 << ALLOC_MINBITS))\n\t{\n\t\ttsize = (size - 1) >> ALLOC_MINBITS;\n\n\t\t/*\n\t\t * At this point we need to obtain log2(tsize)+1, ie, the number of\n\t\t * not-all-zero bits at the right.  We used to do this with a\n\t\t * shift-and-count loop, but this function is enough of a hotspot to\n\t\t * justify micro-optimization effort.  The best approach seems to be\n\t\t * to use a lookup table.  Note that this code assumes that\n\t\t * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of\n\t\t * the tsize value.\n\t\t */\n\t\tt = tsize >> 8;\n\t\tidx = t ? LogTable256[t] + 8 : LogTable256[tsize];\n\n\t\tAssert(idx < ALLOCSET_NUM_FREELISTS);\n\t}\n\telse\n\t\tidx = 0;\n\n\treturn idx;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALLOCSET_NUM_FREELISTS\t11",
      "#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */"
    ],
    "globals_used": [
      "static void *AllocSetAlloc(MemoryContext context, Size size);",
      "static void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);",
      "static const unsigned char LogTable256[256] =\n{\n\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n\tLT16(5), LT16(6), LT16(6), LT16(7), LT16(7), LT16(7), LT16(7),\n\tLT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "idx < ALLOCSET_NUM_FREELISTS"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\n#define ALLOCSET_NUM_FREELISTS\t11\n#define ALLOC_MINBITS\t\t3\t/* smallest chunk size is 8 bytes */\n\nstatic void *AllocSetAlloc(MemoryContext context, Size size);\nstatic void *AllocSetRealloc(MemoryContext context, void *pointer, Size size);\nstatic const unsigned char LogTable256[256] =\n{\n\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n\tLT16(5), LT16(6), LT16(6), LT16(7), LT16(7), LT16(7), LT16(7),\n\tLT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8), LT16(8)\n};\n\nstatic inline int\nAllocSetFreeIndex(Size size)\n{\n\tint\t\t\tidx;\n\tunsigned int t,\n\t\t\t\ttsize;\n\n\tif (size > (1 << ALLOC_MINBITS))\n\t{\n\t\ttsize = (size - 1) >> ALLOC_MINBITS;\n\n\t\t/*\n\t\t * At this point we need to obtain log2(tsize)+1, ie, the number of\n\t\t * not-all-zero bits at the right.  We used to do this with a\n\t\t * shift-and-count loop, but this function is enough of a hotspot to\n\t\t * justify micro-optimization effort.  The best approach seems to be\n\t\t * to use a lookup table.  Note that this code assumes that\n\t\t * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of\n\t\t * the tsize value.\n\t\t */\n\t\tt = tsize >> 8;\n\t\tidx = t ? LogTable256[t] + 8 : LogTable256[tsize];\n\n\t\tAssert(idx < ALLOCSET_NUM_FREELISTS);\n\t}\n\telse\n\t\tidx = 0;\n\n\treturn idx;\n}"
  }
]