[
  {
    "function_name": "load_tzoffsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
    "lines": "437-476",
    "snippet": "TimeZoneAbbrevTable *\nload_tzoffsets(const char *filename)\n{\n\tTimeZoneAbbrevTable *result = NULL;\n\tMemoryContext tmpContext;\n\tMemoryContext oldContext;\n\ttzEntry    *array;\n\tint\t\t\tarraysize;\n\tint\t\t\tn;\n\n\t/*\n\t * Create a temp memory context to work in.  This makes it easy to clean\n\t * up afterwards.\n\t */\n\ttmpContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t   \"TZParserMemory\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\toldContext = MemoryContextSwitchTo(tmpContext);\n\n\t/* Initialize array at a reasonable size */\n\tarraysize = 128;\n\tarray = (tzEntry *) palloc(arraysize * sizeof(tzEntry));\n\n\t/* Parse the file(s) */\n\tn = ParseTzFile(filename, 0, &array, &arraysize, 0);\n\n\t/* If no errors so far, let datetime.c allocate memory & convert format */\n\tif (n >= 0)\n\t{\n\t\tresult = ConvertTimeZoneAbbrevs(array, n);\n\t\tif (!result)\n\t\t\tGUC_check_errmsg(\"out of memory\");\n\t}\n\n\t/* Clean up */\n\tMemoryContextSwitchTo(oldContext);\n\tMemoryContextDelete(tmpContext);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "tmpContext"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldContext"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConvertTimeZoneAbbrevs",
          "args": [
            "array",
            "n"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertTimeZoneAbbrevs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4507-4584",
          "snippet": "TimeZoneAbbrevTable *\nConvertTimeZoneAbbrevs(struct tzEntry *abbrevs, int n)\n{\n\tTimeZoneAbbrevTable *tbl;\n\tSize\t\ttbl_size;\n\tint\t\t\ti;\n\n\t/* Space for fixed fields and datetkn array */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\t/* Count up space for dynamic abbreviations */\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\tSize\t\tdsize;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t}\n\n\t/* Alloc the result ... */\n\ttbl = malloc(tbl_size);\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* ... and fill it in */\n\ttbl->tblsize = tbl_size;\n\ttbl->numabbrevs = n;\n\t/* in this loop, tbl_size reprises the space calculation above */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\t\tdatetkn    *dtoken = tbl->abbrevs + i;\n\n\t\t/* use strlcpy to truncate name if necessary */\n\t\tstrlcpy(dtoken->token, abbr->abbrev, TOKMAXLEN + 1);\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\t/* Allocate a DynamicZoneAbbrev for this abbreviation */\n\t\t\tDynamicZoneAbbrev *dtza;\n\t\t\tSize\t\tdsize;\n\n\t\t\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tbl_size);\n\t\t\tdtza->tz = NULL;\n\t\t\tstrcpy(dtza->zone, abbr->zone);\n\n\t\t\tdtoken->type = DYNTZ;\n\t\t\t/* value is offset from table start to DynamicZoneAbbrev */\n\t\t\tdtoken->value = (int32) tbl_size;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdtoken->type = abbr->is_dst ? DTZ : TZ;\n\t\t\tdtoken->value = abbr->offset;\n\t\t}\n\t}\n\n\t/* Assert the two loops above agreed on size calculations */\n\tAssert(tbl->tblsize == tbl_size);\n\n\t/* Check the ordering, if testing */\n\tAssert(CheckDateTokenTable(\"timezone abbreviations\", tbl->abbrevs, n));\n\n\treturn tbl;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimeZoneAbbrevTable *\nConvertTimeZoneAbbrevs(struct tzEntry *abbrevs, int n)\n{\n\tTimeZoneAbbrevTable *tbl;\n\tSize\t\ttbl_size;\n\tint\t\t\ti;\n\n\t/* Space for fixed fields and datetkn array */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\t/* Count up space for dynamic abbreviations */\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\tSize\t\tdsize;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t}\n\n\t/* Alloc the result ... */\n\ttbl = malloc(tbl_size);\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* ... and fill it in */\n\ttbl->tblsize = tbl_size;\n\ttbl->numabbrevs = n;\n\t/* in this loop, tbl_size reprises the space calculation above */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\t\tdatetkn    *dtoken = tbl->abbrevs + i;\n\n\t\t/* use strlcpy to truncate name if necessary */\n\t\tstrlcpy(dtoken->token, abbr->abbrev, TOKMAXLEN + 1);\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\t/* Allocate a DynamicZoneAbbrev for this abbreviation */\n\t\t\tDynamicZoneAbbrev *dtza;\n\t\t\tSize\t\tdsize;\n\n\t\t\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tbl_size);\n\t\t\tdtza->tz = NULL;\n\t\t\tstrcpy(dtza->zone, abbr->zone);\n\n\t\t\tdtoken->type = DYNTZ;\n\t\t\t/* value is offset from table start to DynamicZoneAbbrev */\n\t\t\tdtoken->value = (int32) tbl_size;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdtoken->type = abbr->is_dst ? DTZ : TZ;\n\t\t\tdtoken->value = abbr->offset;\n\t\t}\n\t}\n\n\t/* Assert the two loops above agreed on size calculations */\n\tAssert(tbl->tblsize == tbl_size);\n\n\t/* Check the ordering, if testing */\n\tAssert(CheckDateTokenTable(\"timezone abbreviations\", tbl->abbrevs, n));\n\n\treturn tbl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseTzFile",
          "args": [
            "filename",
            "0",
            "&array",
            "&arraysize",
            "0"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "ParseTzFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
          "lines": "275-428",
          "snippet": "static int\nParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n)\n{\n\tchar\t\tshare_path[MAXPGPATH];\n\tchar\t\tfile_path[MAXPGPATH];\n\tFILE\t   *tzFile;\n\tchar\t\ttzbuf[1024];\n\tchar\t   *line;\n\ttzEntry\t\ttzentry;\n\tint\t\t\tlineno = 0;\n\tbool\t\toverride = false;\n\tconst char *p;\n\n\t/*\n\t * We enforce that the filename is all alpha characters.  This may be\n\t * overly restrictive, but we don't want to allow access to anything\n\t * outside the timezonesets directory, so for instance '/' *must* be\n\t * rejected.\n\t */\n\tfor (p = filename; *p; p++)\n\t{\n\t\tif (!isalpha((unsigned char) *p))\n\t\t{\n\t\t\t/* at level 0, just use guc.c's regular \"invalid value\" message */\n\t\t\tif (depth > 0)\n\t\t\t\tGUC_check_errmsg(\"invalid time zone file name \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * The maximal recursion depth is a pretty arbitrary setting. It is hard\n\t * to imagine that someone needs more than 3 levels so stick with this\n\t * conservative setting until someone complains.\n\t */\n\tif (depth > 3)\n\t{\n\t\tGUC_check_errmsg(\"time zone file recursion limit exceeded in file \\\"%s\\\"\",\n\t\t\t\t\t\t filename);\n\t\treturn -1;\n\t}\n\n\tget_share_path(my_exec_path, share_path);\n\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets/%s\",\n\t\t\t share_path, filename);\n\ttzFile = AllocateFile(file_path, \"r\");\n\tif (!tzFile)\n\t{\n\t\t/*\n\t\t * Check to see if the problem is not the filename but the directory.\n\t\t * This is worth troubling over because if the installation share/\n\t\t * directory is missing or unreadable, this is likely to be the first\n\t\t * place we notice a problem during postmaster startup.\n\t\t */\n\t\tint\t\t\tsave_errno = errno;\n\t\tDIR\t\t   *tzdir;\n\n\t\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets\",\n\t\t\t\t share_path);\n\t\ttzdir = AllocateDir(file_path);\n\t\tif (tzdir == NULL)\n\t\t{\n\t\t\tGUC_check_errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t file_path);\n\t\t\tGUC_check_errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t\t  my_exec_path);\n\t\t\treturn -1;\n\t\t}\n\t\tFreeDir(tzdir);\n\t\terrno = save_errno;\n\n\t\t/*\n\t\t * otherwise, if file doesn't exist and it's level 0, guc.c's\n\t\t * complaint is enough\n\t\t */\n\t\tif (errno != ENOENT || depth > 0)\n\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t filename);\n\n\t\treturn -1;\n\t}\n\n\twhile (!feof(tzFile))\n\t{\n\t\tlineno++;\n\t\tif (fgets(tzbuf, sizeof(tzbuf), tzFile) == NULL)\n\t\t{\n\t\t\tif (ferror(tzFile))\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* else we're at EOF after all */\n\t\t\tbreak;\n\t\t}\n\t\tif (strlen(tzbuf) == sizeof(tzbuf) - 1)\n\t\t{\n\t\t\t/* the line is too long for tzbuf */\n\t\t\tGUC_check_errmsg(\"line is too long in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* skip over whitespace */\n\t\tline = tzbuf;\n\t\twhile (*line && isspace((unsigned char) *line))\n\t\t\tline++;\n\n\t\tif (*line == '\\0')\t\t/* empty line */\n\t\t\tcontinue;\n\t\tif (*line == '#')\t\t/* comment line */\n\t\t\tcontinue;\n\n\t\tif (pg_strncasecmp(line, \"@INCLUDE\", strlen(\"@INCLUDE\")) == 0)\n\t\t{\n\t\t\t/* pstrdup so we can use filename in result data structure */\n\t\t\tchar\t   *includeFile = pstrdup(line + strlen(\"@INCLUDE\"));\n\n\t\t\tincludeFile = strtok(includeFile, WHITESPACE);\n\t\t\tif (!includeFile || !*includeFile)\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"@INCLUDE without file name in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t\t filename, lineno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn = ParseTzFile(includeFile, depth + 1,\n\t\t\t\t\t\t\tbase, arraysize, n);\n\t\t\tif (n < 0)\n\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pg_strncasecmp(line, \"@OVERRIDE\", strlen(\"@OVERRIDE\")) == 0)\n\t\t{\n\t\t\toverride = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!splitTzLine(filename, lineno, line, &tzentry))\n\t\t\treturn -1;\n\t\tif (!validateTzEntry(&tzentry))\n\t\t\treturn -1;\n\t\tn = addToArray(base, arraysize, n, &tzentry, override);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t}\n\n\tFreeFile(tzFile);\n\n\treturn n;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\n\\r\""
          ],
          "globals_used": [
            "static bool validateTzEntry(tzEntry *tzentry);",
            "static bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);",
            "static int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);",
            "static int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define WHITESPACE \" \\t\\n\\r\"\n\nstatic bool validateTzEntry(tzEntry *tzentry);\nstatic bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);\nstatic int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);\nstatic int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);\n\nstatic int\nParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n)\n{\n\tchar\t\tshare_path[MAXPGPATH];\n\tchar\t\tfile_path[MAXPGPATH];\n\tFILE\t   *tzFile;\n\tchar\t\ttzbuf[1024];\n\tchar\t   *line;\n\ttzEntry\t\ttzentry;\n\tint\t\t\tlineno = 0;\n\tbool\t\toverride = false;\n\tconst char *p;\n\n\t/*\n\t * We enforce that the filename is all alpha characters.  This may be\n\t * overly restrictive, but we don't want to allow access to anything\n\t * outside the timezonesets directory, so for instance '/' *must* be\n\t * rejected.\n\t */\n\tfor (p = filename; *p; p++)\n\t{\n\t\tif (!isalpha((unsigned char) *p))\n\t\t{\n\t\t\t/* at level 0, just use guc.c's regular \"invalid value\" message */\n\t\t\tif (depth > 0)\n\t\t\t\tGUC_check_errmsg(\"invalid time zone file name \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * The maximal recursion depth is a pretty arbitrary setting. It is hard\n\t * to imagine that someone needs more than 3 levels so stick with this\n\t * conservative setting until someone complains.\n\t */\n\tif (depth > 3)\n\t{\n\t\tGUC_check_errmsg(\"time zone file recursion limit exceeded in file \\\"%s\\\"\",\n\t\t\t\t\t\t filename);\n\t\treturn -1;\n\t}\n\n\tget_share_path(my_exec_path, share_path);\n\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets/%s\",\n\t\t\t share_path, filename);\n\ttzFile = AllocateFile(file_path, \"r\");\n\tif (!tzFile)\n\t{\n\t\t/*\n\t\t * Check to see if the problem is not the filename but the directory.\n\t\t * This is worth troubling over because if the installation share/\n\t\t * directory is missing or unreadable, this is likely to be the first\n\t\t * place we notice a problem during postmaster startup.\n\t\t */\n\t\tint\t\t\tsave_errno = errno;\n\t\tDIR\t\t   *tzdir;\n\n\t\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets\",\n\t\t\t\t share_path);\n\t\ttzdir = AllocateDir(file_path);\n\t\tif (tzdir == NULL)\n\t\t{\n\t\t\tGUC_check_errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t file_path);\n\t\t\tGUC_check_errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t\t  my_exec_path);\n\t\t\treturn -1;\n\t\t}\n\t\tFreeDir(tzdir);\n\t\terrno = save_errno;\n\n\t\t/*\n\t\t * otherwise, if file doesn't exist and it's level 0, guc.c's\n\t\t * complaint is enough\n\t\t */\n\t\tif (errno != ENOENT || depth > 0)\n\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t filename);\n\n\t\treturn -1;\n\t}\n\n\twhile (!feof(tzFile))\n\t{\n\t\tlineno++;\n\t\tif (fgets(tzbuf, sizeof(tzbuf), tzFile) == NULL)\n\t\t{\n\t\t\tif (ferror(tzFile))\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* else we're at EOF after all */\n\t\t\tbreak;\n\t\t}\n\t\tif (strlen(tzbuf) == sizeof(tzbuf) - 1)\n\t\t{\n\t\t\t/* the line is too long for tzbuf */\n\t\t\tGUC_check_errmsg(\"line is too long in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* skip over whitespace */\n\t\tline = tzbuf;\n\t\twhile (*line && isspace((unsigned char) *line))\n\t\t\tline++;\n\n\t\tif (*line == '\\0')\t\t/* empty line */\n\t\t\tcontinue;\n\t\tif (*line == '#')\t\t/* comment line */\n\t\t\tcontinue;\n\n\t\tif (pg_strncasecmp(line, \"@INCLUDE\", strlen(\"@INCLUDE\")) == 0)\n\t\t{\n\t\t\t/* pstrdup so we can use filename in result data structure */\n\t\t\tchar\t   *includeFile = pstrdup(line + strlen(\"@INCLUDE\"));\n\n\t\t\tincludeFile = strtok(includeFile, WHITESPACE);\n\t\t\tif (!includeFile || !*includeFile)\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"@INCLUDE without file name in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t\t filename, lineno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn = ParseTzFile(includeFile, depth + 1,\n\t\t\t\t\t\t\tbase, arraysize, n);\n\t\t\tif (n < 0)\n\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pg_strncasecmp(line, \"@OVERRIDE\", strlen(\"@OVERRIDE\")) == 0)\n\t\t{\n\t\t\toverride = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!splitTzLine(filename, lineno, line, &tzentry))\n\t\t\treturn -1;\n\t\tif (!validateTzEntry(&tzentry))\n\t\t\treturn -1;\n\t\tn = addToArray(base, arraysize, n, &tzentry, override);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t}\n\n\tFreeFile(tzFile);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "arraysize * sizeof(tzEntry)"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "tmpContext"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"TZParserMemory\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);\n\nTimeZoneAbbrevTable *\nload_tzoffsets(const char *filename)\n{\n\tTimeZoneAbbrevTable *result = NULL;\n\tMemoryContext tmpContext;\n\tMemoryContext oldContext;\n\ttzEntry    *array;\n\tint\t\t\tarraysize;\n\tint\t\t\tn;\n\n\t/*\n\t * Create a temp memory context to work in.  This makes it easy to clean\n\t * up afterwards.\n\t */\n\ttmpContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t   \"TZParserMemory\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\toldContext = MemoryContextSwitchTo(tmpContext);\n\n\t/* Initialize array at a reasonable size */\n\tarraysize = 128;\n\tarray = (tzEntry *) palloc(arraysize * sizeof(tzEntry));\n\n\t/* Parse the file(s) */\n\tn = ParseTzFile(filename, 0, &array, &arraysize, 0);\n\n\t/* If no errors so far, let datetime.c allocate memory & convert format */\n\tif (n >= 0)\n\t{\n\t\tresult = ConvertTimeZoneAbbrevs(array, n);\n\t\tif (!result)\n\t\t\tGUC_check_errmsg(\"out of memory\");\n\t}\n\n\t/* Clean up */\n\tMemoryContextSwitchTo(oldContext);\n\tMemoryContextDelete(tmpContext);\n\n\treturn result;\n}"
  },
  {
    "function_name": "ParseTzFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
    "lines": "275-428",
    "snippet": "static int\nParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n)\n{\n\tchar\t\tshare_path[MAXPGPATH];\n\tchar\t\tfile_path[MAXPGPATH];\n\tFILE\t   *tzFile;\n\tchar\t\ttzbuf[1024];\n\tchar\t   *line;\n\ttzEntry\t\ttzentry;\n\tint\t\t\tlineno = 0;\n\tbool\t\toverride = false;\n\tconst char *p;\n\n\t/*\n\t * We enforce that the filename is all alpha characters.  This may be\n\t * overly restrictive, but we don't want to allow access to anything\n\t * outside the timezonesets directory, so for instance '/' *must* be\n\t * rejected.\n\t */\n\tfor (p = filename; *p; p++)\n\t{\n\t\tif (!isalpha((unsigned char) *p))\n\t\t{\n\t\t\t/* at level 0, just use guc.c's regular \"invalid value\" message */\n\t\t\tif (depth > 0)\n\t\t\t\tGUC_check_errmsg(\"invalid time zone file name \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * The maximal recursion depth is a pretty arbitrary setting. It is hard\n\t * to imagine that someone needs more than 3 levels so stick with this\n\t * conservative setting until someone complains.\n\t */\n\tif (depth > 3)\n\t{\n\t\tGUC_check_errmsg(\"time zone file recursion limit exceeded in file \\\"%s\\\"\",\n\t\t\t\t\t\t filename);\n\t\treturn -1;\n\t}\n\n\tget_share_path(my_exec_path, share_path);\n\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets/%s\",\n\t\t\t share_path, filename);\n\ttzFile = AllocateFile(file_path, \"r\");\n\tif (!tzFile)\n\t{\n\t\t/*\n\t\t * Check to see if the problem is not the filename but the directory.\n\t\t * This is worth troubling over because if the installation share/\n\t\t * directory is missing or unreadable, this is likely to be the first\n\t\t * place we notice a problem during postmaster startup.\n\t\t */\n\t\tint\t\t\tsave_errno = errno;\n\t\tDIR\t\t   *tzdir;\n\n\t\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets\",\n\t\t\t\t share_path);\n\t\ttzdir = AllocateDir(file_path);\n\t\tif (tzdir == NULL)\n\t\t{\n\t\t\tGUC_check_errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t file_path);\n\t\t\tGUC_check_errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t\t  my_exec_path);\n\t\t\treturn -1;\n\t\t}\n\t\tFreeDir(tzdir);\n\t\terrno = save_errno;\n\n\t\t/*\n\t\t * otherwise, if file doesn't exist and it's level 0, guc.c's\n\t\t * complaint is enough\n\t\t */\n\t\tif (errno != ENOENT || depth > 0)\n\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t filename);\n\n\t\treturn -1;\n\t}\n\n\twhile (!feof(tzFile))\n\t{\n\t\tlineno++;\n\t\tif (fgets(tzbuf, sizeof(tzbuf), tzFile) == NULL)\n\t\t{\n\t\t\tif (ferror(tzFile))\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* else we're at EOF after all */\n\t\t\tbreak;\n\t\t}\n\t\tif (strlen(tzbuf) == sizeof(tzbuf) - 1)\n\t\t{\n\t\t\t/* the line is too long for tzbuf */\n\t\t\tGUC_check_errmsg(\"line is too long in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* skip over whitespace */\n\t\tline = tzbuf;\n\t\twhile (*line && isspace((unsigned char) *line))\n\t\t\tline++;\n\n\t\tif (*line == '\\0')\t\t/* empty line */\n\t\t\tcontinue;\n\t\tif (*line == '#')\t\t/* comment line */\n\t\t\tcontinue;\n\n\t\tif (pg_strncasecmp(line, \"@INCLUDE\", strlen(\"@INCLUDE\")) == 0)\n\t\t{\n\t\t\t/* pstrdup so we can use filename in result data structure */\n\t\t\tchar\t   *includeFile = pstrdup(line + strlen(\"@INCLUDE\"));\n\n\t\t\tincludeFile = strtok(includeFile, WHITESPACE);\n\t\t\tif (!includeFile || !*includeFile)\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"@INCLUDE without file name in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t\t filename, lineno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn = ParseTzFile(includeFile, depth + 1,\n\t\t\t\t\t\t\tbase, arraysize, n);\n\t\t\tif (n < 0)\n\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pg_strncasecmp(line, \"@OVERRIDE\", strlen(\"@OVERRIDE\")) == 0)\n\t\t{\n\t\t\toverride = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!splitTzLine(filename, lineno, line, &tzentry))\n\t\t\treturn -1;\n\t\tif (!validateTzEntry(&tzentry))\n\t\t\treturn -1;\n\t\tn = addToArray(base, arraysize, n, &tzentry, override);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t}\n\n\tFreeFile(tzFile);\n\n\treturn n;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define WHITESPACE \" \\t\\n\\r\""
    ],
    "globals_used": [
      "static bool validateTzEntry(tzEntry *tzentry);",
      "static bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);",
      "static int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);",
      "static int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "tzFile"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addToArray",
          "args": [
            "base",
            "arraysize",
            "n",
            "&tzentry",
            "override"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "addToArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
          "lines": "187-262",
          "snippet": "static int\naddToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override)\n{\n\ttzEntry    *arrayptr;\n\tint\t\t\tlow;\n\tint\t\t\thigh;\n\n\t/*\n\t * Search the array for a duplicate; as a useful side effect, the array is\n\t * maintained in sorted order.  We use strcmp() to ensure we match the\n\t * sort order datetime.c expects.\n\t */\n\tarrayptr = *base;\n\tlow = 0;\n\thigh = n - 1;\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmid = (low + high) >> 1;\n\t\ttzEntry    *midptr = arrayptr + mid;\n\t\tint\t\t\tcmp;\n\n\t\tcmp = strcmp(entry->abbrev, midptr->abbrev);\n\t\tif (cmp < 0)\n\t\t\thigh = mid - 1;\n\t\telse if (cmp > 0)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Found a duplicate entry; complain unless it's the same.\n\t\t\t */\n\t\t\tif ((midptr->zone == NULL && entry->zone == NULL &&\n\t\t\t\t midptr->offset == entry->offset &&\n\t\t\t\t midptr->is_dst == entry->is_dst) ||\n\t\t\t\t(midptr->zone != NULL && entry->zone != NULL &&\n\t\t\t\t strcmp(midptr->zone, entry->zone) == 0))\n\t\t\t{\n\t\t\t\t/* return unchanged array */\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\t/* same abbrev but something is different, override */\n\t\t\t\tmidptr->zone = entry->zone;\n\t\t\t\tmidptr->offset = entry->offset;\n\t\t\t\tmidptr->is_dst = entry->is_dst;\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\t/* same abbrev but something is different, complain */\n\t\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is multiply defined\",\n\t\t\t\t\t\t\t entry->abbrev);\n\t\t\tGUC_check_errdetail(\"Entry in time zone file \\\"%s\\\", line %d, conflicts with entry in file \\\"%s\\\", line %d.\",\n\t\t\t\t\t\t\t\tmidptr->filename, midptr->lineno,\n\t\t\t\t\t\t\t\tentry->filename, entry->lineno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * No match, insert at position \"low\".\n\t */\n\tif (n >= *arraysize)\n\t{\n\t\t*arraysize *= 2;\n\t\t*base = (tzEntry *) repalloc(*base, *arraysize * sizeof(tzEntry));\n\t}\n\n\tarrayptr = *base + low;\n\n\tmemmove(arrayptr + 1, arrayptr, (n - low) * sizeof(tzEntry));\n\n\tmemcpy(arrayptr, entry, sizeof(tzEntry));\n\n\treturn n + 1;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);",
            "static int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);\nstatic int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);\n\nstatic int\naddToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override)\n{\n\ttzEntry    *arrayptr;\n\tint\t\t\tlow;\n\tint\t\t\thigh;\n\n\t/*\n\t * Search the array for a duplicate; as a useful side effect, the array is\n\t * maintained in sorted order.  We use strcmp() to ensure we match the\n\t * sort order datetime.c expects.\n\t */\n\tarrayptr = *base;\n\tlow = 0;\n\thigh = n - 1;\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmid = (low + high) >> 1;\n\t\ttzEntry    *midptr = arrayptr + mid;\n\t\tint\t\t\tcmp;\n\n\t\tcmp = strcmp(entry->abbrev, midptr->abbrev);\n\t\tif (cmp < 0)\n\t\t\thigh = mid - 1;\n\t\telse if (cmp > 0)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Found a duplicate entry; complain unless it's the same.\n\t\t\t */\n\t\t\tif ((midptr->zone == NULL && entry->zone == NULL &&\n\t\t\t\t midptr->offset == entry->offset &&\n\t\t\t\t midptr->is_dst == entry->is_dst) ||\n\t\t\t\t(midptr->zone != NULL && entry->zone != NULL &&\n\t\t\t\t strcmp(midptr->zone, entry->zone) == 0))\n\t\t\t{\n\t\t\t\t/* return unchanged array */\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\t/* same abbrev but something is different, override */\n\t\t\t\tmidptr->zone = entry->zone;\n\t\t\t\tmidptr->offset = entry->offset;\n\t\t\t\tmidptr->is_dst = entry->is_dst;\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\t/* same abbrev but something is different, complain */\n\t\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is multiply defined\",\n\t\t\t\t\t\t\t entry->abbrev);\n\t\t\tGUC_check_errdetail(\"Entry in time zone file \\\"%s\\\", line %d, conflicts with entry in file \\\"%s\\\", line %d.\",\n\t\t\t\t\t\t\t\tmidptr->filename, midptr->lineno,\n\t\t\t\t\t\t\t\tentry->filename, entry->lineno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * No match, insert at position \"low\".\n\t */\n\tif (n >= *arraysize)\n\t{\n\t\t*arraysize *= 2;\n\t\t*base = (tzEntry *) repalloc(*base, *arraysize * sizeof(tzEntry));\n\t}\n\n\tarrayptr = *base + low;\n\n\tmemmove(arrayptr + 1, arrayptr, (n - low) * sizeof(tzEntry));\n\n\tmemcpy(arrayptr, entry, sizeof(tzEntry));\n\n\treturn n + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validateTzEntry",
          "args": [
            "&tzentry"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "validateTzEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
          "lines": "50-86",
          "snippet": "static bool\nvalidateTzEntry(tzEntry *tzentry)\n{\n\tunsigned char *p;\n\n\t/*\n\t * Check restrictions imposed by datetkntbl storage format (see\n\t * datetime.c)\n\t */\n\tif (strlen(tzentry->abbrev) > TOKMAXLEN)\n\t{\n\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is too long (maximum %d characters) in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->abbrev, TOKMAXLEN,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Sanity-check the offset: shouldn't exceed 14 hours\n\t */\n\tif (tzentry->offset > 14 * 60 * 60 ||\n\t\ttzentry->offset < -14 * 60 * 60)\n\t{\n\t\tGUC_check_errmsg(\"time zone offset %d is out of range in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->offset,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Convert abbrev to lowercase (must match datetime.c's conversion)\n\t */\n\tfor (p = (unsigned char *) tzentry->abbrev; *p; p++)\n\t\t*p = pg_tolower(*p);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool validateTzEntry(tzEntry *tzentry);",
            "static bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool validateTzEntry(tzEntry *tzentry);\nstatic bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);\n\nstatic bool\nvalidateTzEntry(tzEntry *tzentry)\n{\n\tunsigned char *p;\n\n\t/*\n\t * Check restrictions imposed by datetkntbl storage format (see\n\t * datetime.c)\n\t */\n\tif (strlen(tzentry->abbrev) > TOKMAXLEN)\n\t{\n\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is too long (maximum %d characters) in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->abbrev, TOKMAXLEN,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Sanity-check the offset: shouldn't exceed 14 hours\n\t */\n\tif (tzentry->offset > 14 * 60 * 60 ||\n\t\ttzentry->offset < -14 * 60 * 60)\n\t{\n\t\tGUC_check_errmsg(\"time zone offset %d is out of range in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->offset,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Convert abbrev to lowercase (must match datetime.c's conversion)\n\t */\n\tfor (p = (unsigned char *) tzentry->abbrev; *p; p++)\n\t\t*p = pg_tolower(*p);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splitTzLine",
          "args": [
            "filename",
            "lineno",
            "line",
            "&tzentry"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "splitTzLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
          "lines": "97-174",
          "snippet": "static bool\nsplitTzLine(const char *filename, int lineno, char *line, tzEntry *tzentry)\n{\n\tchar\t   *abbrev;\n\tchar\t   *offset;\n\tchar\t   *offset_endptr;\n\tchar\t   *remain;\n\tchar\t   *is_dst;\n\n\ttzentry->lineno = lineno;\n\ttzentry->filename = filename;\n\n\tabbrev = strtok(line, WHITESPACE);\n\tif (!abbrev)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone abbreviation in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\ttzentry->abbrev = pstrdup(abbrev);\n\n\toffset = strtok(NULL, WHITESPACE);\n\tif (!offset)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\n\t/* We assume zone names don't begin with a digit or sign */\n\tif (isdigit((unsigned char) *offset) || *offset == '+' || *offset == '-')\n\t{\n\t\ttzentry->zone = NULL;\n\t\ttzentry->offset = strtol(offset, &offset_endptr, 10);\n\t\tif (offset_endptr == offset || *offset_endptr != '\\0')\n\t\t{\n\t\t\tGUC_check_errmsg(\"invalid number for time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn false;\n\t\t}\n\n\t\tis_dst = strtok(NULL, WHITESPACE);\n\t\tif (is_dst && pg_strcasecmp(is_dst, \"D\") == 0)\n\t\t{\n\t\t\ttzentry->is_dst = true;\n\t\t\tremain = strtok(NULL, WHITESPACE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there was no 'D' dst specifier */\n\t\t\ttzentry->is_dst = false;\n\t\t\tremain = is_dst;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume entry is a zone name.  We do not try to validate it by\n\t\t * looking up the zone, because that would force loading of a lot of\n\t\t * zones that probably will never be used in the current session.\n\t\t */\n\t\ttzentry->zone = pstrdup(offset);\n\t\ttzentry->offset = 0;\n\t\ttzentry->is_dst = false;\n\t\tremain = strtok(NULL, WHITESPACE);\n\t}\n\n\tif (!remain)\t\t\t\t/* no more non-whitespace chars */\n\t\treturn true;\n\n\tif (remain[0] != '#')\t\t/* must be a comment */\n\t{\n\t\tGUC_check_errmsg(\"invalid syntax in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define WHITESPACE \" \\t\\n\\r\""
          ],
          "globals_used": [
            "static bool validateTzEntry(tzEntry *tzentry);",
            "static bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define WHITESPACE \" \\t\\n\\r\"\n\nstatic bool validateTzEntry(tzEntry *tzentry);\nstatic bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);\n\nstatic bool\nsplitTzLine(const char *filename, int lineno, char *line, tzEntry *tzentry)\n{\n\tchar\t   *abbrev;\n\tchar\t   *offset;\n\tchar\t   *offset_endptr;\n\tchar\t   *remain;\n\tchar\t   *is_dst;\n\n\ttzentry->lineno = lineno;\n\ttzentry->filename = filename;\n\n\tabbrev = strtok(line, WHITESPACE);\n\tif (!abbrev)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone abbreviation in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\ttzentry->abbrev = pstrdup(abbrev);\n\n\toffset = strtok(NULL, WHITESPACE);\n\tif (!offset)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\n\t/* We assume zone names don't begin with a digit or sign */\n\tif (isdigit((unsigned char) *offset) || *offset == '+' || *offset == '-')\n\t{\n\t\ttzentry->zone = NULL;\n\t\ttzentry->offset = strtol(offset, &offset_endptr, 10);\n\t\tif (offset_endptr == offset || *offset_endptr != '\\0')\n\t\t{\n\t\t\tGUC_check_errmsg(\"invalid number for time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn false;\n\t\t}\n\n\t\tis_dst = strtok(NULL, WHITESPACE);\n\t\tif (is_dst && pg_strcasecmp(is_dst, \"D\") == 0)\n\t\t{\n\t\t\ttzentry->is_dst = true;\n\t\t\tremain = strtok(NULL, WHITESPACE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there was no 'D' dst specifier */\n\t\t\ttzentry->is_dst = false;\n\t\t\tremain = is_dst;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume entry is a zone name.  We do not try to validate it by\n\t\t * looking up the zone, because that would force loading of a lot of\n\t\t * zones that probably will never be used in the current session.\n\t\t */\n\t\ttzentry->zone = pstrdup(offset);\n\t\ttzentry->offset = 0;\n\t\ttzentry->is_dst = false;\n\t\tremain = strtok(NULL, WHITESPACE);\n\t}\n\n\tif (!remain)\t\t\t\t/* no more non-whitespace chars */\n\t\treturn true;\n\n\tif (remain[0] != '#')\t\t/* must be a comment */\n\t{\n\t\tGUC_check_errmsg(\"invalid syntax in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "line",
            "\"@OVERRIDE\"",
            "strlen(\"@OVERRIDE\")"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"@OVERRIDE\""
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseTzFile",
          "args": [
            "includeFile",
            "depth + 1",
            "base",
            "arraysize",
            "n"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ParseTzFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
          "lines": "275-428",
          "snippet": "static int\nParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n)\n{\n\tchar\t\tshare_path[MAXPGPATH];\n\tchar\t\tfile_path[MAXPGPATH];\n\tFILE\t   *tzFile;\n\tchar\t\ttzbuf[1024];\n\tchar\t   *line;\n\ttzEntry\t\ttzentry;\n\tint\t\t\tlineno = 0;\n\tbool\t\toverride = false;\n\tconst char *p;\n\n\t/*\n\t * We enforce that the filename is all alpha characters.  This may be\n\t * overly restrictive, but we don't want to allow access to anything\n\t * outside the timezonesets directory, so for instance '/' *must* be\n\t * rejected.\n\t */\n\tfor (p = filename; *p; p++)\n\t{\n\t\tif (!isalpha((unsigned char) *p))\n\t\t{\n\t\t\t/* at level 0, just use guc.c's regular \"invalid value\" message */\n\t\t\tif (depth > 0)\n\t\t\t\tGUC_check_errmsg(\"invalid time zone file name \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * The maximal recursion depth is a pretty arbitrary setting. It is hard\n\t * to imagine that someone needs more than 3 levels so stick with this\n\t * conservative setting until someone complains.\n\t */\n\tif (depth > 3)\n\t{\n\t\tGUC_check_errmsg(\"time zone file recursion limit exceeded in file \\\"%s\\\"\",\n\t\t\t\t\t\t filename);\n\t\treturn -1;\n\t}\n\n\tget_share_path(my_exec_path, share_path);\n\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets/%s\",\n\t\t\t share_path, filename);\n\ttzFile = AllocateFile(file_path, \"r\");\n\tif (!tzFile)\n\t{\n\t\t/*\n\t\t * Check to see if the problem is not the filename but the directory.\n\t\t * This is worth troubling over because if the installation share/\n\t\t * directory is missing or unreadable, this is likely to be the first\n\t\t * place we notice a problem during postmaster startup.\n\t\t */\n\t\tint\t\t\tsave_errno = errno;\n\t\tDIR\t\t   *tzdir;\n\n\t\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets\",\n\t\t\t\t share_path);\n\t\ttzdir = AllocateDir(file_path);\n\t\tif (tzdir == NULL)\n\t\t{\n\t\t\tGUC_check_errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t file_path);\n\t\t\tGUC_check_errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t\t  my_exec_path);\n\t\t\treturn -1;\n\t\t}\n\t\tFreeDir(tzdir);\n\t\terrno = save_errno;\n\n\t\t/*\n\t\t * otherwise, if file doesn't exist and it's level 0, guc.c's\n\t\t * complaint is enough\n\t\t */\n\t\tif (errno != ENOENT || depth > 0)\n\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t filename);\n\n\t\treturn -1;\n\t}\n\n\twhile (!feof(tzFile))\n\t{\n\t\tlineno++;\n\t\tif (fgets(tzbuf, sizeof(tzbuf), tzFile) == NULL)\n\t\t{\n\t\t\tif (ferror(tzFile))\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* else we're at EOF after all */\n\t\t\tbreak;\n\t\t}\n\t\tif (strlen(tzbuf) == sizeof(tzbuf) - 1)\n\t\t{\n\t\t\t/* the line is too long for tzbuf */\n\t\t\tGUC_check_errmsg(\"line is too long in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* skip over whitespace */\n\t\tline = tzbuf;\n\t\twhile (*line && isspace((unsigned char) *line))\n\t\t\tline++;\n\n\t\tif (*line == '\\0')\t\t/* empty line */\n\t\t\tcontinue;\n\t\tif (*line == '#')\t\t/* comment line */\n\t\t\tcontinue;\n\n\t\tif (pg_strncasecmp(line, \"@INCLUDE\", strlen(\"@INCLUDE\")) == 0)\n\t\t{\n\t\t\t/* pstrdup so we can use filename in result data structure */\n\t\t\tchar\t   *includeFile = pstrdup(line + strlen(\"@INCLUDE\"));\n\n\t\t\tincludeFile = strtok(includeFile, WHITESPACE);\n\t\t\tif (!includeFile || !*includeFile)\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"@INCLUDE without file name in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t\t filename, lineno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn = ParseTzFile(includeFile, depth + 1,\n\t\t\t\t\t\t\tbase, arraysize, n);\n\t\t\tif (n < 0)\n\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pg_strncasecmp(line, \"@OVERRIDE\", strlen(\"@OVERRIDE\")) == 0)\n\t\t{\n\t\t\toverride = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!splitTzLine(filename, lineno, line, &tzentry))\n\t\t\treturn -1;\n\t\tif (!validateTzEntry(&tzentry))\n\t\t\treturn -1;\n\t\tn = addToArray(base, arraysize, n, &tzentry, override);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t}\n\n\tFreeFile(tzFile);\n\n\treturn n;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"@INCLUDE without file name in time zone file \\\"%s\\\", line %d\"",
            "filename",
            "lineno"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "includeFile",
            "WHITESPACE"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "line + strlen(\"@INCLUDE\")"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "line",
            "\"@INCLUDE\"",
            "strlen(\"@INCLUDE\")"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *line"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"line is too long in time zone file \\\"%s\\\", line %d\"",
            "filename",
            "lineno"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"could not read time zone file \\\"%s\\\": %m\"",
            "filename"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ferror",
          "args": [
            "tzFile"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tzbuf",
            "sizeof(tzbuf)",
            "tzFile"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "tzFile"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"could not read time zone file \\\"%s\\\": %m\"",
            "filename"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "tzdir"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errhint",
          "args": [
            "\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\"",
            "my_exec_path"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"could not open directory \\\"%s\\\": %m\"",
            "file_path"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "file_path"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "file_path",
            "sizeof(file_path)",
            "\"%s/timezonesets\"",
            "share_path"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "file_path",
            "\"r\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "file_path",
            "sizeof(file_path)",
            "\"%s/timezonesets/%s\"",
            "share_path",
            "filename"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_share_path",
          "args": [
            "my_exec_path",
            "share_path"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"time zone file recursion limit exceeded in file \\\"%s\\\"\"",
            "filename"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"invalid time zone file name \\\"%s\\\"\"",
            "filename"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define WHITESPACE \" \\t\\n\\r\"\n\nstatic bool validateTzEntry(tzEntry *tzentry);\nstatic bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);\nstatic int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);\nstatic int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);\n\nstatic int\nParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n)\n{\n\tchar\t\tshare_path[MAXPGPATH];\n\tchar\t\tfile_path[MAXPGPATH];\n\tFILE\t   *tzFile;\n\tchar\t\ttzbuf[1024];\n\tchar\t   *line;\n\ttzEntry\t\ttzentry;\n\tint\t\t\tlineno = 0;\n\tbool\t\toverride = false;\n\tconst char *p;\n\n\t/*\n\t * We enforce that the filename is all alpha characters.  This may be\n\t * overly restrictive, but we don't want to allow access to anything\n\t * outside the timezonesets directory, so for instance '/' *must* be\n\t * rejected.\n\t */\n\tfor (p = filename; *p; p++)\n\t{\n\t\tif (!isalpha((unsigned char) *p))\n\t\t{\n\t\t\t/* at level 0, just use guc.c's regular \"invalid value\" message */\n\t\t\tif (depth > 0)\n\t\t\t\tGUC_check_errmsg(\"invalid time zone file name \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * The maximal recursion depth is a pretty arbitrary setting. It is hard\n\t * to imagine that someone needs more than 3 levels so stick with this\n\t * conservative setting until someone complains.\n\t */\n\tif (depth > 3)\n\t{\n\t\tGUC_check_errmsg(\"time zone file recursion limit exceeded in file \\\"%s\\\"\",\n\t\t\t\t\t\t filename);\n\t\treturn -1;\n\t}\n\n\tget_share_path(my_exec_path, share_path);\n\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets/%s\",\n\t\t\t share_path, filename);\n\ttzFile = AllocateFile(file_path, \"r\");\n\tif (!tzFile)\n\t{\n\t\t/*\n\t\t * Check to see if the problem is not the filename but the directory.\n\t\t * This is worth troubling over because if the installation share/\n\t\t * directory is missing or unreadable, this is likely to be the first\n\t\t * place we notice a problem during postmaster startup.\n\t\t */\n\t\tint\t\t\tsave_errno = errno;\n\t\tDIR\t\t   *tzdir;\n\n\t\tsnprintf(file_path, sizeof(file_path), \"%s/timezonesets\",\n\t\t\t\t share_path);\n\t\ttzdir = AllocateDir(file_path);\n\t\tif (tzdir == NULL)\n\t\t{\n\t\t\tGUC_check_errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t file_path);\n\t\t\tGUC_check_errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t\t  my_exec_path);\n\t\t\treturn -1;\n\t\t}\n\t\tFreeDir(tzdir);\n\t\terrno = save_errno;\n\n\t\t/*\n\t\t * otherwise, if file doesn't exist and it's level 0, guc.c's\n\t\t * complaint is enough\n\t\t */\n\t\tif (errno != ENOENT || depth > 0)\n\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t filename);\n\n\t\treturn -1;\n\t}\n\n\twhile (!feof(tzFile))\n\t{\n\t\tlineno++;\n\t\tif (fgets(tzbuf, sizeof(tzbuf), tzFile) == NULL)\n\t\t{\n\t\t\tif (ferror(tzFile))\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"could not read time zone file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t filename);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* else we're at EOF after all */\n\t\t\tbreak;\n\t\t}\n\t\tif (strlen(tzbuf) == sizeof(tzbuf) - 1)\n\t\t{\n\t\t\t/* the line is too long for tzbuf */\n\t\t\tGUC_check_errmsg(\"line is too long in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* skip over whitespace */\n\t\tline = tzbuf;\n\t\twhile (*line && isspace((unsigned char) *line))\n\t\t\tline++;\n\n\t\tif (*line == '\\0')\t\t/* empty line */\n\t\t\tcontinue;\n\t\tif (*line == '#')\t\t/* comment line */\n\t\t\tcontinue;\n\n\t\tif (pg_strncasecmp(line, \"@INCLUDE\", strlen(\"@INCLUDE\")) == 0)\n\t\t{\n\t\t\t/* pstrdup so we can use filename in result data structure */\n\t\t\tchar\t   *includeFile = pstrdup(line + strlen(\"@INCLUDE\"));\n\n\t\t\tincludeFile = strtok(includeFile, WHITESPACE);\n\t\t\tif (!includeFile || !*includeFile)\n\t\t\t{\n\t\t\t\tGUC_check_errmsg(\"@INCLUDE without file name in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t\t filename, lineno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn = ParseTzFile(includeFile, depth + 1,\n\t\t\t\t\t\t\tbase, arraysize, n);\n\t\t\tif (n < 0)\n\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pg_strncasecmp(line, \"@OVERRIDE\", strlen(\"@OVERRIDE\")) == 0)\n\t\t{\n\t\t\toverride = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!splitTzLine(filename, lineno, line, &tzentry))\n\t\t\treturn -1;\n\t\tif (!validateTzEntry(&tzentry))\n\t\t\treturn -1;\n\t\tn = addToArray(base, arraysize, n, &tzentry, override);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t}\n\n\tFreeFile(tzFile);\n\n\treturn n;\n}"
  },
  {
    "function_name": "addToArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
    "lines": "187-262",
    "snippet": "static int\naddToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override)\n{\n\ttzEntry    *arrayptr;\n\tint\t\t\tlow;\n\tint\t\t\thigh;\n\n\t/*\n\t * Search the array for a duplicate; as a useful side effect, the array is\n\t * maintained in sorted order.  We use strcmp() to ensure we match the\n\t * sort order datetime.c expects.\n\t */\n\tarrayptr = *base;\n\tlow = 0;\n\thigh = n - 1;\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmid = (low + high) >> 1;\n\t\ttzEntry    *midptr = arrayptr + mid;\n\t\tint\t\t\tcmp;\n\n\t\tcmp = strcmp(entry->abbrev, midptr->abbrev);\n\t\tif (cmp < 0)\n\t\t\thigh = mid - 1;\n\t\telse if (cmp > 0)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Found a duplicate entry; complain unless it's the same.\n\t\t\t */\n\t\t\tif ((midptr->zone == NULL && entry->zone == NULL &&\n\t\t\t\t midptr->offset == entry->offset &&\n\t\t\t\t midptr->is_dst == entry->is_dst) ||\n\t\t\t\t(midptr->zone != NULL && entry->zone != NULL &&\n\t\t\t\t strcmp(midptr->zone, entry->zone) == 0))\n\t\t\t{\n\t\t\t\t/* return unchanged array */\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\t/* same abbrev but something is different, override */\n\t\t\t\tmidptr->zone = entry->zone;\n\t\t\t\tmidptr->offset = entry->offset;\n\t\t\t\tmidptr->is_dst = entry->is_dst;\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\t/* same abbrev but something is different, complain */\n\t\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is multiply defined\",\n\t\t\t\t\t\t\t entry->abbrev);\n\t\t\tGUC_check_errdetail(\"Entry in time zone file \\\"%s\\\", line %d, conflicts with entry in file \\\"%s\\\", line %d.\",\n\t\t\t\t\t\t\t\tmidptr->filename, midptr->lineno,\n\t\t\t\t\t\t\t\tentry->filename, entry->lineno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * No match, insert at position \"low\".\n\t */\n\tif (n >= *arraysize)\n\t{\n\t\t*arraysize *= 2;\n\t\t*base = (tzEntry *) repalloc(*base, *arraysize * sizeof(tzEntry));\n\t}\n\n\tarrayptr = *base + low;\n\n\tmemmove(arrayptr + 1, arrayptr, (n - low) * sizeof(tzEntry));\n\n\tmemcpy(arrayptr, entry, sizeof(tzEntry));\n\n\treturn n + 1;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);",
      "static int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "arrayptr",
            "entry",
            "sizeof(tzEntry)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "arrayptr + 1",
            "arrayptr",
            "(n - low) * sizeof(tzEntry)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "*base",
            "*arraysize * sizeof(tzEntry)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GUC_check_errdetail",
          "args": [
            "\"Entry in time zone file \\\"%s\\\", line %d, conflicts with entry in file \\\"%s\\\", line %d.\"",
            "midptr->filename",
            "midptr->lineno",
            "entry->filename",
            "entry->lineno"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"time zone abbreviation \\\"%s\\\" is multiply defined\"",
            "entry->abbrev"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "midptr->zone",
            "entry->zone"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int addToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override);\nstatic int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);\n\nstatic int\naddToArray(tzEntry **base, int *arraysize, int n,\n\t\t   tzEntry *entry, bool override)\n{\n\ttzEntry    *arrayptr;\n\tint\t\t\tlow;\n\tint\t\t\thigh;\n\n\t/*\n\t * Search the array for a duplicate; as a useful side effect, the array is\n\t * maintained in sorted order.  We use strcmp() to ensure we match the\n\t * sort order datetime.c expects.\n\t */\n\tarrayptr = *base;\n\tlow = 0;\n\thigh = n - 1;\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmid = (low + high) >> 1;\n\t\ttzEntry    *midptr = arrayptr + mid;\n\t\tint\t\t\tcmp;\n\n\t\tcmp = strcmp(entry->abbrev, midptr->abbrev);\n\t\tif (cmp < 0)\n\t\t\thigh = mid - 1;\n\t\telse if (cmp > 0)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Found a duplicate entry; complain unless it's the same.\n\t\t\t */\n\t\t\tif ((midptr->zone == NULL && entry->zone == NULL &&\n\t\t\t\t midptr->offset == entry->offset &&\n\t\t\t\t midptr->is_dst == entry->is_dst) ||\n\t\t\t\t(midptr->zone != NULL && entry->zone != NULL &&\n\t\t\t\t strcmp(midptr->zone, entry->zone) == 0))\n\t\t\t{\n\t\t\t\t/* return unchanged array */\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\t/* same abbrev but something is different, override */\n\t\t\t\tmidptr->zone = entry->zone;\n\t\t\t\tmidptr->offset = entry->offset;\n\t\t\t\tmidptr->is_dst = entry->is_dst;\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\t/* same abbrev but something is different, complain */\n\t\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is multiply defined\",\n\t\t\t\t\t\t\t entry->abbrev);\n\t\t\tGUC_check_errdetail(\"Entry in time zone file \\\"%s\\\", line %d, conflicts with entry in file \\\"%s\\\", line %d.\",\n\t\t\t\t\t\t\t\tmidptr->filename, midptr->lineno,\n\t\t\t\t\t\t\t\tentry->filename, entry->lineno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * No match, insert at position \"low\".\n\t */\n\tif (n >= *arraysize)\n\t{\n\t\t*arraysize *= 2;\n\t\t*base = (tzEntry *) repalloc(*base, *arraysize * sizeof(tzEntry));\n\t}\n\n\tarrayptr = *base + low;\n\n\tmemmove(arrayptr + 1, arrayptr, (n - low) * sizeof(tzEntry));\n\n\tmemcpy(arrayptr, entry, sizeof(tzEntry));\n\n\treturn n + 1;\n}"
  },
  {
    "function_name": "splitTzLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
    "lines": "97-174",
    "snippet": "static bool\nsplitTzLine(const char *filename, int lineno, char *line, tzEntry *tzentry)\n{\n\tchar\t   *abbrev;\n\tchar\t   *offset;\n\tchar\t   *offset_endptr;\n\tchar\t   *remain;\n\tchar\t   *is_dst;\n\n\ttzentry->lineno = lineno;\n\ttzentry->filename = filename;\n\n\tabbrev = strtok(line, WHITESPACE);\n\tif (!abbrev)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone abbreviation in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\ttzentry->abbrev = pstrdup(abbrev);\n\n\toffset = strtok(NULL, WHITESPACE);\n\tif (!offset)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\n\t/* We assume zone names don't begin with a digit or sign */\n\tif (isdigit((unsigned char) *offset) || *offset == '+' || *offset == '-')\n\t{\n\t\ttzentry->zone = NULL;\n\t\ttzentry->offset = strtol(offset, &offset_endptr, 10);\n\t\tif (offset_endptr == offset || *offset_endptr != '\\0')\n\t\t{\n\t\t\tGUC_check_errmsg(\"invalid number for time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn false;\n\t\t}\n\n\t\tis_dst = strtok(NULL, WHITESPACE);\n\t\tif (is_dst && pg_strcasecmp(is_dst, \"D\") == 0)\n\t\t{\n\t\t\ttzentry->is_dst = true;\n\t\t\tremain = strtok(NULL, WHITESPACE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there was no 'D' dst specifier */\n\t\t\ttzentry->is_dst = false;\n\t\t\tremain = is_dst;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume entry is a zone name.  We do not try to validate it by\n\t\t * looking up the zone, because that would force loading of a lot of\n\t\t * zones that probably will never be used in the current session.\n\t\t */\n\t\ttzentry->zone = pstrdup(offset);\n\t\ttzentry->offset = 0;\n\t\ttzentry->is_dst = false;\n\t\tremain = strtok(NULL, WHITESPACE);\n\t}\n\n\tif (!remain)\t\t\t\t/* no more non-whitespace chars */\n\t\treturn true;\n\n\tif (remain[0] != '#')\t\t/* must be a comment */\n\t{\n\t\tGUC_check_errmsg(\"invalid syntax in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define WHITESPACE \" \\t\\n\\r\""
    ],
    "globals_used": [
      "static bool validateTzEntry(tzEntry *tzentry);",
      "static bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"invalid syntax in time zone file \\\"%s\\\", line %d\"",
            "filename",
            "lineno"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "WHITESPACE"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "offset"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "WHITESPACE"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "is_dst",
            "\"D\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "WHITESPACE"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"invalid number for time zone offset in time zone file \\\"%s\\\", line %d\"",
            "filename",
            "lineno"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "offset",
            "&offset_endptr",
            "10"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *offset"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"missing time zone offset in time zone file \\\"%s\\\", line %d\"",
            "filename",
            "lineno"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "WHITESPACE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"missing time zone abbreviation in time zone file \\\"%s\\\", line %d\"",
            "filename",
            "lineno"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "line",
            "WHITESPACE"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define WHITESPACE \" \\t\\n\\r\"\n\nstatic bool validateTzEntry(tzEntry *tzentry);\nstatic bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);\n\nstatic bool\nsplitTzLine(const char *filename, int lineno, char *line, tzEntry *tzentry)\n{\n\tchar\t   *abbrev;\n\tchar\t   *offset;\n\tchar\t   *offset_endptr;\n\tchar\t   *remain;\n\tchar\t   *is_dst;\n\n\ttzentry->lineno = lineno;\n\ttzentry->filename = filename;\n\n\tabbrev = strtok(line, WHITESPACE);\n\tif (!abbrev)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone abbreviation in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\ttzentry->abbrev = pstrdup(abbrev);\n\n\toffset = strtok(NULL, WHITESPACE);\n\tif (!offset)\n\t{\n\t\tGUC_check_errmsg(\"missing time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\n\t/* We assume zone names don't begin with a digit or sign */\n\tif (isdigit((unsigned char) *offset) || *offset == '+' || *offset == '-')\n\t{\n\t\ttzentry->zone = NULL;\n\t\ttzentry->offset = strtol(offset, &offset_endptr, 10);\n\t\tif (offset_endptr == offset || *offset_endptr != '\\0')\n\t\t{\n\t\t\tGUC_check_errmsg(\"invalid number for time zone offset in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t\t filename, lineno);\n\t\t\treturn false;\n\t\t}\n\n\t\tis_dst = strtok(NULL, WHITESPACE);\n\t\tif (is_dst && pg_strcasecmp(is_dst, \"D\") == 0)\n\t\t{\n\t\t\ttzentry->is_dst = true;\n\t\t\tremain = strtok(NULL, WHITESPACE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there was no 'D' dst specifier */\n\t\t\ttzentry->is_dst = false;\n\t\t\tremain = is_dst;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume entry is a zone name.  We do not try to validate it by\n\t\t * looking up the zone, because that would force loading of a lot of\n\t\t * zones that probably will never be used in the current session.\n\t\t */\n\t\ttzentry->zone = pstrdup(offset);\n\t\ttzentry->offset = 0;\n\t\ttzentry->is_dst = false;\n\t\tremain = strtok(NULL, WHITESPACE);\n\t}\n\n\tif (!remain)\t\t\t\t/* no more non-whitespace chars */\n\t\treturn true;\n\n\tif (remain[0] != '#')\t\t/* must be a comment */\n\t{\n\t\tGUC_check_errmsg(\"invalid syntax in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t filename, lineno);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "validateTzEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
    "lines": "50-86",
    "snippet": "static bool\nvalidateTzEntry(tzEntry *tzentry)\n{\n\tunsigned char *p;\n\n\t/*\n\t * Check restrictions imposed by datetkntbl storage format (see\n\t * datetime.c)\n\t */\n\tif (strlen(tzentry->abbrev) > TOKMAXLEN)\n\t{\n\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is too long (maximum %d characters) in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->abbrev, TOKMAXLEN,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Sanity-check the offset: shouldn't exceed 14 hours\n\t */\n\tif (tzentry->offset > 14 * 60 * 60 ||\n\t\ttzentry->offset < -14 * 60 * 60)\n\t{\n\t\tGUC_check_errmsg(\"time zone offset %d is out of range in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->offset,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Convert abbrev to lowercase (must match datetime.c's conversion)\n\t */\n\tfor (p = (unsigned char *) tzentry->abbrev; *p; p++)\n\t\t*p = pg_tolower(*p);\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool validateTzEntry(tzEntry *tzentry);",
      "static bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "*p"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"time zone offset %d is out of range in time zone file \\\"%s\\\", line %d\"",
            "tzentry->offset",
            "tzentry->filename",
            "tzentry->lineno"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUC_check_errmsg",
          "args": [
            "\"time zone abbreviation \\\"%s\\\" is too long (maximum %d characters) in time zone file \\\"%s\\\", line %d\"",
            "tzentry->abbrev",
            "TOKMAXLEN",
            "tzentry->filename",
            "tzentry->lineno"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tzentry->abbrev"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool validateTzEntry(tzEntry *tzentry);\nstatic bool splitTzLine(const char *filename, int lineno,\n\t\t\tchar *line, tzEntry *tzentry);\n\nstatic bool\nvalidateTzEntry(tzEntry *tzentry)\n{\n\tunsigned char *p;\n\n\t/*\n\t * Check restrictions imposed by datetkntbl storage format (see\n\t * datetime.c)\n\t */\n\tif (strlen(tzentry->abbrev) > TOKMAXLEN)\n\t{\n\t\tGUC_check_errmsg(\"time zone abbreviation \\\"%s\\\" is too long (maximum %d characters) in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->abbrev, TOKMAXLEN,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Sanity-check the offset: shouldn't exceed 14 hours\n\t */\n\tif (tzentry->offset > 14 * 60 * 60 ||\n\t\ttzentry->offset < -14 * 60 * 60)\n\t{\n\t\tGUC_check_errmsg(\"time zone offset %d is out of range in time zone file \\\"%s\\\", line %d\",\n\t\t\t\t\t\t tzentry->offset,\n\t\t\t\t\t\t tzentry->filename, tzentry->lineno);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Convert abbrev to lowercase (must match datetime.c's conversion)\n\t */\n\tfor (p = (unsigned char *) tzentry->abbrev; *p; p++)\n\t\t*p = pg_tolower(*p);\n\n\treturn true;\n}"
  }
]