[
  {
    "function_name": "LogicalTapeSetBlocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "1081-1085",
    "snippet": "long\nLogicalTapeSetBlocks(LogicalTapeSet *lts)\n{\n\treturn lts->nBlocksAllocated - lts->nHoleBlocks;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nlong\nLogicalTapeSetBlocks(LogicalTapeSet *lts)\n{\n\treturn lts->nBlocksAllocated - lts->nHoleBlocks;\n}"
  },
  {
    "function_name": "LogicalTapeTell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "1061-1076",
    "snippet": "void\nLogicalTapeTell(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong *blocknum, int *offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* With a larger buffer, 'pos' wouldn't be the same as offset within page */\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t*blocknum = lt->curBlockNumber;\n\t*offset = lt->pos;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->buffer_size == BLCKSZ"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->offsetBlockNumber == 0L"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nvoid\nLogicalTapeTell(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong *blocknum, int *offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* With a larger buffer, 'pos' wouldn't be the same as offset within page */\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t*blocknum = lt->curBlockNumber;\n\t*offset = lt->pos;\n}"
  },
  {
    "function_name": "LogicalTapeSeek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "1030-1053",
    "snippet": "void\nLogicalTapeSeek(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong blocknum, int offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(offset >= 0 && offset <= TapeBlockPayloadSize);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\tif (blocknum != lt->curBlockNumber)\n\t{\n\t\tltsReadBlock(lts, blocknum, (void *) lt->buffer);\n\t\tlt->curBlockNumber = blocknum;\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\t}\n\n\tif (offset > lt->nbytes)\n\t\telog(ERROR, \"invalid tape seek position\");\n\tlt->pos = offset;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
    ],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tape seek position\""
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsReadBlock",
          "args": [
            "lts",
            "blocknum",
            "(void *) lt->buffer"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "269-278",
          "snippet": "static void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->buffer_size == BLCKSZ"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "offset >= 0 && offset <= TapeBlockPayloadSize"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->frozen"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nvoid\nLogicalTapeSeek(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong blocknum, int offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(offset >= 0 && offset <= TapeBlockPayloadSize);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\tif (blocknum != lt->curBlockNumber)\n\t{\n\t\tltsReadBlock(lts, blocknum, (void *) lt->buffer);\n\t\tlt->curBlockNumber = blocknum;\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\t}\n\n\tif (offset > lt->nbytes)\n\t\telog(ERROR, \"invalid tape seek position\");\n\tlt->pos = offset;\n}"
  },
  {
    "function_name": "LogicalTapeBackspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "959-1020",
    "snippet": "size_t\nLogicalTapeBackspace(LogicalTapeSet *lts, int tapenum, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tseekpos = 0;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t/*\n\t * Easy case for seek within current block.\n\t */\n\tif (size <= (size_t) lt->pos)\n\t{\n\t\tlt->pos -= (int) size;\n\t\treturn size;\n\t}\n\n\t/*\n\t * Not-so-easy case, have to walk back the chain of blocks.  This\n\t * implementation would be pretty inefficient for long seeks, but we\n\t * really aren't doing that (a seek over one tuple is typical).\n\t */\n\tseekpos = (size_t) lt->pos; /* part within this block */\n\twhile (size > seekpos)\n\t{\n\t\tlong\t\tprev = TapeBlockGetTrailer(lt->buffer)->prev;\n\n\t\tif (prev == -1L)\n\t\t{\n\t\t\t/* Tried to back up beyond the beginning of tape. */\n\t\t\tif (lt->curBlockNumber != lt->firstBlockNumber)\n\t\t\t\telog(ERROR, \"unexpected end of tape\");\n\t\t\tlt->pos = 0;\n\t\t\treturn seekpos;\n\t\t}\n\n\t\tltsReadBlock(lts, prev, (void *) lt->buffer);\n\n\t\tif (TapeBlockGetTrailer(lt->buffer)->next != lt->curBlockNumber)\n\t\t\telog(ERROR, \"broken tape, next of block %ld is %ld, expected %ld\",\n\t\t\t\t prev,\n\t\t\t\t TapeBlockGetTrailer(lt->buffer)->next,\n\t\t\t\t lt->curBlockNumber);\n\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->curBlockNumber = prev;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\n\t\tseekpos += TapeBlockPayloadSize;\n\t}\n\n\t/*\n\t * 'seekpos' can now be greater than 'size', because it points to the\n\t * beginning the target block.  The difference is the position within the\n\t * page.\n\t */\n\tlt->pos = seekpos - size;\n\treturn size;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
    ],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"broken tape, next of block %ld is %ld, expected %ld\"",
            "prev",
            "TapeBlockGetTrailer(lt->buffer)->next",
            "lt->curBlockNumber"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsReadBlock",
          "args": [
            "lts",
            "prev",
            "(void *) lt->buffer"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "269-278",
          "snippet": "static void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->buffer_size == BLCKSZ"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->frozen"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nsize_t\nLogicalTapeBackspace(LogicalTapeSet *lts, int tapenum, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tseekpos = 0;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t/*\n\t * Easy case for seek within current block.\n\t */\n\tif (size <= (size_t) lt->pos)\n\t{\n\t\tlt->pos -= (int) size;\n\t\treturn size;\n\t}\n\n\t/*\n\t * Not-so-easy case, have to walk back the chain of blocks.  This\n\t * implementation would be pretty inefficient for long seeks, but we\n\t * really aren't doing that (a seek over one tuple is typical).\n\t */\n\tseekpos = (size_t) lt->pos; /* part within this block */\n\twhile (size > seekpos)\n\t{\n\t\tlong\t\tprev = TapeBlockGetTrailer(lt->buffer)->prev;\n\n\t\tif (prev == -1L)\n\t\t{\n\t\t\t/* Tried to back up beyond the beginning of tape. */\n\t\t\tif (lt->curBlockNumber != lt->firstBlockNumber)\n\t\t\t\telog(ERROR, \"unexpected end of tape\");\n\t\t\tlt->pos = 0;\n\t\t\treturn seekpos;\n\t\t}\n\n\t\tltsReadBlock(lts, prev, (void *) lt->buffer);\n\n\t\tif (TapeBlockGetTrailer(lt->buffer)->next != lt->curBlockNumber)\n\t\t\telog(ERROR, \"broken tape, next of block %ld is %ld, expected %ld\",\n\t\t\t\t prev,\n\t\t\t\t TapeBlockGetTrailer(lt->buffer)->next,\n\t\t\t\t lt->curBlockNumber);\n\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->curBlockNumber = prev;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\n\t\tseekpos += TapeBlockPayloadSize;\n\t}\n\n\t/*\n\t * 'seekpos' can now be greater than 'size', because it points to the\n\t * beginning the target block.  The difference is the position within the\n\t * page.\n\t */\n\tlt->pos = seekpos - size;\n\treturn size;\n}"
  },
  {
    "function_name": "LogicalTapeFreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "875-944",
    "snippet": "void\nLogicalTapeFreeze(LogicalTapeSet *lts, int tapenum, TapeShare *share)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/*\n\t * Completion of a write phase.  Flush last partial data block, and rewind\n\t * for nondestructive read.\n\t */\n\tif (lt->dirty)\n\t{\n\t\t/*\n\t\t * As long as we've filled the buffer at least once, its contents are\n\t\t * entirely defined from valgrind's point of view, even though\n\t\t * contents beyond the current end point may be stale.  But it's\n\t\t * possible - at least in the case of a parallel sort - to sort such\n\t\t * small amount of data that we do not fill the buffer even once. Tell\n\t\t * valgrind that its contents are defined, so it doesn't bleat.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\tlt->writing = false;\n\t}\n\tlt->writing = false;\n\tlt->frozen = true;\n\n\t/*\n\t * The seek and backspace functions assume a single block read buffer.\n\t * That's OK with current usage.  A larger buffer is helpful to make the\n\t * read pattern of the backing file look more sequential to the OS, when\n\t * we're reading from multiple tapes.  But at the end of a sort, when a\n\t * tape is frozen, we only read from a single tape anyway.\n\t */\n\tif (!lt->buffer || lt->buffer_size != BLCKSZ)\n\t{\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t\tlt->buffer = palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->curBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tif (lt->firstBlockNumber == -1L)\n\t\tlt->nextBlockNumber = -1L;\n\tltsReadBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\tif (TapeBlockIsLast(lt->buffer))\n\t\tlt->nextBlockNumber = -1L;\n\telse\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\tlt->nbytes = TapeBlockGetNBytes(lt->buffer);\n\n\t/* Handle extra steps when caller is to share its tapeset */\n\tif (share)\n\t{\n\t\tBufFileExportShared(lts->pfile);\n\t\tshare->firstblocknumber = lt->firstBlockNumber;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BufFileExportShared",
          "args": [
            "lts->pfile"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockGetNBytes",
          "args": [
            "lt->buffer"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockIsLast",
          "args": [
            "lt->buffer"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsReadBlock",
          "args": [
            "lts",
            "lt->curBlockNumber",
            "(void *) lt->buffer"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "269-278",
          "snippet": "static void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "BLCKSZ"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "lt->buffer"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltsWriteBlock",
          "args": [
            "lts",
            "lt->curBlockNumber",
            "(void *) lt->buffer"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ltsWriteBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "221-261",
          "snippet": "static void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TapeBlockSetNBytes",
          "args": [
            "lt->buffer",
            "lt->nbytes"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "lt->buffer + lt->nbytes",
            "lt->buffer_size - lt->nbytes"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->offsetBlockNumber == 0L"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->writing"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeFreeze(LogicalTapeSet *lts, int tapenum, TapeShare *share)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/*\n\t * Completion of a write phase.  Flush last partial data block, and rewind\n\t * for nondestructive read.\n\t */\n\tif (lt->dirty)\n\t{\n\t\t/*\n\t\t * As long as we've filled the buffer at least once, its contents are\n\t\t * entirely defined from valgrind's point of view, even though\n\t\t * contents beyond the current end point may be stale.  But it's\n\t\t * possible - at least in the case of a parallel sort - to sort such\n\t\t * small amount of data that we do not fill the buffer even once. Tell\n\t\t * valgrind that its contents are defined, so it doesn't bleat.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\tlt->writing = false;\n\t}\n\tlt->writing = false;\n\tlt->frozen = true;\n\n\t/*\n\t * The seek and backspace functions assume a single block read buffer.\n\t * That's OK with current usage.  A larger buffer is helpful to make the\n\t * read pattern of the backing file look more sequential to the OS, when\n\t * we're reading from multiple tapes.  But at the end of a sort, when a\n\t * tape is frozen, we only read from a single tape anyway.\n\t */\n\tif (!lt->buffer || lt->buffer_size != BLCKSZ)\n\t{\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t\tlt->buffer = palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->curBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tif (lt->firstBlockNumber == -1L)\n\t\tlt->nextBlockNumber = -1L;\n\tltsReadBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\tif (TapeBlockIsLast(lt->buffer))\n\t\tlt->nextBlockNumber = -1L;\n\telse\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\tlt->nbytes = TapeBlockGetNBytes(lt->buffer);\n\n\t/* Handle extra steps when caller is to share its tapeset */\n\tif (share)\n\t{\n\t\tBufFileExportShared(lts->pfile);\n\t\tshare->firstblocknumber = lt->firstBlockNumber;\n\t}\n}"
  },
  {
    "function_name": "LogicalTapeRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "821-856",
    "snippet": "size_t\nLogicalTapeRead(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tvoid *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnread = 0;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(!lt->writing);\n\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= lt->nbytes)\n\t\t{\n\t\t\t/* Try to load more data into buffer. */\n\t\t\tif (!ltsReadFillBuffer(lts, lt))\n\t\t\t\tbreak;\t\t\t/* EOF */\n\t\t}\n\n\t\tnthistime = lt->nbytes - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(ptr, lt->buffer + lt->pos, nthistime);\n\n\t\tlt->pos += nthistime;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t\tnread += nthistime;\n\t}\n\n\treturn nread;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "lt->buffer + lt->pos",
            "nthistime"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nthistime > 0"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsReadFillBuffer",
          "args": [
            "lts",
            "lt"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReadFillBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "285-322",
          "snippet": "static bool\nltsReadFillBuffer(LogicalTapeSet *lts, LogicalTape *lt)\n{\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tdo\n\t{\n\t\tchar\t   *thisbuf = lt->buffer + lt->nbytes;\n\t\tlong\t\tdatablocknum = lt->nextBlockNumber;\n\n\t\t/* Fetch next block number */\n\t\tif (datablocknum == -1L)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\t\t/* Apply worker offset, needed for leader tapesets */\n\t\tdatablocknum += lt->offsetBlockNumber;\n\n\t\t/* Read the block */\n\t\tltsReadBlock(lts, datablocknum, (void *) thisbuf);\n\t\tif (!lt->frozen)\n\t\t\tltsReleaseBlock(lts, datablocknum);\n\t\tlt->curBlockNumber = lt->nextBlockNumber;\n\n\t\tlt->nbytes += TapeBlockGetNBytes(thisbuf);\n\t\tif (TapeBlockIsLast(thisbuf))\n\t\t{\n\t\t\tlt->nextBlockNumber = -1L;\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlt->nextBlockNumber = TapeBlockGetTrailer(thisbuf)->next;\n\n\t\t/* Advance to next block, if we have buffer space left */\n\t} while (lt->buffer_size - lt->nbytes > BLCKSZ);\n\n\treturn (lt->nbytes > 0);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nstatic bool\nltsReadFillBuffer(LogicalTapeSet *lts, LogicalTape *lt)\n{\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tdo\n\t{\n\t\tchar\t   *thisbuf = lt->buffer + lt->nbytes;\n\t\tlong\t\tdatablocknum = lt->nextBlockNumber;\n\n\t\t/* Fetch next block number */\n\t\tif (datablocknum == -1L)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\t\t/* Apply worker offset, needed for leader tapesets */\n\t\tdatablocknum += lt->offsetBlockNumber;\n\n\t\t/* Read the block */\n\t\tltsReadBlock(lts, datablocknum, (void *) thisbuf);\n\t\tif (!lt->frozen)\n\t\t\tltsReleaseBlock(lts, datablocknum);\n\t\tlt->curBlockNumber = lt->nextBlockNumber;\n\n\t\tlt->nbytes += TapeBlockGetNBytes(thisbuf);\n\t\tif (TapeBlockIsLast(thisbuf))\n\t\t{\n\t\t\tlt->nextBlockNumber = -1L;\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlt->nextBlockNumber = TapeBlockGetTrailer(thisbuf)->next;\n\n\t\t/* Advance to next block, if we have buffer space left */\n\t} while (lt->buffer_size - lt->nbytes > BLCKSZ);\n\n\treturn (lt->nbytes > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!lt->writing"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nsize_t\nLogicalTapeRead(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tvoid *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnread = 0;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(!lt->writing);\n\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= lt->nbytes)\n\t\t{\n\t\t\t/* Try to load more data into buffer. */\n\t\t\tif (!ltsReadFillBuffer(lts, lt))\n\t\t\t\tbreak;\t\t\t/* EOF */\n\t\t}\n\n\t\tnthistime = lt->nbytes - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(ptr, lt->buffer + lt->pos, nthistime);\n\n\t\tlt->pos += nthistime;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t\tnread += nthistime;\n\t}\n\n\treturn nread;\n}"
  },
  {
    "function_name": "LogicalTapeRewindForWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "795-814",
    "snippet": "void\nLogicalTapeRewindForWrite(LogicalTapeSet *lts, int tapenum)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\tAssert(!lt->writing && !lt->frozen);\n\tlt->writing = true;\n\tlt->dirty = false;\n\tlt->firstBlockNumber = -1L;\n\tlt->curBlockNumber = -1L;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "lt->buffer"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!lt->writing && !lt->frozen"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeRewindForWrite(LogicalTapeSet *lts, int tapenum)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\tAssert(!lt->writing && !lt->frozen);\n\tlt->writing = true;\n\tlt->dirty = false;\n\tlt->firstBlockNumber = -1L;\n\tlt->curBlockNumber = -1L;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n}"
  },
  {
    "function_name": "LogicalTapeRewindForRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "708-785",
    "snippet": "void\nLogicalTapeRewindForRead(LogicalTapeSet *lts, int tapenum, size_t buffer_size)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\t/*\n\t * Round and cap buffer_size if needed.\n\t */\n\tif (lt->frozen)\n\t\tbuffer_size = BLCKSZ;\n\telse\n\t{\n\t\t/* need at least one block */\n\t\tif (buffer_size < BLCKSZ)\n\t\t\tbuffer_size = BLCKSZ;\n\n\t\t/* palloc() larger than max_size is unlikely to be helpful */\n\t\tif (buffer_size > lt->max_size)\n\t\t\tbuffer_size = lt->max_size;\n\n\t\t/* round down to BLCKSZ boundary */\n\t\tbuffer_size -= buffer_size % BLCKSZ;\n\t}\n\n\tif (lt->writing)\n\t{\n\t\t/*\n\t\t * Completion of a write phase.  Flush last partial data block, and\n\t\t * rewind for normal (destructive) read.\n\t\t */\n\t\tif (lt->dirty)\n\t\t{\n\t\t\t/*\n\t\t\t * As long as we've filled the buffer at least once, its contents\n\t\t\t * are entirely defined from valgrind's point of view, even though\n\t\t\t * contents beyond the current end point may be stale.  But it's\n\t\t\t * possible - at least in the case of a parallel sort - to sort\n\t\t\t * such small amount of data that we do not fill the buffer even\n\t\t\t * once.  Tell valgrind that its contents are defined, so it\n\t\t\t * doesn't bleat.\n\t\t\t */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\t}\n\t\tlt->writing = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is only OK if tape is frozen; we rewind for (another) read\n\t\t * pass.\n\t\t */\n\t\tAssert(lt->frozen);\n\t}\n\n\t/* Allocate a read buffer (unless the tape is empty) */\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n\tif (lt->firstBlockNumber != -1L)\n\t{\n\t\tlt->buffer = palloc(buffer_size);\n\t\tlt->buffer_size = buffer_size;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->nextBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tltsReadFillBuffer(lts, lt);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ltsReadFillBuffer",
          "args": [
            "lts",
            "lt"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReadFillBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "285-322",
          "snippet": "static bool\nltsReadFillBuffer(LogicalTapeSet *lts, LogicalTape *lt)\n{\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tdo\n\t{\n\t\tchar\t   *thisbuf = lt->buffer + lt->nbytes;\n\t\tlong\t\tdatablocknum = lt->nextBlockNumber;\n\n\t\t/* Fetch next block number */\n\t\tif (datablocknum == -1L)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\t\t/* Apply worker offset, needed for leader tapesets */\n\t\tdatablocknum += lt->offsetBlockNumber;\n\n\t\t/* Read the block */\n\t\tltsReadBlock(lts, datablocknum, (void *) thisbuf);\n\t\tif (!lt->frozen)\n\t\t\tltsReleaseBlock(lts, datablocknum);\n\t\tlt->curBlockNumber = lt->nextBlockNumber;\n\n\t\tlt->nbytes += TapeBlockGetNBytes(thisbuf);\n\t\tif (TapeBlockIsLast(thisbuf))\n\t\t{\n\t\t\tlt->nextBlockNumber = -1L;\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlt->nextBlockNumber = TapeBlockGetTrailer(thisbuf)->next;\n\n\t\t/* Advance to next block, if we have buffer space left */\n\t} while (lt->buffer_size - lt->nbytes > BLCKSZ);\n\n\treturn (lt->nbytes > 0);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nstatic bool\nltsReadFillBuffer(LogicalTapeSet *lts, LogicalTape *lt)\n{\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tdo\n\t{\n\t\tchar\t   *thisbuf = lt->buffer + lt->nbytes;\n\t\tlong\t\tdatablocknum = lt->nextBlockNumber;\n\n\t\t/* Fetch next block number */\n\t\tif (datablocknum == -1L)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\t\t/* Apply worker offset, needed for leader tapesets */\n\t\tdatablocknum += lt->offsetBlockNumber;\n\n\t\t/* Read the block */\n\t\tltsReadBlock(lts, datablocknum, (void *) thisbuf);\n\t\tif (!lt->frozen)\n\t\t\tltsReleaseBlock(lts, datablocknum);\n\t\tlt->curBlockNumber = lt->nextBlockNumber;\n\n\t\tlt->nbytes += TapeBlockGetNBytes(thisbuf);\n\t\tif (TapeBlockIsLast(thisbuf))\n\t\t{\n\t\t\tlt->nextBlockNumber = -1L;\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlt->nextBlockNumber = TapeBlockGetTrailer(thisbuf)->next;\n\n\t\t/* Advance to next block, if we have buffer space left */\n\t} while (lt->buffer_size - lt->nbytes > BLCKSZ);\n\n\treturn (lt->nbytes > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "buffer_size"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "lt->buffer"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->frozen"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsWriteBlock",
          "args": [
            "lts",
            "lt->curBlockNumber",
            "(void *) lt->buffer"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "ltsWriteBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "221-261",
          "snippet": "static void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TapeBlockSetNBytes",
          "args": [
            "lt->buffer",
            "lt->nbytes"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "lt->buffer + lt->nbytes",
            "lt->buffer_size - lt->nbytes"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeRewindForRead(LogicalTapeSet *lts, int tapenum, size_t buffer_size)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\t/*\n\t * Round and cap buffer_size if needed.\n\t */\n\tif (lt->frozen)\n\t\tbuffer_size = BLCKSZ;\n\telse\n\t{\n\t\t/* need at least one block */\n\t\tif (buffer_size < BLCKSZ)\n\t\t\tbuffer_size = BLCKSZ;\n\n\t\t/* palloc() larger than max_size is unlikely to be helpful */\n\t\tif (buffer_size > lt->max_size)\n\t\t\tbuffer_size = lt->max_size;\n\n\t\t/* round down to BLCKSZ boundary */\n\t\tbuffer_size -= buffer_size % BLCKSZ;\n\t}\n\n\tif (lt->writing)\n\t{\n\t\t/*\n\t\t * Completion of a write phase.  Flush last partial data block, and\n\t\t * rewind for normal (destructive) read.\n\t\t */\n\t\tif (lt->dirty)\n\t\t{\n\t\t\t/*\n\t\t\t * As long as we've filled the buffer at least once, its contents\n\t\t\t * are entirely defined from valgrind's point of view, even though\n\t\t\t * contents beyond the current end point may be stale.  But it's\n\t\t\t * possible - at least in the case of a parallel sort - to sort\n\t\t\t * such small amount of data that we do not fill the buffer even\n\t\t\t * once.  Tell valgrind that its contents are defined, so it\n\t\t\t * doesn't bleat.\n\t\t\t */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\t}\n\t\tlt->writing = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is only OK if tape is frozen; we rewind for (another) read\n\t\t * pass.\n\t\t */\n\t\tAssert(lt->frozen);\n\t}\n\n\t/* Allocate a read buffer (unless the tape is empty) */\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n\tif (lt->firstBlockNumber != -1L)\n\t{\n\t\tlt->buffer = palloc(buffer_size);\n\t\tlt->buffer_size = buffer_size;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->nextBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tltsReadFillBuffer(lts, lt);\n}"
  },
  {
    "function_name": "LogicalTapeWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "620-694",
    "snippet": "void\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
    ],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lt->buffer + lt->pos",
            "ptr",
            "nthistime"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nthistime > 0"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsWriteBlock",
          "args": [
            "lts",
            "lt->curBlockNumber",
            "(void *) lt->buffer"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ltsWriteBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "221-261",
          "snippet": "static void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsGetFreeBlock",
          "args": [
            "lts"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ltsGetFreeBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "344-364",
          "snippet": "static long\nltsGetFreeBlock(LogicalTapeSet *lts)\n{\n\t/*\n\t * If there are multiple free blocks, we select the one appearing last in\n\t * freeBlocks[] (after sorting the array if needed).  If there are none,\n\t * assign the next block at the end of the file.\n\t */\n\tif (lts->nFreeBlocks > 0)\n\t{\n\t\tif (!lts->blocksSorted)\n\t\t{\n\t\t\tqsort((void *) lts->freeBlocks, lts->nFreeBlocks,\n\t\t\t\t  sizeof(long), freeBlocks_cmp);\n\t\t\tlts->blocksSorted = true;\n\t\t}\n\t\treturn lts->freeBlocks[--lts->nFreeBlocks];\n\t}\n\telse\n\t\treturn lts->nBlocksAllocated++;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nstatic long\nltsGetFreeBlock(LogicalTapeSet *lts)\n{\n\t/*\n\t * If there are multiple free blocks, we select the one appearing last in\n\t * freeBlocks[] (after sorting the array if needed).  If there are none,\n\t * assign the next block at the end of the file.\n\t */\n\tif (lts->nFreeBlocks > 0)\n\t{\n\t\tif (!lts->blocksSorted)\n\t\t{\n\t\t\tqsort((void *) lts->freeBlocks, lts->nFreeBlocks,\n\t\t\t\t  sizeof(long), freeBlocks_cmp);\n\t\t\tlts->blocksSorted = true;\n\t\t}\n\t\treturn lts->freeBlocks[--lts->nFreeBlocks];\n\t}\n\telse\n\t\treturn lts->nBlocksAllocated++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid logtape state: should be dirty\""
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->buffer_size == BLCKSZ"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "lt->buffer"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->pos == 0"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->firstBlockNumber == -1"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "BLCKSZ"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->offsetBlockNumber == 0L"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lt->writing"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tapenum >= 0 && tapenum < lts->nTapes"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}"
  },
  {
    "function_name": "LogicalTapeSetForgetFreeSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "609-613",
    "snippet": "void\nLogicalTapeSetForgetFreeSpace(LogicalTapeSet *lts)\n{\n\tlts->forgetFreeSpace = true;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeSetForgetFreeSpace(LogicalTapeSet *lts)\n{\n\tlts->forgetFreeSpace = true;\n}"
  },
  {
    "function_name": "LogicalTapeSetClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "583-598",
    "snippet": "void\nLogicalTapeSetClose(LogicalTapeSet *lts)\n{\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\tBufFileClose(lts->pfile);\n\tfor (i = 0; i < lts->nTapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t}\n\tpfree(lts->freeBlocks);\n\tpfree(lts);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "lts"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileClose",
          "args": [
            "lts->pfile"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeSetClose(LogicalTapeSet *lts)\n{\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\tBufFileClose(lts->pfile);\n\tfor (i = 0; i < lts->nTapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t}\n\tpfree(lts->freeBlocks);\n\tpfree(lts);\n}"
  },
  {
    "function_name": "LogicalTapeSetCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "509-578",
    "snippet": "LogicalTapeSet *\nLogicalTapeSetCreate(int ntapes, TapeShare *shared, SharedFileSet *fileset,\n\t\t\t\t\t int worker)\n{\n\tLogicalTapeSet *lts;\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\t/*\n\t * Create top-level struct including per-tape LogicalTape structs.\n\t */\n\tAssert(ntapes > 0);\n\tlts = (LogicalTapeSet *) palloc(offsetof(LogicalTapeSet, tapes) +\n\t\t\t\t\t\t\t\t\tntapes * sizeof(LogicalTape));\n\tlts->nBlocksAllocated = 0L;\n\tlts->nBlocksWritten = 0L;\n\tlts->nHoleBlocks = 0L;\n\tlts->forgetFreeSpace = false;\n\tlts->blocksSorted = true;\t/* a zero-length array is sorted ... */\n\tlts->freeBlocksLen = 32;\t/* reasonable initial guess */\n\tlts->freeBlocks = (long *) palloc(lts->freeBlocksLen * sizeof(long));\n\tlts->nFreeBlocks = 0;\n\tlts->nTapes = ntapes;\n\n\t/*\n\t * Initialize per-tape structs.  Note we allocate the I/O buffer and the\n\t * first block for a tape only when it is first actually written to.  This\n\t * avoids wasting memory space when tuplesort.c overestimates the number\n\t * of tapes needed.\n\t */\n\tfor (i = 0; i < ntapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tlt->writing = true;\n\t\tlt->frozen = false;\n\t\tlt->dirty = false;\n\t\tlt->firstBlockNumber = -1L;\n\t\tlt->curBlockNumber = -1L;\n\t\tlt->nextBlockNumber = -1L;\n\t\tlt->offsetBlockNumber = 0L;\n\t\tlt->buffer = NULL;\n\t\tlt->buffer_size = 0;\n\t\t/* palloc() larger than MaxAllocSize would fail */\n\t\tlt->max_size = MaxAllocSize;\n\t\tlt->pos = 0;\n\t\tlt->nbytes = 0;\n\t}\n\n\t/*\n\t * Create temp BufFile storage as required.\n\t *\n\t * Leader concatenates worker tapes, which requires special adjustment to\n\t * final tapeset data.  Things are simpler for the worker case and the\n\t * serial case, though.  They are generally very similar -- workers use a\n\t * shared fileset, whereas serial sorts use a conventional serial BufFile.\n\t */\n\tif (shared)\n\t\tltsConcatWorkerTapes(lts, shared, fileset);\n\telse if (fileset)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\tpg_itoa(worker, filename);\n\t\tlts->pfile = BufFileCreateShared(fileset, filename);\n\t}\n\telse\n\t\tlts->pfile = BufFileCreateTemp(false);\n\n\treturn lts;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BufFileCreateTemp",
          "args": [
            "false"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileCreateShared",
          "args": [
            "fileset",
            "filename"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_itoa",
          "args": [
            "worker",
            "filename"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "pg_itoa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "119-123",
          "snippet": "void\npg_itoa(int16 i, char *a)\n{\n\tpg_ltoa((int32) i, a);\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\npg_itoa(int16 i, char *a)\n{\n\tpg_ltoa((int32) i, a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltsConcatWorkerTapes",
          "args": [
            "lts",
            "shared",
            "fileset"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ltsConcatWorkerTapes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "408-487",
          "snippet": "static void\nltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset)\n{\n\tLogicalTape *lt = NULL;\n\tlong\t\ttapeblocks = 0L;\n\tlong\t\tnphysicalblocks = 0L;\n\tint\t\t\ti;\n\n\t/* Should have at least one worker tape, plus leader's tape */\n\tAssert(lts->nTapes >= 2);\n\n\t/*\n\t * Build concatenated view of all BufFiles, remembering the block number\n\t * where each source file begins.  No changes are needed for leader/last\n\t * tape.\n\t */\n\tfor (i = 0; i < lts->nTapes - 1; i++)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\t\tBufFile    *file;\n\t\tint64\t\tfilesize;\n\n\t\tlt = &lts->tapes[i];\n\n\t\tpg_itoa(i, filename);\n\t\tfile = BufFileOpenShared(fileset, filename);\n\t\tfilesize = BufFileSize(file);\n\n\t\t/*\n\t\t * Stash first BufFile, and concatenate subsequent BufFiles to that.\n\t\t * Store block offset into each tape as we go.\n\t\t */\n\t\tlt->firstBlockNumber = shared[i].firstblocknumber;\n\t\tif (i == 0)\n\t\t{\n\t\t\tlts->pfile = file;\n\t\t\tlt->offsetBlockNumber = 0L;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlt->offsetBlockNumber = BufFileAppend(lts->pfile, file);\n\t\t}\n\t\t/* Don't allocate more for read buffer than could possibly help */\n\t\tlt->max_size = Min(MaxAllocSize, filesize);\n\t\ttapeblocks = filesize / BLCKSZ;\n\t\tnphysicalblocks += tapeblocks;\n\t}\n\n\t/*\n\t * Set # of allocated blocks, as well as # blocks written.  Use extent of\n\t * new BufFile space (from 0 to end of last worker's tape space) for this.\n\t * Allocated/written blocks should include space used by holes left\n\t * between concatenated BufFiles.\n\t */\n\tlts->nBlocksAllocated = lt->offsetBlockNumber + tapeblocks;\n\tlts->nBlocksWritten = lts->nBlocksAllocated;\n\n\t/*\n\t * Compute number of hole blocks so that we can later work backwards, and\n\t * instrument number of physical blocks.  We don't simply use physical\n\t * blocks directly for instrumentation because this would break if we ever\n\t * subsequently wrote to the leader tape.\n\t *\n\t * Working backwards like this keeps our options open.  If shared BufFiles\n\t * ever support being written to post-export, logtape.c can automatically\n\t * take advantage of that.  We'd then support writing to the leader tape\n\t * while recycling space from worker tapes, because the leader tape has a\n\t * zero offset (write routines won't need to have extra logic to apply an\n\t * offset).\n\t *\n\t * The only thing that currently prevents writing to the leader tape from\n\t * working is the fact that BufFiles opened using BufFileOpenShared() are\n\t * read-only by definition, but that could be changed if it seemed\n\t * worthwhile.  For now, writing to the leader tape will raise a \"Bad file\n\t * descriptor\" error, so tuplesort must avoid writing to the leader tape\n\t * altogether.\n\t */\n\tlts->nHoleBlocks = lts->nBlocksAllocated - nphysicalblocks;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);\n\nstatic void\nltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset)\n{\n\tLogicalTape *lt = NULL;\n\tlong\t\ttapeblocks = 0L;\n\tlong\t\tnphysicalblocks = 0L;\n\tint\t\t\ti;\n\n\t/* Should have at least one worker tape, plus leader's tape */\n\tAssert(lts->nTapes >= 2);\n\n\t/*\n\t * Build concatenated view of all BufFiles, remembering the block number\n\t * where each source file begins.  No changes are needed for leader/last\n\t * tape.\n\t */\n\tfor (i = 0; i < lts->nTapes - 1; i++)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\t\tBufFile    *file;\n\t\tint64\t\tfilesize;\n\n\t\tlt = &lts->tapes[i];\n\n\t\tpg_itoa(i, filename);\n\t\tfile = BufFileOpenShared(fileset, filename);\n\t\tfilesize = BufFileSize(file);\n\n\t\t/*\n\t\t * Stash first BufFile, and concatenate subsequent BufFiles to that.\n\t\t * Store block offset into each tape as we go.\n\t\t */\n\t\tlt->firstBlockNumber = shared[i].firstblocknumber;\n\t\tif (i == 0)\n\t\t{\n\t\t\tlts->pfile = file;\n\t\t\tlt->offsetBlockNumber = 0L;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlt->offsetBlockNumber = BufFileAppend(lts->pfile, file);\n\t\t}\n\t\t/* Don't allocate more for read buffer than could possibly help */\n\t\tlt->max_size = Min(MaxAllocSize, filesize);\n\t\ttapeblocks = filesize / BLCKSZ;\n\t\tnphysicalblocks += tapeblocks;\n\t}\n\n\t/*\n\t * Set # of allocated blocks, as well as # blocks written.  Use extent of\n\t * new BufFile space (from 0 to end of last worker's tape space) for this.\n\t * Allocated/written blocks should include space used by holes left\n\t * between concatenated BufFiles.\n\t */\n\tlts->nBlocksAllocated = lt->offsetBlockNumber + tapeblocks;\n\tlts->nBlocksWritten = lts->nBlocksAllocated;\n\n\t/*\n\t * Compute number of hole blocks so that we can later work backwards, and\n\t * instrument number of physical blocks.  We don't simply use physical\n\t * blocks directly for instrumentation because this would break if we ever\n\t * subsequently wrote to the leader tape.\n\t *\n\t * Working backwards like this keeps our options open.  If shared BufFiles\n\t * ever support being written to post-export, logtape.c can automatically\n\t * take advantage of that.  We'd then support writing to the leader tape\n\t * while recycling space from worker tapes, because the leader tape has a\n\t * zero offset (write routines won't need to have extra logic to apply an\n\t * offset).\n\t *\n\t * The only thing that currently prevents writing to the leader tape from\n\t * working is the fact that BufFiles opened using BufFileOpenShared() are\n\t * read-only by definition, but that could be changed if it seemed\n\t * worthwhile.  For now, writing to the leader tape will raise a \"Bad file\n\t * descriptor\" error, so tuplesort must avoid writing to the leader tape\n\t * altogether.\n\t */\n\tlts->nHoleBlocks = lts->nBlocksAllocated - nphysicalblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "lts->freeBlocksLen * sizeof(long)"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ntapes > 0"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);\n\nLogicalTapeSet *\nLogicalTapeSetCreate(int ntapes, TapeShare *shared, SharedFileSet *fileset,\n\t\t\t\t\t int worker)\n{\n\tLogicalTapeSet *lts;\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\t/*\n\t * Create top-level struct including per-tape LogicalTape structs.\n\t */\n\tAssert(ntapes > 0);\n\tlts = (LogicalTapeSet *) palloc(offsetof(LogicalTapeSet, tapes) +\n\t\t\t\t\t\t\t\t\tntapes * sizeof(LogicalTape));\n\tlts->nBlocksAllocated = 0L;\n\tlts->nBlocksWritten = 0L;\n\tlts->nHoleBlocks = 0L;\n\tlts->forgetFreeSpace = false;\n\tlts->blocksSorted = true;\t/* a zero-length array is sorted ... */\n\tlts->freeBlocksLen = 32;\t/* reasonable initial guess */\n\tlts->freeBlocks = (long *) palloc(lts->freeBlocksLen * sizeof(long));\n\tlts->nFreeBlocks = 0;\n\tlts->nTapes = ntapes;\n\n\t/*\n\t * Initialize per-tape structs.  Note we allocate the I/O buffer and the\n\t * first block for a tape only when it is first actually written to.  This\n\t * avoids wasting memory space when tuplesort.c overestimates the number\n\t * of tapes needed.\n\t */\n\tfor (i = 0; i < ntapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tlt->writing = true;\n\t\tlt->frozen = false;\n\t\tlt->dirty = false;\n\t\tlt->firstBlockNumber = -1L;\n\t\tlt->curBlockNumber = -1L;\n\t\tlt->nextBlockNumber = -1L;\n\t\tlt->offsetBlockNumber = 0L;\n\t\tlt->buffer = NULL;\n\t\tlt->buffer_size = 0;\n\t\t/* palloc() larger than MaxAllocSize would fail */\n\t\tlt->max_size = MaxAllocSize;\n\t\tlt->pos = 0;\n\t\tlt->nbytes = 0;\n\t}\n\n\t/*\n\t * Create temp BufFile storage as required.\n\t *\n\t * Leader concatenates worker tapes, which requires special adjustment to\n\t * final tapeset data.  Things are simpler for the worker case and the\n\t * serial case, though.  They are generally very similar -- workers use a\n\t * shared fileset, whereas serial sorts use a conventional serial BufFile.\n\t */\n\tif (shared)\n\t\tltsConcatWorkerTapes(lts, shared, fileset);\n\telse if (fileset)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\tpg_itoa(worker, filename);\n\t\tlts->pfile = BufFileCreateShared(fileset, filename);\n\t}\n\telse\n\t\tlts->pfile = BufFileCreateTemp(false);\n\n\treturn lts;\n}"
  },
  {
    "function_name": "ltsConcatWorkerTapes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "408-487",
    "snippet": "static void\nltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset)\n{\n\tLogicalTape *lt = NULL;\n\tlong\t\ttapeblocks = 0L;\n\tlong\t\tnphysicalblocks = 0L;\n\tint\t\t\ti;\n\n\t/* Should have at least one worker tape, plus leader's tape */\n\tAssert(lts->nTapes >= 2);\n\n\t/*\n\t * Build concatenated view of all BufFiles, remembering the block number\n\t * where each source file begins.  No changes are needed for leader/last\n\t * tape.\n\t */\n\tfor (i = 0; i < lts->nTapes - 1; i++)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\t\tBufFile    *file;\n\t\tint64\t\tfilesize;\n\n\t\tlt = &lts->tapes[i];\n\n\t\tpg_itoa(i, filename);\n\t\tfile = BufFileOpenShared(fileset, filename);\n\t\tfilesize = BufFileSize(file);\n\n\t\t/*\n\t\t * Stash first BufFile, and concatenate subsequent BufFiles to that.\n\t\t * Store block offset into each tape as we go.\n\t\t */\n\t\tlt->firstBlockNumber = shared[i].firstblocknumber;\n\t\tif (i == 0)\n\t\t{\n\t\t\tlts->pfile = file;\n\t\t\tlt->offsetBlockNumber = 0L;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlt->offsetBlockNumber = BufFileAppend(lts->pfile, file);\n\t\t}\n\t\t/* Don't allocate more for read buffer than could possibly help */\n\t\tlt->max_size = Min(MaxAllocSize, filesize);\n\t\ttapeblocks = filesize / BLCKSZ;\n\t\tnphysicalblocks += tapeblocks;\n\t}\n\n\t/*\n\t * Set # of allocated blocks, as well as # blocks written.  Use extent of\n\t * new BufFile space (from 0 to end of last worker's tape space) for this.\n\t * Allocated/written blocks should include space used by holes left\n\t * between concatenated BufFiles.\n\t */\n\tlts->nBlocksAllocated = lt->offsetBlockNumber + tapeblocks;\n\tlts->nBlocksWritten = lts->nBlocksAllocated;\n\n\t/*\n\t * Compute number of hole blocks so that we can later work backwards, and\n\t * instrument number of physical blocks.  We don't simply use physical\n\t * blocks directly for instrumentation because this would break if we ever\n\t * subsequently wrote to the leader tape.\n\t *\n\t * Working backwards like this keeps our options open.  If shared BufFiles\n\t * ever support being written to post-export, logtape.c can automatically\n\t * take advantage of that.  We'd then support writing to the leader tape\n\t * while recycling space from worker tapes, because the leader tape has a\n\t * zero offset (write routines won't need to have extra logic to apply an\n\t * offset).\n\t *\n\t * The only thing that currently prevents writing to the leader tape from\n\t * working is the fact that BufFiles opened using BufFileOpenShared() are\n\t * read-only by definition, but that could be changed if it seemed\n\t * worthwhile.  For now, writing to the leader tape will raise a \"Bad file\n\t * descriptor\" error, so tuplesort must avoid writing to the leader tape\n\t * altogether.\n\t */\n\tlts->nHoleBlocks = lts->nBlocksAllocated - nphysicalblocks;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "MaxAllocSize",
            "filesize"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileAppend",
          "args": [
            "lts->pfile",
            "file"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSize",
          "args": [
            "file"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileOpenShared",
          "args": [
            "fileset",
            "filename"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_itoa",
          "args": [
            "i",
            "filename"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "pg_itoa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "119-123",
          "snippet": "void\npg_itoa(int16 i, char *a)\n{\n\tpg_ltoa((int32) i, a);\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\npg_itoa(int16 i, char *a)\n{\n\tpg_ltoa((int32) i, a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lts->nTapes >= 2"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);\n\nstatic void\nltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset)\n{\n\tLogicalTape *lt = NULL;\n\tlong\t\ttapeblocks = 0L;\n\tlong\t\tnphysicalblocks = 0L;\n\tint\t\t\ti;\n\n\t/* Should have at least one worker tape, plus leader's tape */\n\tAssert(lts->nTapes >= 2);\n\n\t/*\n\t * Build concatenated view of all BufFiles, remembering the block number\n\t * where each source file begins.  No changes are needed for leader/last\n\t * tape.\n\t */\n\tfor (i = 0; i < lts->nTapes - 1; i++)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\t\tBufFile    *file;\n\t\tint64\t\tfilesize;\n\n\t\tlt = &lts->tapes[i];\n\n\t\tpg_itoa(i, filename);\n\t\tfile = BufFileOpenShared(fileset, filename);\n\t\tfilesize = BufFileSize(file);\n\n\t\t/*\n\t\t * Stash first BufFile, and concatenate subsequent BufFiles to that.\n\t\t * Store block offset into each tape as we go.\n\t\t */\n\t\tlt->firstBlockNumber = shared[i].firstblocknumber;\n\t\tif (i == 0)\n\t\t{\n\t\t\tlts->pfile = file;\n\t\t\tlt->offsetBlockNumber = 0L;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlt->offsetBlockNumber = BufFileAppend(lts->pfile, file);\n\t\t}\n\t\t/* Don't allocate more for read buffer than could possibly help */\n\t\tlt->max_size = Min(MaxAllocSize, filesize);\n\t\ttapeblocks = filesize / BLCKSZ;\n\t\tnphysicalblocks += tapeblocks;\n\t}\n\n\t/*\n\t * Set # of allocated blocks, as well as # blocks written.  Use extent of\n\t * new BufFile space (from 0 to end of last worker's tape space) for this.\n\t * Allocated/written blocks should include space used by holes left\n\t * between concatenated BufFiles.\n\t */\n\tlts->nBlocksAllocated = lt->offsetBlockNumber + tapeblocks;\n\tlts->nBlocksWritten = lts->nBlocksAllocated;\n\n\t/*\n\t * Compute number of hole blocks so that we can later work backwards, and\n\t * instrument number of physical blocks.  We don't simply use physical\n\t * blocks directly for instrumentation because this would break if we ever\n\t * subsequently wrote to the leader tape.\n\t *\n\t * Working backwards like this keeps our options open.  If shared BufFiles\n\t * ever support being written to post-export, logtape.c can automatically\n\t * take advantage of that.  We'd then support writing to the leader tape\n\t * while recycling space from worker tapes, because the leader tape has a\n\t * zero offset (write routines won't need to have extra logic to apply an\n\t * offset).\n\t *\n\t * The only thing that currently prevents writing to the leader tape from\n\t * working is the fact that BufFiles opened using BufFileOpenShared() are\n\t * read-only by definition, but that could be changed if it seemed\n\t * worthwhile.  For now, writing to the leader tape will raise a \"Bad file\n\t * descriptor\" error, so tuplesort must avoid writing to the leader tape\n\t * altogether.\n\t */\n\tlts->nHoleBlocks = lts->nBlocksAllocated - nphysicalblocks;\n}"
  },
  {
    "function_name": "ltsReleaseBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "369-398",
    "snippet": "static void\nltsReleaseBlock(LogicalTapeSet *lts, long blocknum)\n{\n\tint\t\t\tndx;\n\n\t/*\n\t * Do nothing if we're no longer interested in remembering free space.\n\t */\n\tif (lts->forgetFreeSpace)\n\t\treturn;\n\n\t/*\n\t * Enlarge freeBlocks array if full.\n\t */\n\tif (lts->nFreeBlocks >= lts->freeBlocksLen)\n\t{\n\t\tlts->freeBlocksLen *= 2;\n\t\tlts->freeBlocks = (long *) repalloc(lts->freeBlocks,\n\t\t\t\t\t\t\t\t\t\t\tlts->freeBlocksLen * sizeof(long));\n\t}\n\n\t/*\n\t * Add blocknum to array, and mark the array unsorted if it's no longer in\n\t * decreasing order.\n\t */\n\tndx = lts->nFreeBlocks++;\n\tlts->freeBlocks[ndx] = blocknum;\n\tif (ndx > 0 && lts->freeBlocks[ndx - 1] < blocknum)\n\t\tlts->blocksSorted = false;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "lts->freeBlocks",
            "lts->freeBlocksLen * sizeof(long)"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReleaseBlock(LogicalTapeSet *lts, long blocknum)\n{\n\tint\t\t\tndx;\n\n\t/*\n\t * Do nothing if we're no longer interested in remembering free space.\n\t */\n\tif (lts->forgetFreeSpace)\n\t\treturn;\n\n\t/*\n\t * Enlarge freeBlocks array if full.\n\t */\n\tif (lts->nFreeBlocks >= lts->freeBlocksLen)\n\t{\n\t\tlts->freeBlocksLen *= 2;\n\t\tlts->freeBlocks = (long *) repalloc(lts->freeBlocks,\n\t\t\t\t\t\t\t\t\t\t\tlts->freeBlocksLen * sizeof(long));\n\t}\n\n\t/*\n\t * Add blocknum to array, and mark the array unsorted if it's no longer in\n\t * decreasing order.\n\t */\n\tndx = lts->nFreeBlocks++;\n\tlts->freeBlocks[ndx] = blocknum;\n\tif (ndx > 0 && lts->freeBlocks[ndx - 1] < blocknum)\n\t\tlts->blocksSorted = false;\n}"
  },
  {
    "function_name": "ltsGetFreeBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "344-364",
    "snippet": "static long\nltsGetFreeBlock(LogicalTapeSet *lts)\n{\n\t/*\n\t * If there are multiple free blocks, we select the one appearing last in\n\t * freeBlocks[] (after sorting the array if needed).  If there are none,\n\t * assign the next block at the end of the file.\n\t */\n\tif (lts->nFreeBlocks > 0)\n\t{\n\t\tif (!lts->blocksSorted)\n\t\t{\n\t\t\tqsort((void *) lts->freeBlocks, lts->nFreeBlocks,\n\t\t\t\t  sizeof(long), freeBlocks_cmp);\n\t\t\tlts->blocksSorted = true;\n\t\t}\n\t\treturn lts->freeBlocks[--lts->nFreeBlocks];\n\t}\n\telse\n\t\treturn lts->nBlocksAllocated++;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "(void *) lts->freeBlocks",
            "lts->nFreeBlocks",
            "sizeof(long)",
            "freeBlocks_cmp"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nstatic long\nltsGetFreeBlock(LogicalTapeSet *lts)\n{\n\t/*\n\t * If there are multiple free blocks, we select the one appearing last in\n\t * freeBlocks[] (after sorting the array if needed).  If there are none,\n\t * assign the next block at the end of the file.\n\t */\n\tif (lts->nFreeBlocks > 0)\n\t{\n\t\tif (!lts->blocksSorted)\n\t\t{\n\t\t\tqsort((void *) lts->freeBlocks, lts->nFreeBlocks,\n\t\t\t\t  sizeof(long), freeBlocks_cmp);\n\t\t\tlts->blocksSorted = true;\n\t\t}\n\t\treturn lts->freeBlocks[--lts->nFreeBlocks];\n\t}\n\telse\n\t\treturn lts->nBlocksAllocated++;\n}"
  },
  {
    "function_name": "freeBlocks_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "327-339",
    "snippet": "static int\nfreeBlocks_cmp(const void *a, const void *b)\n{\n\tlong\t\tablk = *((const long *) a);\n\tlong\t\tbblk = *((const long *) b);\n\n\t/* can't just subtract because long might be wider than int */\n\tif (ablk < bblk)\n\t\treturn 1;\n\tif (ablk > bblk)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic int\nfreeBlocks_cmp(const void *a, const void *b)\n{\n\tlong\t\tablk = *((const long *) a);\n\tlong\t\tbblk = *((const long *) b);\n\n\t/* can't just subtract because long might be wider than int */\n\tif (ablk < bblk)\n\t\treturn 1;\n\tif (ablk > bblk)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ltsReadFillBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "285-322",
    "snippet": "static bool\nltsReadFillBuffer(LogicalTapeSet *lts, LogicalTape *lt)\n{\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tdo\n\t{\n\t\tchar\t   *thisbuf = lt->buffer + lt->nbytes;\n\t\tlong\t\tdatablocknum = lt->nextBlockNumber;\n\n\t\t/* Fetch next block number */\n\t\tif (datablocknum == -1L)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\t\t/* Apply worker offset, needed for leader tapesets */\n\t\tdatablocknum += lt->offsetBlockNumber;\n\n\t\t/* Read the block */\n\t\tltsReadBlock(lts, datablocknum, (void *) thisbuf);\n\t\tif (!lt->frozen)\n\t\t\tltsReleaseBlock(lts, datablocknum);\n\t\tlt->curBlockNumber = lt->nextBlockNumber;\n\n\t\tlt->nbytes += TapeBlockGetNBytes(thisbuf);\n\t\tif (TapeBlockIsLast(thisbuf))\n\t\t{\n\t\t\tlt->nextBlockNumber = -1L;\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlt->nextBlockNumber = TapeBlockGetTrailer(thisbuf)->next;\n\n\t\t/* Advance to next block, if we have buffer space left */\n\t} while (lt->buffer_size - lt->nbytes > BLCKSZ);\n\n\treturn (lt->nbytes > 0);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TapeBlockGetTrailer",
          "args": [
            "thisbuf"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockIsLast",
          "args": [
            "thisbuf"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TapeBlockGetNBytes",
          "args": [
            "thisbuf"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsReleaseBlock",
          "args": [
            "lts",
            "datablocknum"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReleaseBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "369-398",
          "snippet": "static void\nltsReleaseBlock(LogicalTapeSet *lts, long blocknum)\n{\n\tint\t\t\tndx;\n\n\t/*\n\t * Do nothing if we're no longer interested in remembering free space.\n\t */\n\tif (lts->forgetFreeSpace)\n\t\treturn;\n\n\t/*\n\t * Enlarge freeBlocks array if full.\n\t */\n\tif (lts->nFreeBlocks >= lts->freeBlocksLen)\n\t{\n\t\tlts->freeBlocksLen *= 2;\n\t\tlts->freeBlocks = (long *) repalloc(lts->freeBlocks,\n\t\t\t\t\t\t\t\t\t\t\tlts->freeBlocksLen * sizeof(long));\n\t}\n\n\t/*\n\t * Add blocknum to array, and mark the array unsorted if it's no longer in\n\t * decreasing order.\n\t */\n\tndx = lts->nFreeBlocks++;\n\tlts->freeBlocks[ndx] = blocknum;\n\tif (ndx > 0 && lts->freeBlocks[ndx - 1] < blocknum)\n\t\tlts->blocksSorted = false;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReleaseBlock(LogicalTapeSet *lts, long blocknum)\n{\n\tint\t\t\tndx;\n\n\t/*\n\t * Do nothing if we're no longer interested in remembering free space.\n\t */\n\tif (lts->forgetFreeSpace)\n\t\treturn;\n\n\t/*\n\t * Enlarge freeBlocks array if full.\n\t */\n\tif (lts->nFreeBlocks >= lts->freeBlocksLen)\n\t{\n\t\tlts->freeBlocksLen *= 2;\n\t\tlts->freeBlocks = (long *) repalloc(lts->freeBlocks,\n\t\t\t\t\t\t\t\t\t\t\tlts->freeBlocksLen * sizeof(long));\n\t}\n\n\t/*\n\t * Add blocknum to array, and mark the array unsorted if it's no longer in\n\t * decreasing order.\n\t */\n\tndx = lts->nFreeBlocks++;\n\tlts->freeBlocks[ndx] = blocknum;\n\tif (ndx > 0 && lts->freeBlocks[ndx - 1] < blocknum)\n\t\tlts->blocksSorted = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltsReadBlock",
          "args": [
            "lts",
            "datablocknum",
            "(void *) thisbuf"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ltsReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "269-278",
          "snippet": "static void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nstatic bool\nltsReadFillBuffer(LogicalTapeSet *lts, LogicalTape *lt)\n{\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tdo\n\t{\n\t\tchar\t   *thisbuf = lt->buffer + lt->nbytes;\n\t\tlong\t\tdatablocknum = lt->nextBlockNumber;\n\n\t\t/* Fetch next block number */\n\t\tif (datablocknum == -1L)\n\t\t\tbreak;\t\t\t\t/* EOF */\n\t\t/* Apply worker offset, needed for leader tapesets */\n\t\tdatablocknum += lt->offsetBlockNumber;\n\n\t\t/* Read the block */\n\t\tltsReadBlock(lts, datablocknum, (void *) thisbuf);\n\t\tif (!lt->frozen)\n\t\t\tltsReleaseBlock(lts, datablocknum);\n\t\tlt->curBlockNumber = lt->nextBlockNumber;\n\n\t\tlt->nbytes += TapeBlockGetNBytes(thisbuf);\n\t\tif (TapeBlockIsLast(thisbuf))\n\t\t{\n\t\t\tlt->nextBlockNumber = -1L;\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tlt->nextBlockNumber = TapeBlockGetTrailer(thisbuf)->next;\n\n\t\t/* Advance to next block, if we have buffer space left */\n\t} while (lt->buffer_size - lt->nbytes > BLCKSZ);\n\n\treturn (lt->nbytes > 0);\n}"
  },
  {
    "function_name": "ltsReadBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "269-278",
    "snippet": "static void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum))"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read block %ld of temporary file: %m\"",
            "blocknum"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "lts->pfile",
            "buffer",
            "BLCKSZ"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeekBlock",
          "args": [
            "lts->pfile",
            "blocknum"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileRead(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n}"
  },
  {
    "function_name": "ltsWriteBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
    "lines": "221-261",
    "snippet": "static void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
      "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
      "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum))"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not write block %ld of temporary file: %m\"",
            "blocknum"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileWrite",
          "args": [
            "lts->pfile",
            "buffer",
            "BLCKSZ"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeekBlock",
          "args": [
            "lts->pfile",
            "blocknum"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltsWriteBlock",
          "args": [
            "lts",
            "lts->nBlocksWritten",
            "zerobuf.data"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "ltsWriteBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "221-261",
          "snippet": "static void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "zerobuf.data",
            "0",
            "sizeof(zerobuf)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nstatic void\nltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer)\n{\n\t/*\n\t * BufFile does not support \"holes\", so if we're about to write a block\n\t * that's past the current end of file, fill the space between the current\n\t * end of file and the target block with zeros.\n\t *\n\t * This should happen rarely, otherwise you are not writing very\n\t * sequentially.  In current use, this only happens when the sort ends\n\t * writing a run, and switches to another tape.  The last block of the\n\t * previous tape isn't flushed to disk until the end of the sort, so you\n\t * get one-block hole, where the last block of the previous tape will\n\t * later go.\n\t *\n\t * Note that BufFile concatenation can leave \"holes\" in BufFile between\n\t * worker-owned block ranges.  These are tracked for reporting purposes\n\t * only.  We never read from nor write to these hole blocks, and so they\n\t * are not considered here.\n\t */\n\twhile (blocknum > lts->nBlocksWritten)\n\t{\n\t\tPGAlignedBlock zerobuf;\n\n\t\tMemSet(zerobuf.data, 0, sizeof(zerobuf));\n\n\t\tltsWriteBlock(lts, lts->nBlocksWritten, zerobuf.data);\n\t}\n\n\t/* Write the requested block */\n\tif (BufFileSeekBlock(lts->pfile, blocknum) != 0 ||\n\t\tBufFileWrite(lts->pfile, buffer, BLCKSZ) != BLCKSZ)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write block %ld of temporary file: %m\",\n\t\t\t\t\t\tblocknum)));\n\n\t/* Update nBlocksWritten, if we extended the file */\n\tif (blocknum == lts->nBlocksWritten)\n\t\tlts->nBlocksWritten++;\n}"
  }
]