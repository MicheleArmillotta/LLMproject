[
  {
    "function_name": "row_security_active_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/rls.c",
    "lines": "152-167",
    "snippet": "Datum\nrow_security_active_name(PG_FUNCTION_ARGS)\n{\n\t/* By qualified name */\n\ttext\t   *tablename = PG_GETARG_TEXT_PP(0);\n\tRangeVar   *tablerel;\n\tOid\t\t\ttableoid;\n\tint\t\t\trls_status;\n\n\t/* Look up table name.  Can't lock it - we might not have privileges. */\n\ttablerel = makeRangeVarFromNameList(textToQualifiedNameList(tablename));\n\ttableoid = RangeVarGetRelid(tablerel, NoLock, false);\n\n\trls_status = check_enable_rls(tableoid, InvalidOid, true);\n\tPG_RETURN_BOOL(rls_status == RLS_ENABLED);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rls_status == RLS_ENABLED"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_enable_rls",
          "args": [
            "tableoid",
            "InvalidOid",
            "true"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "check_enable_rls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/rls.c",
          "lines": "51-133",
          "snippet": "int\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rls.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nint\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeVarGetRelid",
          "args": [
            "tablerel",
            "NoLock",
            "false"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeRangeVarFromNameList",
          "args": [
            "textToQualifiedNameList(tablename)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textToQualifiedNameList",
          "args": [
            "tablename"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "textToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3231-3264",
          "snippet": "List *\ntextToQualifiedNameList(text *textval)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* Convert to C string (handles possible detoasting). */\n\t/* Note we rely on being able to modify rawname below. */\n\trawname = text_to_cstring(textval);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ntextToQualifiedNameList(text *textval)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* Convert to C string (handles possible detoasting). */\n\t/* Note we rely on being able to modify rawname below. */\n\trawname = text_to_cstring(textval);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rls.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nDatum\nrow_security_active_name(PG_FUNCTION_ARGS)\n{\n\t/* By qualified name */\n\ttext\t   *tablename = PG_GETARG_TEXT_PP(0);\n\tRangeVar   *tablerel;\n\tOid\t\t\ttableoid;\n\tint\t\t\trls_status;\n\n\t/* Look up table name.  Can't lock it - we might not have privileges. */\n\ttablerel = makeRangeVarFromNameList(textToQualifiedNameList(tablename));\n\ttableoid = RangeVarGetRelid(tablerel, NoLock, false);\n\n\trls_status = check_enable_rls(tableoid, InvalidOid, true);\n\tPG_RETURN_BOOL(rls_status == RLS_ENABLED);\n}"
  },
  {
    "function_name": "row_security_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/rls.c",
    "lines": "141-150",
    "snippet": "Datum\nrow_security_active(PG_FUNCTION_ARGS)\n{\n\t/* By OID */\n\tOid\t\t\ttableoid = PG_GETARG_OID(0);\n\tint\t\t\trls_status;\n\n\trls_status = check_enable_rls(tableoid, InvalidOid, true);\n\tPG_RETURN_BOOL(rls_status == RLS_ENABLED);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rls_status == RLS_ENABLED"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_enable_rls",
          "args": [
            "tableoid",
            "InvalidOid",
            "true"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "check_enable_rls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/rls.c",
          "lines": "51-133",
          "snippet": "int\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rls.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nint\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rls.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nDatum\nrow_security_active(PG_FUNCTION_ARGS)\n{\n\t/* By OID */\n\tOid\t\t\ttableoid = PG_GETARG_OID(0);\n\tint\t\t\trls_status;\n\n\trls_status = check_enable_rls(tableoid, InvalidOid, true);\n\tPG_RETURN_BOOL(rls_status == RLS_ENABLED);\n}"
  },
  {
    "function_name": "check_enable_rls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/rls.c",
    "lines": "51-133",
    "snippet": "int\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\""
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"query would be affected by row-level security policy for table \\\"%s\\\"\"",
            "get_rel_name(relid)"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rel_name",
          "args": [
            "relid"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "get_rel_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1753-1770",
          "snippet": "Oid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "GUC_check_errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "10064-10068",
          "snippet": "void\nGUC_check_errcode(int sqlerrcode)\n{\n\tGUC_check_errcode_value = sqlerrcode;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGUC_check_errcode_value;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGUC_check_errcode_value;\n\nvoid\nGUC_check_errcode(int sqlerrcode)\n{\n\tGUC_check_errcode_value = sqlerrcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InNoForceRLSOperation",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "InNoForceRLSOperation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "527-531",
          "snippet": "bool\nInNoForceRLSOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_NOFORCE_RLS) != 0;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic int\tSecurityRestrictionContext = 0;\n\nbool\nInNoForceRLSOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_NOFORCE_RLS) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_class_ownercheck",
          "args": [
            "relid",
            "user_id"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_bypassrls_privilege",
          "args": [
            "user_id"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(relid)"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rls.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nint\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}"
  }
]