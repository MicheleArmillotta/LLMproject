[
  {
    "function_name": "compute_range_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_typanalyze.c",
    "lines": "95-357",
    "snippet": "static void\ncompute_range_stats(VacAttrStats *stats, AnalyzeAttrFetchFunc fetchfunc,\n\t\t\t\t\tint samplerows, double totalrows)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) stats->extra_data;\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tint\t\t\tnull_cnt = 0;\n\tint\t\t\tnon_null_cnt = 0;\n\tint\t\t\tnon_empty_cnt = 0;\n\tint\t\t\tempty_cnt = 0;\n\tint\t\t\trange_no;\n\tint\t\t\tslot_idx;\n\tint\t\t\tnum_bins = stats->attr->attstattarget;\n\tint\t\t\tnum_hist;\n\tfloat8\t   *lengths;\n\tRangeBound *lowers,\n\t\t\t   *uppers;\n\tdouble\t\ttotal_width = 0;\n\n\t/* Allocate memory to hold range bounds and lengths of the sample ranges. */\n\tlowers = (RangeBound *) palloc(sizeof(RangeBound) * samplerows);\n\tuppers = (RangeBound *) palloc(sizeof(RangeBound) * samplerows);\n\tlengths = (float8 *) palloc(sizeof(float8) * samplerows);\n\n\t/* Loop over the sample ranges. */\n\tfor (range_no = 0; range_no < samplerows; range_no++)\n\t{\n\t\tDatum\t\tvalue;\n\t\tbool\t\tisnull,\n\t\t\t\t\tempty;\n\t\tRangeType  *range;\n\t\tRangeBound\tlower,\n\t\t\t\t\tupper;\n\t\tfloat8\t\tlength;\n\n\t\tvacuum_delay_point();\n\n\t\tvalue = fetchfunc(stats, range_no, &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\t/* range is null, just count that */\n\t\t\tnull_cnt++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * XXX: should we ignore wide values, like std_typanalyze does, to\n\t\t * avoid bloating the statistics table?\n\t\t */\n\t\ttotal_width += VARSIZE_ANY(DatumGetPointer(value));\n\n\t\t/* Get range and deserialize it for further analysis. */\n\t\trange = DatumGetRangeTypeP(value);\n\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\n\t\tif (!empty)\n\t\t{\n\t\t\t/* Remember bounds and length for further usage in histograms */\n\t\t\tlowers[non_empty_cnt] = lower;\n\t\t\tuppers[non_empty_cnt] = upper;\n\n\t\t\tif (lower.infinite || upper.infinite)\n\t\t\t{\n\t\t\t\t/* Length of any kind of an infinite range is infinite */\n\t\t\t\tlength = get_float8_infinity();\n\t\t\t}\n\t\t\telse if (has_subdiff)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For an ordinary range, use subdiff function between upper\n\t\t\t\t * and lower bound values.\n\t\t\t\t */\n\t\t\t\tlength = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val, lower.val));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Use default value of 1.0 if no subdiff is available. */\n\t\t\t\tlength = 1.0;\n\t\t\t}\n\t\t\tlengths[non_empty_cnt] = length;\n\n\t\t\tnon_empty_cnt++;\n\t\t}\n\t\telse\n\t\t\tempty_cnt++;\n\n\t\tnon_null_cnt++;\n\t}\n\n\tslot_idx = 0;\n\n\t/* We can only compute real stats if we found some non-null values. */\n\tif (non_null_cnt > 0)\n\t{\n\t\tDatum\t   *bound_hist_values;\n\t\tDatum\t   *length_hist_values;\n\t\tint\t\t\tpos,\n\t\t\t\t\tposfrac,\n\t\t\t\t\tdelta,\n\t\t\t\t\tdeltafrac,\n\t\t\t\t\ti;\n\t\tMemoryContext old_cxt;\n\t\tfloat4\t   *emptyfrac;\n\n\t\tstats->stats_valid = true;\n\t\t/* Do the simple null-frac and width stats */\n\t\tstats->stanullfrac = (double) null_cnt / (double) samplerows;\n\t\tstats->stawidth = total_width / (double) non_null_cnt;\n\n\t\t/* Estimate that non-null values are unique */\n\t\tstats->stadistinct = -1.0 * (1.0 - stats->stanullfrac);\n\n\t\t/* Must copy the target values into anl_context */\n\t\told_cxt = MemoryContextSwitchTo(stats->anl_context);\n\n\t\t/*\n\t\t * Generate a bounds histogram slot entry if there are at least two\n\t\t * values.\n\t\t */\n\t\tif (non_empty_cnt >= 2)\n\t\t{\n\t\t\t/* Sort bound values */\n\t\t\tqsort_arg(lowers, non_empty_cnt, sizeof(RangeBound),\n\t\t\t\t\t  range_bound_qsort_cmp, typcache);\n\t\t\tqsort_arg(uppers, non_empty_cnt, sizeof(RangeBound),\n\t\t\t\t\t  range_bound_qsort_cmp, typcache);\n\n\t\t\tnum_hist = non_empty_cnt;\n\t\t\tif (num_hist > num_bins)\n\t\t\t\tnum_hist = num_bins + 1;\n\n\t\t\tbound_hist_values = (Datum *) palloc(num_hist * sizeof(Datum));\n\n\t\t\t/*\n\t\t\t * The object of this loop is to construct ranges from first and\n\t\t\t * last entries in lowers[] and uppers[] along with evenly-spaced\n\t\t\t * values in between. So the i'th value is a range of lowers[(i *\n\t\t\t * (nvals - 1)) / (num_hist - 1)] and uppers[(i * (nvals - 1)) /\n\t\t\t * (num_hist - 1)]. But computing that subscript directly risks\n\t\t\t * integer overflow when the stats target is more than a couple\n\t\t\t * thousand.  Instead we add (nvals - 1) / (num_hist - 1) to pos\n\t\t\t * at each step, tracking the integral and fractional parts of the\n\t\t\t * sum separately.\n\t\t\t */\n\t\t\tdelta = (non_empty_cnt - 1) / (num_hist - 1);\n\t\t\tdeltafrac = (non_empty_cnt - 1) % (num_hist - 1);\n\t\t\tpos = posfrac = 0;\n\n\t\t\tfor (i = 0; i < num_hist; i++)\n\t\t\t{\n\t\t\t\tbound_hist_values[i] = PointerGetDatum(range_serialize(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   typcache, &lowers[pos], &uppers[pos], false));\n\t\t\t\tpos += delta;\n\t\t\t\tposfrac += deltafrac;\n\t\t\t\tif (posfrac >= (num_hist - 1))\n\t\t\t\t{\n\t\t\t\t\t/* fractional part exceeds 1, carry to integer part */\n\t\t\t\t\tpos++;\n\t\t\t\t\tposfrac -= (num_hist - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstats->stakind[slot_idx] = STATISTIC_KIND_BOUNDS_HISTOGRAM;\n\t\t\tstats->stavalues[slot_idx] = bound_hist_values;\n\t\t\tstats->numvalues[slot_idx] = num_hist;\n\t\t\tslot_idx++;\n\t\t}\n\n\t\t/*\n\t\t * Generate a length histogram slot entry if there are at least two\n\t\t * values.\n\t\t */\n\t\tif (non_empty_cnt >= 2)\n\t\t{\n\t\t\t/*\n\t\t\t * Ascending sort of range lengths for further filling of\n\t\t\t * histogram\n\t\t\t */\n\t\t\tqsort(lengths, non_empty_cnt, sizeof(float8), float8_qsort_cmp);\n\n\t\t\tnum_hist = non_empty_cnt;\n\t\t\tif (num_hist > num_bins)\n\t\t\t\tnum_hist = num_bins + 1;\n\n\t\t\tlength_hist_values = (Datum *) palloc(num_hist * sizeof(Datum));\n\n\t\t\t/*\n\t\t\t * The object of this loop is to copy the first and last lengths[]\n\t\t\t * entries along with evenly-spaced values in between. So the i'th\n\t\t\t * value is lengths[(i * (nvals - 1)) / (num_hist - 1)]. But\n\t\t\t * computing that subscript directly risks integer overflow when\n\t\t\t * the stats target is more than a couple thousand.  Instead we\n\t\t\t * add (nvals - 1) / (num_hist - 1) to pos at each step, tracking\n\t\t\t * the integral and fractional parts of the sum separately.\n\t\t\t */\n\t\t\tdelta = (non_empty_cnt - 1) / (num_hist - 1);\n\t\t\tdeltafrac = (non_empty_cnt - 1) % (num_hist - 1);\n\t\t\tpos = posfrac = 0;\n\n\t\t\tfor (i = 0; i < num_hist; i++)\n\t\t\t{\n\t\t\t\tlength_hist_values[i] = Float8GetDatum(lengths[pos]);\n\t\t\t\tpos += delta;\n\t\t\t\tposfrac += deltafrac;\n\t\t\t\tif (posfrac >= (num_hist - 1))\n\t\t\t\t{\n\t\t\t\t\t/* fractional part exceeds 1, carry to integer part */\n\t\t\t\t\tpos++;\n\t\t\t\t\tposfrac -= (num_hist - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Even when we don't create the histogram, store an empty array\n\t\t\t * to mean \"no histogram\". We can't just leave stavalues NULL,\n\t\t\t * because get_attstatsslot() errors if you ask for stavalues, and\n\t\t\t * it's NULL. We'll still store the empty fraction in stanumbers.\n\t\t\t */\n\t\t\tlength_hist_values = palloc(0);\n\t\t\tnum_hist = 0;\n\t\t}\n\t\tstats->staop[slot_idx] = Float8LessOperator;\n\t\tstats->stavalues[slot_idx] = length_hist_values;\n\t\tstats->numvalues[slot_idx] = num_hist;\n\t\tstats->statypid[slot_idx] = FLOAT8OID;\n\t\tstats->statyplen[slot_idx] = sizeof(float8);\n#ifdef USE_FLOAT8_BYVAL\n\t\tstats->statypbyval[slot_idx] = true;\n#else\n\t\tstats->statypbyval[slot_idx] = false;\n#endif\n\t\tstats->statypalign[slot_idx] = 'd';\n\n\t\t/* Store the fraction of empty ranges */\n\t\temptyfrac = (float4 *) palloc(sizeof(float4));\n\t\t*emptyfrac = ((double) empty_cnt) / ((double) non_null_cnt);\n\t\tstats->stanumbers[slot_idx] = emptyfrac;\n\t\tstats->numnumbers[slot_idx] = 1;\n\n\t\tstats->stakind[slot_idx] = STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM;\n\t\tslot_idx++;\n\n\t\tMemoryContextSwitchTo(old_cxt);\n\t}\n\telse if (null_cnt > 0)\n\t{\n\t\t/* We found only nulls; assume the column is entirely null */\n\t\tstats->stats_valid = true;\n\t\tstats->stanullfrac = 1.0;\n\t\tstats->stawidth = 0;\t/* \"unknown\" */\n\t\tstats->stadistinct = 0.0;\t/* \"unknown\" */\n\t}\n\n\t/*\n\t * We don't need to bother cleaning up any of our temporary palloc's. The\n\t * hashtable should also go away, as it used a child memory context.\n\t */\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"commands/vacuum.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void compute_range_stats(VacAttrStats *stats,\n\t\t\t\t\tAnalyzeAttrFetchFunc fetchfunc, int samplerows, double totalrows);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(float4)"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Float8GetDatum",
          "args": [
            "lengths[pos]"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "Float8GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1900-1907",
          "snippet": "Datum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "lengths",
            "non_empty_cnt",
            "sizeof(float8)",
            "float8_qsort_cmp"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "range_serialize(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   typcache, &lowers[pos], &uppers[pos], false)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "&lowers[pos]",
            "&uppers[pos]",
            "false"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "uppers",
            "non_empty_cnt",
            "sizeof(RangeBound)",
            "range_bound_qsort_cmp",
            "typcache"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "lowers",
            "non_empty_cnt",
            "sizeof(RangeBound)",
            "range_bound_qsort_cmp",
            "typcache"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "stats->anl_context"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val, lower.val)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_subdiff_finfo",
            "typcache->rng_collation",
            "upper.val",
            "lower.val"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "range",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "value"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "DatumGetPointer(value)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetchfunc",
          "args": [
            "stats",
            "range_no",
            "&isnull"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vacuum_delay_point",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"commands/vacuum.h\"\n#include \"catalog/pg_operator.h\"\n#include \"postgres.h\"\n\nstatic void compute_range_stats(VacAttrStats *stats,\n\t\t\t\t\tAnalyzeAttrFetchFunc fetchfunc, int samplerows, double totalrows);\n\nstatic void\ncompute_range_stats(VacAttrStats *stats, AnalyzeAttrFetchFunc fetchfunc,\n\t\t\t\t\tint samplerows, double totalrows)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) stats->extra_data;\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tint\t\t\tnull_cnt = 0;\n\tint\t\t\tnon_null_cnt = 0;\n\tint\t\t\tnon_empty_cnt = 0;\n\tint\t\t\tempty_cnt = 0;\n\tint\t\t\trange_no;\n\tint\t\t\tslot_idx;\n\tint\t\t\tnum_bins = stats->attr->attstattarget;\n\tint\t\t\tnum_hist;\n\tfloat8\t   *lengths;\n\tRangeBound *lowers,\n\t\t\t   *uppers;\n\tdouble\t\ttotal_width = 0;\n\n\t/* Allocate memory to hold range bounds and lengths of the sample ranges. */\n\tlowers = (RangeBound *) palloc(sizeof(RangeBound) * samplerows);\n\tuppers = (RangeBound *) palloc(sizeof(RangeBound) * samplerows);\n\tlengths = (float8 *) palloc(sizeof(float8) * samplerows);\n\n\t/* Loop over the sample ranges. */\n\tfor (range_no = 0; range_no < samplerows; range_no++)\n\t{\n\t\tDatum\t\tvalue;\n\t\tbool\t\tisnull,\n\t\t\t\t\tempty;\n\t\tRangeType  *range;\n\t\tRangeBound\tlower,\n\t\t\t\t\tupper;\n\t\tfloat8\t\tlength;\n\n\t\tvacuum_delay_point();\n\n\t\tvalue = fetchfunc(stats, range_no, &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\t/* range is null, just count that */\n\t\t\tnull_cnt++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * XXX: should we ignore wide values, like std_typanalyze does, to\n\t\t * avoid bloating the statistics table?\n\t\t */\n\t\ttotal_width += VARSIZE_ANY(DatumGetPointer(value));\n\n\t\t/* Get range and deserialize it for further analysis. */\n\t\trange = DatumGetRangeTypeP(value);\n\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\n\t\tif (!empty)\n\t\t{\n\t\t\t/* Remember bounds and length for further usage in histograms */\n\t\t\tlowers[non_empty_cnt] = lower;\n\t\t\tuppers[non_empty_cnt] = upper;\n\n\t\t\tif (lower.infinite || upper.infinite)\n\t\t\t{\n\t\t\t\t/* Length of any kind of an infinite range is infinite */\n\t\t\t\tlength = get_float8_infinity();\n\t\t\t}\n\t\t\telse if (has_subdiff)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For an ordinary range, use subdiff function between upper\n\t\t\t\t * and lower bound values.\n\t\t\t\t */\n\t\t\t\tlength = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val, lower.val));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Use default value of 1.0 if no subdiff is available. */\n\t\t\t\tlength = 1.0;\n\t\t\t}\n\t\t\tlengths[non_empty_cnt] = length;\n\n\t\t\tnon_empty_cnt++;\n\t\t}\n\t\telse\n\t\t\tempty_cnt++;\n\n\t\tnon_null_cnt++;\n\t}\n\n\tslot_idx = 0;\n\n\t/* We can only compute real stats if we found some non-null values. */\n\tif (non_null_cnt > 0)\n\t{\n\t\tDatum\t   *bound_hist_values;\n\t\tDatum\t   *length_hist_values;\n\t\tint\t\t\tpos,\n\t\t\t\t\tposfrac,\n\t\t\t\t\tdelta,\n\t\t\t\t\tdeltafrac,\n\t\t\t\t\ti;\n\t\tMemoryContext old_cxt;\n\t\tfloat4\t   *emptyfrac;\n\n\t\tstats->stats_valid = true;\n\t\t/* Do the simple null-frac and width stats */\n\t\tstats->stanullfrac = (double) null_cnt / (double) samplerows;\n\t\tstats->stawidth = total_width / (double) non_null_cnt;\n\n\t\t/* Estimate that non-null values are unique */\n\t\tstats->stadistinct = -1.0 * (1.0 - stats->stanullfrac);\n\n\t\t/* Must copy the target values into anl_context */\n\t\told_cxt = MemoryContextSwitchTo(stats->anl_context);\n\n\t\t/*\n\t\t * Generate a bounds histogram slot entry if there are at least two\n\t\t * values.\n\t\t */\n\t\tif (non_empty_cnt >= 2)\n\t\t{\n\t\t\t/* Sort bound values */\n\t\t\tqsort_arg(lowers, non_empty_cnt, sizeof(RangeBound),\n\t\t\t\t\t  range_bound_qsort_cmp, typcache);\n\t\t\tqsort_arg(uppers, non_empty_cnt, sizeof(RangeBound),\n\t\t\t\t\t  range_bound_qsort_cmp, typcache);\n\n\t\t\tnum_hist = non_empty_cnt;\n\t\t\tif (num_hist > num_bins)\n\t\t\t\tnum_hist = num_bins + 1;\n\n\t\t\tbound_hist_values = (Datum *) palloc(num_hist * sizeof(Datum));\n\n\t\t\t/*\n\t\t\t * The object of this loop is to construct ranges from first and\n\t\t\t * last entries in lowers[] and uppers[] along with evenly-spaced\n\t\t\t * values in between. So the i'th value is a range of lowers[(i *\n\t\t\t * (nvals - 1)) / (num_hist - 1)] and uppers[(i * (nvals - 1)) /\n\t\t\t * (num_hist - 1)]. But computing that subscript directly risks\n\t\t\t * integer overflow when the stats target is more than a couple\n\t\t\t * thousand.  Instead we add (nvals - 1) / (num_hist - 1) to pos\n\t\t\t * at each step, tracking the integral and fractional parts of the\n\t\t\t * sum separately.\n\t\t\t */\n\t\t\tdelta = (non_empty_cnt - 1) / (num_hist - 1);\n\t\t\tdeltafrac = (non_empty_cnt - 1) % (num_hist - 1);\n\t\t\tpos = posfrac = 0;\n\n\t\t\tfor (i = 0; i < num_hist; i++)\n\t\t\t{\n\t\t\t\tbound_hist_values[i] = PointerGetDatum(range_serialize(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   typcache, &lowers[pos], &uppers[pos], false));\n\t\t\t\tpos += delta;\n\t\t\t\tposfrac += deltafrac;\n\t\t\t\tif (posfrac >= (num_hist - 1))\n\t\t\t\t{\n\t\t\t\t\t/* fractional part exceeds 1, carry to integer part */\n\t\t\t\t\tpos++;\n\t\t\t\t\tposfrac -= (num_hist - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstats->stakind[slot_idx] = STATISTIC_KIND_BOUNDS_HISTOGRAM;\n\t\t\tstats->stavalues[slot_idx] = bound_hist_values;\n\t\t\tstats->numvalues[slot_idx] = num_hist;\n\t\t\tslot_idx++;\n\t\t}\n\n\t\t/*\n\t\t * Generate a length histogram slot entry if there are at least two\n\t\t * values.\n\t\t */\n\t\tif (non_empty_cnt >= 2)\n\t\t{\n\t\t\t/*\n\t\t\t * Ascending sort of range lengths for further filling of\n\t\t\t * histogram\n\t\t\t */\n\t\t\tqsort(lengths, non_empty_cnt, sizeof(float8), float8_qsort_cmp);\n\n\t\t\tnum_hist = non_empty_cnt;\n\t\t\tif (num_hist > num_bins)\n\t\t\t\tnum_hist = num_bins + 1;\n\n\t\t\tlength_hist_values = (Datum *) palloc(num_hist * sizeof(Datum));\n\n\t\t\t/*\n\t\t\t * The object of this loop is to copy the first and last lengths[]\n\t\t\t * entries along with evenly-spaced values in between. So the i'th\n\t\t\t * value is lengths[(i * (nvals - 1)) / (num_hist - 1)]. But\n\t\t\t * computing that subscript directly risks integer overflow when\n\t\t\t * the stats target is more than a couple thousand.  Instead we\n\t\t\t * add (nvals - 1) / (num_hist - 1) to pos at each step, tracking\n\t\t\t * the integral and fractional parts of the sum separately.\n\t\t\t */\n\t\t\tdelta = (non_empty_cnt - 1) / (num_hist - 1);\n\t\t\tdeltafrac = (non_empty_cnt - 1) % (num_hist - 1);\n\t\t\tpos = posfrac = 0;\n\n\t\t\tfor (i = 0; i < num_hist; i++)\n\t\t\t{\n\t\t\t\tlength_hist_values[i] = Float8GetDatum(lengths[pos]);\n\t\t\t\tpos += delta;\n\t\t\t\tposfrac += deltafrac;\n\t\t\t\tif (posfrac >= (num_hist - 1))\n\t\t\t\t{\n\t\t\t\t\t/* fractional part exceeds 1, carry to integer part */\n\t\t\t\t\tpos++;\n\t\t\t\t\tposfrac -= (num_hist - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Even when we don't create the histogram, store an empty array\n\t\t\t * to mean \"no histogram\". We can't just leave stavalues NULL,\n\t\t\t * because get_attstatsslot() errors if you ask for stavalues, and\n\t\t\t * it's NULL. We'll still store the empty fraction in stanumbers.\n\t\t\t */\n\t\t\tlength_hist_values = palloc(0);\n\t\t\tnum_hist = 0;\n\t\t}\n\t\tstats->staop[slot_idx] = Float8LessOperator;\n\t\tstats->stavalues[slot_idx] = length_hist_values;\n\t\tstats->numvalues[slot_idx] = num_hist;\n\t\tstats->statypid[slot_idx] = FLOAT8OID;\n\t\tstats->statyplen[slot_idx] = sizeof(float8);\n#ifdef USE_FLOAT8_BYVAL\n\t\tstats->statypbyval[slot_idx] = true;\n#else\n\t\tstats->statypbyval[slot_idx] = false;\n#endif\n\t\tstats->statypalign[slot_idx] = 'd';\n\n\t\t/* Store the fraction of empty ranges */\n\t\temptyfrac = (float4 *) palloc(sizeof(float4));\n\t\t*emptyfrac = ((double) empty_cnt) / ((double) non_null_cnt);\n\t\tstats->stanumbers[slot_idx] = emptyfrac;\n\t\tstats->numnumbers[slot_idx] = 1;\n\n\t\tstats->stakind[slot_idx] = STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM;\n\t\tslot_idx++;\n\n\t\tMemoryContextSwitchTo(old_cxt);\n\t}\n\telse if (null_cnt > 0)\n\t{\n\t\t/* We found only nulls; assume the column is entirely null */\n\t\tstats->stats_valid = true;\n\t\tstats->stanullfrac = 1.0;\n\t\tstats->stawidth = 0;\t/* \"unknown\" */\n\t\tstats->stadistinct = 0.0;\t/* \"unknown\" */\n\t}\n\n\t/*\n\t * We don't need to bother cleaning up any of our temporary palloc's. The\n\t * hashtable should also go away, as it used a child memory context.\n\t */\n}"
  },
  {
    "function_name": "range_bound_qsort_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_typanalyze.c",
    "lines": "82-90",
    "snippet": "static int\nrange_bound_qsort_cmp(const void *a1, const void *a2, void *arg)\n{\n\tRangeBound *b1 = (RangeBound *) a1;\n\tRangeBound *b2 = (RangeBound *) a2;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, b1, b2);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"commands/vacuum.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tfloat8_qsort_cmp(const void *a1, const void *a2);",
      "static int\trange_bound_qsort_cmp(const void *a1, const void *a2, void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "b1",
            "b2"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"commands/vacuum.h\"\n#include \"catalog/pg_operator.h\"\n#include \"postgres.h\"\n\nstatic int\tfloat8_qsort_cmp(const void *a1, const void *a2);\nstatic int\trange_bound_qsort_cmp(const void *a1, const void *a2, void *arg);\n\nstatic int\nrange_bound_qsort_cmp(const void *a1, const void *a2, void *arg)\n{\n\tRangeBound *b1 = (RangeBound *) a1;\n\tRangeBound *b2 = (RangeBound *) a2;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, b1, b2);\n}"
  },
  {
    "function_name": "float8_qsort_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_typanalyze.c",
    "lines": "65-77",
    "snippet": "static int\nfloat8_qsort_cmp(const void *a1, const void *a2)\n{\n\tconst float8 *f1 = (const float8 *) a1;\n\tconst float8 *f2 = (const float8 *) a2;\n\n\tif (*f1 < *f2)\n\t\treturn -1;\n\telse if (*f1 == *f2)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"commands/vacuum.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tfloat8_qsort_cmp(const void *a1, const void *a2);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"commands/vacuum.h\"\n#include \"catalog/pg_operator.h\"\n#include \"postgres.h\"\n\nstatic int\tfloat8_qsort_cmp(const void *a1, const void *a2);\n\nstatic int\nfloat8_qsort_cmp(const void *a1, const void *a2)\n{\n\tconst float8 *f1 = (const float8 *) a1;\n\tconst float8 *f2 = (const float8 *) a2;\n\n\tif (*f1 < *f2)\n\t\treturn -1;\n\telse if (*f1 == *f2)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}"
  },
  {
    "function_name": "range_typanalyze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_typanalyze.c",
    "lines": "41-60",
    "snippet": "Datum\nrange_typanalyze(PG_FUNCTION_ARGS)\n{\n\tVacAttrStats *stats = (VacAttrStats *) PG_GETARG_POINTER(0);\n\tTypeCacheEntry *typcache;\n\tForm_pg_attribute attr = stats->attr;\n\n\t/* Get information about range type; note column might be a domain */\n\ttypcache = range_get_typcache(fcinfo, getBaseType(stats->attrtypid));\n\n\tif (attr->attstattarget < 0)\n\t\tattr->attstattarget = default_statistics_target;\n\n\tstats->compute_stats = compute_range_stats;\n\tstats->extra_data = typcache;\n\t/* same as in std_typanalyze */\n\tstats->minrows = 300 * attr->attstattarget;\n\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"commands/vacuum.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "getBaseType(stats->attrtypid)"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseType",
          "args": [
            "stats->attrtypid"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2298-2304",
          "snippet": "Oid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"commands/vacuum.h\"\n#include \"catalog/pg_operator.h\"\n#include \"postgres.h\"\n\nDatum\nrange_typanalyze(PG_FUNCTION_ARGS)\n{\n\tVacAttrStats *stats = (VacAttrStats *) PG_GETARG_POINTER(0);\n\tTypeCacheEntry *typcache;\n\tForm_pg_attribute attr = stats->attr;\n\n\t/* Get information about range type; note column might be a domain */\n\ttypcache = range_get_typcache(fcinfo, getBaseType(stats->attrtypid));\n\n\tif (attr->attstattarget < 0)\n\t\tattr->attstattarget = default_statistics_target;\n\n\tstats->compute_stats = compute_range_stats;\n\tstats->extra_data = typcache;\n\t/* same as in std_typanalyze */\n\tstats->minrows = 300 * attr->attstattarget;\n\n\tPG_RETURN_BOOL(true);\n}"
  }
]