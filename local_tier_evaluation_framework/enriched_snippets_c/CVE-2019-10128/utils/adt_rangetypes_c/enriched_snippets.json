[
  {
    "function_name": "datum_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2421-2489",
    "snippet": "static Pointer\ndatum_write(Pointer ptr, Datum datum, bool typbyval, char typalign,\n\t\t\tint16 typlen, char typstorage)\n{\n\tSize\t\tdata_length;\n\n\tif (typbyval)\n\t{\n\t\t/* pass-by-value */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tstore_att_byval(ptr, datum, typlen);\n\t\tdata_length = typlen;\n\t}\n\telse if (typlen == -1)\n\t{\n\t\t/* varlena */\n\t\tPointer\t\tval = DatumGetPointer(datum);\n\n\t\tif (VARATT_IS_EXTERNAL(val))\n\t\t{\n\t\t\t/*\n\t\t\t * Throw error, because we must never put a toast pointer inside a\n\t\t\t * range object.  Caller should have detoasted it.\n\t\t\t */\n\t\t\telog(ERROR, \"cannot store a toast pointer inside a range\");\n\t\t\tdata_length = 0;\t/* keep compiler quiet */\n\t\t}\n\t\telse if (VARATT_IS_SHORT(val))\n\t\t{\n\t\t\t/* no alignment for short varlenas */\n\t\t\tdata_length = VARSIZE_SHORT(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t\telse if (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\t\t\t VARATT_CAN_MAKE_SHORT(val))\n\t\t{\n\t\t\t/* convert to short varlena -- no alignment */\n\t\t\tdata_length = VARATT_CONVERTED_SHORT_SIZE(val);\n\t\t\tSET_VARSIZE_SHORT(ptr, data_length);\n\t\t\tmemcpy(ptr + 1, VARDATA(val), data_length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* full 4-byte header varlena */\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\tdata_length = VARSIZE(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t}\n\telse if (typlen == -2)\n\t{\n\t\t/* cstring ... never needs alignment */\n\t\tAssert(typalign == 'c');\n\t\tdata_length = strlen(DatumGetCString(datum)) + 1;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\telse\n\t{\n\t\t/* fixed-length pass-by-reference */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tAssert(typlen > 0);\n\t\tdata_length = typlen;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\n\tptr += data_length;\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *range_bound_escape(const char *value);",
      "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
      "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "DatumGetPointer(datum)",
            "data_length"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typlen > 0"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "DatumGetPointer(datum)",
            "data_length"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DatumGetCString(datum)"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "datum"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typalign == 'c'"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "val",
            "data_length"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "val"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr + 1",
            "VARDATA(val)",
            "data_length - 1"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "val"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE_SHORT",
          "args": [
            "ptr",
            "data_length"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_CONVERTED_SHORT_SIZE",
          "args": [
            "val"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_CAN_MAKE_SHORT",
          "args": [
            "val"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TYPE_IS_PACKABLE",
          "args": [
            "typlen",
            "typstorage"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "val",
            "data_length"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_SHORT",
          "args": [
            "val"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_SHORT",
          "args": [
            "val"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot store a toast pointer inside a range\""
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "val"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_att_byval",
          "args": [
            "ptr",
            "datum",
            "typlen"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nstatic Pointer\ndatum_write(Pointer ptr, Datum datum, bool typbyval, char typalign,\n\t\t\tint16 typlen, char typstorage)\n{\n\tSize\t\tdata_length;\n\n\tif (typbyval)\n\t{\n\t\t/* pass-by-value */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tstore_att_byval(ptr, datum, typlen);\n\t\tdata_length = typlen;\n\t}\n\telse if (typlen == -1)\n\t{\n\t\t/* varlena */\n\t\tPointer\t\tval = DatumGetPointer(datum);\n\n\t\tif (VARATT_IS_EXTERNAL(val))\n\t\t{\n\t\t\t/*\n\t\t\t * Throw error, because we must never put a toast pointer inside a\n\t\t\t * range object.  Caller should have detoasted it.\n\t\t\t */\n\t\t\telog(ERROR, \"cannot store a toast pointer inside a range\");\n\t\t\tdata_length = 0;\t/* keep compiler quiet */\n\t\t}\n\t\telse if (VARATT_IS_SHORT(val))\n\t\t{\n\t\t\t/* no alignment for short varlenas */\n\t\t\tdata_length = VARSIZE_SHORT(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t\telse if (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\t\t\t VARATT_CAN_MAKE_SHORT(val))\n\t\t{\n\t\t\t/* convert to short varlena -- no alignment */\n\t\t\tdata_length = VARATT_CONVERTED_SHORT_SIZE(val);\n\t\t\tSET_VARSIZE_SHORT(ptr, data_length);\n\t\t\tmemcpy(ptr + 1, VARDATA(val), data_length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* full 4-byte header varlena */\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\tdata_length = VARSIZE(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t}\n\telse if (typlen == -2)\n\t{\n\t\t/* cstring ... never needs alignment */\n\t\tAssert(typalign == 'c');\n\t\tdata_length = strlen(DatumGetCString(datum)) + 1;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\telse\n\t{\n\t\t/* fixed-length pass-by-reference */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tAssert(typlen > 0);\n\t\tdata_length = typlen;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\n\tptr += data_length;\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "datum_compute_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2395-2415",
    "snippet": "static Size\ndatum_compute_size(Size data_length, Datum val, bool typbyval, char typalign,\n\t\t\t\t   int16 typlen, char typstorage)\n{\n\tif (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\tVARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))\n\t{\n\t\t/*\n\t\t * we're anticipating converting to a short varlena header, so adjust\n\t\t * length and don't count any alignment\n\t\t */\n\t\tdata_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));\n\t}\n\telse\n\t{\n\t\tdata_length = att_align_datum(data_length, typalign, typlen, val);\n\t\tdata_length = att_addlength_datum(data_length, typlen, val);\n\t}\n\n\treturn data_length;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
      "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "data_length",
            "typlen",
            "val"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_datum",
          "args": [
            "data_length",
            "typalign",
            "typlen",
            "val"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_CONVERTED_SHORT_SIZE",
          "args": [
            "DatumGetPointer(val)"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "val"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_CAN_MAKE_SHORT",
          "args": [
            "DatumGetPointer(val)"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "val"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TYPE_IS_PACKABLE",
          "args": [
            "typlen",
            "typstorage"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nstatic Size\ndatum_compute_size(Size data_length, Datum val, bool typbyval, char typalign,\n\t\t\t\t   int16 typlen, char typstorage)\n{\n\tif (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\tVARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))\n\t{\n\t\t/*\n\t\t * we're anticipating converting to a short varlena header, so adjust\n\t\t * length and don't count any alignment\n\t\t */\n\t\tdata_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));\n\t}\n\telse\n\t{\n\t\tdata_length = att_align_datum(data_length, typalign, typlen, val);\n\t\tdata_length = att_addlength_datum(data_length, typlen, val);\n\t}\n\n\treturn data_length;\n}"
  },
  {
    "function_name": "range_contains_elem_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2340-2376",
    "snippet": "bool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val)"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_cmp_proc_finfo",
            "typcache->rng_collation",
            "upper.val",
            "val"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val)"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nbool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "range_contained_by_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2331-2335",
    "snippet": "bool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_contains_internal",
          "args": [
            "typcache",
            "r2",
            "r1"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2299-2329",
          "snippet": "bool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}"
  },
  {
    "function_name": "range_contains_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2299-2329",
    "snippet": "bool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "range_bound_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2250-2291",
    "snippet": "static char *\nrange_bound_escape(const char *value)\n{\n\tbool\t\tnq;\n\tconst char *ptr;\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\t/* Detect whether we need double quotes for this value */\n\tnq = (value[0] == '\\0');\t/* force quotes for empty string */\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\' ||\n\t\t\tch == '(' || ch == ')' ||\n\t\t\tch == '[' || ch == ']' ||\n\t\t\tch == ',' ||\n\t\t\tisspace((unsigned char) ch))\n\t\t{\n\t\t\tnq = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* And emit the string */\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\tappendStringInfoChar(&buf, ch);\n\t\tappendStringInfoChar(&buf, ch);\n\t}\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\n\treturn buf.data;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *range_bound_escape(const char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\"'"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "ch"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "ch"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\"'"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) ch"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *range_bound_escape(const char *value);\n\nstatic char *\nrange_bound_escape(const char *value)\n{\n\tbool\t\tnq;\n\tconst char *ptr;\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\t/* Detect whether we need double quotes for this value */\n\tnq = (value[0] == '\\0');\t/* force quotes for empty string */\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\' ||\n\t\t\tch == '(' || ch == ')' ||\n\t\t\tch == '[' || ch == ']' ||\n\t\t\tch == ',' ||\n\t\t\tisspace((unsigned char) ch))\n\t\t{\n\t\t\tnq = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* And emit the string */\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\tappendStringInfoChar(&buf, ch);\n\t\tappendStringInfoChar(&buf, ch);\n\t}\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\n\treturn buf.data;\n}"
  },
  {
    "function_name": "range_deparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2220-2243",
    "snippet": "static char *\nrange_deparse(char flags, const char *lbound_str, const char *ubound_str)\n{\n\tStringInfoData buf;\n\n\tif (flags & RANGE_EMPTY)\n\t\treturn pstrdup(RANGE_EMPTY_LITERAL);\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, (flags & RANGE_LB_INC) ? '[' : '(');\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(lbound_str));\n\n\tappendStringInfoChar(&buf, ',');\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(ubound_str));\n\n\tappendStringInfoChar(&buf, (flags & RANGE_UB_INC) ? ']' : ')');\n\n\treturn buf.data;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RANGE_EMPTY_LITERAL \"empty\""
    ],
    "globals_used": [
      "static void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);",
      "static char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "(flags & RANGE_UB_INC) ? ']' : ')'"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "range_bound_escape(ubound_str)"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_bound_escape",
          "args": [
            "ubound_str"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "range_bound_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2250-2291",
          "snippet": "static char *\nrange_bound_escape(const char *value)\n{\n\tbool\t\tnq;\n\tconst char *ptr;\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\t/* Detect whether we need double quotes for this value */\n\tnq = (value[0] == '\\0');\t/* force quotes for empty string */\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\' ||\n\t\t\tch == '(' || ch == ')' ||\n\t\t\tch == '[' || ch == ']' ||\n\t\t\tch == ',' ||\n\t\t\tisspace((unsigned char) ch))\n\t\t{\n\t\t\tnq = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* And emit the string */\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\tappendStringInfoChar(&buf, ch);\n\t\tappendStringInfoChar(&buf, ch);\n\t}\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *range_bound_escape(const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *range_bound_escape(const char *value);\n\nstatic char *\nrange_bound_escape(const char *value)\n{\n\tbool\t\tnq;\n\tconst char *ptr;\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\t/* Detect whether we need double quotes for this value */\n\tnq = (value[0] == '\\0');\t/* force quotes for empty string */\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\' ||\n\t\t\tch == '(' || ch == ')' ||\n\t\t\tch == '[' || ch == ']' ||\n\t\t\tch == ',' ||\n\t\t\tisspace((unsigned char) ch))\n\t\t{\n\t\t\tnq = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* And emit the string */\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\tfor (ptr = value; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\tappendStringInfoChar(&buf, ch);\n\t\tappendStringInfoChar(&buf, ch);\n\t}\n\tif (nq)\n\t\tappendStringInfoChar(&buf, '\"');\n\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "range_bound_escape(lbound_str)"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "(flags & RANGE_LB_INC) ? '[' : '('"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "RANGE_EMPTY_LITERAL"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RANGE_EMPTY_LITERAL \"empty\"\n\nstatic void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);\nstatic char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);\n\nstatic char *\nrange_deparse(char flags, const char *lbound_str, const char *ubound_str)\n{\n\tStringInfoData buf;\n\n\tif (flags & RANGE_EMPTY)\n\t\treturn pstrdup(RANGE_EMPTY_LITERAL);\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, (flags & RANGE_LB_INC) ? '[' : '(');\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(lbound_str));\n\n\tappendStringInfoChar(&buf, ',');\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(ubound_str));\n\n\tappendStringInfoChar(&buf, (flags & RANGE_UB_INC) ? ']' : ')');\n\n\treturn buf.data;\n}"
  },
  {
    "function_name": "range_parse_bound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2151-2210",
    "snippet": "static const char *\nrange_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite)\n{\n\tStringInfoData buf;\n\n\t/* Check for null: completely empty input means null */\n\tif (*ptr == ',' || *ptr == ')' || *ptr == ']')\n\t{\n\t\t*bound_str = NULL;\n\t\t*infinite = true;\n\t}\n\telse\n\t{\n\t\t/* Extract string for this bound */\n\t\tbool\t\tinquote = false;\n\n\t\tinitStringInfo(&buf);\n\t\twhile (inquote || !(*ptr == ',' || *ptr == ')' || *ptr == ']'))\n\t\t{\n\t\t\tchar\t\tch = *ptr++;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\tif (ch == '\\\\')\n\t\t\t{\n\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t}\n\t\t\telse if (ch == '\"')\n\t\t\t{\n\t\t\t\tif (!inquote)\n\t\t\t\t\tinquote = true;\n\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t{\n\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinquote = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t}\n\n\t\t*bound_str = buf.data;\n\t\t*infinite = false;\n\t}\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "ch"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "*ptr++"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "*ptr++"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\"))"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Unexpected end of input.\""
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"malformed range literal: \\\"%s\\\"\"",
            "string"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\"))"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nstatic const char *\nrange_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite)\n{\n\tStringInfoData buf;\n\n\t/* Check for null: completely empty input means null */\n\tif (*ptr == ',' || *ptr == ')' || *ptr == ']')\n\t{\n\t\t*bound_str = NULL;\n\t\t*infinite = true;\n\t}\n\telse\n\t{\n\t\t/* Extract string for this bound */\n\t\tbool\t\tinquote = false;\n\n\t\tinitStringInfo(&buf);\n\t\twhile (inquote || !(*ptr == ',' || *ptr == ')' || *ptr == ']'))\n\t\t{\n\t\t\tchar\t\tch = *ptr++;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\tif (ch == '\\\\')\n\t\t\t{\n\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t}\n\t\t\telse if (ch == '\"')\n\t\t\t{\n\t\t\t\tif (!inquote)\n\t\t\t\t\tinquote = true;\n\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t{\n\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinquote = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t}\n\n\t\t*bound_str = buf.data;\n\t\t*infinite = false;\n\t}\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "range_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "2042-2135",
    "snippet": "static void\nrange_parse(const char *string, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str)\n{\n\tconst char *ptr = string;\n\tbool\t\tinfinite;\n\n\t*flags = 0;\n\n\t/* consume whitespace */\n\twhile (*ptr != '\\0' && isspace((unsigned char) *ptr))\n\t\tptr++;\n\n\t/* check for empty range */\n\tif (pg_strncasecmp(ptr, RANGE_EMPTY_LITERAL,\n\t\t\t\t\t   strlen(RANGE_EMPTY_LITERAL)) == 0)\n\t{\n\t\t*flags = RANGE_EMPTY;\n\t\t*lbound_str = NULL;\n\t\t*ubound_str = NULL;\n\n\t\tptr += strlen(RANGE_EMPTY_LITERAL);\n\n\t\t/* the rest should be whitespace */\n\t\twhile (*ptr != '\\0' && isspace((unsigned char) *ptr))\n\t\t\tptr++;\n\n\t\t/* should have consumed everything */\n\t\tif (*ptr != '\\0')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstring),\n\t\t\t\t\t errdetail(\"Junk after \\\"empty\\\" key word.\")));\n\n\t\treturn;\n\t}\n\n\tif (*ptr == '[')\n\t{\n\t\t*flags |= RANGE_LB_INC;\n\t\tptr++;\n\t}\n\telse if (*ptr == '(')\n\t\tptr++;\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Missing left parenthesis or bracket.\")));\n\n\tptr = range_parse_bound(string, ptr, lbound_str, &infinite);\n\tif (infinite)\n\t\t*flags |= RANGE_LB_INF;\n\n\tif (*ptr == ',')\n\t\tptr++;\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Missing comma after lower bound.\")));\n\n\tptr = range_parse_bound(string, ptr, ubound_str, &infinite);\n\tif (infinite)\n\t\t*flags |= RANGE_UB_INF;\n\n\tif (*ptr == ']')\n\t{\n\t\t*flags |= RANGE_UB_INC;\n\t\tptr++;\n\t}\n\telse if (*ptr == ')')\n\t\tptr++;\n\telse\t\t\t\t\t\t/* must be a comma */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Too many commas.\")));\n\n\t/* consume whitespace */\n\twhile (*ptr != '\\0' && isspace((unsigned char) *ptr))\n\t\tptr++;\n\n\tif (*ptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Junk after right parenthesis or bracket.\")));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RANGE_EMPTY_LITERAL \"empty\""
    ],
    "globals_used": [
      "static void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);",
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
      "static char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Junk after right parenthesis or bracket.\"))"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Junk after right parenthesis or bracket.\""
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"malformed range literal: \\\"%s\\\"\"",
            "string"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *ptr"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Too many commas.\"))"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_parse_bound",
          "args": [
            "string",
            "ptr",
            "ubound_str",
            "&infinite"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "range_parse_bound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2151-2210",
          "snippet": "static const char *\nrange_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite)\n{\n\tStringInfoData buf;\n\n\t/* Check for null: completely empty input means null */\n\tif (*ptr == ',' || *ptr == ')' || *ptr == ']')\n\t{\n\t\t*bound_str = NULL;\n\t\t*infinite = true;\n\t}\n\telse\n\t{\n\t\t/* Extract string for this bound */\n\t\tbool\t\tinquote = false;\n\n\t\tinitStringInfo(&buf);\n\t\twhile (inquote || !(*ptr == ',' || *ptr == ')' || *ptr == ']'))\n\t\t{\n\t\t\tchar\t\tch = *ptr++;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\tif (ch == '\\\\')\n\t\t\t{\n\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t}\n\t\t\telse if (ch == '\"')\n\t\t\t{\n\t\t\t\tif (!inquote)\n\t\t\t\t\tinquote = true;\n\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t{\n\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinquote = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t}\n\n\t\t*bound_str = buf.data;\n\t\t*infinite = false;\n\t}\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nstatic const char *\nrange_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite)\n{\n\tStringInfoData buf;\n\n\t/* Check for null: completely empty input means null */\n\tif (*ptr == ',' || *ptr == ')' || *ptr == ']')\n\t{\n\t\t*bound_str = NULL;\n\t\t*infinite = true;\n\t}\n\telse\n\t{\n\t\t/* Extract string for this bound */\n\t\tbool\t\tinquote = false;\n\n\t\tinitStringInfo(&buf);\n\t\twhile (inquote || !(*ptr == ',' || *ptr == ')' || *ptr == ']'))\n\t\t{\n\t\t\tchar\t\tch = *ptr++;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\tif (ch == '\\\\')\n\t\t\t{\n\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t}\n\t\t\telse if (ch == '\"')\n\t\t\t{\n\t\t\t\tif (!inquote)\n\t\t\t\t\tinquote = true;\n\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t{\n\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinquote = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t}\n\n\t\t*bound_str = buf.data;\n\t\t*infinite = false;\n\t}\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Missing comma after lower bound.\"))"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Missing left parenthesis or bracket.\"))"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstring),\n\t\t\t\t\t errdetail(\"Junk after \\\"empty\\\" key word.\"))"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RANGE_EMPTY_LITERAL"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "ptr",
            "RANGE_EMPTY_LITERAL",
            "strlen(RANGE_EMPTY_LITERAL)"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RANGE_EMPTY_LITERAL \"empty\"\n\nstatic void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);\n\nstatic void\nrange_parse(const char *string, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str)\n{\n\tconst char *ptr = string;\n\tbool\t\tinfinite;\n\n\t*flags = 0;\n\n\t/* consume whitespace */\n\twhile (*ptr != '\\0' && isspace((unsigned char) *ptr))\n\t\tptr++;\n\n\t/* check for empty range */\n\tif (pg_strncasecmp(ptr, RANGE_EMPTY_LITERAL,\n\t\t\t\t\t   strlen(RANGE_EMPTY_LITERAL)) == 0)\n\t{\n\t\t*flags = RANGE_EMPTY;\n\t\t*lbound_str = NULL;\n\t\t*ubound_str = NULL;\n\n\t\tptr += strlen(RANGE_EMPTY_LITERAL);\n\n\t\t/* the rest should be whitespace */\n\t\twhile (*ptr != '\\0' && isspace((unsigned char) *ptr))\n\t\t\tptr++;\n\n\t\t/* should have consumed everything */\n\t\tif (*ptr != '\\0')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstring),\n\t\t\t\t\t errdetail(\"Junk after \\\"empty\\\" key word.\")));\n\n\t\treturn;\n\t}\n\n\tif (*ptr == '[')\n\t{\n\t\t*flags |= RANGE_LB_INC;\n\t\tptr++;\n\t}\n\telse if (*ptr == '(')\n\t\tptr++;\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Missing left parenthesis or bracket.\")));\n\n\tptr = range_parse_bound(string, ptr, lbound_str, &infinite);\n\tif (infinite)\n\t\t*flags |= RANGE_LB_INF;\n\n\tif (*ptr == ',')\n\t\tptr++;\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Missing comma after lower bound.\")));\n\n\tptr = range_parse_bound(string, ptr, ubound_str, &infinite);\n\tif (infinite)\n\t\t*flags |= RANGE_UB_INF;\n\n\tif (*ptr == ']')\n\t{\n\t\t*flags |= RANGE_UB_INC;\n\t\tptr++;\n\t}\n\telse if (*ptr == ')')\n\t\tptr++;\n\telse\t\t\t\t\t\t/* must be a comma */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Too many commas.\")));\n\n\t/* consume whitespace */\n\twhile (*ptr != '\\0' && isspace((unsigned char) *ptr))\n\t\tptr++;\n\n\tif (*ptr != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\tstring),\n\t\t\t\t errdetail(\"Junk after right parenthesis or bracket.\")));\n}"
  },
  {
    "function_name": "range_parse_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1970-2012",
    "snippet": "static char\nrange_parse_flags(const char *flags_str)\n{\n\tchar\t\tflags = 0;\n\n\tif (flags_str[0] == '\\0' ||\n\t\tflags_str[1] == '\\0' ||\n\t\tflags_str[2] != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\n\tswitch (flags_str[0])\n\t{\n\t\tcase '[':\n\t\t\tflags |= RANGE_LB_INC;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\tswitch (flags_str[1])\n\t{\n\t\tcase ']':\n\t\t\tflags |= RANGE_UB_INC;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\treturn flags;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char range_parse_flags(const char *flags_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\"))"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\""
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid range bound flags\""
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\"))"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\"))"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char range_parse_flags(const char *flags_str);\n\nstatic char\nrange_parse_flags(const char *flags_str)\n{\n\tchar\t\tflags = 0;\n\n\tif (flags_str[0] == '\\0' ||\n\t\tflags_str[1] == '\\0' ||\n\t\tflags_str[2] != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\n\tswitch (flags_str[0])\n\t{\n\t\tcase '[':\n\t\t\tflags |= RANGE_LB_INC;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\tswitch (flags_str[1])\n\t{\n\t\tcase ']':\n\t\t\tflags |= RANGE_UB_INC;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\treturn flags;\n}"
  },
  {
    "function_name": "make_empty_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1940-1957",
    "snippet": "RangeType *\nmake_empty_range(TypeCacheEntry *typcache)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tlower.val = (Datum) 0;\n\tlower.infinite = false;\n\tlower.inclusive = false;\n\tlower.lower = true;\n\n\tupper.val = (Datum) 0;\n\tupper.infinite = false;\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\treturn make_range(typcache, &lower, &upper, true);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "true"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nRangeType *\nmake_empty_range(TypeCacheEntry *typcache)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tlower.val = (Datum) 0;\n\tlower.infinite = false;\n\tlower.inclusive = false;\n\tlower.lower = true;\n\n\tupper.val = (Datum) 0;\n\tupper.infinite = false;\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\treturn make_range(typcache, &lower, &upper, true);\n}"
  },
  {
    "function_name": "range_cmp_bound_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1905-1935",
    "snippet": "int\nrange_cmp_bound_values(TypeCacheEntry *typcache, RangeBound *b1,\n\t\t\t\t\t   RangeBound *b2)\n{\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\treturn DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val)"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_cmp_proc_finfo",
            "typcache->rng_collation",
            "b1->val",
            "b2->val"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bound_values(TypeCacheEntry *typcache, RangeBound *b1,\n\t\t\t\t\t   RangeBound *b2)\n{\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\treturn DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val));\n}"
  },
  {
    "function_name": "range_cmp_bounds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1831-1894",
    "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_cmp_proc_finfo",
            "typcache->rng_collation",
            "b1->val",
            "b2->val"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "make_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1791-1806",
    "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range))"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall1",
          "args": [
            "&typcache->rng_canonical_finfo",
            "RangeTypePGetDatum(range)"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "range"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "range"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_canonical_finfo.fn_oid"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "lower",
            "upper",
            "empty"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
  },
  {
    "function_name": "range_set_contain_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1776-1785",
    "snippet": "void\nrange_set_contain_empty(RangeType *range)\n{\n\tchar\t   *flagsp;\n\n\t/* flag byte is datum's last byte */\n\tflagsp = (char *) range + VARSIZE(range) - 1;\n\n\t*flagsp |= RANGE_CONTAIN_EMPTY;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "range"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nrange_set_contain_empty(RangeType *range)\n{\n\tchar\t   *flagsp;\n\n\t/* flag byte is datum's last byte */\n\tflagsp = (char *) range + VARSIZE(range) - 1;\n\n\t*flagsp |= RANGE_CONTAIN_EMPTY;\n}"
  },
  {
    "function_name": "range_get_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1762-1767",
    "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "range"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
  },
  {
    "function_name": "range_deserialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1695-1754",
    "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "ptr",
            "typbyval",
            "typlen"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_pointer",
          "args": [
            "ptr",
            "typalign",
            "typlen",
            "ptr"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "ptr",
            "typlen",
            "ptr"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "ptr",
            "typbyval",
            "typlen"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "range + 1"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "range"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "RangeTypeGetOid(range) == typcache->type_id"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "range"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
  },
  {
    "function_name": "range_serialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1566-1684",
    "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
      "static char *range_bound_escape(const char *value);",
      "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
      "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datum_write",
          "args": [
            "ptr",
            "upper->val",
            "typbyval",
            "typalign",
            "typlen",
            "typstorage"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "datum_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2421-2489",
          "snippet": "static Pointer\ndatum_write(Pointer ptr, Datum datum, bool typbyval, char typalign,\n\t\t\tint16 typlen, char typstorage)\n{\n\tSize\t\tdata_length;\n\n\tif (typbyval)\n\t{\n\t\t/* pass-by-value */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tstore_att_byval(ptr, datum, typlen);\n\t\tdata_length = typlen;\n\t}\n\telse if (typlen == -1)\n\t{\n\t\t/* varlena */\n\t\tPointer\t\tval = DatumGetPointer(datum);\n\n\t\tif (VARATT_IS_EXTERNAL(val))\n\t\t{\n\t\t\t/*\n\t\t\t * Throw error, because we must never put a toast pointer inside a\n\t\t\t * range object.  Caller should have detoasted it.\n\t\t\t */\n\t\t\telog(ERROR, \"cannot store a toast pointer inside a range\");\n\t\t\tdata_length = 0;\t/* keep compiler quiet */\n\t\t}\n\t\telse if (VARATT_IS_SHORT(val))\n\t\t{\n\t\t\t/* no alignment for short varlenas */\n\t\t\tdata_length = VARSIZE_SHORT(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t\telse if (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\t\t\t VARATT_CAN_MAKE_SHORT(val))\n\t\t{\n\t\t\t/* convert to short varlena -- no alignment */\n\t\t\tdata_length = VARATT_CONVERTED_SHORT_SIZE(val);\n\t\t\tSET_VARSIZE_SHORT(ptr, data_length);\n\t\t\tmemcpy(ptr + 1, VARDATA(val), data_length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* full 4-byte header varlena */\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\tdata_length = VARSIZE(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t}\n\telse if (typlen == -2)\n\t{\n\t\t/* cstring ... never needs alignment */\n\t\tAssert(typalign == 'c');\n\t\tdata_length = strlen(DatumGetCString(datum)) + 1;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\telse\n\t{\n\t\t/* fixed-length pass-by-reference */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tAssert(typlen > 0);\n\t\tdata_length = typlen;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\n\tptr += data_length;\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nstatic Pointer\ndatum_write(Pointer ptr, Datum datum, bool typbyval, char typalign,\n\t\t\tint16 typlen, char typstorage)\n{\n\tSize\t\tdata_length;\n\n\tif (typbyval)\n\t{\n\t\t/* pass-by-value */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tstore_att_byval(ptr, datum, typlen);\n\t\tdata_length = typlen;\n\t}\n\telse if (typlen == -1)\n\t{\n\t\t/* varlena */\n\t\tPointer\t\tval = DatumGetPointer(datum);\n\n\t\tif (VARATT_IS_EXTERNAL(val))\n\t\t{\n\t\t\t/*\n\t\t\t * Throw error, because we must never put a toast pointer inside a\n\t\t\t * range object.  Caller should have detoasted it.\n\t\t\t */\n\t\t\telog(ERROR, \"cannot store a toast pointer inside a range\");\n\t\t\tdata_length = 0;\t/* keep compiler quiet */\n\t\t}\n\t\telse if (VARATT_IS_SHORT(val))\n\t\t{\n\t\t\t/* no alignment for short varlenas */\n\t\t\tdata_length = VARSIZE_SHORT(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t\telse if (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\t\t\t VARATT_CAN_MAKE_SHORT(val))\n\t\t{\n\t\t\t/* convert to short varlena -- no alignment */\n\t\t\tdata_length = VARATT_CONVERTED_SHORT_SIZE(val);\n\t\t\tSET_VARSIZE_SHORT(ptr, data_length);\n\t\t\tmemcpy(ptr + 1, VARDATA(val), data_length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* full 4-byte header varlena */\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\tdata_length = VARSIZE(val);\n\t\t\tmemcpy(ptr, val, data_length);\n\t\t}\n\t}\n\telse if (typlen == -2)\n\t{\n\t\t/* cstring ... never needs alignment */\n\t\tAssert(typalign == 'c');\n\t\tdata_length = strlen(DatumGetCString(datum)) + 1;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\telse\n\t{\n\t\t/* fixed-length pass-by-reference */\n\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\tAssert(typlen > 0);\n\t\tdata_length = typlen;\n\t\tmemcpy(ptr, DatumGetPointer(datum), data_length);\n\t}\n\n\tptr += data_length;\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!upper->lower"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lower->lower"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "range",
            "msize"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "msize"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datum_compute_size",
          "args": [
            "msize",
            "upper->val",
            "typbyval",
            "typalign",
            "typlen",
            "typstorage"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "datum_compute_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2395-2415",
          "snippet": "static Size\ndatum_compute_size(Size data_length, Datum val, bool typbyval, char typalign,\n\t\t\t\t   int16 typlen, char typstorage)\n{\n\tif (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\tVARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))\n\t{\n\t\t/*\n\t\t * we're anticipating converting to a short varlena header, so adjust\n\t\t * length and don't count any alignment\n\t\t */\n\t\tdata_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));\n\t}\n\telse\n\t{\n\t\tdata_length = att_align_datum(data_length, typalign, typlen, val);\n\t\tdata_length = att_addlength_datum(data_length, typlen, val);\n\t}\n\n\treturn data_length;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nstatic Size\ndatum_compute_size(Size data_length, Datum val, bool typbyval, char typalign,\n\t\t\t\t   int16 typlen, char typstorage)\n{\n\tif (TYPE_IS_PACKABLE(typlen, typstorage) &&\n\t\tVARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))\n\t{\n\t\t/*\n\t\t * we're anticipating converting to a short varlena header, so adjust\n\t\t * length and don't count any alignment\n\t\t */\n\t\tdata_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));\n\t}\n\telse\n\t{\n\t\tdata_length = att_align_datum(data_length, typalign, typlen, val);\n\t\tdata_length = att_addlength_datum(data_length, typlen, val);\n\t}\n\n\treturn data_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM_PACKED(upper->val)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_PACKED",
          "args": [
            "upper->val"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM_PACKED(lower->val)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_PACKED",
          "args": [
            "lower->val"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "msize == MAXALIGN(msize)"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "msize"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\"))"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"range lower bound must be less than or equal to range upper bound\""
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bound_values",
          "args": [
            "typcache",
            "lower",
            "upper"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bound_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1905-1935",
          "snippet": "int\nrange_cmp_bound_values(TypeCacheEntry *typcache, RangeBound *b1,\n\t\t\t\t\t   RangeBound *b2)\n{\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\treturn DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bound_values(TypeCacheEntry *typcache, RangeBound *b1,\n\t\t\t\t\t   RangeBound *b2)\n{\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\treturn DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!upper->lower"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lower->lower"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
  },
  {
    "function_name": "range_get_typcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1542-1557",
    "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"type %u is not a range type\"",
            "rngtypid"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "rngtypid",
            "TYPECACHE_RANGE_INFO"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
  },
  {
    "function_name": "tstzrange_subdiff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1514-1523",
    "snippet": "Datum\ntstzrange_subdiff(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tv1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tv2 = PG_GETARG_TIMESTAMP(1);\n\tfloat8\t\tresult;\n\n\tresult = ((float8) v1 - (float8) v2) / USECS_PER_SEC;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\ntstzrange_subdiff(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tv1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tv2 = PG_GETARG_TIMESTAMP(1);\n\tfloat8\t\tresult;\n\n\tresult = ((float8) v1 - (float8) v2) / USECS_PER_SEC;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "tsrange_subdiff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1503-1512",
    "snippet": "Datum\ntsrange_subdiff(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tv1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tv2 = PG_GETARG_TIMESTAMP(1);\n\tfloat8\t\tresult;\n\n\tresult = ((float8) v1 - (float8) v2) / USECS_PER_SEC;\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\ntsrange_subdiff(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tv1 = PG_GETARG_TIMESTAMP(0);\n\tTimestamp\tv2 = PG_GETARG_TIMESTAMP(1);\n\tfloat8\t\tresult;\n\n\tresult = ((float8) v1 - (float8) v2) / USECS_PER_SEC;\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "daterange_subdiff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1494-1501",
    "snippet": "Datum\ndaterange_subdiff(PG_FUNCTION_ARGS)\n{\n\tint32\t\tv1 = PG_GETARG_INT32(0);\n\tint32\t\tv2 = PG_GETARG_INT32(1);\n\n\tPG_RETURN_FLOAT8((float8) v1 - (float8) v2);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) v1 - (float8) v2"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\ndaterange_subdiff(PG_FUNCTION_ARGS)\n{\n\tint32\t\tv1 = PG_GETARG_INT32(0);\n\tint32\t\tv2 = PG_GETARG_INT32(1);\n\n\tPG_RETURN_FLOAT8((float8) v1 - (float8) v2);\n}"
  },
  {
    "function_name": "numrange_subdiff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1478-1492",
    "snippet": "Datum\nnumrange_subdiff(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tv1 = PG_GETARG_DATUM(0);\n\tDatum\t\tv2 = PG_GETARG_DATUM(1);\n\tDatum\t\tnumresult;\n\tfloat8\t\tfloatresult;\n\n\tnumresult = DirectFunctionCall2(numeric_sub, v1, v2);\n\n\tfloatresult = DatumGetFloat8(DirectFunctionCall1(numeric_float8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t numresult));\n\n\tPG_RETURN_FLOAT8(floatresult);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "floatresult"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "DirectFunctionCall1(numeric_float8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t numresult)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_float8",
            "numresult"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_sub",
            "v1",
            "v2"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nnumrange_subdiff(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tv1 = PG_GETARG_DATUM(0);\n\tDatum\t\tv2 = PG_GETARG_DATUM(1);\n\tDatum\t\tnumresult;\n\tfloat8\t\tfloatresult;\n\n\tnumresult = DirectFunctionCall2(numeric_sub, v1, v2);\n\n\tfloatresult = DatumGetFloat8(DirectFunctionCall1(numeric_float8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t numresult));\n\n\tPG_RETURN_FLOAT8(floatresult);\n}"
  },
  {
    "function_name": "int8range_subdiff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1469-1476",
    "snippet": "Datum\nint8range_subdiff(PG_FUNCTION_ARGS)\n{\n\tint64\t\tv1 = PG_GETARG_INT64(0);\n\tint64\t\tv2 = PG_GETARG_INT64(1);\n\n\tPG_RETURN_FLOAT8((float8) v1 - (float8) v2);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) v1 - (float8) v2"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nint8range_subdiff(PG_FUNCTION_ARGS)\n{\n\tint64\t\tv1 = PG_GETARG_INT64(0);\n\tint64\t\tv2 = PG_GETARG_INT64(1);\n\n\tPG_RETURN_FLOAT8((float8) v1 - (float8) v2);\n}"
  },
  {
    "function_name": "int4range_subdiff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1460-1467",
    "snippet": "Datum\nint4range_subdiff(PG_FUNCTION_ARGS)\n{\n\tint32\t\tv1 = PG_GETARG_INT32(0);\n\tint32\t\tv2 = PG_GETARG_INT32(1);\n\n\tPG_RETURN_FLOAT8((float8) v1 - (float8) v2);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) v1 - (float8) v2"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nint4range_subdiff(PG_FUNCTION_ARGS)\n{\n\tint32\t\tv1 = PG_GETARG_INT32(0);\n\tint32\t\tv2 = PG_GETARG_INT32(1);\n\n\tPG_RETURN_FLOAT8((float8) v1 - (float8) v2);\n}"
  },
  {
    "function_name": "daterange_canonical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1417-1446",
    "snippet": "Datum\ndaterange_canonical(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\tPG_RETURN_RANGE_P(r);\n\n\tif (!lower.infinite && !lower.inclusive)\n\t{\n\t\tlower.val = DirectFunctionCall2(date_pli, lower.val, Int32GetDatum(1));\n\t\tlower.inclusive = true;\n\t}\n\n\tif (!upper.infinite && upper.inclusive)\n\t{\n\t\tupper.val = DirectFunctionCall2(date_pli, upper.val, Int32GetDatum(1));\n\t\tupper.inclusive = false;\n\t}\n\n\tPG_RETURN_RANGE_P(range_serialize(typcache, &lower, &upper, false));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range_serialize(typcache, &lower, &upper, false)"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "false"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "date_pli",
            "upper.val",
            "Int32GetDatum(1)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "1"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "date_pli",
            "lower.val",
            "Int32GetDatum(1)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "1"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "r"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\ndaterange_canonical(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\tPG_RETURN_RANGE_P(r);\n\n\tif (!lower.infinite && !lower.inclusive)\n\t{\n\t\tlower.val = DirectFunctionCall2(date_pli, lower.val, Int32GetDatum(1));\n\t\tlower.inclusive = true;\n\t}\n\n\tif (!upper.infinite && upper.inclusive)\n\t{\n\t\tupper.val = DirectFunctionCall2(date_pli, upper.val, Int32GetDatum(1));\n\t\tupper.inclusive = false;\n\t}\n\n\tPG_RETURN_RANGE_P(range_serialize(typcache, &lower, &upper, false));\n}"
  },
  {
    "function_name": "int8range_canonical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1386-1415",
    "snippet": "Datum\nint8range_canonical(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\tPG_RETURN_RANGE_P(r);\n\n\tif (!lower.infinite && !lower.inclusive)\n\t{\n\t\tlower.val = DirectFunctionCall2(int8pl, lower.val, Int64GetDatum(1));\n\t\tlower.inclusive = true;\n\t}\n\n\tif (!upper.infinite && upper.inclusive)\n\t{\n\t\tupper.val = DirectFunctionCall2(int8pl, upper.val, Int64GetDatum(1));\n\t\tupper.inclusive = false;\n\t}\n\n\tPG_RETURN_RANGE_P(range_serialize(typcache, &lower, &upper, false));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range_serialize(typcache, &lower, &upper, false)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "false"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int8pl",
            "upper.val",
            "Int64GetDatum(1)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "1"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int8pl",
            "lower.val",
            "Int64GetDatum(1)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "r"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nint8range_canonical(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\tPG_RETURN_RANGE_P(r);\n\n\tif (!lower.infinite && !lower.inclusive)\n\t{\n\t\tlower.val = DirectFunctionCall2(int8pl, lower.val, Int64GetDatum(1));\n\t\tlower.inclusive = true;\n\t}\n\n\tif (!upper.infinite && upper.inclusive)\n\t{\n\t\tupper.val = DirectFunctionCall2(int8pl, upper.val, Int64GetDatum(1));\n\t\tupper.inclusive = false;\n\t}\n\n\tPG_RETURN_RANGE_P(range_serialize(typcache, &lower, &upper, false));\n}"
  },
  {
    "function_name": "int4range_canonical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1355-1384",
    "snippet": "Datum\nint4range_canonical(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\tPG_RETURN_RANGE_P(r);\n\n\tif (!lower.infinite && !lower.inclusive)\n\t{\n\t\tlower.val = DirectFunctionCall2(int4pl, lower.val, Int32GetDatum(1));\n\t\tlower.inclusive = true;\n\t}\n\n\tif (!upper.infinite && upper.inclusive)\n\t{\n\t\tupper.val = DirectFunctionCall2(int4pl, upper.val, Int32GetDatum(1));\n\t\tupper.inclusive = false;\n\t}\n\n\tPG_RETURN_RANGE_P(range_serialize(typcache, &lower, &upper, false));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range_serialize(typcache, &lower, &upper, false)"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "false"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int4pl",
            "upper.val",
            "Int32GetDatum(1)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "1"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int4pl",
            "lower.val",
            "Int32GetDatum(1)"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "1"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "r"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nint4range_canonical(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\tPG_RETURN_RANGE_P(r);\n\n\tif (!lower.infinite && !lower.inclusive)\n\t{\n\t\tlower.val = DirectFunctionCall2(int4pl, lower.val, Int32GetDatum(1));\n\t\tlower.inclusive = true;\n\t}\n\n\tif (!upper.infinite && upper.inclusive)\n\t{\n\t\tupper.val = DirectFunctionCall2(int4pl, upper.val, Int32GetDatum(1));\n\t\tupper.inclusive = false;\n\t}\n\n\tPG_RETURN_RANGE_P(range_serialize(typcache, &lower, &upper, false));\n}"
  },
  {
    "function_name": "hash_range_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1287-1345",
    "snippet": "Datum\nhash_range_extended(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tDatum\t\tseed = PG_GETARG_DATUM(1);\n\tuint64\t\tresult;\n\tTypeCacheEntry *typcache;\n\tTypeCacheEntry *scache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tchar\t\tflags;\n\tuint64\t\tlower_hash;\n\tuint64\t\tupper_hash;\n\n\tcheck_stack_depth();\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\tflags = range_get_flags(r);\n\n\tscache = typcache->rngelemtype;\n\tif (!OidIsValid(scache->hash_extended_proc_finfo.fn_oid))\n\t{\n\t\tscache = lookup_type_cache(scache->type_id,\n\t\t\t\t\t\t\t\t   TYPECACHE_HASH_EXTENDED_PROC_FINFO);\n\t\tif (!OidIsValid(scache->hash_extended_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(scache->type_id))));\n\t}\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlower_hash = DatumGetUInt64(FunctionCall2Coll(&scache->hash_extended_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  seed));\n\telse\n\t\tlower_hash = 0;\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tupper_hash = DatumGetUInt64(FunctionCall2Coll(&scache->hash_extended_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  seed));\n\telse\n\t\tupper_hash = 0;\n\n\t/* Merge hashes of flags and bounds */\n\tresult = DatumGetUInt64(hash_uint32_extended((uint32) flags,\n\t\t\t\t\t\t\t\t\t\t\t\t DatumGetInt64(seed)));\n\tresult ^= lower_hash;\n\tresult = ROTATE_HIGH_AND_LOW_32BITS(result);\n\tresult ^= upper_hash;\n\n\tPG_RETURN_UINT64(result);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_UINT64",
          "args": [
            "result"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROTATE_HIGH_AND_LOW_32BITS",
          "args": [
            "result"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "hash_uint32_extended((uint32) flags,\n\t\t\t\t\t\t\t\t\t\t\t\t DatumGetInt64(seed))"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32_extended",
          "args": [
            "(uint32) flags",
            "DatumGetInt64(seed)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "seed"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "FunctionCall2Coll(&scache->hash_extended_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  seed)"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&scache->hash_extended_proc_finfo",
            "typcache->rng_collation",
            "upper.val",
            "seed"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "FunctionCall2Coll(&scache->hash_extended_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  seed)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(scache->type_id)))"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify a hash function for type %s\"",
            "format_type_be(scache->type_id)"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "scache->type_id"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "scache->hash_extended_proc_finfo.fn_oid"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "scache->type_id",
            "TYPECACHE_HASH_EXTENDED_PROC_FINFO"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "scache->hash_extended_proc_finfo.fn_oid"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nhash_range_extended(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tDatum\t\tseed = PG_GETARG_DATUM(1);\n\tuint64\t\tresult;\n\tTypeCacheEntry *typcache;\n\tTypeCacheEntry *scache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tchar\t\tflags;\n\tuint64\t\tlower_hash;\n\tuint64\t\tupper_hash;\n\n\tcheck_stack_depth();\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\tflags = range_get_flags(r);\n\n\tscache = typcache->rngelemtype;\n\tif (!OidIsValid(scache->hash_extended_proc_finfo.fn_oid))\n\t{\n\t\tscache = lookup_type_cache(scache->type_id,\n\t\t\t\t\t\t\t\t   TYPECACHE_HASH_EXTENDED_PROC_FINFO);\n\t\tif (!OidIsValid(scache->hash_extended_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(scache->type_id))));\n\t}\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlower_hash = DatumGetUInt64(FunctionCall2Coll(&scache->hash_extended_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  seed));\n\telse\n\t\tlower_hash = 0;\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tupper_hash = DatumGetUInt64(FunctionCall2Coll(&scache->hash_extended_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  seed));\n\telse\n\t\tupper_hash = 0;\n\n\t/* Merge hashes of flags and bounds */\n\tresult = DatumGetUInt64(hash_uint32_extended((uint32) flags,\n\t\t\t\t\t\t\t\t\t\t\t\t DatumGetInt64(seed)));\n\tresult ^= lower_hash;\n\tresult = ROTATE_HIGH_AND_LOW_32BITS(result);\n\tresult ^= upper_hash;\n\n\tPG_RETURN_UINT64(result);\n}"
  },
  {
    "function_name": "hash_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1221-1281",
    "snippet": "Datum\nhash_range(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tuint32\t\tresult;\n\tTypeCacheEntry *typcache;\n\tTypeCacheEntry *scache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tchar\t\tflags;\n\tuint32\t\tlower_hash;\n\tuint32\t\tupper_hash;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\t/* deserialize */\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\tflags = range_get_flags(r);\n\n\t/*\n\t * Look up the element type's hash function, if not done already.\n\t */\n\tscache = typcache->rngelemtype;\n\tif (!OidIsValid(scache->hash_proc_finfo.fn_oid))\n\t{\n\t\tscache = lookup_type_cache(scache->type_id, TYPECACHE_HASH_PROC_FINFO);\n\t\tif (!OidIsValid(scache->hash_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(scache->type_id))));\n\t}\n\n\t/*\n\t * Apply the hash function to each bound.\n\t */\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlower_hash = DatumGetUInt32(FunctionCall1Coll(&scache->hash_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lower.val));\n\telse\n\t\tlower_hash = 0;\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tupper_hash = DatumGetUInt32(FunctionCall1Coll(&scache->hash_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val));\n\telse\n\t\tupper_hash = 0;\n\n\t/* Merge hashes of flags and bounds */\n\tresult = hash_uint32((uint32) flags);\n\tresult ^= lower_hash;\n\tresult = (result << 1) | (result >> 31);\n\tresult ^= upper_hash;\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32",
          "args": [
            "(uint32) flags"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "FunctionCall1Coll(&scache->hash_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall1Coll",
          "args": [
            "&scache->hash_proc_finfo",
            "typcache->rng_collation",
            "upper.val"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall1Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1404-1425",
          "snippet": "Datum\nOidFunctionCall1Coll(Oid functionId, Oid collation, Datum arg1)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall1Coll(Oid functionId, Oid collation, Datum arg1)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "FunctionCall1Coll(&scache->hash_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lower.val)"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(scache->type_id)))"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify a hash function for type %s\"",
            "format_type_be(scache->type_id)"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "scache->type_id"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "scache->hash_proc_finfo.fn_oid"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "scache->type_id",
            "TYPECACHE_HASH_PROC_FINFO"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "scache->hash_proc_finfo.fn_oid"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nhash_range(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tuint32\t\tresult;\n\tTypeCacheEntry *typcache;\n\tTypeCacheEntry *scache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tchar\t\tflags;\n\tuint32\t\tlower_hash;\n\tuint32\t\tupper_hash;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\t/* deserialize */\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\tflags = range_get_flags(r);\n\n\t/*\n\t * Look up the element type's hash function, if not done already.\n\t */\n\tscache = typcache->rngelemtype;\n\tif (!OidIsValid(scache->hash_proc_finfo.fn_oid))\n\t{\n\t\tscache = lookup_type_cache(scache->type_id, TYPECACHE_HASH_PROC_FINFO);\n\t\tif (!OidIsValid(scache->hash_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(scache->type_id))));\n\t}\n\n\t/*\n\t * Apply the hash function to each bound.\n\t */\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlower_hash = DatumGetUInt32(FunctionCall1Coll(&scache->hash_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lower.val));\n\telse\n\t\tlower_hash = 0;\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tupper_hash = DatumGetUInt32(FunctionCall1Coll(&scache->hash_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  upper.val));\n\telse\n\t\tupper_hash = 0;\n\n\t/* Merge hashes of flags and bounds */\n\tresult = hash_uint32((uint32) flags);\n\tresult ^= lower_hash;\n\tresult = (result << 1) | (result >> 31);\n\tresult ^= upper_hash;\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "range_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1210-1216",
    "snippet": "Datum\nrange_gt(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp > 0);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp > 0"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1140-1183",
          "snippet": "Datum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_gt(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp > 0);\n}"
  },
  {
    "function_name": "range_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1202-1208",
    "snippet": "Datum\nrange_ge(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp >= 0);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp >= 0"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1140-1183",
          "snippet": "Datum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_ge(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp >= 0);\n}"
  },
  {
    "function_name": "range_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1194-1200",
    "snippet": "Datum\nrange_le(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp <= 0);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp <= 0"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1140-1183",
          "snippet": "Datum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_le(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp <= 0);\n}"
  },
  {
    "function_name": "range_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1186-1192",
    "snippet": "Datum\nrange_lt(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp < 0);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp < 0"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1140-1183",
          "snippet": "Datum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_lt(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tcmp = range_cmp(fcinfo);\n\n\tPG_RETURN_BOOL(cmp < 0);\n}"
  },
  {
    "function_name": "range_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1140-1183",
    "snippet": "Datum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "cmp"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "r2",
            "1"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "r1",
            "0"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_cmp(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* For b-tree use, empty ranges sort before all else */\n\tif (empty1 && empty2)\n\t\tcmp = 0;\n\telse if (empty1)\n\t\tcmp = -1;\n\telse if (empty2)\n\t\tcmp = 1;\n\telse\n\t{\n\t\tcmp = range_cmp_bounds(typcache, &lower1, &lower2);\n\t\tif (cmp == 0)\n\t\t\tcmp = range_cmp_bounds(typcache, &upper1, &upper2);\n\t}\n\n\tPG_FREE_IF_COPY(r1, 0);\n\tPG_FREE_IF_COPY(r2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
  },
  {
    "function_name": "range_intersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1097-1135",
    "snippet": "Datum\nrange_intersect(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 || empty2 || !DatumGetBool(range_overlaps(fcinfo)))\n\t\tPG_RETURN_RANGE_P(make_empty_range(typcache));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\tPG_RETURN_RANGE_P(make_range(typcache, result_lower, result_upper, false));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "make_range(typcache, result_lower, result_upper, false)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "result_lower",
            "result_upper",
            "false"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "make_empty_range(typcache)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_empty_range",
          "args": [
            "typcache"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1940-1957",
          "snippet": "RangeType *\nmake_empty_range(TypeCacheEntry *typcache)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tlower.val = (Datum) 0;\n\tlower.infinite = false;\n\tlower.inclusive = false;\n\tlower.lower = true;\n\n\tupper.val = (Datum) 0;\n\tupper.infinite = false;\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\treturn make_range(typcache, &lower, &upper, true);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nRangeType *\nmake_empty_range(TypeCacheEntry *typcache)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tlower.val = (Datum) 0;\n\tlower.infinite = false;\n\tlower.inclusive = false;\n\tlower.lower = true;\n\n\tupper.val = (Datum) 0;\n\tupper.infinite = false;\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\treturn make_range(typcache, &lower, &upper, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "range_overlaps(fcinfo)"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overlaps",
          "args": [
            "fcinfo"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "856-866",
          "snippet": "Datum\nrange_overlaps(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overlaps_internal(typcache, r1, r2));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_overlaps(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overlaps_internal(typcache, r1, r2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_intersect(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 || empty2 || !DatumGetBool(range_overlaps(fcinfo)))\n\t\tPG_RETURN_RANGE_P(make_empty_range(typcache));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\tPG_RETURN_RANGE_P(make_range(typcache, result_lower, result_upper, false));\n}"
  },
  {
    "function_name": "range_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1084-1094",
    "snippet": "Datum\nrange_merge(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_RANGE_P(range_union_internal(typcache, r1, r2, false));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range_union_internal(typcache, r1, r2, false)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_union_internal",
          "args": [
            "typcache",
            "r1",
            "r2",
            "false"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "range_union_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1022-1066",
          "snippet": "static RangeType *\nrange_union_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,\n\t\t\t\t\t bool strict)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, the other is the correct answer */\n\tif (empty1)\n\t\treturn r2;\n\tif (empty2)\n\t\treturn r1;\n\n\tif (strict &&\n\t\t!DatumGetBool(range_overlaps_internal(typcache, r1, r2)) &&\n\t\t!DatumGetBool(range_adjacent_internal(typcache, r1, r2)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\")));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) < 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) > 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\treturn make_range(typcache, result_lower, result_upper, false);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeType *\nrange_union_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,\n\t\t\t\t\t bool strict)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, the other is the correct answer */\n\tif (empty1)\n\t\treturn r2;\n\tif (empty2)\n\t\treturn r1;\n\n\tif (strict &&\n\t\t!DatumGetBool(range_overlaps_internal(typcache, r1, r2)) &&\n\t\t!DatumGetBool(range_adjacent_internal(typcache, r1, r2)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\")));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) < 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) > 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\treturn make_range(typcache, result_lower, result_upper, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_merge(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_RANGE_P(range_union_internal(typcache, r1, r2, false));\n}"
  },
  {
    "function_name": "range_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1068-1078",
    "snippet": "Datum\nrange_union(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_RANGE_P(range_union_internal(typcache, r1, r2, true));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range_union_internal(typcache, r1, r2, true)"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_union_internal",
          "args": [
            "typcache",
            "r1",
            "r2",
            "true"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "range_union_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1022-1066",
          "snippet": "static RangeType *\nrange_union_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,\n\t\t\t\t\t bool strict)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, the other is the correct answer */\n\tif (empty1)\n\t\treturn r2;\n\tif (empty2)\n\t\treturn r1;\n\n\tif (strict &&\n\t\t!DatumGetBool(range_overlaps_internal(typcache, r1, r2)) &&\n\t\t!DatumGetBool(range_adjacent_internal(typcache, r1, r2)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\")));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) < 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) > 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\treturn make_range(typcache, result_lower, result_upper, false);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeType *\nrange_union_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,\n\t\t\t\t\t bool strict)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, the other is the correct answer */\n\tif (empty1)\n\t\treturn r2;\n\tif (empty2)\n\t\treturn r1;\n\n\tif (strict &&\n\t\t!DatumGetBool(range_overlaps_internal(typcache, r1, r2)) &&\n\t\t!DatumGetBool(range_adjacent_internal(typcache, r1, r2)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\")));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) < 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) > 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\treturn make_range(typcache, result_lower, result_upper, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_union(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_RANGE_P(range_union_internal(typcache, r1, r2, true));\n}"
  },
  {
    "function_name": "range_union_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "1022-1066",
    "snippet": "static RangeType *\nrange_union_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,\n\t\t\t\t\t bool strict)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, the other is the correct answer */\n\tif (empty1)\n\t\treturn r2;\n\tif (empty2)\n\t\treturn r1;\n\n\tif (strict &&\n\t\t!DatumGetBool(range_overlaps_internal(typcache, r1, r2)) &&\n\t\t!DatumGetBool(range_adjacent_internal(typcache, r1, r2)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\")));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) < 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) > 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\treturn make_range(typcache, result_lower, result_upper, false);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "result_lower",
            "result_upper",
            "false"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\"))"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"result of range union would not be contiguous\""
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "range_adjacent_internal(typcache, r1, r2)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_adjacent_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "range_adjacent_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "780-807",
          "snippet": "bool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "range_overlaps_internal(typcache, r1, r2)"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overlaps_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "823-853",
          "snippet": "bool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeType *\nrange_union_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2,\n\t\t\t\t\t bool strict)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, the other is the correct answer */\n\tif (empty1)\n\t\treturn r2;\n\tif (empty2)\n\t\treturn r1;\n\n\tif (strict &&\n\t\t!DatumGetBool(range_overlaps_internal(typcache, r1, r2)) &&\n\t\t!DatumGetBool(range_adjacent_internal(typcache, r1, r2)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range union would not be contiguous\")));\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) < 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) > 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\treturn make_range(typcache, result_lower, result_upper, false);\n}"
  },
  {
    "function_name": "range_minus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "954-1016",
    "snippet": "Datum\nrange_minus(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp_l1l2,\n\t\t\t\tcmp_l1u2,\n\t\t\t\tcmp_u1l2,\n\t\t\t\tcmp_u1u2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, r1 is the correct answer */\n\tif (empty1 || empty2)\n\t\tPG_RETURN_RANGE_P(r1);\n\n\tcmp_l1l2 = range_cmp_bounds(typcache, &lower1, &lower2);\n\tcmp_l1u2 = range_cmp_bounds(typcache, &lower1, &upper2);\n\tcmp_u1l2 = range_cmp_bounds(typcache, &upper1, &lower2);\n\tcmp_u1u2 = range_cmp_bounds(typcache, &upper1, &upper2);\n\n\tif (cmp_l1l2 < 0 && cmp_u1u2 > 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range difference would not be contiguous\")));\n\n\tif (cmp_l1u2 > 0 || cmp_u1l2 < 0)\n\t\tPG_RETURN_RANGE_P(r1);\n\n\tif (cmp_l1l2 >= 0 && cmp_u1u2 <= 0)\n\t\tPG_RETURN_RANGE_P(make_empty_range(typcache));\n\n\tif (cmp_l1l2 <= 0 && cmp_u1l2 >= 0 && cmp_u1u2 <= 0)\n\t{\n\t\tlower2.inclusive = !lower2.inclusive;\n\t\tlower2.lower = false;\t/* it will become the upper bound */\n\t\tPG_RETURN_RANGE_P(make_range(typcache, &lower1, &lower2, false));\n\t}\n\n\tif (cmp_l1l2 >= 0 && cmp_u1u2 >= 0 && cmp_l1u2 <= 0)\n\t{\n\t\tupper2.inclusive = !upper2.inclusive;\n\t\tupper2.lower = true;\t/* it will become the lower bound */\n\t\tPG_RETURN_RANGE_P(make_range(typcache, &upper2, &upper1, false));\n\t}\n\n\telog(ERROR, \"unexpected case in range_minus\");\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected case in range_minus\""
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "make_range(typcache, &upper2, &upper1, false)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "&upper2",
            "&upper1",
            "false"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "make_range(typcache, &lower1, &lower2, false)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "make_empty_range(typcache)"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_empty_range",
          "args": [
            "typcache"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1940-1957",
          "snippet": "RangeType *\nmake_empty_range(TypeCacheEntry *typcache)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tlower.val = (Datum) 0;\n\tlower.infinite = false;\n\tlower.inclusive = false;\n\tlower.lower = true;\n\n\tupper.val = (Datum) 0;\n\tupper.infinite = false;\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\treturn make_range(typcache, &lower, &upper, true);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nRangeType *\nmake_empty_range(TypeCacheEntry *typcache)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tlower.val = (Datum) 0;\n\tlower.infinite = false;\n\tlower.inclusive = false;\n\tlower.lower = true;\n\n\tupper.val = (Datum) 0;\n\tupper.infinite = false;\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\treturn make_range(typcache, &lower, &upper, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "r1"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range difference would not be contiguous\"))"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"result of range difference would not be contiguous\""
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "r1"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_minus(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tint\t\t\tcmp_l1l2,\n\t\t\t\tcmp_l1u2,\n\t\t\t\tcmp_u1l2,\n\t\t\t\tcmp_u1u2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* if either is empty, r1 is the correct answer */\n\tif (empty1 || empty2)\n\t\tPG_RETURN_RANGE_P(r1);\n\n\tcmp_l1l2 = range_cmp_bounds(typcache, &lower1, &lower2);\n\tcmp_l1u2 = range_cmp_bounds(typcache, &lower1, &upper2);\n\tcmp_u1l2 = range_cmp_bounds(typcache, &upper1, &lower2);\n\tcmp_u1u2 = range_cmp_bounds(typcache, &upper1, &upper2);\n\n\tif (cmp_l1l2 < 0 && cmp_u1u2 > 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"result of range difference would not be contiguous\")));\n\n\tif (cmp_l1u2 > 0 || cmp_u1l2 < 0)\n\t\tPG_RETURN_RANGE_P(r1);\n\n\tif (cmp_l1l2 >= 0 && cmp_u1u2 <= 0)\n\t\tPG_RETURN_RANGE_P(make_empty_range(typcache));\n\n\tif (cmp_l1l2 <= 0 && cmp_u1l2 >= 0 && cmp_u1u2 <= 0)\n\t{\n\t\tlower2.inclusive = !lower2.inclusive;\n\t\tlower2.lower = false;\t/* it will become the upper bound */\n\t\tPG_RETURN_RANGE_P(make_range(typcache, &lower1, &lower2, false));\n\t}\n\n\tif (cmp_l1l2 >= 0 && cmp_u1u2 >= 0 && cmp_l1u2 <= 0)\n\t{\n\t\tupper2.inclusive = !upper2.inclusive;\n\t\tupper2.lower = true;\t/* it will become the lower bound */\n\t\tPG_RETURN_RANGE_P(make_range(typcache, &upper2, &upper1, false));\n\t}\n\n\telog(ERROR, \"unexpected case in range_minus\");\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "range_overright",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "938-948",
    "snippet": "Datum\nrange_overright(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overright_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_overright_internal(typcache, r1, r2)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overright_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "range_overright_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "910-935",
          "snippet": "bool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_overright(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overright_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_overright_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "910-935",
    "snippet": "bool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&lower1",
            "&lower2"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "range_overleft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "897-907",
    "snippet": "Datum\nrange_overleft(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overleft_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_overleft_internal(typcache, r1, r2)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overleft_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "range_overleft_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "869-894",
          "snippet": "bool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_overleft(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overleft_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_overleft_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "869-894",
    "snippet": "bool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "range_overlaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "856-866",
    "snippet": "Datum\nrange_overlaps(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overlaps_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_overlaps_internal(typcache, r1, r2)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overlaps_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "823-853",
          "snippet": "bool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_overlaps(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_overlaps_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_overlaps_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "823-853",
    "snippet": "bool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&lower2",
            "&upper1"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "range_adjacent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "810-820",
    "snippet": "Datum\nrange_adjacent(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_adjacent_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_adjacent_internal(typcache, r1, r2)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_adjacent_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "range_adjacent_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "780-807",
          "snippet": "bool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_adjacent(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_adjacent_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_adjacent_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "780-807",
    "snippet": "bool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bounds_adjacent",
          "args": [
            "typcache",
            "upper2",
            "lower1"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "bounds_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "739-777",
          "snippet": "bool\nbounds_adjacent(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)\n{\n\tint\t\t\tcmp;\n\n\tAssert(!boundA.lower && boundB.lower);\n\n\tcmp = range_cmp_bound_values(typcache, &boundA, &boundB);\n\tif (cmp < 0)\n\t{\n\t\tRangeType  *r;\n\n\t\t/*\n\t\t * Bounds do not overlap; see if there are points in between.\n\t\t */\n\n\t\t/* in a continuous subtype, there are assumed to be points between */\n\t\tif (!OidIsValid(typcache->rng_canonical_finfo.fn_oid))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * The bounds are of a discrete range type; so make a range A..B and\n\t\t * see if it's empty.\n\t\t */\n\n\t\t/* flip the inclusion flags */\n\t\tboundA.inclusive = !boundA.inclusive;\n\t\tboundB.inclusive = !boundB.inclusive;\n\t\t/* change upper/lower labels to avoid Assert failures */\n\t\tboundA.lower = true;\n\t\tboundB.lower = false;\n\t\tr = make_range(typcache, &boundA, &boundB, false);\n\t\treturn RangeIsEmpty(r);\n\t}\n\telse if (cmp == 0)\n\t\treturn boundA.inclusive != boundB.inclusive;\n\telse\n\t\treturn false;\t\t\t/* bounds overlap */\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nbounds_adjacent(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)\n{\n\tint\t\t\tcmp;\n\n\tAssert(!boundA.lower && boundB.lower);\n\n\tcmp = range_cmp_bound_values(typcache, &boundA, &boundB);\n\tif (cmp < 0)\n\t{\n\t\tRangeType  *r;\n\n\t\t/*\n\t\t * Bounds do not overlap; see if there are points in between.\n\t\t */\n\n\t\t/* in a continuous subtype, there are assumed to be points between */\n\t\tif (!OidIsValid(typcache->rng_canonical_finfo.fn_oid))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * The bounds are of a discrete range type; so make a range A..B and\n\t\t * see if it's empty.\n\t\t */\n\n\t\t/* flip the inclusion flags */\n\t\tboundA.inclusive = !boundA.inclusive;\n\t\tboundB.inclusive = !boundB.inclusive;\n\t\t/* change upper/lower labels to avoid Assert failures */\n\t\tboundA.lower = true;\n\t\tboundB.lower = false;\n\t\tr = make_range(typcache, &boundA, &boundB, false);\n\t\treturn RangeIsEmpty(r);\n\t}\n\telse if (cmp == 0)\n\t\treturn boundA.inclusive != boundB.inclusive;\n\telse\n\t\treturn false;\t\t\t/* bounds overlap */\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}"
  },
  {
    "function_name": "bounds_adjacent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "739-777",
    "snippet": "bool\nbounds_adjacent(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)\n{\n\tint\t\t\tcmp;\n\n\tAssert(!boundA.lower && boundB.lower);\n\n\tcmp = range_cmp_bound_values(typcache, &boundA, &boundB);\n\tif (cmp < 0)\n\t{\n\t\tRangeType  *r;\n\n\t\t/*\n\t\t * Bounds do not overlap; see if there are points in between.\n\t\t */\n\n\t\t/* in a continuous subtype, there are assumed to be points between */\n\t\tif (!OidIsValid(typcache->rng_canonical_finfo.fn_oid))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * The bounds are of a discrete range type; so make a range A..B and\n\t\t * see if it's empty.\n\t\t */\n\n\t\t/* flip the inclusion flags */\n\t\tboundA.inclusive = !boundA.inclusive;\n\t\tboundB.inclusive = !boundB.inclusive;\n\t\t/* change upper/lower labels to avoid Assert failures */\n\t\tboundA.lower = true;\n\t\tboundB.lower = false;\n\t\tr = make_range(typcache, &boundA, &boundB, false);\n\t\treturn RangeIsEmpty(r);\n\t}\n\telse if (cmp == 0)\n\t\treturn boundA.inclusive != boundB.inclusive;\n\telse\n\t\treturn false;\t\t\t/* bounds overlap */\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "r"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "&boundA",
            "&boundB",
            "false"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_canonical_finfo.fn_oid"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp_bound_values",
          "args": [
            "typcache",
            "&boundA",
            "&boundB"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bound_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1905-1935",
          "snippet": "int\nrange_cmp_bound_values(TypeCacheEntry *typcache, RangeBound *b1,\n\t\t\t\t\t   RangeBound *b2)\n{\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\treturn DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bound_values(TypeCacheEntry *typcache, RangeBound *b1,\n\t\t\t\t\t   RangeBound *b2)\n{\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\treturn DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t   typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t   b1->val, b2->val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!boundA.lower && boundB.lower"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nbounds_adjacent(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)\n{\n\tint\t\t\tcmp;\n\n\tAssert(!boundA.lower && boundB.lower);\n\n\tcmp = range_cmp_bound_values(typcache, &boundA, &boundB);\n\tif (cmp < 0)\n\t{\n\t\tRangeType  *r;\n\n\t\t/*\n\t\t * Bounds do not overlap; see if there are points in between.\n\t\t */\n\n\t\t/* in a continuous subtype, there are assumed to be points between */\n\t\tif (!OidIsValid(typcache->rng_canonical_finfo.fn_oid))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * The bounds are of a discrete range type; so make a range A..B and\n\t\t * see if it's empty.\n\t\t */\n\n\t\t/* flip the inclusion flags */\n\t\tboundA.inclusive = !boundA.inclusive;\n\t\tboundB.inclusive = !boundB.inclusive;\n\t\t/* change upper/lower labels to avoid Assert failures */\n\t\tboundA.lower = true;\n\t\tboundB.lower = false;\n\t\tr = make_range(typcache, &boundA, &boundB, false);\n\t\treturn RangeIsEmpty(r);\n\t}\n\telse if (cmp == 0)\n\t\treturn boundA.inclusive != boundB.inclusive;\n\telse\n\t\treturn false;\t\t\t/* bounds overlap */\n}"
  },
  {
    "function_name": "range_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "709-719",
    "snippet": "Datum\nrange_after(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_after_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_after_internal(typcache, r1, r2)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_after_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "range_after_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "684-706",
          "snippet": "bool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_after(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_after_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_after_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "684-706",
    "snippet": "bool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&lower1",
            "&upper2"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}"
  },
  {
    "function_name": "range_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "671-681",
    "snippet": "Datum\nrange_before(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_before_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_before_internal(typcache, r1, r2)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_before_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "range_before_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "646-668",
          "snippet": "bool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_before(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_before_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_before_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "646-668",
    "snippet": "bool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&lower2"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}"
  },
  {
    "function_name": "range_contained_by",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "633-643",
    "snippet": "Datum\nrange_contained_by(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_contained_by_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_contained_by_internal(typcache, r1, r2)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contained_by_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "range_contained_by_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2331-2335",
          "snippet": "bool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_contained_by(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_contained_by_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "620-630",
    "snippet": "Datum\nrange_contains(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_contains_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_contains_internal(typcache, r1, r2)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2299-2329",
          "snippet": "bool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_contains(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_contains_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "607-617",
    "snippet": "Datum\nrange_ne(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_ne_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_ne_internal(typcache, r1, r2)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_ne_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "range_ne_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "600-604",
          "snippet": "bool\nrange_ne_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn (!range_eq_internal(typcache, r1, r2));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_ne_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn (!range_eq_internal(typcache, r1, r2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_ne(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_ne_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_ne_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "600-604",
    "snippet": "bool\nrange_ne_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn (!range_eq_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_eq_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "range_eq_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "555-584",
          "snippet": "bool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_ne_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn (!range_eq_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "587-597",
    "snippet": "Datum\nrange_eq(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_eq_internal(typcache, r1, r2));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_eq_internal(typcache, r1, r2)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_eq_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "range_eq_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "555-584",
          "snippet": "bool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_eq(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\tPG_RETURN_BOOL(range_eq_internal(typcache, r1, r2));\n}"
  },
  {
    "function_name": "range_eq_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "555-584",
    "snippet": "bool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r2"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "elem_contained_by_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "539-549",
    "snippet": "Datum\nelem_contained_by_range(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tval = PG_GETARG_DATUM(0);\n\tRangeType  *r = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\tPG_RETURN_BOOL(range_contains_elem_internal(typcache, r, val));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_contains_elem_internal(typcache, r, val)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_elem_internal",
          "args": [
            "typcache",
            "r",
            "val"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_elem_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2340-2376",
          "snippet": "bool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nbool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nelem_contained_by_range(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tval = PG_GETARG_DATUM(0);\n\tRangeType  *r = PG_GETARG_RANGE_P(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\tPG_RETURN_BOOL(range_contains_elem_internal(typcache, r, val));\n}"
  },
  {
    "function_name": "range_contains_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "526-536",
    "snippet": "Datum\nrange_contains_elem(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tDatum\t\tval = PG_GETARG_DATUM(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\tPG_RETURN_BOOL(range_contains_elem_internal(typcache, r, val));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_contains_elem_internal(typcache, r, val)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_elem_internal",
          "args": [
            "typcache",
            "r",
            "val"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_elem_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2340-2376",
          "snippet": "bool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nbool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r)"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_contains_elem(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r = PG_GETARG_RANGE_P(0);\n\tDatum\t\tval = PG_GETARG_DATUM(1);\n\tTypeCacheEntry *typcache;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r));\n\n\tPG_RETURN_BOOL(range_contains_elem_internal(typcache, r, val));\n}"
  },
  {
    "function_name": "range_upper_inf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "513-520",
    "snippet": "Datum\nrange_upper_inf(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_UB_INF);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "flags & RANGE_UB_INF"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r1"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_upper_inf(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_UB_INF);\n}"
  },
  {
    "function_name": "range_lower_inf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "503-510",
    "snippet": "Datum\nrange_lower_inf(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_LB_INF);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "flags & RANGE_LB_INF"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r1"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_lower_inf(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_LB_INF);\n}"
  },
  {
    "function_name": "range_upper_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "493-500",
    "snippet": "Datum\nrange_upper_inc(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_UB_INC);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "flags & RANGE_UB_INC"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r1"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_upper_inc(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_UB_INC);\n}"
  },
  {
    "function_name": "range_lower_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "483-490",
    "snippet": "Datum\nrange_lower_inc(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_LB_INC);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "flags & RANGE_LB_INC"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r1"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_lower_inc(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_LB_INC);\n}"
  },
  {
    "function_name": "range_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "473-480",
    "snippet": "Datum\nrange_empty(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_EMPTY);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "flags & RANGE_EMPTY"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r1"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_empty(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tchar\t\tflags = range_get_flags(r1);\n\n\tPG_RETURN_BOOL(flags & RANGE_EMPTY);\n}"
  },
  {
    "function_name": "range_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "449-467",
    "snippet": "Datum\nrange_upper(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower, &upper, &empty);\n\n\t/* Return NULL if there's no finite upper bound */\n\tif (empty || upper.infinite)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_DATUM(upper.val);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "upper.val"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r1",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nrange_upper(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower, &upper, &empty);\n\n\t/* Return NULL if there's no finite upper bound */\n\tif (empty || upper.infinite)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_DATUM(upper.val);\n}"
  },
  {
    "function_name": "range_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "428-446",
    "snippet": "Datum\nrange_lower(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower, &upper, &empty);\n\n\t/* Return NULL if there's no finite lower bound */\n\tif (empty || lower.infinite)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_DATUM(lower.val);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "lower.val"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r1",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nrange_lower(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\trange_deserialize(typcache, r1, &lower, &upper, &empty);\n\n\t/* Return NULL if there's no finite lower bound */\n\tif (empty || lower.infinite)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_DATUM(lower.val);\n}"
  },
  {
    "function_name": "range_constructor3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "388-422",
    "snippet": "Datum\nrange_constructor3(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tOid\t\t\trngtypid = get_fn_expr_rettype(fcinfo->flinfo);\n\tRangeType  *range;\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tchar\t\tflags;\n\n\ttypcache = range_get_typcache(fcinfo, rngtypid);\n\n\tif (PG_ARGISNULL(2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"range constructor flags argument must not be null\")));\n\n\tflags = range_parse_flags(text_to_cstring(PG_GETARG_TEXT_PP(2)));\n\n\tlower.val = PG_ARGISNULL(0) ? (Datum) 0 : arg1;\n\tlower.infinite = PG_ARGISNULL(0);\n\tlower.inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower.lower = true;\n\n\tupper.val = PG_ARGISNULL(1) ? (Datum) 0 : arg2;\n\tupper.infinite = PG_ARGISNULL(1);\n\tupper.inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper.lower = false;\n\n\trange = make_range(typcache, &lower, &upper, false);\n\n\tPG_RETURN_RANGE_P(range);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "false"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_parse_flags",
          "args": [
            "text_to_cstring(PG_GETARG_TEXT_PP(2))"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "range_parse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1970-2012",
          "snippet": "static char\nrange_parse_flags(const char *flags_str)\n{\n\tchar\t\tflags = 0;\n\n\tif (flags_str[0] == '\\0' ||\n\t\tflags_str[1] == '\\0' ||\n\t\tflags_str[2] != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\n\tswitch (flags_str[0])\n\t{\n\t\tcase '[':\n\t\t\tflags |= RANGE_LB_INC;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\tswitch (flags_str[1])\n\t{\n\t\tcase ']':\n\t\t\tflags |= RANGE_UB_INC;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\treturn flags;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char range_parse_flags(const char *flags_str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char range_parse_flags(const char *flags_str);\n\nstatic char\nrange_parse_flags(const char *flags_str)\n{\n\tchar\t\tflags = 0;\n\n\tif (flags_str[0] == '\\0' ||\n\t\tflags_str[1] == '\\0' ||\n\t\tflags_str[2] != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\n\tswitch (flags_str[0])\n\t{\n\t\tcase '[':\n\t\t\tflags |= RANGE_LB_INC;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\tswitch (flags_str[1])\n\t{\n\t\tcase ']':\n\t\t\tflags |= RANGE_UB_INC;\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"invalid range bound flags\"),\n\t\t\t\t\t errhint(\"Valid values are \\\"[]\\\", \\\"[)\\\", \\\"(]\\\", and \\\"()\\\".\")));\n\t}\n\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(2)"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"range constructor flags argument must not be null\"))"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"range constructor flags argument must not be null\""
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "rngtypid"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_rettype",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_rettype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1972-1987",
          "snippet": "Oid\nget_fn_expr_rettype(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\texpr = flinfo->fn_expr;\n\n\treturn exprType(expr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_rettype(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\texpr = flinfo->fn_expr;\n\n\treturn exprType(expr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nrange_constructor3(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tOid\t\t\trngtypid = get_fn_expr_rettype(fcinfo->flinfo);\n\tRangeType  *range;\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tchar\t\tflags;\n\n\ttypcache = range_get_typcache(fcinfo, rngtypid);\n\n\tif (PG_ARGISNULL(2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"range constructor flags argument must not be null\")));\n\n\tflags = range_parse_flags(text_to_cstring(PG_GETARG_TEXT_PP(2)));\n\n\tlower.val = PG_ARGISNULL(0) ? (Datum) 0 : arg1;\n\tlower.infinite = PG_ARGISNULL(0);\n\tlower.inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower.lower = true;\n\n\tupper.val = PG_ARGISNULL(1) ? (Datum) 0 : arg2;\n\tupper.infinite = PG_ARGISNULL(1);\n\tupper.inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper.lower = false;\n\n\trange = make_range(typcache, &lower, &upper, false);\n\n\tPG_RETURN_RANGE_P(range);\n}"
  },
  {
    "function_name": "range_constructor2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "359-385",
    "snippet": "Datum\nrange_constructor2(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tOid\t\t\trngtypid = get_fn_expr_rettype(fcinfo->flinfo);\n\tRangeType  *range;\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\ttypcache = range_get_typcache(fcinfo, rngtypid);\n\n\tlower.val = PG_ARGISNULL(0) ? (Datum) 0 : arg1;\n\tlower.infinite = PG_ARGISNULL(0);\n\tlower.inclusive = true;\n\tlower.lower = true;\n\n\tupper.val = PG_ARGISNULL(1) ? (Datum) 0 : arg2;\n\tupper.infinite = PG_ARGISNULL(1);\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\trange = make_range(typcache, &lower, &upper, false);\n\n\tPG_RETURN_RANGE_P(range);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "false"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "rngtypid"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_rettype",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_rettype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1972-1987",
          "snippet": "Oid\nget_fn_expr_rettype(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\texpr = flinfo->fn_expr;\n\n\treturn exprType(expr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_rettype(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\texpr = flinfo->fn_expr;\n\n\treturn exprType(expr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nrange_constructor2(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tOid\t\t\trngtypid = get_fn_expr_rettype(fcinfo->flinfo);\n\tRangeType  *range;\n\tTypeCacheEntry *typcache;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\ttypcache = range_get_typcache(fcinfo, rngtypid);\n\n\tlower.val = PG_ARGISNULL(0) ? (Datum) 0 : arg1;\n\tlower.infinite = PG_ARGISNULL(0);\n\tlower.inclusive = true;\n\tlower.lower = true;\n\n\tupper.val = PG_ARGISNULL(1) ? (Datum) 0 : arg2;\n\tupper.infinite = PG_ARGISNULL(1);\n\tupper.inclusive = false;\n\tupper.lower = false;\n\n\trange = make_range(typcache, &lower, &upper, false);\n\n\tPG_RETURN_RANGE_P(range);\n}"
  },
  {
    "function_name": "get_range_io_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "300-349",
    "snippet": "static RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "cache->typiofunc",
            "&cache->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id)))"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"no binary output function available for type %s\"",
            "format_type_be(cache->typcache->rngelemtype->type_id)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "cache->typcache->rngelemtype->type_id"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id)))"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "cache->typiofunc"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_type_io_data",
          "args": [
            "cache->typcache->rngelemtype->type_id",
            "func",
            "&typlen",
            "&typbyval",
            "&typalign",
            "&typdelim",
            "&cache->typioparam",
            "&cache->typiofunc"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2102-2173",
          "snippet": "void\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"type %u is not a range type\"",
            "rngtypid"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "rngtypid",
            "TYPECACHE_RANGE_INFO"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(RangeIOData)"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);\n\nstatic RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}"
  },
  {
    "function_name": "range_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "244-291",
    "snippet": "Datum\nrange_send(PG_FUNCTION_ARGS)\n{\n\tRangeType  *range = PG_GETARG_RANGE_P(0);\n\tStringInfo\tbuf = makeStringInfo();\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, RangeTypeGetOid(range), IOFunc_send);\n\n\t/* deserialize */\n\trange_deserialize(cache->typcache, range, &lower, &upper, &empty);\n\tflags = range_get_flags(range);\n\n\t/* construct output */\n\tpq_begintypsend(buf);\n\n\tpq_sendbyte(buf, flags);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tDatum\t\tbound = PointerGetDatum(SendFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t lower.val));\n\t\tuint32\t\tbound_len = VARSIZE(bound) - VARHDRSZ;\n\t\tchar\t   *bound_data = VARDATA(bound);\n\n\t\tpq_sendint32(buf, bound_len);\n\t\tpq_sendbytes(buf, bound_data, bound_len);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tDatum\t\tbound = PointerGetDatum(SendFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t upper.val));\n\t\tuint32\t\tbound_len = VARSIZE(bound) - VARHDRSZ;\n\t\tchar\t   *bound_data = VARDATA(bound);\n\n\t\tpq_sendint32(buf, bound_len);\n\t\tpq_sendbytes(buf, bound_data, bound_len);\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(buf));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(buf)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "buf"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbytes",
          "args": [
            "buf",
            "bound_data",
            "bound_len"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "buf",
            "bound_len"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "bound"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "bound"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "SendFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t upper.val)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendFunctionCall",
          "args": [
            "&cache->proc",
            "upper.val"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "OidSendFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1851-1858",
          "snippet": "bytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbytes",
          "args": [
            "buf",
            "bound_data",
            "bound_len"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "buf",
            "bound_len"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "bound"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "bound"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "SendFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t lower.val)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "buf",
            "flags"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "buf"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "range"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "cache->typcache",
            "range",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_range_io_data",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(range)",
            "IOFunc_send"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "get_range_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "300-349",
          "snippet": "static RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);\n\nstatic RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "range"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nrange_send(PG_FUNCTION_ARGS)\n{\n\tRangeType  *range = PG_GETARG_RANGE_P(0);\n\tStringInfo\tbuf = makeStringInfo();\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, RangeTypeGetOid(range), IOFunc_send);\n\n\t/* deserialize */\n\trange_deserialize(cache->typcache, range, &lower, &upper, &empty);\n\tflags = range_get_flags(range);\n\n\t/* construct output */\n\tpq_begintypsend(buf);\n\n\tpq_sendbyte(buf, flags);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tDatum\t\tbound = PointerGetDatum(SendFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t lower.val));\n\t\tuint32\t\tbound_len = VARSIZE(bound) - VARHDRSZ;\n\t\tchar\t   *bound_data = VARDATA(bound);\n\n\t\tpq_sendint32(buf, bound_len);\n\t\tpq_sendbytes(buf, bound_data, bound_len);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tDatum\t\tbound = PointerGetDatum(SendFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t upper.val));\n\t\tuint32\t\tbound_len = VARSIZE(bound) - VARHDRSZ;\n\t\tchar\t   *bound_data = VARDATA(bound);\n\n\t\tpq_sendint32(buf, bound_len);\n\t\tpq_sendbytes(buf, bound_data, bound_len);\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(buf));\n}"
  },
  {
    "function_name": "range_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "161-242",
    "snippet": "Datum\nrange_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\trngtypoid = PG_GETARG_OID(1);\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tRangeType  *range;\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, rngtypoid, IOFunc_receive);\n\n\t/* receive the flags... */\n\tflags = (unsigned char) pq_getmsgbyte(buf);\n\n\t/*\n\t * Mask out any unsupported flags, particularly RANGE_xB_NULL which would\n\t * confuse following tests.  Note that range_serialize will take care of\n\t * cleaning up any inconsistencies in the remaining flags.\n\t */\n\tflags &= (RANGE_EMPTY |\n\t\t\t  RANGE_LB_INC |\n\t\t\t  RANGE_LB_INF |\n\t\t\t  RANGE_UB_INC |\n\t\t\t  RANGE_UB_INF);\n\n\t/* receive the bounds ... */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tuint32\t\tbound_len = pq_getmsgint(buf, 4);\n\t\tconst char *bound_data = pq_getmsgbytes(buf, bound_len);\n\t\tStringInfoData bound_buf;\n\n\t\tinitStringInfo(&bound_buf);\n\t\tappendBinaryStringInfo(&bound_buf, bound_data, bound_len);\n\n\t\tlower.val = ReceiveFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t&bound_buf,\n\t\t\t\t\t\t\t\t\t\tcache->typioparam,\n\t\t\t\t\t\t\t\t\t\ttypmod);\n\t\tpfree(bound_buf.data);\n\t}\n\telse\n\t\tlower.val = (Datum) 0;\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tuint32\t\tbound_len = pq_getmsgint(buf, 4);\n\t\tconst char *bound_data = pq_getmsgbytes(buf, bound_len);\n\t\tStringInfoData bound_buf;\n\n\t\tinitStringInfo(&bound_buf);\n\t\tappendBinaryStringInfo(&bound_buf, bound_data, bound_len);\n\n\t\tupper.val = ReceiveFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t&bound_buf,\n\t\t\t\t\t\t\t\t\t\tcache->typioparam,\n\t\t\t\t\t\t\t\t\t\ttypmod);\n\t\tpfree(bound_buf.data);\n\t}\n\telse\n\t\tupper.val = (Datum) 0;\n\n\tpq_getmsgend(buf);\n\n\t/* finish constructing RangeBound representation */\n\tlower.infinite = (flags & RANGE_LB_INF) != 0;\n\tlower.inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower.lower = true;\n\tupper.infinite = (flags & RANGE_UB_INF) != 0;\n\tupper.inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper.lower = false;\n\n\t/* serialize and canonicalize */\n\trange = make_range(cache->typcache, &lower, &upper, flags & RANGE_EMPTY);\n\n\tPG_RETURN_RANGE_P(range);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "cache->typcache",
            "&lower",
            "&upper",
            "flags & RANGE_EMPTY"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgend",
          "args": [
            "buf"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "bound_buf.data"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReceiveFunctionCall",
          "args": [
            "&cache->proc",
            "&bound_buf",
            "cache->typioparam",
            "typmod"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "OidReceiveFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1841-1849",
          "snippet": "Datum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&bound_buf",
            "bound_data",
            "bound_len"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&bound_buf"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbytes",
          "args": [
            "buf",
            "bound_len"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&bound_buf",
            "bound_data",
            "bound_len"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&bound_buf"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbytes",
          "args": [
            "buf",
            "bound_len"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_range_io_data",
          "args": [
            "fcinfo",
            "rngtypoid",
            "IOFunc_receive"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "get_range_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "300-349",
          "snippet": "static RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);\n\nstatic RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nDatum\nrange_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\trngtypoid = PG_GETARG_OID(1);\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tRangeType  *range;\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, rngtypoid, IOFunc_receive);\n\n\t/* receive the flags... */\n\tflags = (unsigned char) pq_getmsgbyte(buf);\n\n\t/*\n\t * Mask out any unsupported flags, particularly RANGE_xB_NULL which would\n\t * confuse following tests.  Note that range_serialize will take care of\n\t * cleaning up any inconsistencies in the remaining flags.\n\t */\n\tflags &= (RANGE_EMPTY |\n\t\t\t  RANGE_LB_INC |\n\t\t\t  RANGE_LB_INF |\n\t\t\t  RANGE_UB_INC |\n\t\t\t  RANGE_UB_INF);\n\n\t/* receive the bounds ... */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tuint32\t\tbound_len = pq_getmsgint(buf, 4);\n\t\tconst char *bound_data = pq_getmsgbytes(buf, bound_len);\n\t\tStringInfoData bound_buf;\n\n\t\tinitStringInfo(&bound_buf);\n\t\tappendBinaryStringInfo(&bound_buf, bound_data, bound_len);\n\n\t\tlower.val = ReceiveFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t&bound_buf,\n\t\t\t\t\t\t\t\t\t\tcache->typioparam,\n\t\t\t\t\t\t\t\t\t\ttypmod);\n\t\tpfree(bound_buf.data);\n\t}\n\telse\n\t\tlower.val = (Datum) 0;\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tuint32\t\tbound_len = pq_getmsgint(buf, 4);\n\t\tconst char *bound_data = pq_getmsgbytes(buf, bound_len);\n\t\tStringInfoData bound_buf;\n\n\t\tinitStringInfo(&bound_buf);\n\t\tappendBinaryStringInfo(&bound_buf, bound_data, bound_len);\n\n\t\tupper.val = ReceiveFunctionCall(&cache->proc,\n\t\t\t\t\t\t\t\t\t\t&bound_buf,\n\t\t\t\t\t\t\t\t\t\tcache->typioparam,\n\t\t\t\t\t\t\t\t\t\ttypmod);\n\t\tpfree(bound_buf.data);\n\t}\n\telse\n\t\tupper.val = (Datum) 0;\n\n\tpq_getmsgend(buf);\n\n\t/* finish constructing RangeBound representation */\n\tlower.infinite = (flags & RANGE_LB_INF) != 0;\n\tlower.inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower.lower = true;\n\tupper.infinite = (flags & RANGE_UB_INF) != 0;\n\tupper.inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper.lower = false;\n\n\t/* serialize and canonicalize */\n\trange = make_range(cache->typcache, &lower, &upper, flags & RANGE_EMPTY);\n\n\tPG_RETURN_RANGE_P(range);\n}"
  },
  {
    "function_name": "range_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "121-152",
    "snippet": "Datum\nrange_out(PG_FUNCTION_ARGS)\n{\n\tRangeType  *range = PG_GETARG_RANGE_P(0);\n\tchar\t   *output_str;\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tchar\t   *lbound_str = NULL;\n\tchar\t   *ubound_str = NULL;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, RangeTypeGetOid(range), IOFunc_output);\n\n\t/* deserialize */\n\trange_deserialize(cache->typcache, range, &lower, &upper, &empty);\n\tflags = range_get_flags(range);\n\n\t/* call element type's output function */\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlbound_str = OutputFunctionCall(&cache->proc, lower.val);\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tubound_str = OutputFunctionCall(&cache->proc, upper.val);\n\n\t/* construct result string */\n\toutput_str = range_deparse(flags, lbound_str, ubound_str);\n\n\tPG_RETURN_CSTRING(output_str);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);",
      "static char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "output_str"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deparse",
          "args": [
            "flags",
            "lbound_str",
            "ubound_str"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "range_deparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2220-2243",
          "snippet": "static char *\nrange_deparse(char flags, const char *lbound_str, const char *ubound_str)\n{\n\tStringInfoData buf;\n\n\tif (flags & RANGE_EMPTY)\n\t\treturn pstrdup(RANGE_EMPTY_LITERAL);\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, (flags & RANGE_LB_INC) ? '[' : '(');\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(lbound_str));\n\n\tappendStringInfoChar(&buf, ',');\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(ubound_str));\n\n\tappendStringInfoChar(&buf, (flags & RANGE_UB_INC) ? ']' : ')');\n\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANGE_EMPTY_LITERAL \"empty\""
          ],
          "globals_used": [
            "static void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);",
            "static char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define RANGE_EMPTY_LITERAL \"empty\"\n\nstatic void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);\nstatic char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);\n\nstatic char *\nrange_deparse(char flags, const char *lbound_str, const char *ubound_str)\n{\n\tStringInfoData buf;\n\n\tif (flags & RANGE_EMPTY)\n\t\treturn pstrdup(RANGE_EMPTY_LITERAL);\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfoChar(&buf, (flags & RANGE_LB_INC) ? '[' : '(');\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(lbound_str));\n\n\tappendStringInfoChar(&buf, ',');\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tappendStringInfoString(&buf, range_bound_escape(ubound_str));\n\n\tappendStringInfoChar(&buf, (flags & RANGE_UB_INC) ? ']' : ')');\n\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&cache->proc",
            "upper.val"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "range"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "cache->typcache",
            "range",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_range_io_data",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(range)",
            "IOFunc_output"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "get_range_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "300-349",
          "snippet": "static RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);\n\nstatic RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "range"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);\nstatic char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);\n\nDatum\nrange_out(PG_FUNCTION_ARGS)\n{\n\tRangeType  *range = PG_GETARG_RANGE_P(0);\n\tchar\t   *output_str;\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tchar\t   *lbound_str = NULL;\n\tchar\t   *ubound_str = NULL;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, RangeTypeGetOid(range), IOFunc_output);\n\n\t/* deserialize */\n\trange_deserialize(cache->typcache, range, &lower, &upper, &empty);\n\tflags = range_get_flags(range);\n\n\t/* call element type's output function */\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlbound_str = OutputFunctionCall(&cache->proc, lower.val);\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tubound_str = OutputFunctionCall(&cache->proc, upper.val);\n\n\t/* construct result string */\n\toutput_str = range_deparse(flags, lbound_str, ubound_str);\n\n\tPG_RETURN_CSTRING(output_str);\n}"
  },
  {
    "function_name": "range_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
    "lines": "79-119",
    "snippet": "Datum\nrange_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_str = PG_GETARG_CSTRING(0);\n\tOid\t\t\trngtypoid = PG_GETARG_OID(1);\n\tOid\t\t\ttypmod = PG_GETARG_INT32(2);\n\tRangeType  *range;\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tchar\t   *lbound_str;\n\tchar\t   *ubound_str;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, rngtypoid, IOFunc_input);\n\n\t/* parse */\n\trange_parse(input_str, &flags, &lbound_str, &ubound_str);\n\n\t/* call element type's input function */\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlower.val = InputFunctionCall(&cache->proc, lbound_str,\n\t\t\t\t\t\t\t\t\t  cache->typioparam, typmod);\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tupper.val = InputFunctionCall(&cache->proc, ubound_str,\n\t\t\t\t\t\t\t\t\t  cache->typioparam, typmod);\n\n\tlower.infinite = (flags & RANGE_LB_INF) != 0;\n\tlower.inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower.lower = true;\n\tupper.infinite = (flags & RANGE_UB_INF) != 0;\n\tupper.inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper.lower = false;\n\n\t/* serialize and canonicalize */\n\trange = make_range(cache->typcache, &lower, &upper, flags & RANGE_EMPTY);\n\n\tPG_RETURN_RANGE_P(range);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);",
      "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
      "static char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "range"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "cache->typcache",
            "&lower",
            "&upper",
            "flags & RANGE_EMPTY"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "&cache->proc",
            "ubound_str",
            "cache->typioparam",
            "typmod"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_UBOUND",
          "args": [
            "flags"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_HAS_LBOUND",
          "args": [
            "flags"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_parse",
          "args": [
            "input_str",
            "&flags",
            "&lbound_str",
            "&ubound_str"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "range_parse_bound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2151-2210",
          "snippet": "static const char *\nrange_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite)\n{\n\tStringInfoData buf;\n\n\t/* Check for null: completely empty input means null */\n\tif (*ptr == ',' || *ptr == ')' || *ptr == ']')\n\t{\n\t\t*bound_str = NULL;\n\t\t*infinite = true;\n\t}\n\telse\n\t{\n\t\t/* Extract string for this bound */\n\t\tbool\t\tinquote = false;\n\n\t\tinitStringInfo(&buf);\n\t\twhile (inquote || !(*ptr == ',' || *ptr == ')' || *ptr == ']'))\n\t\t{\n\t\t\tchar\t\tch = *ptr++;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\tif (ch == '\\\\')\n\t\t\t{\n\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t}\n\t\t\telse if (ch == '\"')\n\t\t\t{\n\t\t\t\tif (!inquote)\n\t\t\t\t\tinquote = true;\n\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t{\n\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinquote = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t}\n\n\t\t*bound_str = buf.data;\n\t\t*infinite = false;\n\t}\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nstatic const char *\nrange_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite)\n{\n\tStringInfoData buf;\n\n\t/* Check for null: completely empty input means null */\n\tif (*ptr == ',' || *ptr == ')' || *ptr == ']')\n\t{\n\t\t*bound_str = NULL;\n\t\t*infinite = true;\n\t}\n\telse\n\t{\n\t\t/* Extract string for this bound */\n\t\tbool\t\tinquote = false;\n\n\t\tinitStringInfo(&buf);\n\t\twhile (inquote || !(*ptr == ',' || *ptr == ')' || *ptr == ']'))\n\t\t{\n\t\t\tchar\t\tch = *ptr++;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\tif (ch == '\\\\')\n\t\t\t{\n\t\t\t\tif (*ptr == '\\0')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed range literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstring),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t}\n\t\t\telse if (ch == '\"')\n\t\t\t{\n\t\t\t\tif (!inquote)\n\t\t\t\t\tinquote = true;\n\t\t\t\telse if (*ptr == '\"')\n\t\t\t\t{\n\t\t\t\t\t/* doubled quote within quote sequence */\n\t\t\t\t\tappendStringInfoChar(&buf, *ptr++);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinquote = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tappendStringInfoChar(&buf, ch);\n\t\t}\n\n\t\t*bound_str = buf.data;\n\t\t*infinite = false;\n\t}\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_range_io_data",
          "args": [
            "fcinfo",
            "rngtypoid",
            "IOFunc_input"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "get_range_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "300-349",
          "snippet": "static RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic RangeIOData *get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid,\n\t\t\t\t  IOFuncSelector func);\n\nstatic RangeIOData *\nget_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func)\n{\n\tRangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra;\n\n\tif (cache == NULL || cache->typcache->type_id != rngtypid)\n\t{\n\t\tint16\t\ttyplen;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tchar\t\ttypdelim;\n\n\t\tcache = (RangeIOData *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(RangeIOData));\n\t\tcache->typcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (cache->typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\n\t\t/* get_type_io_data does more than we need, but is convenient */\n\t\tget_type_io_data(cache->typcache->rngelemtype->type_id,\n\t\t\t\t\t\t func,\n\t\t\t\t\t\t &typlen,\n\t\t\t\t\t\t &typbyval,\n\t\t\t\t\t\t &typalign,\n\t\t\t\t\t\t &typdelim,\n\t\t\t\t\t\t &cache->typioparam,\n\t\t\t\t\t\t &cache->typiofunc);\n\n\t\tif (!OidIsValid(cache->typiofunc))\n\t\t{\n\t\t\t/* this could only happen for receive or send */\n\t\t\tif (func == IOFunc_receive)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(cache->typcache->rngelemtype->type_id))));\n\t\t}\n\t\tfmgr_info_cxt(cache->typiofunc, &cache->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\n\t\tfcinfo->flinfo->fn_extra = (void *) cache;\n\t}\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void range_parse(const char *input_str, char *flags, char **lbound_str,\n\t\t\tchar **ubound_str);\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_deparse(char flags, const char *lbound_str,\n\t\t\t  const char *ubound_str);\n\nDatum\nrange_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_str = PG_GETARG_CSTRING(0);\n\tOid\t\t\trngtypoid = PG_GETARG_OID(1);\n\tOid\t\t\ttypmod = PG_GETARG_INT32(2);\n\tRangeType  *range;\n\tRangeIOData *cache;\n\tchar\t\tflags;\n\tchar\t   *lbound_str;\n\tchar\t   *ubound_str;\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\n\tcheck_stack_depth();\t\t/* recurses when subtype is a range type */\n\n\tcache = get_range_io_data(fcinfo, rngtypoid, IOFunc_input);\n\n\t/* parse */\n\trange_parse(input_str, &flags, &lbound_str, &ubound_str);\n\n\t/* call element type's input function */\n\tif (RANGE_HAS_LBOUND(flags))\n\t\tlower.val = InputFunctionCall(&cache->proc, lbound_str,\n\t\t\t\t\t\t\t\t\t  cache->typioparam, typmod);\n\tif (RANGE_HAS_UBOUND(flags))\n\t\tupper.val = InputFunctionCall(&cache->proc, ubound_str,\n\t\t\t\t\t\t\t\t\t  cache->typioparam, typmod);\n\n\tlower.infinite = (flags & RANGE_LB_INF) != 0;\n\tlower.inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower.lower = true;\n\tupper.infinite = (flags & RANGE_UB_INF) != 0;\n\tupper.inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper.lower = false;\n\n\t/* serialize and canonicalize */\n\trange = make_range(cache->typcache, &lower, &upper, flags & RANGE_EMPTY);\n\n\tPG_RETURN_RANGE_P(range);\n}"
  }
]