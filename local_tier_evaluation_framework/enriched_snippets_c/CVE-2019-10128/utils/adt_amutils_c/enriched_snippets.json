[
  {
    "function_name": "pg_index_column_has_property",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
    "lines": "435-447",
    "snippet": "Datum\npg_index_column_has_property(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tint32\t\tattno = PG_GETARG_INT32(1);\n\tchar\t   *propname = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\n\t/* Reject attno 0 immediately, so that attno > 0 identifies this case */\n\tif (attno <= 0)\n\t\tPG_RETURN_NULL();\n\n\treturn indexam_property(fcinfo, propname, InvalidOid, relid, attno);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_index.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/amapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "indexam_property",
          "args": [
            "fcinfo",
            "propname",
            "InvalidOid",
            "relid",
            "attno"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "indexam_property",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
          "lines": "153-406",
          "snippet": "static Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_index.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(2)"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nDatum\npg_index_column_has_property(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tint32\t\tattno = PG_GETARG_INT32(1);\n\tchar\t   *propname = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\n\t/* Reject attno 0 immediately, so that attno > 0 identifies this case */\n\tif (attno <= 0)\n\t\tPG_RETURN_NULL();\n\n\treturn indexam_property(fcinfo, propname, InvalidOid, relid, attno);\n}"
  },
  {
    "function_name": "pg_index_has_property",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
    "lines": "423-430",
    "snippet": "Datum\npg_index_has_property(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tchar\t   *propname = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\treturn indexam_property(fcinfo, propname, InvalidOid, relid, 0);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_index.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/amapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "indexam_property",
          "args": [
            "fcinfo",
            "propname",
            "InvalidOid",
            "relid",
            "0"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "indexam_property",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
          "lines": "153-406",
          "snippet": "static Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_index.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(1)"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nDatum\npg_index_has_property(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tchar\t   *propname = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\treturn indexam_property(fcinfo, propname, InvalidOid, relid, 0);\n}"
  },
  {
    "function_name": "pg_indexam_has_property",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
    "lines": "411-418",
    "snippet": "Datum\npg_indexam_has_property(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tamoid = PG_GETARG_OID(0);\n\tchar\t   *propname = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\treturn indexam_property(fcinfo, propname, amoid, InvalidOid, 0);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_index.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/amapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "indexam_property",
          "args": [
            "fcinfo",
            "propname",
            "amoid",
            "InvalidOid",
            "0"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "indexam_property",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
          "lines": "153-406",
          "snippet": "static Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_index.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(1)"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nDatum\npg_indexam_has_property(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tamoid = PG_GETARG_OID(0);\n\tchar\t   *propname = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\treturn indexam_property(fcinfo, propname, amoid, InvalidOid, 0);\n}"
  },
  {
    "function_name": "indexam_property",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
    "lines": "153-406",
    "snippet": "static Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_index.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/amapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amcaninclude"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amgettuple ? true : false"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amcanmulticol"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amcanunique"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amcanorder"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amcanbackward"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amgetbitmap ? true : false"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amgettuple ? true : false"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "routine->amclusterable"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "index_oid"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "indexrel",
            "AccessShareLock"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_can_return",
          "args": [
            "indexrel",
            "attno"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "index_oid",
            "AccessShareLock"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_indoption",
          "args": [
            "tuple",
            "attno",
            "routine->amcanorder",
            "INDOPTION_NULLS_FIRST",
            "0",
            "&res"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "test_indoption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
          "lines": "116-142",
          "snippet": "static bool\ntest_indoption(HeapTuple tuple, int attno, bool guard,\n\t\t\t   int16 iopt_mask, int16 iopt_expect,\n\t\t\t   bool *res)\n{\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\tint2vector *indoption;\n\tint16\t\tindoption_val;\n\n\tif (!guard)\n\t{\n\t\t*res = false;\n\t\treturn true;\n\t}\n\n\tdatum = SysCacheGetAttr(INDEXRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_index_indoption, &isnull);\n\tAssert(!isnull);\n\n\tindoption = ((int2vector *) DatumGetPointer(datum));\n\tindoption_val = indoption->values[attno - 1];\n\n\t*res = (indoption_val & iopt_mask) == iopt_expect;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_index.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic bool\ntest_indoption(HeapTuple tuple, int attno, bool guard,\n\t\t\t   int16 iopt_mask, int16 iopt_expect,\n\t\t\t   bool *res)\n{\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\tint2vector *indoption;\n\tint16\t\tindoption_val;\n\n\tif (!guard)\n\t{\n\t\t*res = false;\n\t\treturn true;\n\t}\n\n\tdatum = SysCacheGetAttr(INDEXRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_index_indoption, &isnull);\n\tAssert(!isnull);\n\n\tindoption = ((int2vector *) DatumGetPointer(datum));\n\tindoption_val = indoption->values[attno - 1];\n\n\t*res = (indoption_val & iopt_mask) == iopt_expect;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "attno > 0 && attno <= rd_index->indnatts"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index_oid == rd_index->indexrelid"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "INDEXRELID",
            "ObjectIdGetDatum(index_oid)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "index_oid"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "routine->amproperty",
          "args": [
            "index_oid",
            "attno",
            "prop",
            "propname",
            "&res",
            "&isnull"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetIndexAmRoutineByAmId",
          "args": [
            "amoid",
            "true"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "index_oid"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!OidIsValid(amoid)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "amoid"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "index_oid"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_prop_name",
          "args": [
            "propname"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_prop_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
          "lines": "89-102",
          "snippet": "static IndexAMProperty\nlookup_prop_name(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(am_propnames); i++)\n\t{\n\t\tif (pg_strcasecmp(am_propnames[i].name, name) == 0)\n\t\t\treturn am_propnames[i].prop;\n\t}\n\n\t/* We do not throw an error, so that AMs can define their own properties */\n\treturn AMPROP_UNKNOWN;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_index.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct am_propname am_propnames[] =\n{\n\t{\n\t\t\"asc\", AMPROP_ASC\n\t},\n\t{\n\t\t\"desc\", AMPROP_DESC\n\t},\n\t{\n\t\t\"nulls_first\", AMPROP_NULLS_FIRST\n\t},\n\t{\n\t\t\"nulls_last\", AMPROP_NULLS_LAST\n\t},\n\t{\n\t\t\"orderable\", AMPROP_ORDERABLE\n\t},\n\t{\n\t\t\"distance_orderable\", AMPROP_DISTANCE_ORDERABLE\n\t},\n\t{\n\t\t\"returnable\", AMPROP_RETURNABLE\n\t},\n\t{\n\t\t\"search_array\", AMPROP_SEARCH_ARRAY\n\t},\n\t{\n\t\t\"search_nulls\", AMPROP_SEARCH_NULLS\n\t},\n\t{\n\t\t\"clusterable\", AMPROP_CLUSTERABLE\n\t},\n\t{\n\t\t\"index_scan\", AMPROP_INDEX_SCAN\n\t},\n\t{\n\t\t\"bitmap_scan\", AMPROP_BITMAP_SCAN\n\t},\n\t{\n\t\t\"backward_scan\", AMPROP_BACKWARD_SCAN\n\t},\n\t{\n\t\t\"can_order\", AMPROP_CAN_ORDER\n\t},\n\t{\n\t\t\"can_unique\", AMPROP_CAN_UNIQUE\n\t},\n\t{\n\t\t\"can_multi_col\", AMPROP_CAN_MULTI_COL\n\t},\n\t{\n\t\t\"can_exclude\", AMPROP_CAN_EXCLUDE\n\t},\n\t{\n\t\t\"can_include\", AMPROP_CAN_INCLUDE\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic const struct am_propname am_propnames[] =\n{\n\t{\n\t\t\"asc\", AMPROP_ASC\n\t},\n\t{\n\t\t\"desc\", AMPROP_DESC\n\t},\n\t{\n\t\t\"nulls_first\", AMPROP_NULLS_FIRST\n\t},\n\t{\n\t\t\"nulls_last\", AMPROP_NULLS_LAST\n\t},\n\t{\n\t\t\"orderable\", AMPROP_ORDERABLE\n\t},\n\t{\n\t\t\"distance_orderable\", AMPROP_DISTANCE_ORDERABLE\n\t},\n\t{\n\t\t\"returnable\", AMPROP_RETURNABLE\n\t},\n\t{\n\t\t\"search_array\", AMPROP_SEARCH_ARRAY\n\t},\n\t{\n\t\t\"search_nulls\", AMPROP_SEARCH_NULLS\n\t},\n\t{\n\t\t\"clusterable\", AMPROP_CLUSTERABLE\n\t},\n\t{\n\t\t\"index_scan\", AMPROP_INDEX_SCAN\n\t},\n\t{\n\t\t\"bitmap_scan\", AMPROP_BITMAP_SCAN\n\t},\n\t{\n\t\t\"backward_scan\", AMPROP_BACKWARD_SCAN\n\t},\n\t{\n\t\t\"can_order\", AMPROP_CAN_ORDER\n\t},\n\t{\n\t\t\"can_unique\", AMPROP_CAN_UNIQUE\n\t},\n\t{\n\t\t\"can_multi_col\", AMPROP_CAN_MULTI_COL\n\t},\n\t{\n\t\t\"can_exclude\", AMPROP_CAN_EXCLUDE\n\t},\n\t{\n\t\t\"can_include\", AMPROP_CAN_INCLUDE\n\t},\n};\n\nstatic IndexAMProperty\nlookup_prop_name(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(am_propnames); i++)\n\t{\n\t\tif (pg_strcasecmp(am_propnames[i].name, name) == 0)\n\t\t\treturn am_propnames[i].prop;\n\t}\n\n\t/* We do not throw an error, so that AMs can define their own properties */\n\treturn AMPROP_UNKNOWN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic Datum\nindexam_property(FunctionCallInfo fcinfo,\n\t\t\t\t const char *propname,\n\t\t\t\t Oid amoid, Oid index_oid, int attno)\n{\n\tbool\t\tres = false;\n\tbool\t\tisnull = false;\n\tint\t\t\tnatts = 0;\n\tIndexAMProperty prop;\n\tIndexAmRoutine *routine;\n\n\t/* Try to convert property name to enum (no error if not known) */\n\tprop = lookup_prop_name(propname);\n\n\t/* If we have an index OID, look up the AM, and get # of columns too */\n\tif (OidIsValid(index_oid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class rd_rel;\n\n\t\tAssert(!OidIsValid(amoid));\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_rel = (Form_pg_class) GETSTRUCT(tuple);\n\t\tif (rd_rel->relkind != RELKIND_INDEX &&\n\t\t\trd_rel->relkind != RELKIND_PARTITIONED_INDEX)\n\t\t{\n\t\t\tReleaseSysCache(tuple);\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\t\tamoid = rd_rel->relam;\n\t\tnatts = rd_rel->relnatts;\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/*\n\t * At this point, either index_oid == InvalidOid or it's a valid index\n\t * OID. Also, after this test and the one below, either attno == 0 for\n\t * index-wide or AM-wide tests, or it's a valid column number in a valid\n\t * index.\n\t */\n\tif (attno < 0 || attno > natts)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Get AM information.  If we don't have a valid AM OID, return NULL.\n\t */\n\troutine = GetIndexAmRoutineByAmId(amoid, true);\n\tif (routine == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * If there's an AM property routine, give it a chance to override the\n\t * generic logic.  Proceed if it returns false.\n\t */\n\tif (routine->amproperty &&\n\t\troutine->amproperty(index_oid, attno, prop, propname,\n\t\t\t\t\t\t\t&res, &isnull))\n\t{\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(res);\n\t}\n\n\tif (attno > 0)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index rd_index;\n\t\tbool\t\tiskey = true;\n\n\t\t/*\n\t\t * Handle column-level properties. Many of these need the pg_index row\n\t\t * (which we also need to use to check for nonkey atts) so we fetch\n\t\t * that first.\n\t\t */\n\t\ttuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(index_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\tPG_RETURN_NULL();\n\t\trd_index = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\tAssert(index_oid == rd_index->indexrelid);\n\t\tAssert(attno > 0 && attno <= rd_index->indnatts);\n\n\t\tisnull = true;\n\n\t\t/*\n\t\t * If amcaninclude, we might be looking at an attno for a nonkey\n\t\t * column, for which we (generically) assume that most properties are\n\t\t * null.\n\t\t */\n\t\tif (routine->amcaninclude\n\t\t\t&& attno > rd_index->indnkeyatts)\n\t\t\tiskey = false;\n\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_ASC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DESC:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_DESC, INDOPTION_DESC, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_FIRST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, INDOPTION_NULLS_FIRST, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_NULLS_LAST:\n\t\t\t\tif (iskey &&\n\t\t\t\t\ttest_indoption(tuple, attno, routine->amcanorder,\n\t\t\t\t\t\t\t\t   INDOPTION_NULLS_FIRST, 0, &res))\n\t\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * generic assumption is that nonkey columns are not orderable\n\t\t\t\t */\n\t\t\t\tres = iskey ? routine->amcanorder : false;\n\t\t\t\tisnull = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_DISTANCE_ORDERABLE:\n\n\t\t\t\t/*\n\t\t\t\t * The conditions for whether a column is distance-orderable\n\t\t\t\t * are really up to the AM (at time of writing, only GiST\n\t\t\t\t * supports it at all). The planner has its own idea based on\n\t\t\t\t * whether it finds an operator with amoppurpose 'o', but\n\t\t\t\t * getting there from just the index column type seems like a\n\t\t\t\t * lot of work. So instead we expect the AM to handle this in\n\t\t\t\t * its amproperty routine. The generic result is to return\n\t\t\t\t * false if the AM says it never supports this, or if this is\n\t\t\t\t * a nonkey column, and null otherwise (meaning we don't\n\t\t\t\t * know).\n\t\t\t\t */\n\t\t\t\tif (!iskey || !routine->amcanorderbyop)\n\t\t\t\t{\n\t\t\t\t\tres = false;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_RETURNABLE:\n\n\t\t\t\t/* note that we ignore iskey for this property */\n\n\t\t\t\tisnull = false;\n\t\t\t\tres = false;\n\n\t\t\t\tif (routine->amcanreturn)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If possible, the AM should handle this test in its\n\t\t\t\t\t * amproperty function without opening the rel. But this\n\t\t\t\t\t * is the generic fallback if it does not.\n\t\t\t\t\t */\n\t\t\t\t\tRelation\tindexrel = index_open(index_oid, AccessShareLock);\n\n\t\t\t\t\tres = index_can_return(indexrel, attno);\n\t\t\t\t\tindex_close(indexrel, AccessShareLock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_ARRAY:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearcharray;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AMPROP_SEARCH_NULLS:\n\t\t\t\tif (iskey)\n\t\t\t\t{\n\t\t\t\t\tres = routine->amsearchnulls;\n\t\t\t\t\tisnull = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tif (!isnull)\n\t\t\tPG_RETURN_BOOL(res);\n\t\tPG_RETURN_NULL();\n\t}\n\n\tif (OidIsValid(index_oid))\n\t{\n\t\t/*\n\t\t * Handle index-level properties.  Currently, these only depend on the\n\t\t * AM, but that might not be true forever, so we make users name an\n\t\t * index not just an AM.\n\t\t */\n\t\tswitch (prop)\n\t\t{\n\t\t\tcase AMPROP_CLUSTERABLE:\n\t\t\t\tPG_RETURN_BOOL(routine->amclusterable);\n\n\t\t\tcase AMPROP_INDEX_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\t\tcase AMPROP_BITMAP_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amgetbitmap ? true : false);\n\n\t\t\tcase AMPROP_BACKWARD_SCAN:\n\t\t\t\tPG_RETURN_BOOL(routine->amcanbackward);\n\n\t\t\tdefault:\n\t\t\t\tPG_RETURN_NULL();\n\t\t}\n\t}\n\n\t/*\n\t * Handle AM-level properties (those that control what you can say in\n\t * CREATE INDEX).\n\t */\n\tswitch (prop)\n\t{\n\t\tcase AMPROP_CAN_ORDER:\n\t\t\tPG_RETURN_BOOL(routine->amcanorder);\n\n\t\tcase AMPROP_CAN_UNIQUE:\n\t\t\tPG_RETURN_BOOL(routine->amcanunique);\n\n\t\tcase AMPROP_CAN_MULTI_COL:\n\t\t\tPG_RETURN_BOOL(routine->amcanmulticol);\n\n\t\tcase AMPROP_CAN_EXCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amgettuple ? true : false);\n\n\t\tcase AMPROP_CAN_INCLUDE:\n\t\t\tPG_RETURN_BOOL(routine->amcaninclude);\n\n\t\tdefault:\n\t\t\tPG_RETURN_NULL();\n\t}\n}"
  },
  {
    "function_name": "test_indoption",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
    "lines": "116-142",
    "snippet": "static bool\ntest_indoption(HeapTuple tuple, int attno, bool guard,\n\t\t\t   int16 iopt_mask, int16 iopt_expect,\n\t\t\t   bool *res)\n{\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\tint2vector *indoption;\n\tint16\t\tindoption_val;\n\n\tif (!guard)\n\t{\n\t\t*res = false;\n\t\treturn true;\n\t}\n\n\tdatum = SysCacheGetAttr(INDEXRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_index_indoption, &isnull);\n\tAssert(!isnull);\n\n\tindoption = ((int2vector *) DatumGetPointer(datum));\n\tindoption_val = indoption->values[attno - 1];\n\n\t*res = (indoption_val & iopt_mask) == iopt_expect;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_index.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/amapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "INDEXRELID",
            "tuple",
            "Anum_pg_index_indoption",
            "&isnull"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic bool\ntest_indoption(HeapTuple tuple, int attno, bool guard,\n\t\t\t   int16 iopt_mask, int16 iopt_expect,\n\t\t\t   bool *res)\n{\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\tint2vector *indoption;\n\tint16\t\tindoption_val;\n\n\tif (!guard)\n\t{\n\t\t*res = false;\n\t\treturn true;\n\t}\n\n\tdatum = SysCacheGetAttr(INDEXRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_index_indoption, &isnull);\n\tAssert(!isnull);\n\n\tindoption = ((int2vector *) DatumGetPointer(datum));\n\tindoption_val = indoption->values[attno - 1];\n\n\t*res = (indoption_val & iopt_mask) == iopt_expect;\n\n\treturn true;\n}"
  },
  {
    "function_name": "lookup_prop_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/amutils.c",
    "lines": "89-102",
    "snippet": "static IndexAMProperty\nlookup_prop_name(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(am_propnames); i++)\n\t{\n\t\tif (pg_strcasecmp(am_propnames[i].name, name) == 0)\n\t\t\treturn am_propnames[i].prop;\n\t}\n\n\t/* We do not throw an error, so that AMs can define their own properties */\n\treturn AMPROP_UNKNOWN;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_index.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/amapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct am_propname am_propnames[] =\n{\n\t{\n\t\t\"asc\", AMPROP_ASC\n\t},\n\t{\n\t\t\"desc\", AMPROP_DESC\n\t},\n\t{\n\t\t\"nulls_first\", AMPROP_NULLS_FIRST\n\t},\n\t{\n\t\t\"nulls_last\", AMPROP_NULLS_LAST\n\t},\n\t{\n\t\t\"orderable\", AMPROP_ORDERABLE\n\t},\n\t{\n\t\t\"distance_orderable\", AMPROP_DISTANCE_ORDERABLE\n\t},\n\t{\n\t\t\"returnable\", AMPROP_RETURNABLE\n\t},\n\t{\n\t\t\"search_array\", AMPROP_SEARCH_ARRAY\n\t},\n\t{\n\t\t\"search_nulls\", AMPROP_SEARCH_NULLS\n\t},\n\t{\n\t\t\"clusterable\", AMPROP_CLUSTERABLE\n\t},\n\t{\n\t\t\"index_scan\", AMPROP_INDEX_SCAN\n\t},\n\t{\n\t\t\"bitmap_scan\", AMPROP_BITMAP_SCAN\n\t},\n\t{\n\t\t\"backward_scan\", AMPROP_BACKWARD_SCAN\n\t},\n\t{\n\t\t\"can_order\", AMPROP_CAN_ORDER\n\t},\n\t{\n\t\t\"can_unique\", AMPROP_CAN_UNIQUE\n\t},\n\t{\n\t\t\"can_multi_col\", AMPROP_CAN_MULTI_COL\n\t},\n\t{\n\t\t\"can_exclude\", AMPROP_CAN_EXCLUDE\n\t},\n\t{\n\t\t\"can_include\", AMPROP_CAN_INCLUDE\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "am_propnames[i].name",
            "name"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "am_propnames"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_index.h\"\n#include \"catalog/pg_class.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include \"postgres.h\"\n\nstatic const struct am_propname am_propnames[] =\n{\n\t{\n\t\t\"asc\", AMPROP_ASC\n\t},\n\t{\n\t\t\"desc\", AMPROP_DESC\n\t},\n\t{\n\t\t\"nulls_first\", AMPROP_NULLS_FIRST\n\t},\n\t{\n\t\t\"nulls_last\", AMPROP_NULLS_LAST\n\t},\n\t{\n\t\t\"orderable\", AMPROP_ORDERABLE\n\t},\n\t{\n\t\t\"distance_orderable\", AMPROP_DISTANCE_ORDERABLE\n\t},\n\t{\n\t\t\"returnable\", AMPROP_RETURNABLE\n\t},\n\t{\n\t\t\"search_array\", AMPROP_SEARCH_ARRAY\n\t},\n\t{\n\t\t\"search_nulls\", AMPROP_SEARCH_NULLS\n\t},\n\t{\n\t\t\"clusterable\", AMPROP_CLUSTERABLE\n\t},\n\t{\n\t\t\"index_scan\", AMPROP_INDEX_SCAN\n\t},\n\t{\n\t\t\"bitmap_scan\", AMPROP_BITMAP_SCAN\n\t},\n\t{\n\t\t\"backward_scan\", AMPROP_BACKWARD_SCAN\n\t},\n\t{\n\t\t\"can_order\", AMPROP_CAN_ORDER\n\t},\n\t{\n\t\t\"can_unique\", AMPROP_CAN_UNIQUE\n\t},\n\t{\n\t\t\"can_multi_col\", AMPROP_CAN_MULTI_COL\n\t},\n\t{\n\t\t\"can_exclude\", AMPROP_CAN_EXCLUDE\n\t},\n\t{\n\t\t\"can_include\", AMPROP_CAN_INCLUDE\n\t},\n};\n\nstatic IndexAMProperty\nlookup_prop_name(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(am_propnames); i++)\n\t{\n\t\tif (pg_strcasecmp(am_propnames[i].name, name) == 0)\n\t\t\treturn am_propnames[i].prop;\n\t}\n\n\t/* We do not throw an error, so that AMs can define their own properties */\n\treturn AMPROP_UNKNOWN;\n}"
  }
]