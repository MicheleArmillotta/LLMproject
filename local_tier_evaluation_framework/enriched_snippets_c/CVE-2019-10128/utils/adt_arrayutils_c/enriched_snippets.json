[
  {
    "function_name": "ArrayGetIntegerTypmods",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "199-235",
    "snippet": "int32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elem_values"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_atoi",
          "args": [
            "DatumGetCString(elem_values[i])",
            "sizeof(int32)",
            "'\\0'"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "pg_atoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "36-109",
          "snippet": "int32\npg_atoi(const char *s, int size, int c)\n{\n\tlong\t\tl;\n\tchar\t   *badp;\n\n\t/*\n\t * Some versions of strtol treat the empty string as an error, but some\n\t * seem not to.  Make an explicit test to be sure we catch it.\n\t */\n\tif (s == NULL)\n\t\telog(ERROR, \"NULL pointer\");\n\tif (*s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\terrno = 0;\n\tl = strtol(s, &badp, 10);\n\n\t/* We made no progress parsing the string, so bail out */\n\tif (s == badp)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\tswitch (size)\n\t{\n\t\tcase sizeof(int32):\n\t\t\tif (errno == ERANGE\n#if defined(HAVE_LONG_INT_64)\n\t\t\t/* won't get ERANGE on these with 64-bit longs... */\n\t\t\t\t|| l < INT_MIN || l > INT_MAX\n#endif\n\t\t\t\t)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\")));\n\t\t\tbreak;\n\t\tcase sizeof(int16):\n\t\t\tif (errno == ERANGE || l < SHRT_MIN || l > SHRT_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\")));\n\t\t\tbreak;\n\t\tcase sizeof(int8):\n\t\t\tif (errno == ERANGE || l < SCHAR_MIN || l > SCHAR_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported result size: %d\", size);\n\t}\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, bail out\n\t */\n\twhile (*badp && *badp != c && isspace((unsigned char) *badp))\n\t\tbadp++;\n\n\tif (*badp && *badp != c)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\treturn (int32) l;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nint32\npg_atoi(const char *s, int size, int c)\n{\n\tlong\t\tl;\n\tchar\t   *badp;\n\n\t/*\n\t * Some versions of strtol treat the empty string as an error, but some\n\t * seem not to.  Make an explicit test to be sure we catch it.\n\t */\n\tif (s == NULL)\n\t\telog(ERROR, \"NULL pointer\");\n\tif (*s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\terrno = 0;\n\tl = strtol(s, &badp, 10);\n\n\t/* We made no progress parsing the string, so bail out */\n\tif (s == badp)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\tswitch (size)\n\t{\n\t\tcase sizeof(int32):\n\t\t\tif (errno == ERANGE\n#if defined(HAVE_LONG_INT_64)\n\t\t\t/* won't get ERANGE on these with 64-bit longs... */\n\t\t\t\t|| l < INT_MIN || l > INT_MAX\n#endif\n\t\t\t\t)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\")));\n\t\t\tbreak;\n\t\tcase sizeof(int16):\n\t\t\tif (errno == ERANGE || l < SHRT_MIN || l > SHRT_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\")));\n\t\t\tbreak;\n\t\tcase sizeof(int8):\n\t\t\tif (errno == ERANGE || l < SCHAR_MIN || l > SCHAR_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported result size: %d\", size);\n\t}\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, bail out\n\t */\n\twhile (*badp && *badp != c && isspace((unsigned char) *badp))\n\t\tbadp++;\n\n\tif (*badp && *badp != c)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\treturn (int32) l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "elem_values[i]"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "*n * sizeof(int32)"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arr",
            "CSTRINGOID",
            "-2",
            "false",
            "'c'",
            "&elem_values",
            "NULL",
            "n"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\"))"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"typmod array must not contain nulls\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "arr"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\"))"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\"))"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}"
  },
  {
    "function_name": "mda_next_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "174-192",
    "snippet": "int\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}"
  },
  {
    "function_name": "mda_get_offset_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "149-162",
    "snippet": "void\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}"
  },
  {
    "function_name": "mda_get_prod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "133-141",
    "snippet": "void\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}"
  },
  {
    "function_name": "mda_get_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "119-126",
    "snippet": "void\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}"
  },
  {
    "function_name": "ArrayGetNItems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "74-112",
    "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize))"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxArraySize"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ret >= 0"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize))"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize))"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
  },
  {
    "function_name": "ArrayGetOffset0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "49-58",
    "snippet": "int\nArrayGetOffset0(int n, const int *tup, const int *scale)\n{\n\tint\t\t\ti,\n\t\t\t\tlin = 0;\n\n\tfor (i = 0; i < n; i++)\n\t\tlin += tup[i] * scale[i];\n\treturn lin;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset0(int n, const int *tup, const int *scale)\n{\n\tint\t\t\ti,\n\t\t\t\tlin = 0;\n\n\tfor (i = 0; i < n; i++)\n\t\tlin += tup[i] * scale[i];\n\treturn lin;\n}"
  },
  {
    "function_name": "ArrayGetOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
    "lines": "30-43",
    "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
  }
]