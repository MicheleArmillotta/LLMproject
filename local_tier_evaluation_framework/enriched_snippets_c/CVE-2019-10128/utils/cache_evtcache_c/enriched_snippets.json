[
  {
    "function_name": "InvalidateEventCacheCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/evtcache.c",
    "lines": "253-269",
    "snippet": "static void\nInvalidateEventCacheCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\t/*\n\t * If the cache isn't valid, then there might be a rebuild in progress, so\n\t * we can't immediately blow it away.  But it's advantageous to do this\n\t * when possible, so as to immediately free memory.\n\t */\n\tif (EventTriggerCacheState == ETCS_VALID)\n\t{\n\t\tMemoryContextResetAndDeleteChildren(EventTriggerCacheContext);\n\t\tEventTriggerCache = NULL;\n\t}\n\n\t/* Mark cache for rebuild. */\n\tEventTriggerCacheState = ETCS_NEEDS_REBUILD;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/evtcache.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/pg_event_trigger.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *EventTriggerCache;",
      "static MemoryContext EventTriggerCacheContext;",
      "static EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;",
      "static void InvalidateEventCacheCallback(Datum arg,\n\t\t\t\t\t\t\t int cacheid, uint32 hashvalue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextResetAndDeleteChildren",
          "args": [
            "EventTriggerCacheContext"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/evtcache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *EventTriggerCache;\nstatic MemoryContext EventTriggerCacheContext;\nstatic EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;\nstatic void InvalidateEventCacheCallback(Datum arg,\n\t\t\t\t\t\t\t int cacheid, uint32 hashvalue);\n\nstatic void\nInvalidateEventCacheCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\t/*\n\t * If the cache isn't valid, then there might be a rebuild in progress, so\n\t * we can't immediately blow it away.  But it's advantageous to do this\n\t * when possible, so as to immediately free memory.\n\t */\n\tif (EventTriggerCacheState == ETCS_VALID)\n\t{\n\t\tMemoryContextResetAndDeleteChildren(EventTriggerCacheContext);\n\t\tEventTriggerCache = NULL;\n\t}\n\n\t/* Mark cache for rebuild. */\n\tEventTriggerCacheState = ETCS_NEEDS_REBUILD;\n}"
  },
  {
    "function_name": "DecodeTextArrayToCString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/evtcache.c",
    "lines": "224-244",
    "snippet": "static int\nDecodeTextArrayToCString(Datum array, char ***cstringp)\n{\n\tArrayType  *arr = DatumGetArrayTypeP(array);\n\tDatum\t   *elems;\n\tchar\t  **cstring;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ARR_NDIM(arr) != 1 || ARR_HASNULL(arr) || ARR_ELEMTYPE(arr) != TEXTOID)\n\t\telog(ERROR, \"expected 1-D text array\");\n\tdeconstruct_array(arr, TEXTOID, -1, false, 'i', &elems, NULL, &nelems);\n\n\tcstring = palloc(nelems * sizeof(char *));\n\tfor (i = 0; i < nelems; ++i)\n\t\tcstring[i] = TextDatumGetCString(elems[i]);\n\n\tpfree(elems);\n\t*cstringp = cstring;\n\treturn nelems;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/evtcache.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/pg_event_trigger.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tDecodeTextArrayToCString(Datum array, char ***cstringp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elems"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "elems[i]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nelems * sizeof(char *)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arr",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&elems",
            "NULL",
            "&nelems"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"expected 1-D text array\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "array"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/evtcache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\tDecodeTextArrayToCString(Datum array, char ***cstringp);\n\nstatic int\nDecodeTextArrayToCString(Datum array, char ***cstringp)\n{\n\tArrayType  *arr = DatumGetArrayTypeP(array);\n\tDatum\t   *elems;\n\tchar\t  **cstring;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ARR_NDIM(arr) != 1 || ARR_HASNULL(arr) || ARR_ELEMTYPE(arr) != TEXTOID)\n\t\telog(ERROR, \"expected 1-D text array\");\n\tdeconstruct_array(arr, TEXTOID, -1, false, 'i', &elems, NULL, &nelems);\n\n\tcstring = palloc(nelems * sizeof(char *));\n\tfor (i = 0; i < nelems; ++i)\n\t\tcstring[i] = TextDatumGetCString(elems[i]);\n\n\tpfree(elems);\n\t*cstringp = cstring;\n\treturn nelems;\n}"
  },
  {
    "function_name": "BuildEventTriggerCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/evtcache.c",
    "lines": "77-215",
    "snippet": "static void\nBuildEventTriggerCache(void)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *cache;\n\tMemoryContext oldcontext;\n\tRelation\trel;\n\tRelation\tirel;\n\tSysScanDesc scan;\n\n\tif (EventTriggerCacheContext != NULL)\n\t{\n\t\t/*\n\t\t * Free up any memory already allocated in EventTriggerCacheContext.\n\t\t * This can happen either because a previous rebuild failed, or\n\t\t * because an invalidation happened before the rebuild was complete.\n\t\t */\n\t\tMemoryContextResetAndDeleteChildren(EventTriggerCacheContext);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is our first time attempting to build the cache, so we need to\n\t\t * set up the memory context and register a syscache callback to\n\t\t * capture future invalidation events.\n\t\t */\n\t\tif (CacheMemoryContext == NULL)\n\t\t\tCreateCacheMemoryContext();\n\t\tEventTriggerCacheContext =\n\t\t\tAllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t  \"EventTriggerCache\",\n\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\t\tCacheRegisterSyscacheCallback(EVENTTRIGGEROID,\n\t\t\t\t\t\t\t\t\t  InvalidateEventCacheCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t}\n\n\t/* Switch to correct memory context. */\n\toldcontext = MemoryContextSwitchTo(EventTriggerCacheContext);\n\n\t/* Prevent the memory context from being nuked while we're rebuilding. */\n\tEventTriggerCacheState = ETCS_REBUILD_STARTED;\n\n\t/* Create new hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(EventTriggerEvent);\n\tctl.entrysize = sizeof(EventTriggerCacheEntry);\n\tctl.hcxt = EventTriggerCacheContext;\n\tcache = hash_create(\"Event Trigger Cache\", 32, &ctl,\n\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/*\n\t * Prepare to scan pg_event_trigger in name order.\n\t */\n\trel = relation_open(EventTriggerRelationId, AccessShareLock);\n\tirel = index_open(EventTriggerNameIndexId, AccessShareLock);\n\tscan = systable_beginscan_ordered(rel, irel, NULL, 0, NULL);\n\n\t/*\n\t * Build a cache item for each pg_event_trigger tuple, and append each one\n\t * to the appropriate cache entry.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_event_trigger form;\n\t\tchar\t   *evtevent;\n\t\tEventTriggerEvent event;\n\t\tEventTriggerCacheItem *item;\n\t\tDatum\t\tevttags;\n\t\tbool\t\tevttags_isnull;\n\t\tEventTriggerCacheEntry *entry;\n\t\tbool\t\tfound;\n\n\t\t/* Get next tuple. */\n\t\ttup = systable_getnext_ordered(scan, ForwardScanDirection);\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\n\t\t/* Skip trigger if disabled. */\n\t\tform = (Form_pg_event_trigger) GETSTRUCT(tup);\n\t\tif (form->evtenabled == TRIGGER_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* Decode event name. */\n\t\tevtevent = NameStr(form->evtevent);\n\t\tif (strcmp(evtevent, \"ddl_command_start\") == 0)\n\t\t\tevent = EVT_DDLCommandStart;\n\t\telse if (strcmp(evtevent, \"ddl_command_end\") == 0)\n\t\t\tevent = EVT_DDLCommandEnd;\n\t\telse if (strcmp(evtevent, \"sql_drop\") == 0)\n\t\t\tevent = EVT_SQLDrop;\n\t\telse if (strcmp(evtevent, \"table_rewrite\") == 0)\n\t\t\tevent = EVT_TableRewrite;\n\t\telse\n\t\t\tcontinue;\n\n\t\t/* Allocate new cache item. */\n\t\titem = palloc0(sizeof(EventTriggerCacheItem));\n\t\titem->fnoid = form->evtfoid;\n\t\titem->enabled = form->evtenabled;\n\n\t\t/* Decode and sort tags array. */\n\t\tevttags = heap_getattr(tup, Anum_pg_event_trigger_evttags,\n\t\t\t\t\t\t\t   RelationGetDescr(rel), &evttags_isnull);\n\t\tif (!evttags_isnull)\n\t\t{\n\t\t\titem->ntags = DecodeTextArrayToCString(evttags, &item->tag);\n\t\t\tqsort(item->tag, item->ntags, sizeof(char *), pg_qsort_strcmp);\n\t\t}\n\n\t\t/* Add to cache entry. */\n\t\tentry = hash_search(cache, &event, HASH_ENTER, &found);\n\t\tif (found)\n\t\t\tentry->triggerlist = lappend(entry->triggerlist, item);\n\t\telse\n\t\t\tentry->triggerlist = list_make1(item);\n\t}\n\n\t/* Done with pg_event_trigger scan. */\n\tsystable_endscan_ordered(scan);\n\tindex_close(irel, AccessShareLock);\n\trelation_close(rel, AccessShareLock);\n\n\t/* Restore previous memory context. */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Install new cache. */\n\tEventTriggerCache = cache;\n\n\t/*\n\t * If the cache has been invalidated since we entered this routine, we\n\t * still use and return the cache we just finished constructing, to avoid\n\t * infinite loops, but we leave the cache marked stale so that we'll\n\t * rebuild it again on next access.  Otherwise, we mark the cache valid.\n\t */\n\tif (EventTriggerCacheState == ETCS_REBUILD_STARTED)\n\t\tEventTriggerCacheState = ETCS_VALID;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/evtcache.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/pg_event_trigger.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *EventTriggerCache;",
      "static MemoryContext EventTriggerCacheContext;",
      "static EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;",
      "static void BuildEventTriggerCache(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "irel",
            "AccessShareLock"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan_ordered",
          "args": [
            "scan"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make1",
          "args": [
            "item"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "entry->triggerlist",
            "item"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "cache",
            "&event",
            "HASH_ENTER",
            "&found"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "item->tag",
            "item->ntags",
            "sizeof(char *)",
            "pg_qsort_strcmp"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTextArrayToCString",
          "args": [
            "evttags",
            "&item->tag"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTextArrayToCString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/evtcache.c",
          "lines": "224-244",
          "snippet": "static int\nDecodeTextArrayToCString(Datum array, char ***cstringp)\n{\n\tArrayType  *arr = DatumGetArrayTypeP(array);\n\tDatum\t   *elems;\n\tchar\t  **cstring;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ARR_NDIM(arr) != 1 || ARR_HASNULL(arr) || ARR_ELEMTYPE(arr) != TEXTOID)\n\t\telog(ERROR, \"expected 1-D text array\");\n\tdeconstruct_array(arr, TEXTOID, -1, false, 'i', &elems, NULL, &nelems);\n\n\tcstring = palloc(nelems * sizeof(char *));\n\tfor (i = 0; i < nelems; ++i)\n\t\tcstring[i] = TextDatumGetCString(elems[i]);\n\n\tpfree(elems);\n\t*cstringp = cstring;\n\treturn nelems;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/evtcache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tDecodeTextArrayToCString(Datum array, char ***cstringp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/evtcache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic int\tDecodeTextArrayToCString(Datum array, char ***cstringp);\n\nstatic int\nDecodeTextArrayToCString(Datum array, char ***cstringp)\n{\n\tArrayType  *arr = DatumGetArrayTypeP(array);\n\tDatum\t   *elems;\n\tchar\t  **cstring;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ARR_NDIM(arr) != 1 || ARR_HASNULL(arr) || ARR_ELEMTYPE(arr) != TEXTOID)\n\t\telog(ERROR, \"expected 1-D text array\");\n\tdeconstruct_array(arr, TEXTOID, -1, false, 'i', &elems, NULL, &nelems);\n\n\tcstring = palloc(nelems * sizeof(char *));\n\tfor (i = 0; i < nelems; ++i)\n\t\tcstring[i] = TextDatumGetCString(elems[i]);\n\n\tpfree(elems);\n\t*cstringp = cstring;\n\treturn nelems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tup",
            "Anum_pg_event_trigger_evttags",
            "RelationGetDescr(rel)",
            "&evttags_isnull"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rel"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(EventTriggerCacheItem)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "evtevent",
            "\"table_rewrite\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "form->evtevent"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext_ordered",
          "args": [
            "scan",
            "ForwardScanDirection"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan_ordered",
          "args": [
            "rel",
            "irel",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "EventTriggerNameIndexId",
            "AccessShareLock"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "EventTriggerRelationId",
            "AccessShareLock"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Event Trigger Cache\"",
            "32",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS | HASH_CONTEXT"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "EventTriggerCacheContext"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CacheRegisterSyscacheCallback",
          "args": [
            "EVENTTRIGGEROID",
            "InvalidateEventCacheCallback",
            "(Datum) 0"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterSyscacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1425-1456",
          "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_SYSCACHE_CALLBACKS 64"
          ],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];",
            "static int\tsyscache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CacheMemoryContext",
            "\"EventTriggerCache\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextResetAndDeleteChildren",
          "args": [
            "EventTriggerCacheContext"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/evtcache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *EventTriggerCache;\nstatic MemoryContext EventTriggerCacheContext;\nstatic EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;\nstatic void BuildEventTriggerCache(void);\n\nstatic void\nBuildEventTriggerCache(void)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *cache;\n\tMemoryContext oldcontext;\n\tRelation\trel;\n\tRelation\tirel;\n\tSysScanDesc scan;\n\n\tif (EventTriggerCacheContext != NULL)\n\t{\n\t\t/*\n\t\t * Free up any memory already allocated in EventTriggerCacheContext.\n\t\t * This can happen either because a previous rebuild failed, or\n\t\t * because an invalidation happened before the rebuild was complete.\n\t\t */\n\t\tMemoryContextResetAndDeleteChildren(EventTriggerCacheContext);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is our first time attempting to build the cache, so we need to\n\t\t * set up the memory context and register a syscache callback to\n\t\t * capture future invalidation events.\n\t\t */\n\t\tif (CacheMemoryContext == NULL)\n\t\t\tCreateCacheMemoryContext();\n\t\tEventTriggerCacheContext =\n\t\t\tAllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t  \"EventTriggerCache\",\n\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\t\tCacheRegisterSyscacheCallback(EVENTTRIGGEROID,\n\t\t\t\t\t\t\t\t\t  InvalidateEventCacheCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t}\n\n\t/* Switch to correct memory context. */\n\toldcontext = MemoryContextSwitchTo(EventTriggerCacheContext);\n\n\t/* Prevent the memory context from being nuked while we're rebuilding. */\n\tEventTriggerCacheState = ETCS_REBUILD_STARTED;\n\n\t/* Create new hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(EventTriggerEvent);\n\tctl.entrysize = sizeof(EventTriggerCacheEntry);\n\tctl.hcxt = EventTriggerCacheContext;\n\tcache = hash_create(\"Event Trigger Cache\", 32, &ctl,\n\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/*\n\t * Prepare to scan pg_event_trigger in name order.\n\t */\n\trel = relation_open(EventTriggerRelationId, AccessShareLock);\n\tirel = index_open(EventTriggerNameIndexId, AccessShareLock);\n\tscan = systable_beginscan_ordered(rel, irel, NULL, 0, NULL);\n\n\t/*\n\t * Build a cache item for each pg_event_trigger tuple, and append each one\n\t * to the appropriate cache entry.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_event_trigger form;\n\t\tchar\t   *evtevent;\n\t\tEventTriggerEvent event;\n\t\tEventTriggerCacheItem *item;\n\t\tDatum\t\tevttags;\n\t\tbool\t\tevttags_isnull;\n\t\tEventTriggerCacheEntry *entry;\n\t\tbool\t\tfound;\n\n\t\t/* Get next tuple. */\n\t\ttup = systable_getnext_ordered(scan, ForwardScanDirection);\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\n\t\t/* Skip trigger if disabled. */\n\t\tform = (Form_pg_event_trigger) GETSTRUCT(tup);\n\t\tif (form->evtenabled == TRIGGER_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* Decode event name. */\n\t\tevtevent = NameStr(form->evtevent);\n\t\tif (strcmp(evtevent, \"ddl_command_start\") == 0)\n\t\t\tevent = EVT_DDLCommandStart;\n\t\telse if (strcmp(evtevent, \"ddl_command_end\") == 0)\n\t\t\tevent = EVT_DDLCommandEnd;\n\t\telse if (strcmp(evtevent, \"sql_drop\") == 0)\n\t\t\tevent = EVT_SQLDrop;\n\t\telse if (strcmp(evtevent, \"table_rewrite\") == 0)\n\t\t\tevent = EVT_TableRewrite;\n\t\telse\n\t\t\tcontinue;\n\n\t\t/* Allocate new cache item. */\n\t\titem = palloc0(sizeof(EventTriggerCacheItem));\n\t\titem->fnoid = form->evtfoid;\n\t\titem->enabled = form->evtenabled;\n\n\t\t/* Decode and sort tags array. */\n\t\tevttags = heap_getattr(tup, Anum_pg_event_trigger_evttags,\n\t\t\t\t\t\t\t   RelationGetDescr(rel), &evttags_isnull);\n\t\tif (!evttags_isnull)\n\t\t{\n\t\t\titem->ntags = DecodeTextArrayToCString(evttags, &item->tag);\n\t\t\tqsort(item->tag, item->ntags, sizeof(char *), pg_qsort_strcmp);\n\t\t}\n\n\t\t/* Add to cache entry. */\n\t\tentry = hash_search(cache, &event, HASH_ENTER, &found);\n\t\tif (found)\n\t\t\tentry->triggerlist = lappend(entry->triggerlist, item);\n\t\telse\n\t\t\tentry->triggerlist = list_make1(item);\n\t}\n\n\t/* Done with pg_event_trigger scan. */\n\tsystable_endscan_ordered(scan);\n\tindex_close(irel, AccessShareLock);\n\trelation_close(rel, AccessShareLock);\n\n\t/* Restore previous memory context. */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Install new cache. */\n\tEventTriggerCache = cache;\n\n\t/*\n\t * If the cache has been invalidated since we entered this routine, we\n\t * still use and return the cache we just finished constructing, to avoid\n\t * infinite loops, but we leave the cache marked stale so that we'll\n\t * rebuild it again on next access.  Otherwise, we mark the cache valid.\n\t */\n\tif (EventTriggerCacheState == ETCS_REBUILD_STARTED)\n\t\tEventTriggerCacheState = ETCS_VALID;\n}"
  },
  {
    "function_name": "EventCacheLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/evtcache.c",
    "lines": "63-72",
    "snippet": "List *\nEventCacheLookup(EventTriggerEvent event)\n{\n\tEventTriggerCacheEntry *entry;\n\n\tif (EventTriggerCacheState != ETCS_VALID)\n\t\tBuildEventTriggerCache();\n\tentry = hash_search(EventTriggerCache, &event, HASH_FIND, NULL);\n\treturn entry != NULL ? entry->triggerlist : NIL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/evtcache.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/pg_event_trigger.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *EventTriggerCache;",
      "static EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;",
      "static void BuildEventTriggerCache(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "EventTriggerCache",
            "&event",
            "HASH_FIND",
            "NULL"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildEventTriggerCache",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "BuildEventTriggerCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/evtcache.c",
          "lines": "77-215",
          "snippet": "static void\nBuildEventTriggerCache(void)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *cache;\n\tMemoryContext oldcontext;\n\tRelation\trel;\n\tRelation\tirel;\n\tSysScanDesc scan;\n\n\tif (EventTriggerCacheContext != NULL)\n\t{\n\t\t/*\n\t\t * Free up any memory already allocated in EventTriggerCacheContext.\n\t\t * This can happen either because a previous rebuild failed, or\n\t\t * because an invalidation happened before the rebuild was complete.\n\t\t */\n\t\tMemoryContextResetAndDeleteChildren(EventTriggerCacheContext);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is our first time attempting to build the cache, so we need to\n\t\t * set up the memory context and register a syscache callback to\n\t\t * capture future invalidation events.\n\t\t */\n\t\tif (CacheMemoryContext == NULL)\n\t\t\tCreateCacheMemoryContext();\n\t\tEventTriggerCacheContext =\n\t\t\tAllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t  \"EventTriggerCache\",\n\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\t\tCacheRegisterSyscacheCallback(EVENTTRIGGEROID,\n\t\t\t\t\t\t\t\t\t  InvalidateEventCacheCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t}\n\n\t/* Switch to correct memory context. */\n\toldcontext = MemoryContextSwitchTo(EventTriggerCacheContext);\n\n\t/* Prevent the memory context from being nuked while we're rebuilding. */\n\tEventTriggerCacheState = ETCS_REBUILD_STARTED;\n\n\t/* Create new hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(EventTriggerEvent);\n\tctl.entrysize = sizeof(EventTriggerCacheEntry);\n\tctl.hcxt = EventTriggerCacheContext;\n\tcache = hash_create(\"Event Trigger Cache\", 32, &ctl,\n\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/*\n\t * Prepare to scan pg_event_trigger in name order.\n\t */\n\trel = relation_open(EventTriggerRelationId, AccessShareLock);\n\tirel = index_open(EventTriggerNameIndexId, AccessShareLock);\n\tscan = systable_beginscan_ordered(rel, irel, NULL, 0, NULL);\n\n\t/*\n\t * Build a cache item for each pg_event_trigger tuple, and append each one\n\t * to the appropriate cache entry.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_event_trigger form;\n\t\tchar\t   *evtevent;\n\t\tEventTriggerEvent event;\n\t\tEventTriggerCacheItem *item;\n\t\tDatum\t\tevttags;\n\t\tbool\t\tevttags_isnull;\n\t\tEventTriggerCacheEntry *entry;\n\t\tbool\t\tfound;\n\n\t\t/* Get next tuple. */\n\t\ttup = systable_getnext_ordered(scan, ForwardScanDirection);\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\n\t\t/* Skip trigger if disabled. */\n\t\tform = (Form_pg_event_trigger) GETSTRUCT(tup);\n\t\tif (form->evtenabled == TRIGGER_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* Decode event name. */\n\t\tevtevent = NameStr(form->evtevent);\n\t\tif (strcmp(evtevent, \"ddl_command_start\") == 0)\n\t\t\tevent = EVT_DDLCommandStart;\n\t\telse if (strcmp(evtevent, \"ddl_command_end\") == 0)\n\t\t\tevent = EVT_DDLCommandEnd;\n\t\telse if (strcmp(evtevent, \"sql_drop\") == 0)\n\t\t\tevent = EVT_SQLDrop;\n\t\telse if (strcmp(evtevent, \"table_rewrite\") == 0)\n\t\t\tevent = EVT_TableRewrite;\n\t\telse\n\t\t\tcontinue;\n\n\t\t/* Allocate new cache item. */\n\t\titem = palloc0(sizeof(EventTriggerCacheItem));\n\t\titem->fnoid = form->evtfoid;\n\t\titem->enabled = form->evtenabled;\n\n\t\t/* Decode and sort tags array. */\n\t\tevttags = heap_getattr(tup, Anum_pg_event_trigger_evttags,\n\t\t\t\t\t\t\t   RelationGetDescr(rel), &evttags_isnull);\n\t\tif (!evttags_isnull)\n\t\t{\n\t\t\titem->ntags = DecodeTextArrayToCString(evttags, &item->tag);\n\t\t\tqsort(item->tag, item->ntags, sizeof(char *), pg_qsort_strcmp);\n\t\t}\n\n\t\t/* Add to cache entry. */\n\t\tentry = hash_search(cache, &event, HASH_ENTER, &found);\n\t\tif (found)\n\t\t\tentry->triggerlist = lappend(entry->triggerlist, item);\n\t\telse\n\t\t\tentry->triggerlist = list_make1(item);\n\t}\n\n\t/* Done with pg_event_trigger scan. */\n\tsystable_endscan_ordered(scan);\n\tindex_close(irel, AccessShareLock);\n\trelation_close(rel, AccessShareLock);\n\n\t/* Restore previous memory context. */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Install new cache. */\n\tEventTriggerCache = cache;\n\n\t/*\n\t * If the cache has been invalidated since we entered this routine, we\n\t * still use and return the cache we just finished constructing, to avoid\n\t * infinite loops, but we leave the cache marked stale so that we'll\n\t * rebuild it again on next access.  Otherwise, we mark the cache valid.\n\t */\n\tif (EventTriggerCacheState == ETCS_REBUILD_STARTED)\n\t\tEventTriggerCacheState = ETCS_VALID;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/evtcache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *EventTriggerCache;",
            "static MemoryContext EventTriggerCacheContext;",
            "static EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;",
            "static void BuildEventTriggerCache(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/evtcache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *EventTriggerCache;\nstatic MemoryContext EventTriggerCacheContext;\nstatic EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;\nstatic void BuildEventTriggerCache(void);\n\nstatic void\nBuildEventTriggerCache(void)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *cache;\n\tMemoryContext oldcontext;\n\tRelation\trel;\n\tRelation\tirel;\n\tSysScanDesc scan;\n\n\tif (EventTriggerCacheContext != NULL)\n\t{\n\t\t/*\n\t\t * Free up any memory already allocated in EventTriggerCacheContext.\n\t\t * This can happen either because a previous rebuild failed, or\n\t\t * because an invalidation happened before the rebuild was complete.\n\t\t */\n\t\tMemoryContextResetAndDeleteChildren(EventTriggerCacheContext);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is our first time attempting to build the cache, so we need to\n\t\t * set up the memory context and register a syscache callback to\n\t\t * capture future invalidation events.\n\t\t */\n\t\tif (CacheMemoryContext == NULL)\n\t\t\tCreateCacheMemoryContext();\n\t\tEventTriggerCacheContext =\n\t\t\tAllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t  \"EventTriggerCache\",\n\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\t\tCacheRegisterSyscacheCallback(EVENTTRIGGEROID,\n\t\t\t\t\t\t\t\t\t  InvalidateEventCacheCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t}\n\n\t/* Switch to correct memory context. */\n\toldcontext = MemoryContextSwitchTo(EventTriggerCacheContext);\n\n\t/* Prevent the memory context from being nuked while we're rebuilding. */\n\tEventTriggerCacheState = ETCS_REBUILD_STARTED;\n\n\t/* Create new hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(EventTriggerEvent);\n\tctl.entrysize = sizeof(EventTriggerCacheEntry);\n\tctl.hcxt = EventTriggerCacheContext;\n\tcache = hash_create(\"Event Trigger Cache\", 32, &ctl,\n\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/*\n\t * Prepare to scan pg_event_trigger in name order.\n\t */\n\trel = relation_open(EventTriggerRelationId, AccessShareLock);\n\tirel = index_open(EventTriggerNameIndexId, AccessShareLock);\n\tscan = systable_beginscan_ordered(rel, irel, NULL, 0, NULL);\n\n\t/*\n\t * Build a cache item for each pg_event_trigger tuple, and append each one\n\t * to the appropriate cache entry.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_event_trigger form;\n\t\tchar\t   *evtevent;\n\t\tEventTriggerEvent event;\n\t\tEventTriggerCacheItem *item;\n\t\tDatum\t\tevttags;\n\t\tbool\t\tevttags_isnull;\n\t\tEventTriggerCacheEntry *entry;\n\t\tbool\t\tfound;\n\n\t\t/* Get next tuple. */\n\t\ttup = systable_getnext_ordered(scan, ForwardScanDirection);\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\n\t\t/* Skip trigger if disabled. */\n\t\tform = (Form_pg_event_trigger) GETSTRUCT(tup);\n\t\tif (form->evtenabled == TRIGGER_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* Decode event name. */\n\t\tevtevent = NameStr(form->evtevent);\n\t\tif (strcmp(evtevent, \"ddl_command_start\") == 0)\n\t\t\tevent = EVT_DDLCommandStart;\n\t\telse if (strcmp(evtevent, \"ddl_command_end\") == 0)\n\t\t\tevent = EVT_DDLCommandEnd;\n\t\telse if (strcmp(evtevent, \"sql_drop\") == 0)\n\t\t\tevent = EVT_SQLDrop;\n\t\telse if (strcmp(evtevent, \"table_rewrite\") == 0)\n\t\t\tevent = EVT_TableRewrite;\n\t\telse\n\t\t\tcontinue;\n\n\t\t/* Allocate new cache item. */\n\t\titem = palloc0(sizeof(EventTriggerCacheItem));\n\t\titem->fnoid = form->evtfoid;\n\t\titem->enabled = form->evtenabled;\n\n\t\t/* Decode and sort tags array. */\n\t\tevttags = heap_getattr(tup, Anum_pg_event_trigger_evttags,\n\t\t\t\t\t\t\t   RelationGetDescr(rel), &evttags_isnull);\n\t\tif (!evttags_isnull)\n\t\t{\n\t\t\titem->ntags = DecodeTextArrayToCString(evttags, &item->tag);\n\t\t\tqsort(item->tag, item->ntags, sizeof(char *), pg_qsort_strcmp);\n\t\t}\n\n\t\t/* Add to cache entry. */\n\t\tentry = hash_search(cache, &event, HASH_ENTER, &found);\n\t\tif (found)\n\t\t\tentry->triggerlist = lappend(entry->triggerlist, item);\n\t\telse\n\t\t\tentry->triggerlist = list_make1(item);\n\t}\n\n\t/* Done with pg_event_trigger scan. */\n\tsystable_endscan_ordered(scan);\n\tindex_close(irel, AccessShareLock);\n\trelation_close(rel, AccessShareLock);\n\n\t/* Restore previous memory context. */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Install new cache. */\n\tEventTriggerCache = cache;\n\n\t/*\n\t * If the cache has been invalidated since we entered this routine, we\n\t * still use and return the cache we just finished constructing, to avoid\n\t * infinite loops, but we leave the cache marked stale so that we'll\n\t * rebuild it again on next access.  Otherwise, we mark the cache valid.\n\t */\n\tif (EventTriggerCacheState == ETCS_REBUILD_STARTED)\n\t\tEventTriggerCacheState = ETCS_VALID;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/evtcache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *EventTriggerCache;\nstatic EventTriggerCacheStateType EventTriggerCacheState = ETCS_NEEDS_REBUILD;\nstatic void BuildEventTriggerCache(void);\n\nList *\nEventCacheLookup(EventTriggerEvent event)\n{\n\tEventTriggerCacheEntry *entry;\n\n\tif (EventTriggerCacheState != ETCS_VALID)\n\t\tBuildEventTriggerCache();\n\tentry = hash_search(EventTriggerCache, &event, HASH_FIND, NULL);\n\treturn entry != NULL ? entry->triggerlist : NIL;\n}"
  }
]