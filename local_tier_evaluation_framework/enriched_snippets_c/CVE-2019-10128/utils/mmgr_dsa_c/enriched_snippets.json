[
  {
    "function_name": "check_for_freed_segments_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "2266-2289",
    "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsm_detach",
          "args": [
            "area->segment_maps[i].segment"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "area->freed_segment_counter != freed_segment_counter"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(DSA_AREA_LOCK(area))"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
  },
  {
    "function_name": "check_for_freed_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "2230-2257",
    "snippet": "static void\ncheck_for_freed_segments(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\n\t/*\n\t * Any other process that has freed a segment has incremented\n\t * free_segment_counter while holding an LWLock, and that must precede any\n\t * backend creating a new segment in the same slot while holding an\n\t * LWLock, and that must precede the creation of any dsa_pointer pointing\n\t * into the new segment which might reach us here, and the caller must\n\t * have sent the dsa_pointer to this process using appropriate memory\n\t * synchronization (some kind of locking or atomic primitive or system\n\t * call).  So all we need to do on the reading side is ask for the load of\n\t * freed_segment_counter to follow the caller's load of the dsa_pointer it\n\t * has, and we can be sure to detect any segments that had been freed as\n\t * of the time that the dsa_pointer reached this process.\n\t */\n\tpg_read_barrier();\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\t/* Check all currently mapped segments to find what's been freed. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tcheck_for_freed_segments_locked(area);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_freed_segments_locked",
          "args": [
            "area"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_freed_segments_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2266-2289",
          "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "area->freed_segment_counter != freed_segment_counter"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_read_barrier",
          "args": [],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\n\t/*\n\t * Any other process that has freed a segment has incremented\n\t * free_segment_counter while holding an LWLock, and that must precede any\n\t * backend creating a new segment in the same slot while holding an\n\t * LWLock, and that must precede the creation of any dsa_pointer pointing\n\t * into the new segment which might reach us here, and the caller must\n\t * have sent the dsa_pointer to this process using appropriate memory\n\t * synchronization (some kind of locking or atomic primitive or system\n\t * call).  So all we need to do on the reading side is ask for the load of\n\t * freed_segment_counter to follow the caller's load of the dsa_pointer it\n\t * has, and we can be sure to detect any segments that had been freed as\n\t * of the time that the dsa_pointer reached this process.\n\t */\n\tpg_read_barrier();\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\t/* Check all currently mapped segments to find what's been freed. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tcheck_for_freed_segments_locked(area);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t}\n}"
  },
  {
    "function_name": "make_new_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "2061-2215",
    "snippet": "static dsa_segment_map *\nmake_new_segment(dsa_area *area, size_t requested_pages)\n{\n\tdsa_segment_index new_index;\n\tsize_t\t\tmetadata_bytes;\n\tsize_t\t\ttotal_size;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tusable_pages;\n\tdsa_segment_map *segment_map;\n\tdsm_segment *segment;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\n\t/* Find a segment slot that is not in use (linearly for now). */\n\tfor (new_index = 1; new_index < DSA_MAX_SEGMENTS; ++new_index)\n\t{\n\t\tif (area->control->segment_handles[new_index] == DSM_HANDLE_INVALID)\n\t\t\tbreak;\n\t}\n\tif (new_index == DSA_MAX_SEGMENTS)\n\t\treturn NULL;\n\n\t/*\n\t * If the total size limit is already exceeded, then we exit early and\n\t * avoid arithmetic wraparound in the unsigned expressions below.\n\t */\n\tif (area->control->total_segment_size >=\n\t\tarea->control->max_total_segment_size)\n\t\treturn NULL;\n\n\t/*\n\t * The size should be at least as big as requested, and at least big\n\t * enough to follow a geometric series that approximately doubles the\n\t * total storage each time we create a new segment.  We use geometric\n\t * growth because the underlying DSM system isn't designed for large\n\t * numbers of segments (otherwise we might even consider just using one\n\t * DSM segment for each large allocation and for each superblock, and then\n\t * we wouldn't need to use FreePageManager).\n\t *\n\t * We decide on a total segment size first, so that we produce tidy\n\t * power-of-two sized segments.  This is a good property to have if we\n\t * move to huge pages in the future.  Then we work back to the number of\n\t * pages we can fit.\n\t */\n\ttotal_size = DSA_INITIAL_SEGMENT_SIZE *\n\t\t((size_t) 1 << (new_index / DSA_NUM_SEGMENTS_AT_EACH_SIZE));\n\ttotal_size = Min(total_size, DSA_MAX_SEGMENT_SIZE);\n\ttotal_size = Min(total_size,\n\t\t\t\t\t area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size);\n\n\ttotal_pages = total_size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\tsizeof(dsa_pointer) * total_pages;\n\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tif (total_size <= metadata_bytes)\n\t\treturn NULL;\n\tusable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;\n\tAssert(metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size);\n\n\t/* See if that is enough... */\n\tif (requested_pages > usable_pages)\n\t{\n\t\t/*\n\t\t * We'll make an odd-sized segment, working forward from the requested\n\t\t * number of pages.\n\t\t */\n\t\tusable_pages = requested_pages;\n\t\tmetadata_bytes =\n\t\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\t\tusable_pages * sizeof(dsa_pointer);\n\n\t\t/* Add padding up to next page boundary. */\n\t\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\t\ttotal_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;\n\n\t\t/* Is that too large for dsa_pointer's addressing scheme? */\n\t\tif (total_size > DSA_MAX_SEGMENT_SIZE)\n\t\t\treturn NULL;\n\n\t\t/* Would that exceed the limit? */\n\t\tif (total_size > area->control->max_total_segment_size -\n\t\t\tarea->control->total_segment_size)\n\t\t\treturn NULL;\n\t}\n\n\t/* Create the segment. */\n\tsegment = dsm_create(total_size, 0);\n\tif (segment == NULL)\n\t\treturn NULL;\n\tdsm_pin_segment(segment);\n\tif (area->mapping_pinned)\n\t\tdsm_pin_mapping(segment);\n\n\t/* Store the handle in shared memory to be found by index. */\n\tarea->control->segment_handles[new_index] =\n\t\tdsm_segment_handle(segment);\n\t/* Track the highest segment index in the history of the area. */\n\tif (area->control->high_segment_index < new_index)\n\t\tarea->control->high_segment_index = new_index;\n\t/* Track the highest segment index this backend has ever mapped. */\n\tif (area->high_segment_index < new_index)\n\t\tarea->high_segment_index = new_index;\n\t/* Track total size of all segments. */\n\tarea->control->total_segment_size += total_size;\n\tAssert(area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size);\n\n\t/* Build a segment map for this segment in this backend. */\n\tsegment_map = &area->segment_maps[new_index];\n\tsegment_map->segment = segment;\n\tsegment_map->mapped_address = dsm_segment_address(segment);\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t   usable_pages);\n\n\t/* Set up the segment header and put it in the appropriate bin. */\n\tsegment_map->header->magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ new_index;\n\tsegment_map->header->usable_pages = usable_pages;\n\tsegment_map->header->size = total_size;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\tsegment_map->header->next =\n\t\tarea->control->segment_bins[segment_map->header->bin];\n\tsegment_map->header->freed = false;\n\tarea->control->segment_bins[segment_map->header->bin] = new_index;\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next =\n\t\tget_segment_by_index(area, segment_map->header->next);\n\n\t\tAssert(next->header->bin == segment_map->header->bin);\n\t\tnext->header->prev = new_index;\n\t}\n\n\treturn segment_map;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)",
      "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
      "#define DSA_MAX_SEGMENT_SIZE ((size_t) 1 << DSA_OFFSET_WIDTH)",
      "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))",
      "#define DSA_NUM_SEGMENTS_AT_EACH_SIZE 4",
      "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
    ],
    "globals_used": [
      "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *make_new_segment(dsa_area *area, size_t requested_pages);",
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "next->header->bin == segment_map->header->bin"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "segment_map->header->next"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "contiguous_pages_to_segment_bin",
          "args": [
            "usable_pages"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerPut",
          "args": [
            "segment_map->fpm",
            "metadata_bytes / FPM_PAGE_SIZE",
            "usable_pages"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "378-418",
          "snippet": "void\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerInitialize",
          "args": [
            "segment_map->fpm",
            "segment_map->mapped_address"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "182-202",
          "snippet": "void\nFreePageManagerInitialize(FreePageManager *fpm, char *base)\n{\n\tSize\t\tf;\n\n\trelptr_store(base, fpm->self, fpm);\n\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\trelptr_store(base, fpm->btree_recycle, (FreePageSpanLeader *) NULL);\n\tfpm->btree_depth = 0;\n\tfpm->btree_recycle_count = 0;\n\tfpm->singleton_first_page = 0;\n\tfpm->singleton_npages = 0;\n\tfpm->contiguous_pages = 0;\n\tfpm->contiguous_pages_dirty = true;\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages = 0;\n#endif\n\n\tfor (f = 0; f < FPM_NUM_FREELISTS; f++)\n\t\trelptr_store(base, fpm->freelist[f], (FreePageSpanLeader *) NULL);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerInitialize(FreePageManager *fpm, char *base)\n{\n\tSize\t\tf;\n\n\trelptr_store(base, fpm->self, fpm);\n\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\trelptr_store(base, fpm->btree_recycle, (FreePageSpanLeader *) NULL);\n\tfpm->btree_depth = 0;\n\tfpm->btree_recycle_count = 0;\n\tfpm->singleton_first_page = 0;\n\tfpm->singleton_npages = 0;\n\tfpm->contiguous_pages = 0;\n\tfpm->contiguous_pages_dirty = true;\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages = 0;\n#endif\n\n\tfor (f = 0; f < FPM_NUM_FREELISTS; f++)\n\t\trelptr_store(base, fpm->freelist[f], (FreePageSpanLeader *) NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_segment_header)"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_segment_header)"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_address",
          "args": [
            "segment"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_handle",
          "args": [
            "segment"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_pin_mapping",
          "args": [
            "segment"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_pin_segment",
          "args": [
            "segment"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_create",
          "args": [
            "total_size",
            "0"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_segment_header)"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_segment_header)"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "total_size",
            "area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "total_size",
            "DSA_MAX_SEGMENT_SIZE"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(DSA_AREA_LOCK(area))"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENT_SIZE ((size_t) 1 << DSA_OFFSET_WIDTH)\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n#define DSA_NUM_SEGMENTS_AT_EACH_SIZE 4\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *make_new_segment(dsa_area *area, size_t requested_pages);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nmake_new_segment(dsa_area *area, size_t requested_pages)\n{\n\tdsa_segment_index new_index;\n\tsize_t\t\tmetadata_bytes;\n\tsize_t\t\ttotal_size;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tusable_pages;\n\tdsa_segment_map *segment_map;\n\tdsm_segment *segment;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\n\t/* Find a segment slot that is not in use (linearly for now). */\n\tfor (new_index = 1; new_index < DSA_MAX_SEGMENTS; ++new_index)\n\t{\n\t\tif (area->control->segment_handles[new_index] == DSM_HANDLE_INVALID)\n\t\t\tbreak;\n\t}\n\tif (new_index == DSA_MAX_SEGMENTS)\n\t\treturn NULL;\n\n\t/*\n\t * If the total size limit is already exceeded, then we exit early and\n\t * avoid arithmetic wraparound in the unsigned expressions below.\n\t */\n\tif (area->control->total_segment_size >=\n\t\tarea->control->max_total_segment_size)\n\t\treturn NULL;\n\n\t/*\n\t * The size should be at least as big as requested, and at least big\n\t * enough to follow a geometric series that approximately doubles the\n\t * total storage each time we create a new segment.  We use geometric\n\t * growth because the underlying DSM system isn't designed for large\n\t * numbers of segments (otherwise we might even consider just using one\n\t * DSM segment for each large allocation and for each superblock, and then\n\t * we wouldn't need to use FreePageManager).\n\t *\n\t * We decide on a total segment size first, so that we produce tidy\n\t * power-of-two sized segments.  This is a good property to have if we\n\t * move to huge pages in the future.  Then we work back to the number of\n\t * pages we can fit.\n\t */\n\ttotal_size = DSA_INITIAL_SEGMENT_SIZE *\n\t\t((size_t) 1 << (new_index / DSA_NUM_SEGMENTS_AT_EACH_SIZE));\n\ttotal_size = Min(total_size, DSA_MAX_SEGMENT_SIZE);\n\ttotal_size = Min(total_size,\n\t\t\t\t\t area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size);\n\n\ttotal_pages = total_size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\tsizeof(dsa_pointer) * total_pages;\n\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tif (total_size <= metadata_bytes)\n\t\treturn NULL;\n\tusable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;\n\tAssert(metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size);\n\n\t/* See if that is enough... */\n\tif (requested_pages > usable_pages)\n\t{\n\t\t/*\n\t\t * We'll make an odd-sized segment, working forward from the requested\n\t\t * number of pages.\n\t\t */\n\t\tusable_pages = requested_pages;\n\t\tmetadata_bytes =\n\t\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\t\tusable_pages * sizeof(dsa_pointer);\n\n\t\t/* Add padding up to next page boundary. */\n\t\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\t\ttotal_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;\n\n\t\t/* Is that too large for dsa_pointer's addressing scheme? */\n\t\tif (total_size > DSA_MAX_SEGMENT_SIZE)\n\t\t\treturn NULL;\n\n\t\t/* Would that exceed the limit? */\n\t\tif (total_size > area->control->max_total_segment_size -\n\t\t\tarea->control->total_segment_size)\n\t\t\treturn NULL;\n\t}\n\n\t/* Create the segment. */\n\tsegment = dsm_create(total_size, 0);\n\tif (segment == NULL)\n\t\treturn NULL;\n\tdsm_pin_segment(segment);\n\tif (area->mapping_pinned)\n\t\tdsm_pin_mapping(segment);\n\n\t/* Store the handle in shared memory to be found by index. */\n\tarea->control->segment_handles[new_index] =\n\t\tdsm_segment_handle(segment);\n\t/* Track the highest segment index in the history of the area. */\n\tif (area->control->high_segment_index < new_index)\n\t\tarea->control->high_segment_index = new_index;\n\t/* Track the highest segment index this backend has ever mapped. */\n\tif (area->high_segment_index < new_index)\n\t\tarea->high_segment_index = new_index;\n\t/* Track total size of all segments. */\n\tarea->control->total_segment_size += total_size;\n\tAssert(area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size);\n\n\t/* Build a segment map for this segment in this backend. */\n\tsegment_map = &area->segment_maps[new_index];\n\tsegment_map->segment = segment;\n\tsegment_map->mapped_address = dsm_segment_address(segment);\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t   usable_pages);\n\n\t/* Set up the segment header and put it in the appropriate bin. */\n\tsegment_map->header->magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ new_index;\n\tsegment_map->header->usable_pages = usable_pages;\n\tsegment_map->header->size = total_size;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\tsegment_map->header->next =\n\t\tarea->control->segment_bins[segment_map->header->bin];\n\tsegment_map->header->freed = false;\n\tarea->control->segment_bins[segment_map->header->bin] = new_index;\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next =\n\t\tget_segment_by_index(area, segment_map->header->next);\n\n\t\tAssert(next->header->bin == segment_map->header->bin);\n\t\tnext->header->prev = new_index;\n\t}\n\n\treturn segment_map;\n}"
  },
  {
    "function_name": "get_best_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1969-2054",
    "snippet": "static dsa_segment_map *\nget_best_segment(dsa_area *area, size_t npages)\n{\n\tsize_t\t\tbin;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tcheck_for_freed_segments_locked(area);\n\n\t/*\n\t * Start searching from the first bin that *might* have enough contiguous\n\t * pages.\n\t */\n\tfor (bin = contiguous_pages_to_segment_bin(npages);\n\t\t bin < DSA_NUM_SEGMENT_BINS;\n\t\t ++bin)\n\t{\n\t\t/*\n\t\t * The minimum contiguous size that any segment in this bin should\n\t\t * have.  We'll re-bin if we see segments with fewer.\n\t\t */\n\t\tsize_t\t\tthreshold = (size_t) 1 << (bin - 1);\n\t\tdsa_segment_index segment_index;\n\n\t\t/* Search this bin for a segment with enough contiguous space. */\n\t\tsegment_index = area->control->segment_bins[bin];\n\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_map *segment_map;\n\t\t\tdsa_segment_index next_segment_index;\n\t\t\tsize_t\t\tcontiguous_pages;\n\n\t\t\tsegment_map = get_segment_by_index(area, segment_index);\n\t\t\tnext_segment_index = segment_map->header->next;\n\t\t\tcontiguous_pages = fpm_largest(segment_map->fpm);\n\n\t\t\t/* Not enough for the request, still enough for this bin. */\n\t\t\tif (contiguous_pages >= threshold && contiguous_pages < npages)\n\t\t\t{\n\t\t\t\tsegment_index = next_segment_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Re-bin it if it's no longer in the appropriate bin. */\n\t\t\tif (contiguous_pages < threshold)\n\t\t\t{\n\t\t\t\tsize_t\t\tnew_bin;\n\n\t\t\t\tnew_bin = contiguous_pages_to_segment_bin(contiguous_pages);\n\n\t\t\t\t/* Remove it from its current bin. */\n\t\t\t\tunlink_segment(area, segment_map);\n\n\t\t\t\t/* Push it onto the front of its new bin. */\n\t\t\t\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\t\t\t\tsegment_map->header->next =\n\t\t\t\t\tarea->control->segment_bins[new_bin];\n\t\t\t\tsegment_map->header->bin = new_bin;\n\t\t\t\tarea->control->segment_bins[new_bin] = segment_index;\n\t\t\t\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tdsa_segment_map *next;\n\n\t\t\t\t\tnext = get_segment_by_index(area,\n\t\t\t\t\t\t\t\t\t\t\t\tsegment_map->header->next);\n\t\t\t\t\tAssert(next->header->bin == new_bin);\n\t\t\t\t\tnext->header->prev = segment_index;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * But fall through to see if it's enough to satisfy this\n\t\t\t\t * request anyway....\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* Check if we are done. */\n\t\t\tif (contiguous_pages >= npages)\n\t\t\t\treturn segment_map;\n\n\t\t\t/* Continue searching the same bin. */\n\t\t\tsegment_index = next_segment_index;\n\t\t}\n\t}\n\n\t/* Not found. */\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_NUM_SEGMENT_BINS 16",
      "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
    ],
    "globals_used": [
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "next->header->bin == new_bin"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "segment_map->header->next"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_segment",
          "args": [
            "area",
            "segment_map"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1937-1961",
          "snippet": "static void\nunlink_segment(dsa_area *area, dsa_segment_map *segment_map)\n{\n\tif (segment_map->header->prev != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *prev;\n\n\t\tprev = get_segment_by_index(area, segment_map->header->prev);\n\t\tprev->header->next = segment_map->header->next;\n\t}\n\telse\n\t{\n\t\tAssert(area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map));\n\t\tarea->control->segment_bins[segment_map->header->bin] =\n\t\t\tsegment_map->header->next;\n\t}\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next;\n\n\t\tnext = get_segment_by_index(area, segment_map->header->next);\n\t\tnext->header->prev = segment_map->header->prev;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nunlink_segment(dsa_area *area, dsa_segment_map *segment_map)\n{\n\tif (segment_map->header->prev != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *prev;\n\n\t\tprev = get_segment_by_index(area, segment_map->header->prev);\n\t\tprev->header->next = segment_map->header->next;\n\t}\n\telse\n\t{\n\t\tAssert(area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map));\n\t\tarea->control->segment_bins[segment_map->header->bin] =\n\t\t\tsegment_map->header->next;\n\t}\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next;\n\n\t\tnext = get_segment_by_index(area, segment_map->header->next);\n\t\tnext->header->prev = segment_map->header->prev;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "contiguous_pages_to_segment_bin",
          "args": [
            "contiguous_pages"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_largest",
          "args": [
            "segment_map->fpm"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contiguous_pages_to_segment_bin",
          "args": [
            "npages"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_freed_segments_locked",
          "args": [
            "area"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_freed_segments_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2266-2289",
          "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(DSA_AREA_LOCK(area))"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_best_segment(dsa_area *area, size_t npages)\n{\n\tsize_t\t\tbin;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tcheck_for_freed_segments_locked(area);\n\n\t/*\n\t * Start searching from the first bin that *might* have enough contiguous\n\t * pages.\n\t */\n\tfor (bin = contiguous_pages_to_segment_bin(npages);\n\t\t bin < DSA_NUM_SEGMENT_BINS;\n\t\t ++bin)\n\t{\n\t\t/*\n\t\t * The minimum contiguous size that any segment in this bin should\n\t\t * have.  We'll re-bin if we see segments with fewer.\n\t\t */\n\t\tsize_t\t\tthreshold = (size_t) 1 << (bin - 1);\n\t\tdsa_segment_index segment_index;\n\n\t\t/* Search this bin for a segment with enough contiguous space. */\n\t\tsegment_index = area->control->segment_bins[bin];\n\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_map *segment_map;\n\t\t\tdsa_segment_index next_segment_index;\n\t\t\tsize_t\t\tcontiguous_pages;\n\n\t\t\tsegment_map = get_segment_by_index(area, segment_index);\n\t\t\tnext_segment_index = segment_map->header->next;\n\t\t\tcontiguous_pages = fpm_largest(segment_map->fpm);\n\n\t\t\t/* Not enough for the request, still enough for this bin. */\n\t\t\tif (contiguous_pages >= threshold && contiguous_pages < npages)\n\t\t\t{\n\t\t\t\tsegment_index = next_segment_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Re-bin it if it's no longer in the appropriate bin. */\n\t\t\tif (contiguous_pages < threshold)\n\t\t\t{\n\t\t\t\tsize_t\t\tnew_bin;\n\n\t\t\t\tnew_bin = contiguous_pages_to_segment_bin(contiguous_pages);\n\n\t\t\t\t/* Remove it from its current bin. */\n\t\t\t\tunlink_segment(area, segment_map);\n\n\t\t\t\t/* Push it onto the front of its new bin. */\n\t\t\t\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\t\t\t\tsegment_map->header->next =\n\t\t\t\t\tarea->control->segment_bins[new_bin];\n\t\t\t\tsegment_map->header->bin = new_bin;\n\t\t\t\tarea->control->segment_bins[new_bin] = segment_index;\n\t\t\t\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tdsa_segment_map *next;\n\n\t\t\t\t\tnext = get_segment_by_index(area,\n\t\t\t\t\t\t\t\t\t\t\t\tsegment_map->header->next);\n\t\t\t\t\tAssert(next->header->bin == new_bin);\n\t\t\t\t\tnext->header->prev = segment_index;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * But fall through to see if it's enough to satisfy this\n\t\t\t\t * request anyway....\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* Check if we are done. */\n\t\t\tif (contiguous_pages >= npages)\n\t\t\t\treturn segment_map;\n\n\t\t\t/* Continue searching the same bin. */\n\t\t\tsegment_index = next_segment_index;\n\t\t}\n\t}\n\n\t/* Not found. */\n\treturn NULL;\n}"
  },
  {
    "function_name": "unlink_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1937-1961",
    "snippet": "static void\nunlink_segment(dsa_area *area, dsa_segment_map *segment_map)\n{\n\tif (segment_map->header->prev != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *prev;\n\n\t\tprev = get_segment_by_index(area, segment_map->header->prev);\n\t\tprev->header->next = segment_map->header->next;\n\t}\n\telse\n\t{\n\t\tAssert(area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map));\n\t\tarea->control->segment_bins[segment_map->header->bin] =\n\t\t\tsegment_map->header->next;\n\t}\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next;\n\n\t\tnext = get_segment_by_index(area, segment_map->header->next);\n\t\tnext->header->prev = segment_map->header->prev;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
    ],
    "globals_used": [
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "segment_map->header->next"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map)"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_index",
          "args": [
            "area",
            "segment_map"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nunlink_segment(dsa_area *area, dsa_segment_map *segment_map)\n{\n\tif (segment_map->header->prev != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *prev;\n\n\t\tprev = get_segment_by_index(area, segment_map->header->prev);\n\t\tprev->header->next = segment_map->header->next;\n\t}\n\telse\n\t{\n\t\tAssert(area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map));\n\t\tarea->control->segment_bins[segment_map->header->bin] =\n\t\t\tsegment_map->header->next;\n\t}\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next;\n\n\t\tnext = get_segment_by_index(area, segment_map->header->next);\n\t\tnext->header->prev = segment_map->header->prev;\n\t}\n}"
  },
  {
    "function_name": "dsa_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1911-1932",
    "snippet": "void\ndsa_detach(dsa_area *area)\n{\n\tint\t\t\ti;\n\n\t/* Detach from all segments. */\n\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\tif (area->segment_maps[i].segment != NULL)\n\t\t\tdsm_detach(area->segment_maps[i].segment);\n\n\t/*\n\t * Note that 'detaching' (= detaching from DSM segments) doesn't include\n\t * 'releasing' (= adjusting the reference count).  It would be nice to\n\t * combine these operations, but client code might never get around to\n\t * calling dsa_detach because of an error path, and a detach hook on any\n\t * particular segment is too late to detach other segments in the area\n\t * without risking a 'leak' warning in the non-error path.\n\t */\n\n\t/* Free the backend-local area object. */\n\tpfree(area);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "area"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_detach",
          "args": [
            "area->segment_maps[i].segment"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_detach(dsa_area *area)\n{\n\tint\t\t\ti;\n\n\t/* Detach from all segments. */\n\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\tif (area->segment_maps[i].segment != NULL)\n\t\t\tdsm_detach(area->segment_maps[i].segment);\n\n\t/*\n\t * Note that 'detaching' (= detaching from DSM segments) doesn't include\n\t * 'releasing' (= adjusting the reference count).  It would be nice to\n\t * combine these operations, but client code might never get around to\n\t * calling dsa_detach because of an error path, and a detach hook on any\n\t * particular segment is too late to detach other segments in the area\n\t * without risking a 'leak' warning in the non-error path.\n\t */\n\n\t/* Free the backend-local area object. */\n\tpfree(area);\n}"
  },
  {
    "function_name": "add_span_to_fullness_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1888-1906",
    "snippet": "static void\nadd_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer,\n\t\t\t\t\t\t   int fclass)\n{\n\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\tif (DsaPointerIsValid(pool->spans[fclass]))\n\t{\n\t\tdsa_area_span *head = dsa_get_address(area,\n\t\t\t\t\t\t\t\t\t\t\t  pool->spans[fclass]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->prevspan = InvalidDsaPointer;\n\tspan->nextspan = pool->spans[fclass];\n\tpool->spans[fclass] = span_pointer;\n\tspan->fclass = fclass;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "pool->spans[fclass]"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[fclass]"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nadd_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer,\n\t\t\t\t\t\t   int fclass)\n{\n\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\tif (DsaPointerIsValid(pool->spans[fclass]))\n\t{\n\t\tdsa_area_span *head = dsa_get_address(area,\n\t\t\t\t\t\t\t\t\t\t\t  pool->spans[fclass]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->prevspan = InvalidDsaPointer;\n\tspan->nextspan = pool->spans[fclass];\n\tpool->spans[fclass] = span_pointer;\n\tspan->fclass = fclass;\n}"
  },
  {
    "function_name": "unlink_span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1865-1886",
    "snippet": "static void\nunlink_span(dsa_area *area, dsa_area_span *span)\n{\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tdsa_area_span *next = dsa_get_address(area, span->nextspan);\n\n\t\tnext->prevspan = span->prevspan;\n\t}\n\tif (DsaPointerIsValid(span->prevspan))\n\t{\n\t\tdsa_area_span *prev = dsa_get_address(area, span->prevspan);\n\n\t\tprev->nextspan = span->nextspan;\n\t}\n\telse\n\t{\n\t\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\t\tpool->spans[span->fclass] = span->nextspan;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "span->pool"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->prevspan"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->nextspan"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nunlink_span(dsa_area *area, dsa_area_span *span)\n{\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tdsa_area_span *next = dsa_get_address(area, span->nextspan);\n\n\t\tnext->prevspan = span->prevspan;\n\t}\n\tif (DsaPointerIsValid(span->prevspan))\n\t{\n\t\tdsa_area_span *prev = dsa_get_address(area, span->prevspan);\n\n\t\tprev->nextspan = span->nextspan;\n\t}\n\telse\n\t{\n\t\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\t\tpool->spans[span->fclass] = span->nextspan;\n\t}\n}"
  },
  {
    "function_name": "destroy_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1801-1863",
    "snippet": "static void\ndestroy_superblock(dsa_area *area, dsa_pointer span_pointer)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tint\t\t\tsize_class = span->size_class;\n\tdsa_segment_map *segment_map;\n\n\n\t/* Remove it from its fullness class list. */\n\tunlink_span(area, span);\n\n\t/*\n\t * Note: Here we acquire the area lock while we already hold a per-pool\n\t * lock.  We never hold the area lock and then take a pool lock, or we\n\t * could deadlock.\n\t */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tsegment_map =\n\t\tget_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(span->start));\n\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t   span->npages);\n\t/* Check if the segment is now entirely free. */\n\tif (fpm_largest(segment_map->fpm) == segment_map->header->usable_pages)\n\t{\n\t\tdsa_segment_index index = get_segment_index(area, segment_map);\n\n\t\t/* If it's not the segment with extra control data, free it. */\n\t\tif (index != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Give it back to the OS, and allow other backends to detect that\n\t\t\t * they need to detach.\n\t\t\t */\n\t\t\tunlink_segment(area, segment_map);\n\t\t\tsegment_map->header->freed = true;\n\t\t\tAssert(area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size);\n\t\t\tarea->control->total_segment_size -=\n\t\t\t\tsegment_map->header->size;\n\t\t\tdsm_unpin_segment(dsm_segment_handle(segment_map->segment));\n\t\t\tdsm_detach(segment_map->segment);\n\t\t\tarea->control->segment_handles[index] = DSM_HANDLE_INVALID;\n\t\t\t++area->control->freed_segment_counter;\n\t\t\tsegment_map->segment = NULL;\n\t\t\tsegment_map->header = NULL;\n\t\t\tsegment_map->mapped_address = NULL;\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/*\n\t * Span-of-spans blocks store the span which describes them within the\n\t * block itself, so freeing the storage implicitly frees the descriptor\n\t * also.  If this is a block of any other type, we need to separately free\n\t * the span object also.  This recursive call to dsa_free will acquire the\n\t * span pool's lock.  We can't deadlock because the acquisition order is\n\t * always some other pool and then the span pool.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tdsa_free(area, span_pointer);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
    ],
    "globals_used": [
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsa_free",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "819-923",
          "snippet": "void\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
            "#define DSA_FULLNESS_CLASSES\t\t4",
            "#define DSA_SCLASS_SPAN_LARGE\t\t\t1"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_detach",
          "args": [
            "segment_map->segment"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_unpin_segment",
          "args": [
            "dsm_segment_handle(segment_map->segment)"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_handle",
          "args": [
            "segment_map->segment"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_segment",
          "args": [
            "area",
            "segment_map"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1937-1961",
          "snippet": "static void\nunlink_segment(dsa_area *area, dsa_segment_map *segment_map)\n{\n\tif (segment_map->header->prev != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *prev;\n\n\t\tprev = get_segment_by_index(area, segment_map->header->prev);\n\t\tprev->header->next = segment_map->header->next;\n\t}\n\telse\n\t{\n\t\tAssert(area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map));\n\t\tarea->control->segment_bins[segment_map->header->bin] =\n\t\t\tsegment_map->header->next;\n\t}\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next;\n\n\t\tnext = get_segment_by_index(area, segment_map->header->next);\n\t\tnext->header->prev = segment_map->header->prev;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nunlink_segment(dsa_area *area, dsa_segment_map *segment_map)\n{\n\tif (segment_map->header->prev != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *prev;\n\n\t\tprev = get_segment_by_index(area, segment_map->header->prev);\n\t\tprev->header->next = segment_map->header->next;\n\t}\n\telse\n\t{\n\t\tAssert(area->control->segment_bins[segment_map->header->bin] ==\n\t\t\t   get_segment_index(area, segment_map));\n\t\tarea->control->segment_bins[segment_map->header->bin] =\n\t\t\tsegment_map->header->next;\n\t}\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next;\n\n\t\tnext = get_segment_by_index(area, segment_map->header->next);\n\t\tnext->header->prev = segment_map->header->prev;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_segment_index",
          "args": [
            "area",
            "segment_map"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_largest",
          "args": [
            "segment_map->fpm"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerPut",
          "args": [
            "segment_map->fpm",
            "DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE",
            "span->npages"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "378-418",
          "snippet": "void\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_OFFSET",
          "args": [
            "span->start"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "DSA_EXTRACT_SEGMENT_NUMBER(span->start)"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_SEGMENT_NUMBER",
          "args": [
            "span->start"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_freed_segments_locked",
          "args": [
            "area"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_freed_segments_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2266-2289",
          "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_span",
          "args": [
            "area",
            "span"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1865-1886",
          "snippet": "static void\nunlink_span(dsa_area *area, dsa_area_span *span)\n{\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tdsa_area_span *next = dsa_get_address(area, span->nextspan);\n\n\t\tnext->prevspan = span->prevspan;\n\t}\n\tif (DsaPointerIsValid(span->prevspan))\n\t{\n\t\tdsa_area_span *prev = dsa_get_address(area, span->prevspan);\n\n\t\tprev->nextspan = span->nextspan;\n\t}\n\telse\n\t{\n\t\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\t\tpool->spans[span->fclass] = span->nextspan;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nunlink_span(dsa_area *area, dsa_area_span *span)\n{\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tdsa_area_span *next = dsa_get_address(area, span->nextspan);\n\n\t\tnext->prevspan = span->prevspan;\n\t}\n\tif (DsaPointerIsValid(span->prevspan))\n\t{\n\t\tdsa_area_span *prev = dsa_get_address(area, span->prevspan);\n\n\t\tprev->nextspan = span->nextspan;\n\t}\n\telse\n\t{\n\t\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\t\tpool->spans[span->fclass] = span->nextspan;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ndestroy_superblock(dsa_area *area, dsa_pointer span_pointer)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tint\t\t\tsize_class = span->size_class;\n\tdsa_segment_map *segment_map;\n\n\n\t/* Remove it from its fullness class list. */\n\tunlink_span(area, span);\n\n\t/*\n\t * Note: Here we acquire the area lock while we already hold a per-pool\n\t * lock.  We never hold the area lock and then take a pool lock, or we\n\t * could deadlock.\n\t */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tsegment_map =\n\t\tget_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(span->start));\n\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t   span->npages);\n\t/* Check if the segment is now entirely free. */\n\tif (fpm_largest(segment_map->fpm) == segment_map->header->usable_pages)\n\t{\n\t\tdsa_segment_index index = get_segment_index(area, segment_map);\n\n\t\t/* If it's not the segment with extra control data, free it. */\n\t\tif (index != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Give it back to the OS, and allow other backends to detect that\n\t\t\t * they need to detach.\n\t\t\t */\n\t\t\tunlink_segment(area, segment_map);\n\t\t\tsegment_map->header->freed = true;\n\t\t\tAssert(area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size);\n\t\t\tarea->control->total_segment_size -=\n\t\t\t\tsegment_map->header->size;\n\t\t\tdsm_unpin_segment(dsm_segment_handle(segment_map->segment));\n\t\t\tdsm_detach(segment_map->segment);\n\t\t\tarea->control->segment_handles[index] = DSM_HANDLE_INVALID;\n\t\t\t++area->control->freed_segment_counter;\n\t\t\tsegment_map->segment = NULL;\n\t\t\tsegment_map->header = NULL;\n\t\t\tsegment_map->mapped_address = NULL;\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/*\n\t * Span-of-spans blocks store the span which describes them within the\n\t * block itself, so freeing the storage implicitly frees the descriptor\n\t * also.  If this is a block of any other type, we need to separately free\n\t * the span object also.  This recursive call to dsa_free will acquire the\n\t * span pool's lock.  We can't deadlock because the acquisition order is\n\t * always some other pool and then the span pool.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tdsa_free(area, span_pointer);\n}"
  },
  {
    "function_name": "get_segment_by_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1723-1793",
    "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
    ],
    "globals_used": [
      "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!area->segment_maps[index].header->freed"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_segment_header)"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_segment_header)"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_address",
          "args": [
            "segment"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_pin_mapping",
          "args": [
            "segment"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"dsa_area could not attach to segment\""
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_attach",
          "args": [
            "handle"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "area->segment_maps[index].mapped_address == NULL"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
  },
  {
    "function_name": "ensure_active_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1527-1713",
    "snippet": "static bool\nensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class)\n{\n\tdsa_pointer span_pointer;\n\tdsa_pointer start_pointer;\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\tsize_t\t\tnmax;\n\tint\t\t\tfclass;\n\tsize_t\t\tnpages = 1;\n\tsize_t\t\tfirst_page;\n\tsize_t\t\ti;\n\tdsa_segment_map *segment_map;\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/*\n\t * Compute the number of objects that will fit in a block of this size\n\t * class.  Span-of-spans blocks are just a single page, and the first\n\t * object isn't available for use because it describes the block-of-spans\n\t * itself.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tnmax = FPM_PAGE_SIZE / obsize - 1;\n\telse\n\t\tnmax = DSA_SUPERBLOCK_SIZE / obsize;\n\n\t/*\n\t * If fullness class 1 is empty, try to find a span to put in it by\n\t * scanning higher-numbered fullness classes (excluding the last one,\n\t * whose blocks are certain to all be completely full).\n\t */\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t{\n\t\tspan_pointer = pool->spans[fclass];\n\n\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\tint\t\t\ttfclass;\n\t\t\tdsa_area_span *span;\n\t\t\tdsa_area_span *nextspan;\n\t\t\tdsa_area_span *prevspan;\n\t\t\tdsa_pointer next_span_pointer;\n\n\t\t\tspan = (dsa_area_span *)\n\t\t\t\tdsa_get_address(area, span_pointer);\n\t\t\tnext_span_pointer = span->nextspan;\n\n\t\t\t/* Figure out what fullness class should contain this span. */\n\t\t\ttfclass = (nmax - span->nallocatable)\n\t\t\t\t* (DSA_FULLNESS_CLASSES - 1) / nmax;\n\n\t\t\t/* Look up next span. */\n\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\telse\n\t\t\t\tnextspan = NULL;\n\n\t\t\t/*\n\t\t\t * If utilization has dropped enough that this now belongs in some\n\t\t\t * other fullness class, move it there.\n\t\t\t */\n\t\t\tif (tfclass < fclass)\n\t\t\t{\n\t\t\t\t/* Remove from the current fullness class list. */\n\t\t\t\tif (pool->spans[fclass] == span_pointer)\n\t\t\t\t{\n\t\t\t\t\t/* It was the head; remove it. */\n\t\t\t\t\tAssert(!DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tpool->spans[fclass] = span->nextspan;\n\t\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\t\tnextspan->prevspan = InvalidDsaPointer;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* It was not the head. */\n\t\t\t\t\tAssert(DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tprevspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->prevspan);\n\t\t\t\t\tprevspan->nextspan = span->nextspan;\n\t\t\t\t}\n\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\tnextspan->prevspan = span->prevspan;\n\n\t\t\t\t/* Push onto the head of the new fullness class list. */\n\t\t\t\tspan->nextspan = pool->spans[tfclass];\n\t\t\t\tpool->spans[tfclass] = span_pointer;\n\t\t\t\tspan->prevspan = InvalidDsaPointer;\n\t\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\t{\n\t\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\t\t\tnextspan->prevspan = span_pointer;\n\t\t\t\t}\n\t\t\t\tspan->fclass = tfclass;\n\t\t\t}\n\n\t\t\t/* Advance to next span on list. */\n\t\t\tspan_pointer = next_span_pointer;\n\t\t}\n\n\t\t/* Stop now if we found a suitable block. */\n\t\tif (DsaPointerIsValid(pool->spans[1]))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If there are no blocks that properly belong in fullness class 1, pick\n\t * one from some other fullness class and move it there anyway, so that we\n\t * have an allocation target.  Our last choice is to transfer a block\n\t * that's almost empty (and might become completely empty soon if left\n\t * alone), but even that is better than failing, which is what we must do\n\t * if there are no blocks at all with freespace.\n\t */\n\tAssert(!DsaPointerIsValid(pool->spans[1]));\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t\tif (transfer_first_span(area, pool, fclass, 1))\n\t\t\treturn true;\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\ttransfer_first_span(area, pool, 0, 1))\n\t\treturn true;\n\n\t/*\n\t * We failed to find an existing span with free objects, so we need to\n\t * allocate a new superblock and construct a new span to manage it.\n\t *\n\t * First, get a dsa_area_span object to describe the new superblock block\n\t * ... unless this allocation is for a dsa_area_span object, in which case\n\t * that's surely not going to work.  We handle that case by storing the\n\t * span describing a block-of-spans inline.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\tspan_pointer = alloc_object(area, DSA_SCLASS_BLOCK_OF_SPANS);\n\t\tif (!DsaPointerIsValid(span_pointer))\n\t\t\treturn false;\n\t\tnpages = DSA_PAGES_PER_SUPERBLOCK;\n\t}\n\n\t/* Find or create a segment and allocate the superblock. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tsegment_map = get_best_segment(area, npages);\n\tif (segment_map == NULL)\n\t{\n\t\tsegment_map = make_new_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t{\n\t\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*\n\t * This shouldn't happen: get_best_segment() or make_new_segment()\n\t * promised that we can successfully allocate npages.\n\t */\n\tif (!FreePageManagerGet(segment_map->fpm, npages, &first_page))\n\t\telog(FATAL,\n\t\t\t \"dsa_allocate could not find %zu free pages for superblock\",\n\t\t\t npages);\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/* Compute the start of the superblock. */\n\tstart_pointer =\n\t\tDSA_MAKE_POINTER(get_segment_index(area, segment_map),\n\t\t\t\t\t\t first_page * FPM_PAGE_SIZE);\n\n\t/*\n\t * If this is a block-of-spans, carve the descriptor right out of the\n\t * allocated space.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * We have a pointer into the segment.  We need to build a dsa_pointer\n\t\t * from the segment index and offset into the segment.\n\t\t */\n\t\tspan_pointer = start_pointer;\n\t}\n\n\t/* Initialize span and pagemap. */\n\tinit_span(area, span_pointer, pool, start_pointer, npages, size_class);\n\tfor (i = 0; i < npages; ++i)\n\t\tsegment_map->pagemap[first_page + i] = span_pointer;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
      "#define DSA_FULLNESS_CLASSES\t\t4",
      "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0",
      "#define DSA_PAGES_PER_SUPERBLOCK\t\t16"
    ],
    "globals_used": [
      "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_span",
          "args": [
            "area",
            "span_pointer",
            "pool",
            "start_pointer",
            "npages",
            "size_class"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "init_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1344-1393",
          "snippet": "static void\ninit_span(dsa_area *area,\n\t\t  dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\n\t/*\n\t * The per-pool lock must be held because we manipulate the span list for\n\t * this pool.\n\t */\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/* Push this span onto the front of the span list for fullness class 1. */\n\tif (DsaPointerIsValid(pool->spans[1]))\n\t{\n\t\tdsa_area_span *head = (dsa_area_span *)\n\t\tdsa_get_address(area, pool->spans[1]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->pool = DsaAreaPoolToDsaPointer(area, pool);\n\tspan->nextspan = pool->spans[1];\n\tspan->prevspan = InvalidDsaPointer;\n\tpool->spans[1] = span_pointer;\n\n\tspan->start = start;\n\tspan->npages = npages;\n\tspan->size_class = size_class;\n\tspan->ninitialized = 0;\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * A block-of-spans contains its own descriptor, so mark one object as\n\t\t * initialized and reduce the count of allocatable objects by one.\n\t\t * Doing this here has the side effect of also reducing nmax by one,\n\t\t * which is important to make sure we free this object at the correct\n\t\t * time.\n\t\t */\n\t\tspan->ninitialized = 1;\n\t\tspan->nallocatable = FPM_PAGE_SIZE / obsize - 1;\n\t}\n\telse if (size_class != DSA_SCLASS_SPAN_LARGE)\n\t\tspan->nallocatable = DSA_SUPERBLOCK_SIZE / obsize;\n\tspan->firstfree = DSA_SPAN_NOTHING_FREE;\n\tspan->nmax = span->nallocatable;\n\tspan->fclass = 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
            "#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)",
            "#define DSA_SCLASS_SPAN_LARGE\t\t\t1",
            "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ninit_span(dsa_area *area,\n\t\t  dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\n\t/*\n\t * The per-pool lock must be held because we manipulate the span list for\n\t * this pool.\n\t */\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/* Push this span onto the front of the span list for fullness class 1. */\n\tif (DsaPointerIsValid(pool->spans[1]))\n\t{\n\t\tdsa_area_span *head = (dsa_area_span *)\n\t\tdsa_get_address(area, pool->spans[1]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->pool = DsaAreaPoolToDsaPointer(area, pool);\n\tspan->nextspan = pool->spans[1];\n\tspan->prevspan = InvalidDsaPointer;\n\tpool->spans[1] = span_pointer;\n\n\tspan->start = start;\n\tspan->npages = npages;\n\tspan->size_class = size_class;\n\tspan->ninitialized = 0;\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * A block-of-spans contains its own descriptor, so mark one object as\n\t\t * initialized and reduce the count of allocatable objects by one.\n\t\t * Doing this here has the side effect of also reducing nmax by one,\n\t\t * which is important to make sure we free this object at the correct\n\t\t * time.\n\t\t */\n\t\tspan->ninitialized = 1;\n\t\tspan->nallocatable = FPM_PAGE_SIZE / obsize - 1;\n\t}\n\telse if (size_class != DSA_SCLASS_SPAN_LARGE)\n\t\tspan->nallocatable = DSA_SUPERBLOCK_SIZE / obsize;\n\tspan->firstfree = DSA_SPAN_NOTHING_FREE;\n\tspan->nmax = span->nallocatable;\n\tspan->fclass = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_MAKE_POINTER",
          "args": [
            "get_segment_index(area, segment_map)",
            "first_page * FPM_PAGE_SIZE"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_index",
          "args": [
            "area",
            "segment_map"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"dsa_allocate could not find %zu free pages for superblock\"",
            "npages"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerGet",
          "args": [
            "segment_map->fpm",
            "npages",
            "&first_page"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerGetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1318-1464",
          "snippet": "static bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_new_segment",
          "args": [
            "area",
            "npages"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "make_new_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2061-2215",
          "snippet": "static dsa_segment_map *\nmake_new_segment(dsa_area *area, size_t requested_pages)\n{\n\tdsa_segment_index new_index;\n\tsize_t\t\tmetadata_bytes;\n\tsize_t\t\ttotal_size;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tusable_pages;\n\tdsa_segment_map *segment_map;\n\tdsm_segment *segment;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\n\t/* Find a segment slot that is not in use (linearly for now). */\n\tfor (new_index = 1; new_index < DSA_MAX_SEGMENTS; ++new_index)\n\t{\n\t\tif (area->control->segment_handles[new_index] == DSM_HANDLE_INVALID)\n\t\t\tbreak;\n\t}\n\tif (new_index == DSA_MAX_SEGMENTS)\n\t\treturn NULL;\n\n\t/*\n\t * If the total size limit is already exceeded, then we exit early and\n\t * avoid arithmetic wraparound in the unsigned expressions below.\n\t */\n\tif (area->control->total_segment_size >=\n\t\tarea->control->max_total_segment_size)\n\t\treturn NULL;\n\n\t/*\n\t * The size should be at least as big as requested, and at least big\n\t * enough to follow a geometric series that approximately doubles the\n\t * total storage each time we create a new segment.  We use geometric\n\t * growth because the underlying DSM system isn't designed for large\n\t * numbers of segments (otherwise we might even consider just using one\n\t * DSM segment for each large allocation and for each superblock, and then\n\t * we wouldn't need to use FreePageManager).\n\t *\n\t * We decide on a total segment size first, so that we produce tidy\n\t * power-of-two sized segments.  This is a good property to have if we\n\t * move to huge pages in the future.  Then we work back to the number of\n\t * pages we can fit.\n\t */\n\ttotal_size = DSA_INITIAL_SEGMENT_SIZE *\n\t\t((size_t) 1 << (new_index / DSA_NUM_SEGMENTS_AT_EACH_SIZE));\n\ttotal_size = Min(total_size, DSA_MAX_SEGMENT_SIZE);\n\ttotal_size = Min(total_size,\n\t\t\t\t\t area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size);\n\n\ttotal_pages = total_size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\tsizeof(dsa_pointer) * total_pages;\n\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tif (total_size <= metadata_bytes)\n\t\treturn NULL;\n\tusable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;\n\tAssert(metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size);\n\n\t/* See if that is enough... */\n\tif (requested_pages > usable_pages)\n\t{\n\t\t/*\n\t\t * We'll make an odd-sized segment, working forward from the requested\n\t\t * number of pages.\n\t\t */\n\t\tusable_pages = requested_pages;\n\t\tmetadata_bytes =\n\t\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\t\tusable_pages * sizeof(dsa_pointer);\n\n\t\t/* Add padding up to next page boundary. */\n\t\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\t\ttotal_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;\n\n\t\t/* Is that too large for dsa_pointer's addressing scheme? */\n\t\tif (total_size > DSA_MAX_SEGMENT_SIZE)\n\t\t\treturn NULL;\n\n\t\t/* Would that exceed the limit? */\n\t\tif (total_size > area->control->max_total_segment_size -\n\t\t\tarea->control->total_segment_size)\n\t\t\treturn NULL;\n\t}\n\n\t/* Create the segment. */\n\tsegment = dsm_create(total_size, 0);\n\tif (segment == NULL)\n\t\treturn NULL;\n\tdsm_pin_segment(segment);\n\tif (area->mapping_pinned)\n\t\tdsm_pin_mapping(segment);\n\n\t/* Store the handle in shared memory to be found by index. */\n\tarea->control->segment_handles[new_index] =\n\t\tdsm_segment_handle(segment);\n\t/* Track the highest segment index in the history of the area. */\n\tif (area->control->high_segment_index < new_index)\n\t\tarea->control->high_segment_index = new_index;\n\t/* Track the highest segment index this backend has ever mapped. */\n\tif (area->high_segment_index < new_index)\n\t\tarea->high_segment_index = new_index;\n\t/* Track total size of all segments. */\n\tarea->control->total_segment_size += total_size;\n\tAssert(area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size);\n\n\t/* Build a segment map for this segment in this backend. */\n\tsegment_map = &area->segment_maps[new_index];\n\tsegment_map->segment = segment;\n\tsegment_map->mapped_address = dsm_segment_address(segment);\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t   usable_pages);\n\n\t/* Set up the segment header and put it in the appropriate bin. */\n\tsegment_map->header->magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ new_index;\n\tsegment_map->header->usable_pages = usable_pages;\n\tsegment_map->header->size = total_size;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\tsegment_map->header->next =\n\t\tarea->control->segment_bins[segment_map->header->bin];\n\tsegment_map->header->freed = false;\n\tarea->control->segment_bins[segment_map->header->bin] = new_index;\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next =\n\t\tget_segment_by_index(area, segment_map->header->next);\n\n\t\tAssert(next->header->bin == segment_map->header->bin);\n\t\tnext->header->prev = new_index;\n\t}\n\n\treturn segment_map;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)",
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
            "#define DSA_MAX_SEGMENT_SIZE ((size_t) 1 << DSA_OFFSET_WIDTH)",
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))",
            "#define DSA_NUM_SEGMENTS_AT_EACH_SIZE 4",
            "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *make_new_segment(dsa_area *area, size_t requested_pages);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENT_SIZE ((size_t) 1 << DSA_OFFSET_WIDTH)\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n#define DSA_NUM_SEGMENTS_AT_EACH_SIZE 4\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *make_new_segment(dsa_area *area, size_t requested_pages);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nmake_new_segment(dsa_area *area, size_t requested_pages)\n{\n\tdsa_segment_index new_index;\n\tsize_t\t\tmetadata_bytes;\n\tsize_t\t\ttotal_size;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tusable_pages;\n\tdsa_segment_map *segment_map;\n\tdsm_segment *segment;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\n\t/* Find a segment slot that is not in use (linearly for now). */\n\tfor (new_index = 1; new_index < DSA_MAX_SEGMENTS; ++new_index)\n\t{\n\t\tif (area->control->segment_handles[new_index] == DSM_HANDLE_INVALID)\n\t\t\tbreak;\n\t}\n\tif (new_index == DSA_MAX_SEGMENTS)\n\t\treturn NULL;\n\n\t/*\n\t * If the total size limit is already exceeded, then we exit early and\n\t * avoid arithmetic wraparound in the unsigned expressions below.\n\t */\n\tif (area->control->total_segment_size >=\n\t\tarea->control->max_total_segment_size)\n\t\treturn NULL;\n\n\t/*\n\t * The size should be at least as big as requested, and at least big\n\t * enough to follow a geometric series that approximately doubles the\n\t * total storage each time we create a new segment.  We use geometric\n\t * growth because the underlying DSM system isn't designed for large\n\t * numbers of segments (otherwise we might even consider just using one\n\t * DSM segment for each large allocation and for each superblock, and then\n\t * we wouldn't need to use FreePageManager).\n\t *\n\t * We decide on a total segment size first, so that we produce tidy\n\t * power-of-two sized segments.  This is a good property to have if we\n\t * move to huge pages in the future.  Then we work back to the number of\n\t * pages we can fit.\n\t */\n\ttotal_size = DSA_INITIAL_SEGMENT_SIZE *\n\t\t((size_t) 1 << (new_index / DSA_NUM_SEGMENTS_AT_EACH_SIZE));\n\ttotal_size = Min(total_size, DSA_MAX_SEGMENT_SIZE);\n\ttotal_size = Min(total_size,\n\t\t\t\t\t area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size);\n\n\ttotal_pages = total_size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\tsizeof(dsa_pointer) * total_pages;\n\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tif (total_size <= metadata_bytes)\n\t\treturn NULL;\n\tusable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;\n\tAssert(metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size);\n\n\t/* See if that is enough... */\n\tif (requested_pages > usable_pages)\n\t{\n\t\t/*\n\t\t * We'll make an odd-sized segment, working forward from the requested\n\t\t * number of pages.\n\t\t */\n\t\tusable_pages = requested_pages;\n\t\tmetadata_bytes =\n\t\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\t\tusable_pages * sizeof(dsa_pointer);\n\n\t\t/* Add padding up to next page boundary. */\n\t\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\t\ttotal_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;\n\n\t\t/* Is that too large for dsa_pointer's addressing scheme? */\n\t\tif (total_size > DSA_MAX_SEGMENT_SIZE)\n\t\t\treturn NULL;\n\n\t\t/* Would that exceed the limit? */\n\t\tif (total_size > area->control->max_total_segment_size -\n\t\t\tarea->control->total_segment_size)\n\t\t\treturn NULL;\n\t}\n\n\t/* Create the segment. */\n\tsegment = dsm_create(total_size, 0);\n\tif (segment == NULL)\n\t\treturn NULL;\n\tdsm_pin_segment(segment);\n\tif (area->mapping_pinned)\n\t\tdsm_pin_mapping(segment);\n\n\t/* Store the handle in shared memory to be found by index. */\n\tarea->control->segment_handles[new_index] =\n\t\tdsm_segment_handle(segment);\n\t/* Track the highest segment index in the history of the area. */\n\tif (area->control->high_segment_index < new_index)\n\t\tarea->control->high_segment_index = new_index;\n\t/* Track the highest segment index this backend has ever mapped. */\n\tif (area->high_segment_index < new_index)\n\t\tarea->high_segment_index = new_index;\n\t/* Track total size of all segments. */\n\tarea->control->total_segment_size += total_size;\n\tAssert(area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size);\n\n\t/* Build a segment map for this segment in this backend. */\n\tsegment_map = &area->segment_maps[new_index];\n\tsegment_map->segment = segment;\n\tsegment_map->mapped_address = dsm_segment_address(segment);\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t   usable_pages);\n\n\t/* Set up the segment header and put it in the appropriate bin. */\n\tsegment_map->header->magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ new_index;\n\tsegment_map->header->usable_pages = usable_pages;\n\tsegment_map->header->size = total_size;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\tsegment_map->header->next =\n\t\tarea->control->segment_bins[segment_map->header->bin];\n\tsegment_map->header->freed = false;\n\tarea->control->segment_bins[segment_map->header->bin] = new_index;\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next =\n\t\tget_segment_by_index(area, segment_map->header->next);\n\n\t\tAssert(next->header->bin == segment_map->header->bin);\n\t\tnext->header->prev = new_index;\n\t}\n\n\treturn segment_map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_best_segment",
          "args": [
            "area",
            "npages"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "get_best_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1969-2054",
          "snippet": "static dsa_segment_map *\nget_best_segment(dsa_area *area, size_t npages)\n{\n\tsize_t\t\tbin;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tcheck_for_freed_segments_locked(area);\n\n\t/*\n\t * Start searching from the first bin that *might* have enough contiguous\n\t * pages.\n\t */\n\tfor (bin = contiguous_pages_to_segment_bin(npages);\n\t\t bin < DSA_NUM_SEGMENT_BINS;\n\t\t ++bin)\n\t{\n\t\t/*\n\t\t * The minimum contiguous size that any segment in this bin should\n\t\t * have.  We'll re-bin if we see segments with fewer.\n\t\t */\n\t\tsize_t\t\tthreshold = (size_t) 1 << (bin - 1);\n\t\tdsa_segment_index segment_index;\n\n\t\t/* Search this bin for a segment with enough contiguous space. */\n\t\tsegment_index = area->control->segment_bins[bin];\n\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_map *segment_map;\n\t\t\tdsa_segment_index next_segment_index;\n\t\t\tsize_t\t\tcontiguous_pages;\n\n\t\t\tsegment_map = get_segment_by_index(area, segment_index);\n\t\t\tnext_segment_index = segment_map->header->next;\n\t\t\tcontiguous_pages = fpm_largest(segment_map->fpm);\n\n\t\t\t/* Not enough for the request, still enough for this bin. */\n\t\t\tif (contiguous_pages >= threshold && contiguous_pages < npages)\n\t\t\t{\n\t\t\t\tsegment_index = next_segment_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Re-bin it if it's no longer in the appropriate bin. */\n\t\t\tif (contiguous_pages < threshold)\n\t\t\t{\n\t\t\t\tsize_t\t\tnew_bin;\n\n\t\t\t\tnew_bin = contiguous_pages_to_segment_bin(contiguous_pages);\n\n\t\t\t\t/* Remove it from its current bin. */\n\t\t\t\tunlink_segment(area, segment_map);\n\n\t\t\t\t/* Push it onto the front of its new bin. */\n\t\t\t\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\t\t\t\tsegment_map->header->next =\n\t\t\t\t\tarea->control->segment_bins[new_bin];\n\t\t\t\tsegment_map->header->bin = new_bin;\n\t\t\t\tarea->control->segment_bins[new_bin] = segment_index;\n\t\t\t\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tdsa_segment_map *next;\n\n\t\t\t\t\tnext = get_segment_by_index(area,\n\t\t\t\t\t\t\t\t\t\t\t\tsegment_map->header->next);\n\t\t\t\t\tAssert(next->header->bin == new_bin);\n\t\t\t\t\tnext->header->prev = segment_index;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * But fall through to see if it's enough to satisfy this\n\t\t\t\t * request anyway....\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* Check if we are done. */\n\t\t\tif (contiguous_pages >= npages)\n\t\t\t\treturn segment_map;\n\n\t\t\t/* Continue searching the same bin. */\n\t\t\tsegment_index = next_segment_index;\n\t\t}\n\t}\n\n\t/* Not found. */\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_NUM_SEGMENT_BINS 16",
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_best_segment(dsa_area *area, size_t npages)\n{\n\tsize_t\t\tbin;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tcheck_for_freed_segments_locked(area);\n\n\t/*\n\t * Start searching from the first bin that *might* have enough contiguous\n\t * pages.\n\t */\n\tfor (bin = contiguous_pages_to_segment_bin(npages);\n\t\t bin < DSA_NUM_SEGMENT_BINS;\n\t\t ++bin)\n\t{\n\t\t/*\n\t\t * The minimum contiguous size that any segment in this bin should\n\t\t * have.  We'll re-bin if we see segments with fewer.\n\t\t */\n\t\tsize_t\t\tthreshold = (size_t) 1 << (bin - 1);\n\t\tdsa_segment_index segment_index;\n\n\t\t/* Search this bin for a segment with enough contiguous space. */\n\t\tsegment_index = area->control->segment_bins[bin];\n\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_map *segment_map;\n\t\t\tdsa_segment_index next_segment_index;\n\t\t\tsize_t\t\tcontiguous_pages;\n\n\t\t\tsegment_map = get_segment_by_index(area, segment_index);\n\t\t\tnext_segment_index = segment_map->header->next;\n\t\t\tcontiguous_pages = fpm_largest(segment_map->fpm);\n\n\t\t\t/* Not enough for the request, still enough for this bin. */\n\t\t\tif (contiguous_pages >= threshold && contiguous_pages < npages)\n\t\t\t{\n\t\t\t\tsegment_index = next_segment_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Re-bin it if it's no longer in the appropriate bin. */\n\t\t\tif (contiguous_pages < threshold)\n\t\t\t{\n\t\t\t\tsize_t\t\tnew_bin;\n\n\t\t\t\tnew_bin = contiguous_pages_to_segment_bin(contiguous_pages);\n\n\t\t\t\t/* Remove it from its current bin. */\n\t\t\t\tunlink_segment(area, segment_map);\n\n\t\t\t\t/* Push it onto the front of its new bin. */\n\t\t\t\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\t\t\t\tsegment_map->header->next =\n\t\t\t\t\tarea->control->segment_bins[new_bin];\n\t\t\t\tsegment_map->header->bin = new_bin;\n\t\t\t\tarea->control->segment_bins[new_bin] = segment_index;\n\t\t\t\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tdsa_segment_map *next;\n\n\t\t\t\t\tnext = get_segment_by_index(area,\n\t\t\t\t\t\t\t\t\t\t\t\tsegment_map->header->next);\n\t\t\t\t\tAssert(next->header->bin == new_bin);\n\t\t\t\t\tnext->header->prev = segment_index;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * But fall through to see if it's enough to satisfy this\n\t\t\t\t * request anyway....\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* Check if we are done. */\n\t\t\tif (contiguous_pages >= npages)\n\t\t\t\treturn segment_map;\n\n\t\t\t/* Continue searching the same bin. */\n\t\t\tsegment_index = next_segment_index;\n\t\t}\n\t}\n\n\t/* Not found. */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span_pointer"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_object",
          "args": [
            "area",
            "DSA_SCLASS_BLOCK_OF_SPANS"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1439-1503",
          "snippet": "static inline dsa_pointer\nalloc_object(dsa_area *area, int size_class)\n{\n\tdsa_area_pool *pool = &area->control->pools[size_class];\n\tdsa_area_span *span;\n\tdsa_pointer block;\n\tdsa_pointer result;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\n\t/*\n\t * Even though ensure_active_superblock can in turn call alloc_object if\n\t * it needs to allocate a new span, that's always from a different pool,\n\t * and the order of lock acquisition is always the same, so it's OK that\n\t * we hold this lock for the duration of this function.\n\t */\n\tAssert(!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/*\n\t * If there's no active superblock, we must successfully obtain one or\n\t * fail the request.\n\t */\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\t!ensure_active_superblock(area, pool, size_class))\n\t{\n\t\tresult = InvalidDsaPointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * There should be a block in fullness class 1 at this point, and it\n\t\t * should never be completely full.  Thus we can either pop an object\n\t\t * from the free list or, failing that, initialize a new object.\n\t\t */\n\t\tAssert(DsaPointerIsValid(pool->spans[1]));\n\t\tspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, pool->spans[1]);\n\t\tAssert(span->nallocatable > 0);\n\t\tblock = span->start;\n\t\tAssert(size_class < DSA_NUM_SIZE_CLASSES);\n\t\tsize = dsa_size_classes[size_class];\n\t\tif (span->firstfree != DSA_SPAN_NOTHING_FREE)\n\t\t{\n\t\t\tresult = block + span->firstfree * size;\n\t\t\tobject = dsa_get_address(area, result);\n\t\t\tspan->firstfree = NextFreeObjectIndex(object);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = block + span->ninitialized * size;\n\t\t\t++span->ninitialized;\n\t\t}\n\t\t--span->nallocatable;\n\n\t\t/* If it's now full, move it to the highest-numbered fullness class. */\n\t\tif (span->nallocatable == 0)\n\t\t\ttransfer_first_span(area, pool, 1, DSA_FULLNESS_CLASSES - 1);\n\t}\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)",
            "#define DSA_FULLNESS_CLASSES\t\t4",
            "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic inline dsa_pointer\nalloc_object(dsa_area *area, int size_class)\n{\n\tdsa_area_pool *pool = &area->control->pools[size_class];\n\tdsa_area_span *span;\n\tdsa_pointer block;\n\tdsa_pointer result;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\n\t/*\n\t * Even though ensure_active_superblock can in turn call alloc_object if\n\t * it needs to allocate a new span, that's always from a different pool,\n\t * and the order of lock acquisition is always the same, so it's OK that\n\t * we hold this lock for the duration of this function.\n\t */\n\tAssert(!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/*\n\t * If there's no active superblock, we must successfully obtain one or\n\t * fail the request.\n\t */\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\t!ensure_active_superblock(area, pool, size_class))\n\t{\n\t\tresult = InvalidDsaPointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * There should be a block in fullness class 1 at this point, and it\n\t\t * should never be completely full.  Thus we can either pop an object\n\t\t * from the free list or, failing that, initialize a new object.\n\t\t */\n\t\tAssert(DsaPointerIsValid(pool->spans[1]));\n\t\tspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, pool->spans[1]);\n\t\tAssert(span->nallocatable > 0);\n\t\tblock = span->start;\n\t\tAssert(size_class < DSA_NUM_SIZE_CLASSES);\n\t\tsize = dsa_size_classes[size_class];\n\t\tif (span->firstfree != DSA_SPAN_NOTHING_FREE)\n\t\t{\n\t\t\tresult = block + span->firstfree * size;\n\t\t\tobject = dsa_get_address(area, result);\n\t\t\tspan->firstfree = NextFreeObjectIndex(object);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = block + span->ninitialized * size;\n\t\t\t++span->ninitialized;\n\t\t}\n\t\t--span->nallocatable;\n\n\t\t/* If it's now full, move it to the highest-numbered fullness class. */\n\t\tif (span->nallocatable == 0)\n\t\t\ttransfer_first_span(area, pool, 1, DSA_FULLNESS_CLASSES - 1);\n\t}\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transfer_first_span",
          "args": [
            "area",
            "pool",
            "0",
            "1"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "transfer_first_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1399-1434",
          "snippet": "static bool\ntransfer_first_span(dsa_area *area,\n\t\t\t\t\tdsa_area_pool *pool, int fromclass, int toclass)\n{\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tdsa_area_span *nextspan;\n\n\t/* Can't do it if source list is empty. */\n\tspan_pointer = pool->spans[fromclass];\n\tif (!DsaPointerIsValid(span_pointer))\n\t\treturn false;\n\n\t/* Remove span from head of source list. */\n\tspan = dsa_get_address(area, span_pointer);\n\tpool->spans[fromclass] = span->nextspan;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = InvalidDsaPointer;\n\t}\n\n\t/* Add span to head of target list. */\n\tspan->nextspan = pool->spans[toclass];\n\tpool->spans[toclass] = span_pointer;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = span_pointer;\n\t}\n\tspan->fclass = toclass;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool transfer_first_span(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\tint fromclass, int toclass);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic bool transfer_first_span(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\tint fromclass, int toclass);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic bool\ntransfer_first_span(dsa_area *area,\n\t\t\t\t\tdsa_area_pool *pool, int fromclass, int toclass)\n{\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tdsa_area_span *nextspan;\n\n\t/* Can't do it if source list is empty. */\n\tspan_pointer = pool->spans[fromclass];\n\tif (!DsaPointerIsValid(span_pointer))\n\t\treturn false;\n\n\t/* Remove span from head of source list. */\n\tspan = dsa_get_address(area, span_pointer);\n\tpool->spans[fromclass] = span->nextspan;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = InvalidDsaPointer;\n\t}\n\n\t/* Add span to head of target list. */\n\tspan->nextspan = pool->spans[toclass];\n\tpool->spans[toclass] = span_pointer;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = span_pointer;\n\t}\n\tspan->fclass = toclass;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[1]"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!DsaPointerIsValid(pool->spans[1])"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[1]"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[1]"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "span->nextspan"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->nextspan"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "DsaPointerIsValid(span->prevspan)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->prevspan"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!DsaPointerIsValid(span->prevspan)"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->prevspan"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->nextspan"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span_pointer"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class))"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n#define DSA_PAGES_PER_SUPERBLOCK\t\t16\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic bool\nensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class)\n{\n\tdsa_pointer span_pointer;\n\tdsa_pointer start_pointer;\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\tsize_t\t\tnmax;\n\tint\t\t\tfclass;\n\tsize_t\t\tnpages = 1;\n\tsize_t\t\tfirst_page;\n\tsize_t\t\ti;\n\tdsa_segment_map *segment_map;\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/*\n\t * Compute the number of objects that will fit in a block of this size\n\t * class.  Span-of-spans blocks are just a single page, and the first\n\t * object isn't available for use because it describes the block-of-spans\n\t * itself.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tnmax = FPM_PAGE_SIZE / obsize - 1;\n\telse\n\t\tnmax = DSA_SUPERBLOCK_SIZE / obsize;\n\n\t/*\n\t * If fullness class 1 is empty, try to find a span to put in it by\n\t * scanning higher-numbered fullness classes (excluding the last one,\n\t * whose blocks are certain to all be completely full).\n\t */\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t{\n\t\tspan_pointer = pool->spans[fclass];\n\n\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\tint\t\t\ttfclass;\n\t\t\tdsa_area_span *span;\n\t\t\tdsa_area_span *nextspan;\n\t\t\tdsa_area_span *prevspan;\n\t\t\tdsa_pointer next_span_pointer;\n\n\t\t\tspan = (dsa_area_span *)\n\t\t\t\tdsa_get_address(area, span_pointer);\n\t\t\tnext_span_pointer = span->nextspan;\n\n\t\t\t/* Figure out what fullness class should contain this span. */\n\t\t\ttfclass = (nmax - span->nallocatable)\n\t\t\t\t* (DSA_FULLNESS_CLASSES - 1) / nmax;\n\n\t\t\t/* Look up next span. */\n\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\telse\n\t\t\t\tnextspan = NULL;\n\n\t\t\t/*\n\t\t\t * If utilization has dropped enough that this now belongs in some\n\t\t\t * other fullness class, move it there.\n\t\t\t */\n\t\t\tif (tfclass < fclass)\n\t\t\t{\n\t\t\t\t/* Remove from the current fullness class list. */\n\t\t\t\tif (pool->spans[fclass] == span_pointer)\n\t\t\t\t{\n\t\t\t\t\t/* It was the head; remove it. */\n\t\t\t\t\tAssert(!DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tpool->spans[fclass] = span->nextspan;\n\t\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\t\tnextspan->prevspan = InvalidDsaPointer;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* It was not the head. */\n\t\t\t\t\tAssert(DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tprevspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->prevspan);\n\t\t\t\t\tprevspan->nextspan = span->nextspan;\n\t\t\t\t}\n\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\tnextspan->prevspan = span->prevspan;\n\n\t\t\t\t/* Push onto the head of the new fullness class list. */\n\t\t\t\tspan->nextspan = pool->spans[tfclass];\n\t\t\t\tpool->spans[tfclass] = span_pointer;\n\t\t\t\tspan->prevspan = InvalidDsaPointer;\n\t\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\t{\n\t\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\t\t\tnextspan->prevspan = span_pointer;\n\t\t\t\t}\n\t\t\t\tspan->fclass = tfclass;\n\t\t\t}\n\n\t\t\t/* Advance to next span on list. */\n\t\t\tspan_pointer = next_span_pointer;\n\t\t}\n\n\t\t/* Stop now if we found a suitable block. */\n\t\tif (DsaPointerIsValid(pool->spans[1]))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If there are no blocks that properly belong in fullness class 1, pick\n\t * one from some other fullness class and move it there anyway, so that we\n\t * have an allocation target.  Our last choice is to transfer a block\n\t * that's almost empty (and might become completely empty soon if left\n\t * alone), but even that is better than failing, which is what we must do\n\t * if there are no blocks at all with freespace.\n\t */\n\tAssert(!DsaPointerIsValid(pool->spans[1]));\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t\tif (transfer_first_span(area, pool, fclass, 1))\n\t\t\treturn true;\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\ttransfer_first_span(area, pool, 0, 1))\n\t\treturn true;\n\n\t/*\n\t * We failed to find an existing span with free objects, so we need to\n\t * allocate a new superblock and construct a new span to manage it.\n\t *\n\t * First, get a dsa_area_span object to describe the new superblock block\n\t * ... unless this allocation is for a dsa_area_span object, in which case\n\t * that's surely not going to work.  We handle that case by storing the\n\t * span describing a block-of-spans inline.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\tspan_pointer = alloc_object(area, DSA_SCLASS_BLOCK_OF_SPANS);\n\t\tif (!DsaPointerIsValid(span_pointer))\n\t\t\treturn false;\n\t\tnpages = DSA_PAGES_PER_SUPERBLOCK;\n\t}\n\n\t/* Find or create a segment and allocate the superblock. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tsegment_map = get_best_segment(area, npages);\n\tif (segment_map == NULL)\n\t{\n\t\tsegment_map = make_new_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t{\n\t\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*\n\t * This shouldn't happen: get_best_segment() or make_new_segment()\n\t * promised that we can successfully allocate npages.\n\t */\n\tif (!FreePageManagerGet(segment_map->fpm, npages, &first_page))\n\t\telog(FATAL,\n\t\t\t \"dsa_allocate could not find %zu free pages for superblock\",\n\t\t\t npages);\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/* Compute the start of the superblock. */\n\tstart_pointer =\n\t\tDSA_MAKE_POINTER(get_segment_index(area, segment_map),\n\t\t\t\t\t\t first_page * FPM_PAGE_SIZE);\n\n\t/*\n\t * If this is a block-of-spans, carve the descriptor right out of the\n\t * allocated space.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * We have a pointer into the segment.  We need to build a dsa_pointer\n\t\t * from the segment index and offset into the segment.\n\t\t */\n\t\tspan_pointer = start_pointer;\n\t}\n\n\t/* Initialize span and pagemap. */\n\tinit_span(area, span_pointer, pool, start_pointer, npages, size_class);\n\tfor (i = 0; i < npages; ++i)\n\t\tsegment_map->pagemap[first_page + i] = span_pointer;\n\n\treturn true;\n}"
  },
  {
    "function_name": "alloc_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1439-1503",
    "snippet": "static inline dsa_pointer\nalloc_object(dsa_area *area, int size_class)\n{\n\tdsa_area_pool *pool = &area->control->pools[size_class];\n\tdsa_area_span *span;\n\tdsa_pointer block;\n\tdsa_pointer result;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\n\t/*\n\t * Even though ensure_active_superblock can in turn call alloc_object if\n\t * it needs to allocate a new span, that's always from a different pool,\n\t * and the order of lock acquisition is always the same, so it's OK that\n\t * we hold this lock for the duration of this function.\n\t */\n\tAssert(!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/*\n\t * If there's no active superblock, we must successfully obtain one or\n\t * fail the request.\n\t */\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\t!ensure_active_superblock(area, pool, size_class))\n\t{\n\t\tresult = InvalidDsaPointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * There should be a block in fullness class 1 at this point, and it\n\t\t * should never be completely full.  Thus we can either pop an object\n\t\t * from the free list or, failing that, initialize a new object.\n\t\t */\n\t\tAssert(DsaPointerIsValid(pool->spans[1]));\n\t\tspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, pool->spans[1]);\n\t\tAssert(span->nallocatable > 0);\n\t\tblock = span->start;\n\t\tAssert(size_class < DSA_NUM_SIZE_CLASSES);\n\t\tsize = dsa_size_classes[size_class];\n\t\tif (span->firstfree != DSA_SPAN_NOTHING_FREE)\n\t\t{\n\t\t\tresult = block + span->firstfree * size;\n\t\t\tobject = dsa_get_address(area, result);\n\t\t\tspan->firstfree = NextFreeObjectIndex(object);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = block + span->ninitialized * size;\n\t\t\t++span->ninitialized;\n\t\t}\n\t\t--span->nallocatable;\n\n\t\t/* If it's now full, move it to the highest-numbered fullness class. */\n\t\tif (span->nallocatable == 0)\n\t\t\ttransfer_first_span(area, pool, 1, DSA_FULLNESS_CLASSES - 1);\n\t}\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)",
      "#define DSA_FULLNESS_CLASSES\t\t4",
      "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)"
    ],
    "globals_used": [
      "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class))"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_first_span",
          "args": [
            "area",
            "pool",
            "1",
            "DSA_FULLNESS_CLASSES - 1"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "transfer_first_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1399-1434",
          "snippet": "static bool\ntransfer_first_span(dsa_area *area,\n\t\t\t\t\tdsa_area_pool *pool, int fromclass, int toclass)\n{\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tdsa_area_span *nextspan;\n\n\t/* Can't do it if source list is empty. */\n\tspan_pointer = pool->spans[fromclass];\n\tif (!DsaPointerIsValid(span_pointer))\n\t\treturn false;\n\n\t/* Remove span from head of source list. */\n\tspan = dsa_get_address(area, span_pointer);\n\tpool->spans[fromclass] = span->nextspan;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = InvalidDsaPointer;\n\t}\n\n\t/* Add span to head of target list. */\n\tspan->nextspan = pool->spans[toclass];\n\tpool->spans[toclass] = span_pointer;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = span_pointer;\n\t}\n\tspan->fclass = toclass;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool transfer_first_span(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\tint fromclass, int toclass);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic bool transfer_first_span(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\tint fromclass, int toclass);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic bool\ntransfer_first_span(dsa_area *area,\n\t\t\t\t\tdsa_area_pool *pool, int fromclass, int toclass)\n{\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tdsa_area_span *nextspan;\n\n\t/* Can't do it if source list is empty. */\n\tspan_pointer = pool->spans[fromclass];\n\tif (!DsaPointerIsValid(span_pointer))\n\t\treturn false;\n\n\t/* Remove span from head of source list. */\n\tspan = dsa_get_address(area, span_pointer);\n\tpool->spans[fromclass] = span->nextspan;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = InvalidDsaPointer;\n\t}\n\n\t/* Add span to head of target list. */\n\tspan->nextspan = pool->spans[toclass];\n\tpool->spans[toclass] = span_pointer;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = span_pointer;\n\t}\n\tspan->fclass = toclass;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NextFreeObjectIndex",
          "args": [
            "object"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "result"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "size_class < DSA_NUM_SIZE_CLASSES"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "span->nallocatable > 0"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "DsaPointerIsValid(pool->spans[1])"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[1]"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensure_active_superblock",
          "args": [
            "area",
            "pool",
            "size_class"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_active_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1527-1713",
          "snippet": "static bool\nensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class)\n{\n\tdsa_pointer span_pointer;\n\tdsa_pointer start_pointer;\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\tsize_t\t\tnmax;\n\tint\t\t\tfclass;\n\tsize_t\t\tnpages = 1;\n\tsize_t\t\tfirst_page;\n\tsize_t\t\ti;\n\tdsa_segment_map *segment_map;\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/*\n\t * Compute the number of objects that will fit in a block of this size\n\t * class.  Span-of-spans blocks are just a single page, and the first\n\t * object isn't available for use because it describes the block-of-spans\n\t * itself.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tnmax = FPM_PAGE_SIZE / obsize - 1;\n\telse\n\t\tnmax = DSA_SUPERBLOCK_SIZE / obsize;\n\n\t/*\n\t * If fullness class 1 is empty, try to find a span to put in it by\n\t * scanning higher-numbered fullness classes (excluding the last one,\n\t * whose blocks are certain to all be completely full).\n\t */\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t{\n\t\tspan_pointer = pool->spans[fclass];\n\n\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\tint\t\t\ttfclass;\n\t\t\tdsa_area_span *span;\n\t\t\tdsa_area_span *nextspan;\n\t\t\tdsa_area_span *prevspan;\n\t\t\tdsa_pointer next_span_pointer;\n\n\t\t\tspan = (dsa_area_span *)\n\t\t\t\tdsa_get_address(area, span_pointer);\n\t\t\tnext_span_pointer = span->nextspan;\n\n\t\t\t/* Figure out what fullness class should contain this span. */\n\t\t\ttfclass = (nmax - span->nallocatable)\n\t\t\t\t* (DSA_FULLNESS_CLASSES - 1) / nmax;\n\n\t\t\t/* Look up next span. */\n\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\telse\n\t\t\t\tnextspan = NULL;\n\n\t\t\t/*\n\t\t\t * If utilization has dropped enough that this now belongs in some\n\t\t\t * other fullness class, move it there.\n\t\t\t */\n\t\t\tif (tfclass < fclass)\n\t\t\t{\n\t\t\t\t/* Remove from the current fullness class list. */\n\t\t\t\tif (pool->spans[fclass] == span_pointer)\n\t\t\t\t{\n\t\t\t\t\t/* It was the head; remove it. */\n\t\t\t\t\tAssert(!DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tpool->spans[fclass] = span->nextspan;\n\t\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\t\tnextspan->prevspan = InvalidDsaPointer;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* It was not the head. */\n\t\t\t\t\tAssert(DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tprevspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->prevspan);\n\t\t\t\t\tprevspan->nextspan = span->nextspan;\n\t\t\t\t}\n\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\tnextspan->prevspan = span->prevspan;\n\n\t\t\t\t/* Push onto the head of the new fullness class list. */\n\t\t\t\tspan->nextspan = pool->spans[tfclass];\n\t\t\t\tpool->spans[tfclass] = span_pointer;\n\t\t\t\tspan->prevspan = InvalidDsaPointer;\n\t\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\t{\n\t\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\t\t\tnextspan->prevspan = span_pointer;\n\t\t\t\t}\n\t\t\t\tspan->fclass = tfclass;\n\t\t\t}\n\n\t\t\t/* Advance to next span on list. */\n\t\t\tspan_pointer = next_span_pointer;\n\t\t}\n\n\t\t/* Stop now if we found a suitable block. */\n\t\tif (DsaPointerIsValid(pool->spans[1]))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If there are no blocks that properly belong in fullness class 1, pick\n\t * one from some other fullness class and move it there anyway, so that we\n\t * have an allocation target.  Our last choice is to transfer a block\n\t * that's almost empty (and might become completely empty soon if left\n\t * alone), but even that is better than failing, which is what we must do\n\t * if there are no blocks at all with freespace.\n\t */\n\tAssert(!DsaPointerIsValid(pool->spans[1]));\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t\tif (transfer_first_span(area, pool, fclass, 1))\n\t\t\treturn true;\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\ttransfer_first_span(area, pool, 0, 1))\n\t\treturn true;\n\n\t/*\n\t * We failed to find an existing span with free objects, so we need to\n\t * allocate a new superblock and construct a new span to manage it.\n\t *\n\t * First, get a dsa_area_span object to describe the new superblock block\n\t * ... unless this allocation is for a dsa_area_span object, in which case\n\t * that's surely not going to work.  We handle that case by storing the\n\t * span describing a block-of-spans inline.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\tspan_pointer = alloc_object(area, DSA_SCLASS_BLOCK_OF_SPANS);\n\t\tif (!DsaPointerIsValid(span_pointer))\n\t\t\treturn false;\n\t\tnpages = DSA_PAGES_PER_SUPERBLOCK;\n\t}\n\n\t/* Find or create a segment and allocate the superblock. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tsegment_map = get_best_segment(area, npages);\n\tif (segment_map == NULL)\n\t{\n\t\tsegment_map = make_new_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t{\n\t\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*\n\t * This shouldn't happen: get_best_segment() or make_new_segment()\n\t * promised that we can successfully allocate npages.\n\t */\n\tif (!FreePageManagerGet(segment_map->fpm, npages, &first_page))\n\t\telog(FATAL,\n\t\t\t \"dsa_allocate could not find %zu free pages for superblock\",\n\t\t\t npages);\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/* Compute the start of the superblock. */\n\tstart_pointer =\n\t\tDSA_MAKE_POINTER(get_segment_index(area, segment_map),\n\t\t\t\t\t\t first_page * FPM_PAGE_SIZE);\n\n\t/*\n\t * If this is a block-of-spans, carve the descriptor right out of the\n\t * allocated space.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * We have a pointer into the segment.  We need to build a dsa_pointer\n\t\t * from the segment index and offset into the segment.\n\t\t */\n\t\tspan_pointer = start_pointer;\n\t}\n\n\t/* Initialize span and pagemap. */\n\tinit_span(area, span_pointer, pool, start_pointer, npages, size_class);\n\tfor (i = 0; i < npages; ++i)\n\t\tsegment_map->pagemap[first_page + i] = span_pointer;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
            "#define DSA_FULLNESS_CLASSES\t\t4",
            "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0",
            "#define DSA_PAGES_PER_SUPERBLOCK\t\t16"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n#define DSA_PAGES_PER_SUPERBLOCK\t\t16\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic bool\nensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class)\n{\n\tdsa_pointer span_pointer;\n\tdsa_pointer start_pointer;\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\tsize_t\t\tnmax;\n\tint\t\t\tfclass;\n\tsize_t\t\tnpages = 1;\n\tsize_t\t\tfirst_page;\n\tsize_t\t\ti;\n\tdsa_segment_map *segment_map;\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/*\n\t * Compute the number of objects that will fit in a block of this size\n\t * class.  Span-of-spans blocks are just a single page, and the first\n\t * object isn't available for use because it describes the block-of-spans\n\t * itself.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tnmax = FPM_PAGE_SIZE / obsize - 1;\n\telse\n\t\tnmax = DSA_SUPERBLOCK_SIZE / obsize;\n\n\t/*\n\t * If fullness class 1 is empty, try to find a span to put in it by\n\t * scanning higher-numbered fullness classes (excluding the last one,\n\t * whose blocks are certain to all be completely full).\n\t */\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t{\n\t\tspan_pointer = pool->spans[fclass];\n\n\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\tint\t\t\ttfclass;\n\t\t\tdsa_area_span *span;\n\t\t\tdsa_area_span *nextspan;\n\t\t\tdsa_area_span *prevspan;\n\t\t\tdsa_pointer next_span_pointer;\n\n\t\t\tspan = (dsa_area_span *)\n\t\t\t\tdsa_get_address(area, span_pointer);\n\t\t\tnext_span_pointer = span->nextspan;\n\n\t\t\t/* Figure out what fullness class should contain this span. */\n\t\t\ttfclass = (nmax - span->nallocatable)\n\t\t\t\t* (DSA_FULLNESS_CLASSES - 1) / nmax;\n\n\t\t\t/* Look up next span. */\n\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\telse\n\t\t\t\tnextspan = NULL;\n\n\t\t\t/*\n\t\t\t * If utilization has dropped enough that this now belongs in some\n\t\t\t * other fullness class, move it there.\n\t\t\t */\n\t\t\tif (tfclass < fclass)\n\t\t\t{\n\t\t\t\t/* Remove from the current fullness class list. */\n\t\t\t\tif (pool->spans[fclass] == span_pointer)\n\t\t\t\t{\n\t\t\t\t\t/* It was the head; remove it. */\n\t\t\t\t\tAssert(!DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tpool->spans[fclass] = span->nextspan;\n\t\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\t\tnextspan->prevspan = InvalidDsaPointer;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* It was not the head. */\n\t\t\t\t\tAssert(DsaPointerIsValid(span->prevspan));\n\t\t\t\t\tprevspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->prevspan);\n\t\t\t\t\tprevspan->nextspan = span->nextspan;\n\t\t\t\t}\n\t\t\t\tif (nextspan != NULL)\n\t\t\t\t\tnextspan->prevspan = span->prevspan;\n\n\t\t\t\t/* Push onto the head of the new fullness class list. */\n\t\t\t\tspan->nextspan = pool->spans[tfclass];\n\t\t\t\tpool->spans[tfclass] = span_pointer;\n\t\t\t\tspan->prevspan = InvalidDsaPointer;\n\t\t\t\tif (DsaPointerIsValid(span->nextspan))\n\t\t\t\t{\n\t\t\t\t\tnextspan = (dsa_area_span *)\n\t\t\t\t\t\tdsa_get_address(area, span->nextspan);\n\t\t\t\t\tnextspan->prevspan = span_pointer;\n\t\t\t\t}\n\t\t\t\tspan->fclass = tfclass;\n\t\t\t}\n\n\t\t\t/* Advance to next span on list. */\n\t\t\tspan_pointer = next_span_pointer;\n\t\t}\n\n\t\t/* Stop now if we found a suitable block. */\n\t\tif (DsaPointerIsValid(pool->spans[1]))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If there are no blocks that properly belong in fullness class 1, pick\n\t * one from some other fullness class and move it there anyway, so that we\n\t * have an allocation target.  Our last choice is to transfer a block\n\t * that's almost empty (and might become completely empty soon if left\n\t * alone), but even that is better than failing, which is what we must do\n\t * if there are no blocks at all with freespace.\n\t */\n\tAssert(!DsaPointerIsValid(pool->spans[1]));\n\tfor (fclass = 2; fclass < DSA_FULLNESS_CLASSES - 1; ++fclass)\n\t\tif (transfer_first_span(area, pool, fclass, 1))\n\t\t\treturn true;\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\ttransfer_first_span(area, pool, 0, 1))\n\t\treturn true;\n\n\t/*\n\t * We failed to find an existing span with free objects, so we need to\n\t * allocate a new superblock and construct a new span to manage it.\n\t *\n\t * First, get a dsa_area_span object to describe the new superblock block\n\t * ... unless this allocation is for a dsa_area_span object, in which case\n\t * that's surely not going to work.  We handle that case by storing the\n\t * span describing a block-of-spans inline.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\tspan_pointer = alloc_object(area, DSA_SCLASS_BLOCK_OF_SPANS);\n\t\tif (!DsaPointerIsValid(span_pointer))\n\t\t\treturn false;\n\t\tnpages = DSA_PAGES_PER_SUPERBLOCK;\n\t}\n\n\t/* Find or create a segment and allocate the superblock. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tsegment_map = get_best_segment(area, npages);\n\tif (segment_map == NULL)\n\t{\n\t\tsegment_map = make_new_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t{\n\t\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*\n\t * This shouldn't happen: get_best_segment() or make_new_segment()\n\t * promised that we can successfully allocate npages.\n\t */\n\tif (!FreePageManagerGet(segment_map->fpm, npages, &first_page))\n\t\telog(FATAL,\n\t\t\t \"dsa_allocate could not find %zu free pages for superblock\",\n\t\t\t npages);\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/* Compute the start of the superblock. */\n\tstart_pointer =\n\t\tDSA_MAKE_POINTER(get_segment_index(area, segment_map),\n\t\t\t\t\t\t first_page * FPM_PAGE_SIZE);\n\n\t/*\n\t * If this is a block-of-spans, carve the descriptor right out of the\n\t * allocated space.\n\t */\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * We have a pointer into the segment.  We need to build a dsa_pointer\n\t\t * from the segment index and offset into the segment.\n\t\t */\n\t\tspan_pointer = start_pointer;\n\t}\n\n\t/* Initialize span and pagemap. */\n\tinit_span(area, span_pointer, pool, start_pointer, npages, size_class);\n\tfor (i = 0; i < npages; ++i)\n\t\tsegment_map->pagemap[first_page + i] = span_pointer;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[1]"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)",
            "LW_EXCLUSIVE"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class))"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic inline dsa_pointer\nalloc_object(dsa_area *area, int size_class)\n{\n\tdsa_area_pool *pool = &area->control->pools[size_class];\n\tdsa_area_span *span;\n\tdsa_pointer block;\n\tdsa_pointer result;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\n\t/*\n\t * Even though ensure_active_superblock can in turn call alloc_object if\n\t * it needs to allocate a new span, that's always from a different pool,\n\t * and the order of lock acquisition is always the same, so it's OK that\n\t * we hold this lock for the duration of this function.\n\t */\n\tAssert(!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/*\n\t * If there's no active superblock, we must successfully obtain one or\n\t * fail the request.\n\t */\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\t!ensure_active_superblock(area, pool, size_class))\n\t{\n\t\tresult = InvalidDsaPointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * There should be a block in fullness class 1 at this point, and it\n\t\t * should never be completely full.  Thus we can either pop an object\n\t\t * from the free list or, failing that, initialize a new object.\n\t\t */\n\t\tAssert(DsaPointerIsValid(pool->spans[1]));\n\t\tspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, pool->spans[1]);\n\t\tAssert(span->nallocatable > 0);\n\t\tblock = span->start;\n\t\tAssert(size_class < DSA_NUM_SIZE_CLASSES);\n\t\tsize = dsa_size_classes[size_class];\n\t\tif (span->firstfree != DSA_SPAN_NOTHING_FREE)\n\t\t{\n\t\t\tresult = block + span->firstfree * size;\n\t\t\tobject = dsa_get_address(area, result);\n\t\t\tspan->firstfree = NextFreeObjectIndex(object);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = block + span->ninitialized * size;\n\t\t\t++span->ninitialized;\n\t\t}\n\t\t--span->nallocatable;\n\n\t\t/* If it's now full, move it to the highest-numbered fullness class. */\n\t\tif (span->nallocatable == 0)\n\t\t\ttransfer_first_span(area, pool, 1, DSA_FULLNESS_CLASSES - 1);\n\t}\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\n\treturn result;\n}"
  },
  {
    "function_name": "transfer_first_span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1399-1434",
    "snippet": "static bool\ntransfer_first_span(dsa_area *area,\n\t\t\t\t\tdsa_area_pool *pool, int fromclass, int toclass)\n{\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tdsa_area_span *nextspan;\n\n\t/* Can't do it if source list is empty. */\n\tspan_pointer = pool->spans[fromclass];\n\tif (!DsaPointerIsValid(span_pointer))\n\t\treturn false;\n\n\t/* Remove span from head of source list. */\n\tspan = dsa_get_address(area, span_pointer);\n\tpool->spans[fromclass] = span->nextspan;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = InvalidDsaPointer;\n\t}\n\n\t/* Add span to head of target list. */\n\tspan->nextspan = pool->spans[toclass];\n\tpool->spans[toclass] = span_pointer;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = span_pointer;\n\t}\n\tspan->fclass = toclass;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool transfer_first_span(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\tint fromclass, int toclass);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "span->nextspan"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->nextspan"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span->nextspan"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span_pointer"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic bool transfer_first_span(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\tint fromclass, int toclass);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic bool\ntransfer_first_span(dsa_area *area,\n\t\t\t\t\tdsa_area_pool *pool, int fromclass, int toclass)\n{\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tdsa_area_span *nextspan;\n\n\t/* Can't do it if source list is empty. */\n\tspan_pointer = pool->spans[fromclass];\n\tif (!DsaPointerIsValid(span_pointer))\n\t\treturn false;\n\n\t/* Remove span from head of source list. */\n\tspan = dsa_get_address(area, span_pointer);\n\tpool->spans[fromclass] = span->nextspan;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = InvalidDsaPointer;\n\t}\n\n\t/* Add span to head of target list. */\n\tspan->nextspan = pool->spans[toclass];\n\tpool->spans[toclass] = span_pointer;\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tnextspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, span->nextspan);\n\t\tnextspan->prevspan = span_pointer;\n\t}\n\tspan->fclass = toclass;\n\n\treturn true;\n}"
  },
  {
    "function_name": "init_span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1344-1393",
    "snippet": "static void\ninit_span(dsa_area *area,\n\t\t  dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\n\t/*\n\t * The per-pool lock must be held because we manipulate the span list for\n\t * this pool.\n\t */\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/* Push this span onto the front of the span list for fullness class 1. */\n\tif (DsaPointerIsValid(pool->spans[1]))\n\t{\n\t\tdsa_area_span *head = (dsa_area_span *)\n\t\tdsa_get_address(area, pool->spans[1]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->pool = DsaAreaPoolToDsaPointer(area, pool);\n\tspan->nextspan = pool->spans[1];\n\tspan->prevspan = InvalidDsaPointer;\n\tpool->spans[1] = span_pointer;\n\n\tspan->start = start;\n\tspan->npages = npages;\n\tspan->size_class = size_class;\n\tspan->ninitialized = 0;\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * A block-of-spans contains its own descriptor, so mark one object as\n\t\t * initialized and reduce the count of allocatable objects by one.\n\t\t * Doing this here has the side effect of also reducing nmax by one,\n\t\t * which is important to make sure we free this object at the correct\n\t\t * time.\n\t\t */\n\t\tspan->ninitialized = 1;\n\t\tspan->nallocatable = FPM_PAGE_SIZE / obsize - 1;\n\t}\n\telse if (size_class != DSA_SCLASS_SPAN_LARGE)\n\t\tspan->nallocatable = DSA_SUPERBLOCK_SIZE / obsize;\n\tspan->firstfree = DSA_SPAN_NOTHING_FREE;\n\tspan->nmax = span->nallocatable;\n\tspan->fclass = 1;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
      "#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)",
      "#define DSA_SCLASS_SPAN_LARGE\t\t\t1",
      "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
    ],
    "globals_used": [
      "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DsaAreaPoolToDsaPointer",
          "args": [
            "area",
            "pool"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "pool->spans[1]"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "pool->spans[1]"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class))"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ninit_span(dsa_area *area,\n\t\t  dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\n\t/*\n\t * The per-pool lock must be held because we manipulate the span list for\n\t * this pool.\n\t */\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/* Push this span onto the front of the span list for fullness class 1. */\n\tif (DsaPointerIsValid(pool->spans[1]))\n\t{\n\t\tdsa_area_span *head = (dsa_area_span *)\n\t\tdsa_get_address(area, pool->spans[1]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->pool = DsaAreaPoolToDsaPointer(area, pool);\n\tspan->nextspan = pool->spans[1];\n\tspan->prevspan = InvalidDsaPointer;\n\tpool->spans[1] = span_pointer;\n\n\tspan->start = start;\n\tspan->npages = npages;\n\tspan->size_class = size_class;\n\tspan->ninitialized = 0;\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * A block-of-spans contains its own descriptor, so mark one object as\n\t\t * initialized and reduce the count of allocatable objects by one.\n\t\t * Doing this here has the side effect of also reducing nmax by one,\n\t\t * which is important to make sure we free this object at the correct\n\t\t * time.\n\t\t */\n\t\tspan->ninitialized = 1;\n\t\tspan->nallocatable = FPM_PAGE_SIZE / obsize - 1;\n\t}\n\telse if (size_class != DSA_SCLASS_SPAN_LARGE)\n\t\tspan->nallocatable = DSA_SUPERBLOCK_SIZE / obsize;\n\tspan->firstfree = DSA_SPAN_NOTHING_FREE;\n\tspan->nmax = span->nallocatable;\n\tspan->fclass = 1;\n}"
  },
  {
    "function_name": "attach_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1293-1339",
    "snippet": "static dsa_area *\nattach_internal(void *place, dsm_segment *segment, dsa_handle handle)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\n\tcontrol = (dsa_area_control *) place;\n\tAssert(control->handle == handle);\n\tAssert(control->segment_handles[0] == handle);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0));\n\n\t/* Build the backend-local area object. */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(&area->segment_maps[0], 0,\n\t\t   sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = segment; /* NULL for in-place */\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Bump the reference count. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (control->refcnt == 0)\n\t{\n\t\t/* We can't attach to a DSA area that has already been destroyed. */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\t}\n\t++control->refcnt;\n\tarea->freed_segment_counter = area->control->freed_segment_counter;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\treturn area;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
      "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
    ],
    "globals_used": [
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\"))"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not attach to dynamic shared area\""
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_area_control)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_area_control)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&area->segment_maps[0]",
            "0",
            "sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(dsa_area)"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0)"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "control->segment_handles[0] == handle"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "control->handle == handle"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_area *\nattach_internal(void *place, dsm_segment *segment, dsa_handle handle)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\n\tcontrol = (dsa_area_control *) place;\n\tAssert(control->handle == handle);\n\tAssert(control->segment_handles[0] == handle);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0));\n\n\t/* Build the backend-local area object. */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(&area->segment_maps[0], 0,\n\t\t   sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = segment; /* NULL for in-place */\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Bump the reference count. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (control->refcnt == 0)\n\t{\n\t\t/* We can't attach to a DSA area that has already been destroyed. */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\t}\n\t++control->refcnt;\n\tarea->freed_segment_counter = area->control->freed_segment_counter;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\treturn area;\n}"
  },
  {
    "function_name": "create_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1190-1288",
    "snippet": "static dsa_area *\ncreate_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\tsize_t\t\tusable_pages;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tmetadata_bytes;\n\tint\t\t\ti;\n\n\t/* Sanity check on the space we have to work in. */\n\tif (size < dsa_minimum_size())\n\t\telog(ERROR, \"dsa_area space must be at least %zu, but %zu provided\",\n\t\t\t dsa_minimum_size(), size);\n\n\t/* Now figure out how much space is usable */\n\ttotal_pages = size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\ttotal_pages * sizeof(dsa_pointer);\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tAssert(metadata_bytes <= size);\n\tusable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;\n\n\t/*\n\t * Initialize the dsa_area_control object located at the start of the\n\t * space.\n\t */\n\tcontrol = (dsa_area_control *) place;\n\tcontrol->segment_header.magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ control_handle ^ 0;\n\tcontrol->segment_header.next = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.prev = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.usable_pages = usable_pages;\n\tcontrol->segment_header.freed = false;\n\tcontrol->segment_header.size = DSA_INITIAL_SEGMENT_SIZE;\n\tcontrol->handle = control_handle;\n\tcontrol->max_total_segment_size = (size_t) -1;\n\tcontrol->total_segment_size = size;\n\tmemset(&control->segment_handles[0], 0,\n\t\t   sizeof(dsm_handle) * DSA_MAX_SEGMENTS);\n\tcontrol->segment_handles[0] = control_handle;\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t\tcontrol->segment_bins[i] = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->high_segment_index = 0;\n\tcontrol->refcnt = 1;\n\tcontrol->freed_segment_counter = 0;\n\tcontrol->lwlock_tranche_id = tranche_id;\n\n\t/*\n\t * Create the dsa_area object that this backend will use to access the\n\t * area.  Other backends will need to obtain their own dsa_area object by\n\t * attaching.\n\t */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(area->segment_maps, 0, sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\tarea->freed_segment_counter = 0;\n\tLWLockInitialize(&control->lock, control->lwlock_tranche_id);\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t\tLWLockInitialize(DSA_SCLASS_LOCK(area, i),\n\t\t\t\t\t\t control->lwlock_tranche_id);\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = control_segment;\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) place;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\t/* There can be 0 usable pages if size is dsa_minimum_size(). */\n\n\tif (usable_pages > 0)\n\t\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   usable_pages);\n\n\t/* Put this segment into the appropriate bin. */\n\tcontrol->segment_bins[contiguous_pages_to_segment_bin(usable_pages)] = 0;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\n\treturn area;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)",
      "#define DSA_NUM_SEGMENT_BINS 16",
      "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)",
      "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
      "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))",
      "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
    ],
    "globals_used": [
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_area *create_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment);",
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "contiguous_pages_to_segment_bin",
          "args": [
            "usable_pages"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contiguous_pages_to_segment_bin",
          "args": [
            "usable_pages"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerPut",
          "args": [
            "segment_map->fpm",
            "metadata_bytes / FPM_PAGE_SIZE",
            "usable_pages"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "378-418",
          "snippet": "void\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerInitialize",
          "args": [
            "segment_map->fpm",
            "segment_map->mapped_address"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "182-202",
          "snippet": "void\nFreePageManagerInitialize(FreePageManager *fpm, char *base)\n{\n\tSize\t\tf;\n\n\trelptr_store(base, fpm->self, fpm);\n\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\trelptr_store(base, fpm->btree_recycle, (FreePageSpanLeader *) NULL);\n\tfpm->btree_depth = 0;\n\tfpm->btree_recycle_count = 0;\n\tfpm->singleton_first_page = 0;\n\tfpm->singleton_npages = 0;\n\tfpm->contiguous_pages = 0;\n\tfpm->contiguous_pages_dirty = true;\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages = 0;\n#endif\n\n\tfor (f = 0; f < FPM_NUM_FREELISTS; f++)\n\t\trelptr_store(base, fpm->freelist[f], (FreePageSpanLeader *) NULL);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerInitialize(FreePageManager *fpm, char *base)\n{\n\tSize\t\tf;\n\n\trelptr_store(base, fpm->self, fpm);\n\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\trelptr_store(base, fpm->btree_recycle, (FreePageSpanLeader *) NULL);\n\tfpm->btree_depth = 0;\n\tfpm->btree_recycle_count = 0;\n\tfpm->singleton_first_page = 0;\n\tfpm->singleton_npages = 0;\n\tfpm->contiguous_pages = 0;\n\tfpm->contiguous_pages_dirty = true;\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages = 0;\n#endif\n\n\tfor (f = 0; f < FPM_NUM_FREELISTS; f++)\n\t\trelptr_store(base, fpm->freelist[f], (FreePageSpanLeader *) NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_area_control)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_area_control)"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockInitialize",
          "args": [
            "DSA_SCLASS_LOCK(area, i)",
            "control->lwlock_tranche_id"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "i"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockInitialize",
          "args": [
            "&control->lock",
            "control->lwlock_tranche_id"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "area->segment_maps",
            "0",
            "sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(dsa_area)"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&control->segment_handles[0]",
            "0",
            "sizeof(dsm_handle) * DSA_MAX_SEGMENTS"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "metadata_bytes <= size"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_area_control)"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"dsa_area space must be at least %zu, but %zu provided\"",
            "dsa_minimum_size()",
            "size"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsa_minimum_size",
          "args": [],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_minimum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1168-1185",
          "snippet": "size_t\ndsa_minimum_size(void)\n{\n\tsize_t\t\tsize;\n\tint\t\t\tpages = 0;\n\n\tsize = MAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager));\n\n\t/* Figure out how many pages we need, including the page map... */\n\twhile (((size + FPM_PAGE_SIZE - 1) / FPM_PAGE_SIZE) > pages)\n\t{\n\t\t++pages;\n\t\tsize += sizeof(dsa_pointer);\n\t}\n\n\treturn pages * FPM_PAGE_SIZE;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nsize_t\ndsa_minimum_size(void)\n{\n\tsize_t\t\tsize;\n\tint\t\t\tpages = 0;\n\n\tsize = MAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager));\n\n\t/* Figure out how many pages we need, including the page map... */\n\twhile (((size + FPM_PAGE_SIZE - 1) / FPM_PAGE_SIZE) > pages)\n\t{\n\t\t++pages;\n\t\tsize += sizeof(dsa_pointer);\n\t}\n\n\treturn pages * FPM_PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *create_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_area *\ncreate_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\tsize_t\t\tusable_pages;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tmetadata_bytes;\n\tint\t\t\ti;\n\n\t/* Sanity check on the space we have to work in. */\n\tif (size < dsa_minimum_size())\n\t\telog(ERROR, \"dsa_area space must be at least %zu, but %zu provided\",\n\t\t\t dsa_minimum_size(), size);\n\n\t/* Now figure out how much space is usable */\n\ttotal_pages = size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\ttotal_pages * sizeof(dsa_pointer);\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tAssert(metadata_bytes <= size);\n\tusable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;\n\n\t/*\n\t * Initialize the dsa_area_control object located at the start of the\n\t * space.\n\t */\n\tcontrol = (dsa_area_control *) place;\n\tcontrol->segment_header.magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ control_handle ^ 0;\n\tcontrol->segment_header.next = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.prev = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.usable_pages = usable_pages;\n\tcontrol->segment_header.freed = false;\n\tcontrol->segment_header.size = DSA_INITIAL_SEGMENT_SIZE;\n\tcontrol->handle = control_handle;\n\tcontrol->max_total_segment_size = (size_t) -1;\n\tcontrol->total_segment_size = size;\n\tmemset(&control->segment_handles[0], 0,\n\t\t   sizeof(dsm_handle) * DSA_MAX_SEGMENTS);\n\tcontrol->segment_handles[0] = control_handle;\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t\tcontrol->segment_bins[i] = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->high_segment_index = 0;\n\tcontrol->refcnt = 1;\n\tcontrol->freed_segment_counter = 0;\n\tcontrol->lwlock_tranche_id = tranche_id;\n\n\t/*\n\t * Create the dsa_area object that this backend will use to access the\n\t * area.  Other backends will need to obtain their own dsa_area object by\n\t * attaching.\n\t */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(area->segment_maps, 0, sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\tarea->freed_segment_counter = 0;\n\tLWLockInitialize(&control->lock, control->lwlock_tranche_id);\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t\tLWLockInitialize(DSA_SCLASS_LOCK(area, i),\n\t\t\t\t\t\t control->lwlock_tranche_id);\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = control_segment;\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) place;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\t/* There can be 0 usable pages if size is dsa_minimum_size(). */\n\n\tif (usable_pages > 0)\n\t\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   usable_pages);\n\n\t/* Put this segment into the appropriate bin. */\n\tcontrol->segment_bins[contiguous_pages_to_segment_bin(usable_pages)] = 0;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\n\treturn area;\n}"
  },
  {
    "function_name": "dsa_minimum_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1168-1185",
    "snippet": "size_t\ndsa_minimum_size(void)\n{\n\tsize_t\t\tsize;\n\tint\t\t\tpages = 0;\n\n\tsize = MAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager));\n\n\t/* Figure out how many pages we need, including the page map... */\n\twhile (((size + FPM_PAGE_SIZE - 1) / FPM_PAGE_SIZE) > pages)\n\t{\n\t\t++pages;\n\t\tsize += sizeof(dsa_pointer);\n\t}\n\n\treturn pages * FPM_PAGE_SIZE;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(FreePageManager)"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(dsa_area_control)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nsize_t\ndsa_minimum_size(void)\n{\n\tsize_t\t\tsize;\n\tint\t\t\tpages = 0;\n\n\tsize = MAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager));\n\n\t/* Figure out how many pages we need, including the page map... */\n\twhile (((size + FPM_PAGE_SIZE - 1) / FPM_PAGE_SIZE) > pages)\n\t{\n\t\t++pages;\n\t\tsize += sizeof(dsa_pointer);\n\t}\n\n\treturn pages * FPM_PAGE_SIZE;\n}"
  },
  {
    "function_name": "dsa_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1064-1162",
    "snippet": "void\ndsa_dump(dsa_area *area)\n{\n\tsize_t\t\ti,\n\t\t\t\tj;\n\n\t/*\n\t * Note: This gives an inconsistent snapshot as it acquires and releases\n\t * individual locks as it goes...\n\t */\n\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tfprintf(stderr, \"dsa_area handle %x:\\n\", area->control->handle);\n\tfprintf(stderr, \"  max_total_segment_size: %zu\\n\",\n\t\t\tarea->control->max_total_segment_size);\n\tfprintf(stderr, \"  total_segment_size: %zu\\n\",\n\t\t\tarea->control->total_segment_size);\n\tfprintf(stderr, \"  refcnt: %d\\n\", area->control->refcnt);\n\tfprintf(stderr, \"  pinned: %c\\n\", area->control->pinned ? 't' : 'f');\n\tfprintf(stderr, \"  segment bins:\\n\");\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t{\n\t\tif (area->control->segment_bins[i] != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_index segment_index;\n\n\t\t\tfprintf(stderr,\n\t\t\t\t\t\"    segment bin %zu (at least %d contiguous pages free):\\n\",\n\t\t\t\t\ti, 1 << (i - 1));\n\t\t\tsegment_index = area->control->segment_bins[i];\n\t\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t\t{\n\t\t\t\tdsa_segment_map *segment_map;\n\n\t\t\t\tsegment_map =\n\t\t\t\t\tget_segment_by_index(area, segment_index);\n\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"      segment index %zu, usable_pages = %zu, \"\n\t\t\t\t\t\t\"contiguous_pages = %zu, mapped at %p\\n\",\n\t\t\t\t\t\tsegment_index,\n\t\t\t\t\t\tsegment_map->header->usable_pages,\n\t\t\t\t\t\tfpm_largest(segment_map->fpm),\n\t\t\t\t\t\tsegment_map->mapped_address);\n\t\t\t\tsegment_index = segment_map->header->next;\n\t\t\t}\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\tfprintf(stderr, \"  pools:\\n\");\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t{\n\t\tbool\t\tfound = false;\n\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, i), LW_EXCLUSIVE);\n\t\tfor (j = 0; j < DSA_FULLNESS_CLASSES; ++j)\n\t\t\tif (DsaPointerIsValid(area->control->pools[i].spans[j]))\n\t\t\t\tfound = true;\n\t\tif (found)\n\t\t{\n\t\t\tif (i == DSA_SCLASS_BLOCK_OF_SPANS)\n\t\t\t\tfprintf(stderr, \"    pool for blocks of span objects:\\n\");\n\t\t\telse if (i == DSA_SCLASS_SPAN_LARGE)\n\t\t\t\tfprintf(stderr, \"    pool for large object spans:\\n\");\n\t\t\telse\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"    pool for size class %zu (object size %hu bytes):\\n\",\n\t\t\t\t\t\ti, dsa_size_classes[i]);\n\t\t\tfor (j = 0; j < DSA_FULLNESS_CLASSES; ++j)\n\t\t\t{\n\t\t\t\tif (!DsaPointerIsValid(area->control->pools[i].spans[j]))\n\t\t\t\t\tfprintf(stderr, \"      fullness class %zu is empty\\n\", j);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdsa_pointer span_pointer = area->control->pools[i].spans[j];\n\n\t\t\t\t\tfprintf(stderr, \"      fullness class %zu:\\n\", j);\n\t\t\t\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t\t\t\t{\n\t\t\t\t\t\tdsa_area_span *span;\n\n\t\t\t\t\t\tspan = dsa_get_address(area, span_pointer);\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\t\"        span descriptor at \"\n\t\t\t\t\t\t\t\tDSA_POINTER_FORMAT \", superblock at \"\n\t\t\t\t\t\t\t\tDSA_POINTER_FORMAT\n\t\t\t\t\t\t\t\t\", pages = %zu, objects free = %hu/%hu\\n\",\n\t\t\t\t\t\t\t\tspan_pointer, span->start, span->npages,\n\t\t\t\t\t\t\t\tspan->nallocatable, span->nmax);\n\t\t\t\t\t\tspan_pointer = span->nextspan;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, i));\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_FULLNESS_CLASSES\t\t4",
      "#define DSA_SCLASS_SPAN_LARGE\t\t\t1",
      "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0",
      "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)",
      "#define DSA_NUM_SEGMENT_BINS 16",
      "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
    ],
    "globals_used": [
      "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
      "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_SCLASS_LOCK(area, i)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "i"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"        span descriptor at \"\n\t\t\t\t\t\t\t\tDSA_POINTER_FORMAT \", superblock at \"\n\t\t\t\t\t\t\t\tDSA_POINTER_FORMAT\n\t\t\t\t\t\t\t\t\", pages = %zu, objects free = %hu/%hu\\n\"",
            "span_pointer",
            "span->start",
            "span->npages",
            "span->nallocatable",
            "span->nmax"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span_pointer"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      fullness class %zu:\\n\"",
            "j"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      fullness class %zu is empty\\n\"",
            "j"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "area->control->pools[i].spans[j]"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    pool for size class %zu (object size %hu bytes):\\n\"",
            "i",
            "dsa_size_classes[i]"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    pool for large object spans:\\n\""
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    pool for blocks of span objects:\\n\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "area->control->pools[i].spans[j]"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_SCLASS_LOCK(area, i)",
            "LW_EXCLUSIVE"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "i"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  pools:\\n\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      segment index %zu, usable_pages = %zu, \"\n\t\t\t\t\t\t\"contiguous_pages = %zu, mapped at %p\\n\"",
            "segment_index",
            "segment_map->header->usable_pages",
            "fpm_largest(segment_map->fpm)",
            "segment_map->mapped_address"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_largest",
          "args": [
            "segment_map->fpm"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "segment_index"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    segment bin %zu (at least %d contiguous pages free):\\n\"",
            "i",
            "1 << (i - 1)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  segment bins:\\n\""
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  pinned: %c\\n\"",
            "area->control->pinned ? 't' : 'f'"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  refcnt: %d\\n\"",
            "area->control->refcnt"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  total_segment_size: %zu\\n\"",
            "area->control->total_segment_size"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  max_total_segment_size: %zu\\n\"",
            "area->control->max_total_segment_size"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dsa_area handle %x:\\n\"",
            "area->control->handle"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_freed_segments_locked",
          "args": [
            "area"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_freed_segments_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2266-2289",
          "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_dump(dsa_area *area)\n{\n\tsize_t\t\ti,\n\t\t\t\tj;\n\n\t/*\n\t * Note: This gives an inconsistent snapshot as it acquires and releases\n\t * individual locks as it goes...\n\t */\n\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tfprintf(stderr, \"dsa_area handle %x:\\n\", area->control->handle);\n\tfprintf(stderr, \"  max_total_segment_size: %zu\\n\",\n\t\t\tarea->control->max_total_segment_size);\n\tfprintf(stderr, \"  total_segment_size: %zu\\n\",\n\t\t\tarea->control->total_segment_size);\n\tfprintf(stderr, \"  refcnt: %d\\n\", area->control->refcnt);\n\tfprintf(stderr, \"  pinned: %c\\n\", area->control->pinned ? 't' : 'f');\n\tfprintf(stderr, \"  segment bins:\\n\");\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t{\n\t\tif (area->control->segment_bins[i] != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_index segment_index;\n\n\t\t\tfprintf(stderr,\n\t\t\t\t\t\"    segment bin %zu (at least %d contiguous pages free):\\n\",\n\t\t\t\t\ti, 1 << (i - 1));\n\t\t\tsegment_index = area->control->segment_bins[i];\n\t\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t\t{\n\t\t\t\tdsa_segment_map *segment_map;\n\n\t\t\t\tsegment_map =\n\t\t\t\t\tget_segment_by_index(area, segment_index);\n\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"      segment index %zu, usable_pages = %zu, \"\n\t\t\t\t\t\t\"contiguous_pages = %zu, mapped at %p\\n\",\n\t\t\t\t\t\tsegment_index,\n\t\t\t\t\t\tsegment_map->header->usable_pages,\n\t\t\t\t\t\tfpm_largest(segment_map->fpm),\n\t\t\t\t\t\tsegment_map->mapped_address);\n\t\t\t\tsegment_index = segment_map->header->next;\n\t\t\t}\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\tfprintf(stderr, \"  pools:\\n\");\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t{\n\t\tbool\t\tfound = false;\n\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, i), LW_EXCLUSIVE);\n\t\tfor (j = 0; j < DSA_FULLNESS_CLASSES; ++j)\n\t\t\tif (DsaPointerIsValid(area->control->pools[i].spans[j]))\n\t\t\t\tfound = true;\n\t\tif (found)\n\t\t{\n\t\t\tif (i == DSA_SCLASS_BLOCK_OF_SPANS)\n\t\t\t\tfprintf(stderr, \"    pool for blocks of span objects:\\n\");\n\t\t\telse if (i == DSA_SCLASS_SPAN_LARGE)\n\t\t\t\tfprintf(stderr, \"    pool for large object spans:\\n\");\n\t\t\telse\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"    pool for size class %zu (object size %hu bytes):\\n\",\n\t\t\t\t\t\ti, dsa_size_classes[i]);\n\t\t\tfor (j = 0; j < DSA_FULLNESS_CLASSES; ++j)\n\t\t\t{\n\t\t\t\tif (!DsaPointerIsValid(area->control->pools[i].spans[j]))\n\t\t\t\t\tfprintf(stderr, \"      fullness class %zu is empty\\n\", j);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdsa_pointer span_pointer = area->control->pools[i].spans[j];\n\n\t\t\t\t\tfprintf(stderr, \"      fullness class %zu:\\n\", j);\n\t\t\t\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t\t\t\t{\n\t\t\t\t\t\tdsa_area_span *span;\n\n\t\t\t\t\t\tspan = dsa_get_address(area, span_pointer);\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\t\"        span descriptor at \"\n\t\t\t\t\t\t\t\tDSA_POINTER_FORMAT \", superblock at \"\n\t\t\t\t\t\t\t\tDSA_POINTER_FORMAT\n\t\t\t\t\t\t\t\t\", pages = %zu, objects free = %hu/%hu\\n\",\n\t\t\t\t\t\t\t\tspan_pointer, span->start, span->npages,\n\t\t\t\t\t\t\t\tspan->nallocatable, span->nmax);\n\t\t\t\t\t\tspan_pointer = span->nextspan;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, i));\n\t}\n}"
  },
  {
    "function_name": "dsa_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1019-1058",
    "snippet": "void\ndsa_trim(dsa_area *area)\n{\n\tint\t\t\tsize_class;\n\n\t/*\n\t * Trim in reverse pool order so we get to the spans-of-spans last, just\n\t * in case any become entirely free while processing all the other pools.\n\t */\n\tfor (size_class = DSA_NUM_SIZE_CLASSES - 1; size_class >= 0; --size_class)\n\t{\n\t\tdsa_area_pool *pool = &area->control->pools[size_class];\n\t\tdsa_pointer span_pointer;\n\n\t\tif (size_class == DSA_SCLASS_SPAN_LARGE)\n\t\t{\n\t\t\t/* Large object frees give back segments aggressively already. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Search fullness class 1 only.  That is where we expect to find an\n\t\t * entirely empty superblock (entirely empty superblocks in other\n\t\t * fullness classes are returned to the free page map by dsa_free).\n\t\t */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\t\tspan_pointer = pool->spans[1];\n\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\t\t\tdsa_pointer next = span->nextspan;\n\n\t\t\tif (span->nallocatable == span->nmax)\n\t\t\t\tdestroy_superblock(area, span_pointer);\n\n\t\t\tspan_pointer = next;\n\t\t}\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SCLASS_SPAN_LARGE\t\t\t1",
      "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)"
    ],
    "globals_used": [
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_superblock",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1801-1863",
          "snippet": "static void\ndestroy_superblock(dsa_area *area, dsa_pointer span_pointer)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tint\t\t\tsize_class = span->size_class;\n\tdsa_segment_map *segment_map;\n\n\n\t/* Remove it from its fullness class list. */\n\tunlink_span(area, span);\n\n\t/*\n\t * Note: Here we acquire the area lock while we already hold a per-pool\n\t * lock.  We never hold the area lock and then take a pool lock, or we\n\t * could deadlock.\n\t */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tsegment_map =\n\t\tget_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(span->start));\n\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t   span->npages);\n\t/* Check if the segment is now entirely free. */\n\tif (fpm_largest(segment_map->fpm) == segment_map->header->usable_pages)\n\t{\n\t\tdsa_segment_index index = get_segment_index(area, segment_map);\n\n\t\t/* If it's not the segment with extra control data, free it. */\n\t\tif (index != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Give it back to the OS, and allow other backends to detect that\n\t\t\t * they need to detach.\n\t\t\t */\n\t\t\tunlink_segment(area, segment_map);\n\t\t\tsegment_map->header->freed = true;\n\t\t\tAssert(area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size);\n\t\t\tarea->control->total_segment_size -=\n\t\t\t\tsegment_map->header->size;\n\t\t\tdsm_unpin_segment(dsm_segment_handle(segment_map->segment));\n\t\t\tdsm_detach(segment_map->segment);\n\t\t\tarea->control->segment_handles[index] = DSM_HANDLE_INVALID;\n\t\t\t++area->control->freed_segment_counter;\n\t\t\tsegment_map->segment = NULL;\n\t\t\tsegment_map->header = NULL;\n\t\t\tsegment_map->mapped_address = NULL;\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/*\n\t * Span-of-spans blocks store the span which describes them within the\n\t * block itself, so freeing the storage implicitly frees the descriptor\n\t * also.  If this is a block of any other type, we need to separately free\n\t * the span object also.  This recursive call to dsa_free will acquire the\n\t * span pool's lock.  We can't deadlock because the acquisition order is\n\t * always some other pool and then the span pool.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tdsa_free(area, span_pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
          ],
          "globals_used": [
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ndestroy_superblock(dsa_area *area, dsa_pointer span_pointer)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tint\t\t\tsize_class = span->size_class;\n\tdsa_segment_map *segment_map;\n\n\n\t/* Remove it from its fullness class list. */\n\tunlink_span(area, span);\n\n\t/*\n\t * Note: Here we acquire the area lock while we already hold a per-pool\n\t * lock.  We never hold the area lock and then take a pool lock, or we\n\t * could deadlock.\n\t */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tsegment_map =\n\t\tget_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(span->start));\n\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t   span->npages);\n\t/* Check if the segment is now entirely free. */\n\tif (fpm_largest(segment_map->fpm) == segment_map->header->usable_pages)\n\t{\n\t\tdsa_segment_index index = get_segment_index(area, segment_map);\n\n\t\t/* If it's not the segment with extra control data, free it. */\n\t\tif (index != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Give it back to the OS, and allow other backends to detect that\n\t\t\t * they need to detach.\n\t\t\t */\n\t\t\tunlink_segment(area, segment_map);\n\t\t\tsegment_map->header->freed = true;\n\t\t\tAssert(area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size);\n\t\t\tarea->control->total_segment_size -=\n\t\t\t\tsegment_map->header->size;\n\t\t\tdsm_unpin_segment(dsm_segment_handle(segment_map->segment));\n\t\t\tdsm_detach(segment_map->segment);\n\t\t\tarea->control->segment_handles[index] = DSM_HANDLE_INVALID;\n\t\t\t++area->control->freed_segment_counter;\n\t\t\tsegment_map->segment = NULL;\n\t\t\tsegment_map->header = NULL;\n\t\t\tsegment_map->mapped_address = NULL;\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/*\n\t * Span-of-spans blocks store the span which describes them within the\n\t * block itself, so freeing the storage implicitly frees the descriptor\n\t * also.  If this is a block of any other type, we need to separately free\n\t * the span object also.  This recursive call to dsa_free will acquire the\n\t * span pool's lock.  We can't deadlock because the acquisition order is\n\t * always some other pool and then the span pool.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tdsa_free(area, span_pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span_pointer"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)",
            "LW_EXCLUSIVE"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_trim(dsa_area *area)\n{\n\tint\t\t\tsize_class;\n\n\t/*\n\t * Trim in reverse pool order so we get to the spans-of-spans last, just\n\t * in case any become entirely free while processing all the other pools.\n\t */\n\tfor (size_class = DSA_NUM_SIZE_CLASSES - 1; size_class >= 0; --size_class)\n\t{\n\t\tdsa_area_pool *pool = &area->control->pools[size_class];\n\t\tdsa_pointer span_pointer;\n\n\t\tif (size_class == DSA_SCLASS_SPAN_LARGE)\n\t\t{\n\t\t\t/* Large object frees give back segments aggressively already. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Search fullness class 1 only.  That is where we expect to find an\n\t\t * entirely empty superblock (entirely empty superblocks in other\n\t\t * fullness classes are returned to the free page map by dsa_free).\n\t\t */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\t\tspan_pointer = pool->spans[1];\n\t\twhile (DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\t\t\tdsa_pointer next = span->nextspan;\n\n\t\t\tif (span->nallocatable == span->nmax)\n\t\t\t\tdestroy_superblock(area, span_pointer);\n\n\t\t\tspan_pointer = next;\n\t\t}\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\t}\n}"
  },
  {
    "function_name": "dsa_set_size_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "1007-1013",
    "snippet": "void\ndsa_set_size_limit(dsa_area *area, size_t limit)\n{\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tarea->control->max_total_segment_size = limit;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_set_size_limit(dsa_area *area, size_t limit)\n{\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tarea->control->max_total_segment_size = limit;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n}"
  },
  {
    "function_name": "dsa_unpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "983-996",
    "snippet": "void\ndsa_unpin(dsa_area *area)\n{\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tAssert(area->control->refcnt > 1);\n\tif (!area->control->pinned)\n\t{\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\telog(ERROR, \"dsa_area not pinned\");\n\t}\n\tarea->control->pinned = false;\n\t--area->control->refcnt;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"dsa_area not pinned\""
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "area->control->refcnt > 1"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_unpin(dsa_area *area)\n{\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tAssert(area->control->refcnt > 1);\n\tif (!area->control->pinned)\n\t{\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\telog(ERROR, \"dsa_area not pinned\");\n\t}\n\tarea->control->pinned = false;\n\t--area->control->refcnt;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n}"
  },
  {
    "function_name": "dsa_pin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "964-976",
    "snippet": "void\ndsa_pin(dsa_area *area)\n{\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (area->control->pinned)\n\t{\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\telog(ERROR, \"dsa_area already pinned\");\n\t}\n\tarea->control->pinned = true;\n\t++area->control->refcnt;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"dsa_area already pinned\""
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_pin(dsa_area *area)\n{\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (area->control->pinned)\n\t{\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\telog(ERROR, \"dsa_area already pinned\");\n\t}\n\tarea->control->pinned = true;\n\t++area->control->refcnt;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n}"
  },
  {
    "function_name": "dsa_get_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "931-957",
    "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
    ],
    "globals_used": [
      "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "index"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "area->segment_maps[index].mapped_address == NULL"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index < DSA_MAX_SEGMENTS"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_OFFSET",
          "args": [
            "dp"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_SEGMENT_NUMBER",
          "args": [
            "dp"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_freed_segments",
          "args": [
            "area"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_freed_segments_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2266-2289",
          "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "dp"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
  },
  {
    "function_name": "dsa_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "819-923",
    "snippet": "void\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
      "#define DSA_FULLNESS_CLASSES\t\t4",
      "#define DSA_SCLASS_SPAN_LARGE\t\t\t1"
    ],
    "globals_used": [
      "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_superblock",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1801-1863",
          "snippet": "static void\ndestroy_superblock(dsa_area *area, dsa_pointer span_pointer)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tint\t\t\tsize_class = span->size_class;\n\tdsa_segment_map *segment_map;\n\n\n\t/* Remove it from its fullness class list. */\n\tunlink_span(area, span);\n\n\t/*\n\t * Note: Here we acquire the area lock while we already hold a per-pool\n\t * lock.  We never hold the area lock and then take a pool lock, or we\n\t * could deadlock.\n\t */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tsegment_map =\n\t\tget_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(span->start));\n\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t   span->npages);\n\t/* Check if the segment is now entirely free. */\n\tif (fpm_largest(segment_map->fpm) == segment_map->header->usable_pages)\n\t{\n\t\tdsa_segment_index index = get_segment_index(area, segment_map);\n\n\t\t/* If it's not the segment with extra control data, free it. */\n\t\tif (index != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Give it back to the OS, and allow other backends to detect that\n\t\t\t * they need to detach.\n\t\t\t */\n\t\t\tunlink_segment(area, segment_map);\n\t\t\tsegment_map->header->freed = true;\n\t\t\tAssert(area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size);\n\t\t\tarea->control->total_segment_size -=\n\t\t\t\tsegment_map->header->size;\n\t\t\tdsm_unpin_segment(dsm_segment_handle(segment_map->segment));\n\t\t\tdsm_detach(segment_map->segment);\n\t\t\tarea->control->segment_handles[index] = DSM_HANDLE_INVALID;\n\t\t\t++area->control->freed_segment_counter;\n\t\t\tsegment_map->segment = NULL;\n\t\t\tsegment_map->header = NULL;\n\t\t\tsegment_map->mapped_address = NULL;\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/*\n\t * Span-of-spans blocks store the span which describes them within the\n\t * block itself, so freeing the storage implicitly frees the descriptor\n\t * also.  If this is a block of any other type, we need to separately free\n\t * the span object also.  This recursive call to dsa_free will acquire the\n\t * span pool's lock.  We can't deadlock because the acquisition order is\n\t * always some other pool and then the span pool.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tdsa_free(area, span_pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
          ],
          "globals_used": [
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ndestroy_superblock(dsa_area *area, dsa_pointer span_pointer)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tint\t\t\tsize_class = span->size_class;\n\tdsa_segment_map *segment_map;\n\n\n\t/* Remove it from its fullness class list. */\n\tunlink_span(area, span);\n\n\t/*\n\t * Note: Here we acquire the area lock while we already hold a per-pool\n\t * lock.  We never hold the area lock and then take a pool lock, or we\n\t * could deadlock.\n\t */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tcheck_for_freed_segments_locked(area);\n\tsegment_map =\n\t\tget_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(span->start));\n\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t   span->npages);\n\t/* Check if the segment is now entirely free. */\n\tif (fpm_largest(segment_map->fpm) == segment_map->header->usable_pages)\n\t{\n\t\tdsa_segment_index index = get_segment_index(area, segment_map);\n\n\t\t/* If it's not the segment with extra control data, free it. */\n\t\tif (index != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Give it back to the OS, and allow other backends to detect that\n\t\t\t * they need to detach.\n\t\t\t */\n\t\t\tunlink_segment(area, segment_map);\n\t\t\tsegment_map->header->freed = true;\n\t\t\tAssert(area->control->total_segment_size >=\n\t\t\t\t   segment_map->header->size);\n\t\t\tarea->control->total_segment_size -=\n\t\t\t\tsegment_map->header->size;\n\t\t\tdsm_unpin_segment(dsm_segment_handle(segment_map->segment));\n\t\t\tdsm_detach(segment_map->segment);\n\t\t\tarea->control->segment_handles[index] = DSM_HANDLE_INVALID;\n\t\t\t++area->control->freed_segment_counter;\n\t\t\tsegment_map->segment = NULL;\n\t\t\tsegment_map->header = NULL;\n\t\t\tsegment_map->mapped_address = NULL;\n\t\t}\n\t}\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t/*\n\t * Span-of-spans blocks store the span which describes them within the\n\t * block itself, so freeing the storage implicitly frees the descriptor\n\t * also.  If this is a block of any other type, we need to separately free\n\t * the span object also.  This recursive call to dsa_free will acquire the\n\t * span pool's lock.  We can't deadlock because the acquisition order is\n\t * always some other pool and then the span pool.\n\t */\n\tif (size_class != DSA_SCLASS_BLOCK_OF_SPANS)\n\t\tdsa_free(area, span_pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_span_to_fullness_class",
          "args": [
            "area",
            "span",
            "span_pointer",
            "DSA_FULLNESS_CLASSES - 2"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "add_span_to_fullness_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1888-1906",
          "snippet": "static void\nadd_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer,\n\t\t\t\t\t\t   int fclass)\n{\n\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\tif (DsaPointerIsValid(pool->spans[fclass]))\n\t{\n\t\tdsa_area_span *head = dsa_get_address(area,\n\t\t\t\t\t\t\t\t\t\t\t  pool->spans[fclass]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->prevspan = InvalidDsaPointer;\n\tspan->nextspan = pool->spans[fclass];\n\tpool->spans[fclass] = span_pointer;\n\tspan->fclass = fclass;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nadd_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer,\n\t\t\t\t\t\t   int fclass)\n{\n\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\tif (DsaPointerIsValid(pool->spans[fclass]))\n\t{\n\t\tdsa_area_span *head = dsa_get_address(area,\n\t\t\t\t\t\t\t\t\t\t\t  pool->spans[fclass]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->prevspan = InvalidDsaPointer;\n\tspan->nextspan = pool->spans[fclass];\n\tpool->spans[fclass] = span_pointer;\n\tspan->fclass = fclass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_span",
          "args": [
            "area",
            "span"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1865-1886",
          "snippet": "static void\nunlink_span(dsa_area *area, dsa_area_span *span)\n{\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tdsa_area_span *next = dsa_get_address(area, span->nextspan);\n\n\t\tnext->prevspan = span->prevspan;\n\t}\n\tif (DsaPointerIsValid(span->prevspan))\n\t{\n\t\tdsa_area_span *prev = dsa_get_address(area, span->prevspan);\n\n\t\tprev->nextspan = span->nextspan;\n\t}\n\telse\n\t{\n\t\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\t\tpool->spans[span->fclass] = span->nextspan;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\nunlink_span(dsa_area *area, dsa_area_span *span)\n{\n\tif (DsaPointerIsValid(span->nextspan))\n\t{\n\t\tdsa_area_span *next = dsa_get_address(area, span->nextspan);\n\n\t\tnext->prevspan = span->prevspan;\n\t}\n\tif (DsaPointerIsValid(span->prevspan))\n\t{\n\t\tdsa_area_span *prev = dsa_get_address(area, span->prevspan);\n\n\t\tprev->nextspan = span->nextspan;\n\t}\n\telse\n\t{\n\t\tdsa_area_pool *pool = dsa_get_address(area, span->pool);\n\n\t\tpool->spans[span->fclass] = span->nextspan;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NextFreeObjectIndex",
          "args": [
            "object"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(object - superblock) % size == 0"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "object < superblock + DSA_SUPERBLOCK_SIZE"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "object >= superblock"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_SCLASS_LOCK(area, size_class)",
            "LW_EXCLUSIVE"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "size_class"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "object",
            "0x7f",
            "size"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_free",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "819-923",
          "snippet": "void\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "DSA_SCLASS_SPAN_LARGE"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE)",
            "LW_EXCLUSIVE"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "DSA_SCLASS_SPAN_LARGE"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerPut",
          "args": [
            "segment_map->fpm",
            "DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE",
            "span->npages"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "378-418",
          "snippet": "void\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_OFFSET",
          "args": [
            "span->start"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "object",
            "0x7f",
            "span->npages * FPM_PAGE_SIZE"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "dp"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_OFFSET",
          "args": [
            "dp"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_by_index",
          "args": [
            "area",
            "DSA_EXTRACT_SEGMENT_NUMBER(dp)"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "get_segment_by_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1723-1793",
          "snippet": "static dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_segment_by_index(dsa_area *area, dsa_segment_index index)\n{\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\tdsm_handle\thandle;\n\t\tdsm_segment *segment;\n\t\tdsa_segment_map *segment_map;\n\n\t\t/*\n\t\t * If we are reached by dsa_free or dsa_get_address, there must be at\n\t\t * least one object allocated in the referenced segment.  Otherwise,\n\t\t * their caller has a double-free or access-after-free bug, which we\n\t\t * have no hope of detecting.  So we know it's safe to access this\n\t\t * array slot without holding a lock; it won't change underneath us.\n\t\t * Furthermore, we know that we can see the latest contents of the\n\t\t * slot, as explained in check_for_freed_segments, which those\n\t\t * functions call before arriving here.\n\t\t */\n\t\thandle = area->control->segment_handles[index];\n\n\t\t/* It's an error to try to access an unused slot. */\n\t\tif (handle == DSM_HANDLE_INVALID)\n\t\t\telog(ERROR,\n\t\t\t\t \"dsa_area could not attach to a segment that has been freed\");\n\n\t\tsegment = dsm_attach(handle);\n\t\tif (segment == NULL)\n\t\t\telog(ERROR, \"dsa_area could not attach to segment\");\n\t\tif (area->mapping_pinned)\n\t\t\tdsm_pin_mapping(segment);\n\t\tsegment_map = &area->segment_maps[index];\n\t\tsegment_map->segment = segment;\n\t\tsegment_map->mapped_address = dsm_segment_address(segment);\n\t\tsegment_map->header =\n\t\t\t(dsa_segment_header *) segment_map->mapped_address;\n\t\tsegment_map->fpm = (FreePageManager *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\t\tsegment_map->pagemap = (dsa_pointer *)\n\t\t\t(segment_map->mapped_address +\n\t\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t\t/* Remember the highest index this backend has ever mapped. */\n\t\tif (area->high_segment_index < index)\n\t\t\tarea->high_segment_index = index;\n\n\t\tAssert(segment_map->header->magic ==\n\t\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ index));\n\t}\n\n\t/*\n\t * Callers of dsa_get_address() and dsa_free() don't hold the area lock,\n\t * but it's a bug in the calling code and undefined behavior if the\n\t * address is not live (ie if the segment might possibly have been freed,\n\t * they're trying to use a dangling pointer).\n\t *\n\t * For dsa.c code that holds the area lock to manipulate segment_bins\n\t * lists, it would be a bug if we ever reach a freed segment here.  After\n\t * it's marked as freed, the only thing any backend should do with it is\n\t * unmap it, and it should always have done that in\n\t * check_for_freed_segments_locked() before arriving here to resolve an\n\t * index to a segment_map.\n\t *\n\t * Either way we can assert that we aren't returning a freed segment.\n\t */\n\tAssert(!area->segment_maps[index].header->freed);\n\n\treturn &area->segment_maps[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "DSA_EXTRACT_SEGMENT_NUMBER",
          "args": [
            "dp"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_freed_segments",
          "args": [
            "area"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_freed_segments_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2266-2289",
          "snippet": "static void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ncheck_for_freed_segments_locked(dsa_area *area)\n{\n\tsize_t\t\tfreed_segment_counter;\n\tint\t\ti;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tfreed_segment_counter = area->control->freed_segment_counter;\n\tif (unlikely(area->freed_segment_counter != freed_segment_counter))\n\t{\n\t\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\t{\n\t\t\tif (area->segment_maps[i].header != NULL &&\n\t\t\t\tarea->segment_maps[i].header->freed)\n\t\t\t{\n\t\t\t\tdsm_detach(area->segment_maps[i].segment);\n\t\t\t\tarea->segment_maps[i].segment = NULL;\n\t\t\t\tarea->segment_maps[i].header = NULL;\n\t\t\t\tarea->segment_maps[i].mapped_address = NULL;\n\t\t\t}\n\t\t}\n\t\tarea->freed_segment_counter = freed_segment_counter;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}"
  },
  {
    "function_name": "dsa_allocate_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "664-814",
    "snippet": "dsa_pointer\ndsa_allocate_extended(dsa_area *area, size_t size, int flags)\n{\n\tuint16\t\tsize_class;\n\tdsa_pointer start_pointer;\n\tdsa_segment_map *segment_map;\n\tdsa_pointer result;\n\n\tAssert(size > 0);\n\n\t/* Sanity check on huge individual allocation size. */\n\tif (((flags & DSA_ALLOC_HUGE) != 0 && !AllocHugeSizeIsValid(size)) ||\n\t\t((flags & DSA_ALLOC_HUGE) == 0 && !AllocSizeIsValid(size)))\n\t\telog(ERROR, \"invalid DSA memory alloc request size %zu\", size);\n\n\t/*\n\t * If bigger than the largest size class, just grab a run of pages from\n\t * the free page manager, instead of allocating an object from a pool.\n\t * There will still be a span, but it's a special class of span that\n\t * manages this whole allocation and simply gives all pages back to the\n\t * free page manager when dsa_free is called.\n\t */\n\tif (size > dsa_size_classes[lengthof(dsa_size_classes) - 1])\n\t{\n\t\tsize_t\t\tnpages = fpm_size_to_pages(size);\n\t\tsize_t\t\tfirst_page;\n\t\tdsa_pointer span_pointer;\n\t\tdsa_area_pool *pool = &area->control->pools[DSA_SCLASS_SPAN_LARGE];\n\n\t\t/* Obtain a span object. */\n\t\tspan_pointer = alloc_object(area, DSA_SCLASS_BLOCK_OF_SPANS);\n\t\tif (!DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\t/* Raise error unless asked not to. */\n\t\t\tif ((flags & DSA_ALLOC_NO_OOM) == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\",\n\t\t\t\t\t\t\t\t   size)));\n\t\t\treturn InvalidDsaPointer;\n\t\t}\n\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\n\t\t/* Find a segment from which to allocate. */\n\t\tsegment_map = get_best_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t\tsegment_map = make_new_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t{\n\t\t\t/* Can't make any more segments: game over. */\n\t\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t\tdsa_free(area, span_pointer);\n\n\t\t\t/* Raise error unless asked not to. */\n\t\t\tif ((flags & DSA_ALLOC_NO_OOM) == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\",\n\t\t\t\t\t\t\t\t   size)));\n\t\t\treturn InvalidDsaPointer;\n\t\t}\n\n\t\t/*\n\t\t * Ask the free page manager for a run of pages.  This should always\n\t\t * succeed, since both get_best_segment and make_new_segment should\n\t\t * only return a non-NULL pointer if it actually contains enough\n\t\t * contiguous freespace.  If it does fail, something in our backend\n\t\t * private state is out of whack, so use FATAL to kill the process.\n\t\t */\n\t\tif (!FreePageManagerGet(segment_map->fpm, npages, &first_page))\n\t\t\telog(FATAL,\n\t\t\t\t \"dsa_allocate could not find %zu free pages\", npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t\tstart_pointer = DSA_MAKE_POINTER(get_segment_index(area, segment_map),\n\t\t\t\t\t\t\t\t\t\t first_page * FPM_PAGE_SIZE);\n\n\t\t/* Initialize span and pagemap. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tinit_span(area, span_pointer, pool, start_pointer, npages,\n\t\t\t\t  DSA_SCLASS_SPAN_LARGE);\n\t\tsegment_map->pagemap[first_page] = span_pointer;\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\n\t\t/* Zero-initialize the memory if requested. */\n\t\tif ((flags & DSA_ALLOC_ZERO) != 0)\n\t\t\tmemset(dsa_get_address(area, start_pointer), 0, size);\n\n\t\treturn start_pointer;\n\t}\n\n\t/* Map allocation to a size class. */\n\tif (size < lengthof(dsa_size_class_map) * DSA_SIZE_CLASS_MAP_QUANTUM)\n\t{\n\t\tint\t\t\tmapidx;\n\n\t\t/* For smaller sizes we have a lookup table... */\n\t\tmapidx = ((size + DSA_SIZE_CLASS_MAP_QUANTUM - 1) /\n\t\t\t\t  DSA_SIZE_CLASS_MAP_QUANTUM) - 1;\n\t\tsize_class = dsa_size_class_map[mapidx];\n\t}\n\telse\n\t{\n\t\tuint16\t\tmin;\n\t\tuint16\t\tmax;\n\n\t\t/* ... and for the rest we search by binary chop. */\n\t\tmin = dsa_size_class_map[lengthof(dsa_size_class_map) - 1];\n\t\tmax = lengthof(dsa_size_classes) - 1;\n\n\t\twhile (min < max)\n\t\t{\n\t\t\tuint16\t\tmid = (min + max) / 2;\n\t\t\tuint16\t\tclass_size = dsa_size_classes[mid];\n\n\t\t\tif (class_size < size)\n\t\t\t\tmin = mid + 1;\n\t\t\telse\n\t\t\t\tmax = mid;\n\t\t}\n\n\t\tsize_class = min;\n\t}\n\tAssert(size <= dsa_size_classes[size_class]);\n\tAssert(size_class == 0 || size > dsa_size_classes[size_class - 1]);\n\n\t/* Attempt to allocate an object from the appropriate pool. */\n\tresult = alloc_object(area, size_class);\n\n\t/* Check for failure to allocate. */\n\tif (!DsaPointerIsValid(result))\n\t{\n\t\t/* Raise error unless asked not to. */\n\t\tif ((flags & DSA_ALLOC_NO_OOM) == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\", size)));\n\t\treturn InvalidDsaPointer;\n\t}\n\n\t/* Zero-initialize the memory if requested. */\n\tif ((flags & DSA_ALLOC_ZERO) != 0)\n\t\tmemset(dsa_get_address(area, result), 0, size);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SIZE_CLASS_MAP_QUANTUM\t8",
      "#define DSA_SCLASS_SPAN_LARGE\t\t\t1",
      "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
    ],
    "globals_used": [
      "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
      "static char dsa_size_class_map[] = {\n\t2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n\t14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17,\n\t18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19,\n\t20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21,\n\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25\n};",
      "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
      "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
      "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
      "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
      "static void unlink_span(dsa_area *area, dsa_area_span *span);",
      "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
      "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dsa_get_address(area, result)",
            "0",
            "size"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_get_address",
          "args": [
            "area",
            "result"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_get_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "931-957",
          "snippet": "void *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid *\ndsa_get_address(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_index index;\n\tsize_t\t\toffset;\n\n\t/* Convert InvalidDsaPointer to NULL. */\n\tif (!DsaPointerIsValid(dp))\n\t\treturn NULL;\n\n\t/* Process any requests to detach from freed segments. */\n\tcheck_for_freed_segments(area);\n\n\t/* Break the dsa_pointer into its components. */\n\tindex = DSA_EXTRACT_SEGMENT_NUMBER(dp);\n\toffset = DSA_EXTRACT_OFFSET(dp);\n\tAssert(index < DSA_MAX_SEGMENTS);\n\n\t/* Check if we need to cause this segment to be mapped in. */\n\tif (unlikely(area->segment_maps[index].mapped_address == NULL))\n\t{\n\t\t/* Call for effect (we don't need the result). */\n\t\tget_segment_by_index(area, index);\n\t}\n\n\treturn area->segment_maps[index].mapped_address + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\", size))"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Failed on DSA request of size %zu.\"",
            "size"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "result"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_object",
          "args": [
            "area",
            "size_class"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1439-1503",
          "snippet": "static inline dsa_pointer\nalloc_object(dsa_area *area, int size_class)\n{\n\tdsa_area_pool *pool = &area->control->pools[size_class];\n\tdsa_area_span *span;\n\tdsa_pointer block;\n\tdsa_pointer result;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\n\t/*\n\t * Even though ensure_active_superblock can in turn call alloc_object if\n\t * it needs to allocate a new span, that's always from a different pool,\n\t * and the order of lock acquisition is always the same, so it's OK that\n\t * we hold this lock for the duration of this function.\n\t */\n\tAssert(!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/*\n\t * If there's no active superblock, we must successfully obtain one or\n\t * fail the request.\n\t */\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\t!ensure_active_superblock(area, pool, size_class))\n\t{\n\t\tresult = InvalidDsaPointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * There should be a block in fullness class 1 at this point, and it\n\t\t * should never be completely full.  Thus we can either pop an object\n\t\t * from the free list or, failing that, initialize a new object.\n\t\t */\n\t\tAssert(DsaPointerIsValid(pool->spans[1]));\n\t\tspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, pool->spans[1]);\n\t\tAssert(span->nallocatable > 0);\n\t\tblock = span->start;\n\t\tAssert(size_class < DSA_NUM_SIZE_CLASSES);\n\t\tsize = dsa_size_classes[size_class];\n\t\tif (span->firstfree != DSA_SPAN_NOTHING_FREE)\n\t\t{\n\t\t\tresult = block + span->firstfree * size;\n\t\t\tobject = dsa_get_address(area, result);\n\t\t\tspan->firstfree = NextFreeObjectIndex(object);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = block + span->ninitialized * size;\n\t\t\t++span->ninitialized;\n\t\t}\n\t\t--span->nallocatable;\n\n\t\t/* If it's now full, move it to the highest-numbered fullness class. */\n\t\tif (span->nallocatable == 0)\n\t\t\ttransfer_first_span(area, pool, 1, DSA_FULLNESS_CLASSES - 1);\n\t}\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)",
            "#define DSA_FULLNESS_CLASSES\t\t4",
            "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic inline dsa_pointer\nalloc_object(dsa_area *area, int size_class)\n{\n\tdsa_area_pool *pool = &area->control->pools[size_class];\n\tdsa_area_span *span;\n\tdsa_pointer block;\n\tdsa_pointer result;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\n\t/*\n\t * Even though ensure_active_superblock can in turn call alloc_object if\n\t * it needs to allocate a new span, that's always from a different pool,\n\t * and the order of lock acquisition is always the same, so it's OK that\n\t * we hold this lock for the duration of this function.\n\t */\n\tAssert(!LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/*\n\t * If there's no active superblock, we must successfully obtain one or\n\t * fail the request.\n\t */\n\tif (!DsaPointerIsValid(pool->spans[1]) &&\n\t\t!ensure_active_superblock(area, pool, size_class))\n\t{\n\t\tresult = InvalidDsaPointer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * There should be a block in fullness class 1 at this point, and it\n\t\t * should never be completely full.  Thus we can either pop an object\n\t\t * from the free list or, failing that, initialize a new object.\n\t\t */\n\t\tAssert(DsaPointerIsValid(pool->spans[1]));\n\t\tspan = (dsa_area_span *)\n\t\t\tdsa_get_address(area, pool->spans[1]);\n\t\tAssert(span->nallocatable > 0);\n\t\tblock = span->start;\n\t\tAssert(size_class < DSA_NUM_SIZE_CLASSES);\n\t\tsize = dsa_size_classes[size_class];\n\t\tif (span->firstfree != DSA_SPAN_NOTHING_FREE)\n\t\t{\n\t\t\tresult = block + span->firstfree * size;\n\t\t\tobject = dsa_get_address(area, result);\n\t\t\tspan->firstfree = NextFreeObjectIndex(object);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = block + span->ninitialized * size;\n\t\t\t++span->ninitialized;\n\t\t}\n\t\t--span->nallocatable;\n\n\t\t/* If it's now full, move it to the highest-numbered fullness class. */\n\t\tif (span->nallocatable == 0)\n\t\t\ttransfer_first_span(area, pool, 1, DSA_FULLNESS_CLASSES - 1);\n\t}\n\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "size_class == 0 || size > dsa_size_classes[size_class - 1]"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "size <= dsa_size_classes[size_class]"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "dsa_size_classes"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "dsa_size_class_map"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "dsa_size_class_map"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dsa_get_address(area, start_pointer)",
            "0",
            "size"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "DSA_SCLASS_SPAN_LARGE"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_span",
          "args": [
            "area",
            "span_pointer",
            "pool",
            "start_pointer",
            "npages",
            "DSA_SCLASS_SPAN_LARGE"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "init_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1344-1393",
          "snippet": "static void\ninit_span(dsa_area *area,\n\t\t  dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\n\t/*\n\t * The per-pool lock must be held because we manipulate the span list for\n\t * this pool.\n\t */\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/* Push this span onto the front of the span list for fullness class 1. */\n\tif (DsaPointerIsValid(pool->spans[1]))\n\t{\n\t\tdsa_area_span *head = (dsa_area_span *)\n\t\tdsa_get_address(area, pool->spans[1]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->pool = DsaAreaPoolToDsaPointer(area, pool);\n\tspan->nextspan = pool->spans[1];\n\tspan->prevspan = InvalidDsaPointer;\n\tpool->spans[1] = span_pointer;\n\n\tspan->start = start;\n\tspan->npages = npages;\n\tspan->size_class = size_class;\n\tspan->ninitialized = 0;\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * A block-of-spans contains its own descriptor, so mark one object as\n\t\t * initialized and reduce the count of allocatable objects by one.\n\t\t * Doing this here has the side effect of also reducing nmax by one,\n\t\t * which is important to make sure we free this object at the correct\n\t\t * time.\n\t\t */\n\t\tspan->ninitialized = 1;\n\t\tspan->nallocatable = FPM_PAGE_SIZE / obsize - 1;\n\t}\n\telse if (size_class != DSA_SCLASS_SPAN_LARGE)\n\t\tspan->nallocatable = DSA_SUPERBLOCK_SIZE / obsize;\n\tspan->firstfree = DSA_SPAN_NOTHING_FREE;\n\tspan->nmax = span->nallocatable;\n\tspan->fclass = 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
            "#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)",
            "#define DSA_SCLASS_SPAN_LARGE\t\t\t1",
            "#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_SPAN_NOTHING_FREE\t((uint16) -1)\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic void\ninit_span(dsa_area *area,\n\t\t  dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class)\n{\n\tdsa_area_span *span = dsa_get_address(area, span_pointer);\n\tsize_t\t\tobsize = dsa_size_classes[size_class];\n\n\t/*\n\t * The per-pool lock must be held because we manipulate the span list for\n\t * this pool.\n\t */\n\tAssert(LWLockHeldByMe(DSA_SCLASS_LOCK(area, size_class)));\n\n\t/* Push this span onto the front of the span list for fullness class 1. */\n\tif (DsaPointerIsValid(pool->spans[1]))\n\t{\n\t\tdsa_area_span *head = (dsa_area_span *)\n\t\tdsa_get_address(area, pool->spans[1]);\n\n\t\thead->prevspan = span_pointer;\n\t}\n\tspan->pool = DsaAreaPoolToDsaPointer(area, pool);\n\tspan->nextspan = pool->spans[1];\n\tspan->prevspan = InvalidDsaPointer;\n\tpool->spans[1] = span_pointer;\n\n\tspan->start = start;\n\tspan->npages = npages;\n\tspan->size_class = size_class;\n\tspan->ninitialized = 0;\n\tif (size_class == DSA_SCLASS_BLOCK_OF_SPANS)\n\t{\n\t\t/*\n\t\t * A block-of-spans contains its own descriptor, so mark one object as\n\t\t * initialized and reduce the count of allocatable objects by one.\n\t\t * Doing this here has the side effect of also reducing nmax by one,\n\t\t * which is important to make sure we free this object at the correct\n\t\t * time.\n\t\t */\n\t\tspan->ninitialized = 1;\n\t\tspan->nallocatable = FPM_PAGE_SIZE / obsize - 1;\n\t}\n\telse if (size_class != DSA_SCLASS_SPAN_LARGE)\n\t\tspan->nallocatable = DSA_SUPERBLOCK_SIZE / obsize;\n\tspan->firstfree = DSA_SPAN_NOTHING_FREE;\n\tspan->nmax = span->nallocatable;\n\tspan->fclass = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE)",
            "LW_EXCLUSIVE"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_SCLASS_LOCK",
          "args": [
            "area",
            "DSA_SCLASS_SPAN_LARGE"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_MAKE_POINTER",
          "args": [
            "get_segment_index(area, segment_map)",
            "first_page * FPM_PAGE_SIZE"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_segment_index",
          "args": [
            "area",
            "segment_map"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"dsa_allocate could not find %zu free pages\"",
            "npages"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerGet",
          "args": [
            "segment_map->fpm",
            "npages",
            "&first_page"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerGetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1318-1464",
          "snippet": "static bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\",\n\t\t\t\t\t\t\t\t   size))"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_free",
          "args": [
            "area",
            "span_pointer"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "819-923",
          "snippet": "void\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)",
            "#define DSA_FULLNESS_CLASSES\t\t4",
            "#define DSA_SCLASS_SPAN_LARGE\t\t\t1"
          ],
          "globals_used": [
            "static const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};",
            "static void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);",
            "static inline dsa_pointer alloc_object(dsa_area *area, int size_class);",
            "static bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);",
            "static void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);",
            "static void unlink_span(dsa_area *area, dsa_area_span *span);",
            "static void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SUPERBLOCK_SIZE (DSA_PAGES_PER_SUPERBLOCK * FPM_PAGE_SIZE)\n#define DSA_FULLNESS_CLASSES\t\t4\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void add_span_to_fullness_class(dsa_area *area, dsa_area_span *span,\n\t\t\t\t\t\t   dsa_pointer span_pointer, int fclass);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_free(dsa_area *area, dsa_pointer dp)\n{\n\tdsa_segment_map *segment_map;\n\tint\t\t\tpageno;\n\tdsa_pointer span_pointer;\n\tdsa_area_span *span;\n\tchar\t   *superblock;\n\tchar\t   *object;\n\tsize_t\t\tsize;\n\tint\t\t\tsize_class;\n\n\t/* Make sure we don't have a stale segment in the slot 'dp' refers to. */\n\tcheck_for_freed_segments(area);\n\n\t/* Locate the object, span and pool. */\n\tsegment_map = get_segment_by_index(area, DSA_EXTRACT_SEGMENT_NUMBER(dp));\n\tpageno = DSA_EXTRACT_OFFSET(dp) / FPM_PAGE_SIZE;\n\tspan_pointer = segment_map->pagemap[pageno];\n\tspan = dsa_get_address(area, span_pointer);\n\tsuperblock = dsa_get_address(area, span->start);\n\tobject = dsa_get_address(area, dp);\n\tsize_class = span->size_class;\n\tsize = dsa_size_classes[size_class];\n\n\t/*\n\t * Special case for large objects that live in a special span: we return\n\t * those pages directly to the free page manager and free the span.\n\t */\n\tif (span->size_class == DSA_SCLASS_SPAN_LARGE)\n\t{\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\tmemset(object, 0x7f, span->npages * FPM_PAGE_SIZE);\n#endif\n\n\t\t/* Give pages back to free page manager. */\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\t\tFreePageManagerPut(segment_map->fpm,\n\t\t\t\t\t\t   DSA_EXTRACT_OFFSET(span->start) / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   span->npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t/* Unlink span. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tunlink_span(area, span);\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\t\t/* Free the span object so it can be reused. */\n\t\tdsa_free(area, span_pointer);\n\t\treturn;\n\t}\n\n#ifdef CLOBBER_FREED_MEMORY\n\tmemset(object, 0x7f, size);\n#endif\n\n\tLWLockAcquire(DSA_SCLASS_LOCK(area, size_class), LW_EXCLUSIVE);\n\n\t/* Put the object on the span's freelist. */\n\tAssert(object >= superblock);\n\tAssert(object < superblock + DSA_SUPERBLOCK_SIZE);\n\tAssert((object - superblock) % size == 0);\n\tNextFreeObjectIndex(object) = span->firstfree;\n\tspan->firstfree = (object - superblock) / size;\n\t++span->nallocatable;\n\n\t/*\n\t * See if the span needs to moved to a different fullness class, or be\n\t * freed so its pages can be given back to the segment.\n\t */\n\tif (span->nallocatable == 1 && span->fclass == DSA_FULLNESS_CLASSES - 1)\n\t{\n\t\t/*\n\t\t * The block was completely full and is located in the\n\t\t * highest-numbered fullness class, which is never scanned for free\n\t\t * chunks.  We must move it to the next-lower fullness class.\n\t\t */\n\t\tunlink_span(area, span);\n\t\tadd_span_to_fullness_class(area, span, span_pointer,\n\t\t\t\t\t\t\t\t   DSA_FULLNESS_CLASSES - 2);\n\n\t\t/*\n\t\t * If this is the only span, and there is no active span, then we\n\t\t * should probably move this span to fullness class 1.  (Otherwise if\n\t\t * you allocate exactly all the objects in the only span, it moves to\n\t\t * class 3, then you free them all, it moves to 2, and then is given\n\t\t * back, leaving no active span).\n\t\t */\n\t}\n\telse if (span->nallocatable == span->nmax &&\n\t\t\t (span->fclass != 1 || span->prevspan != InvalidDsaPointer))\n\t{\n\t\t/*\n\t\t * This entire block is free, and it's not the active block for this\n\t\t * size class.  Return the memory to the free page manager. We don't\n\t\t * do this for the active block to prevent hysteresis: if we\n\t\t * repeatedly allocate and free the only chunk in the active block, it\n\t\t * will be very inefficient if we deallocate and reallocate the block\n\t\t * every time.\n\t\t */\n\t\tdestroy_superblock(area, span_pointer);\n\t}\n\n\tLWLockRelease(DSA_SCLASS_LOCK(area, size_class));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "DSA_AREA_LOCK(area)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_new_segment",
          "args": [
            "area",
            "npages"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "make_new_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "2061-2215",
          "snippet": "static dsa_segment_map *\nmake_new_segment(dsa_area *area, size_t requested_pages)\n{\n\tdsa_segment_index new_index;\n\tsize_t\t\tmetadata_bytes;\n\tsize_t\t\ttotal_size;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tusable_pages;\n\tdsa_segment_map *segment_map;\n\tdsm_segment *segment;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\n\t/* Find a segment slot that is not in use (linearly for now). */\n\tfor (new_index = 1; new_index < DSA_MAX_SEGMENTS; ++new_index)\n\t{\n\t\tif (area->control->segment_handles[new_index] == DSM_HANDLE_INVALID)\n\t\t\tbreak;\n\t}\n\tif (new_index == DSA_MAX_SEGMENTS)\n\t\treturn NULL;\n\n\t/*\n\t * If the total size limit is already exceeded, then we exit early and\n\t * avoid arithmetic wraparound in the unsigned expressions below.\n\t */\n\tif (area->control->total_segment_size >=\n\t\tarea->control->max_total_segment_size)\n\t\treturn NULL;\n\n\t/*\n\t * The size should be at least as big as requested, and at least big\n\t * enough to follow a geometric series that approximately doubles the\n\t * total storage each time we create a new segment.  We use geometric\n\t * growth because the underlying DSM system isn't designed for large\n\t * numbers of segments (otherwise we might even consider just using one\n\t * DSM segment for each large allocation and for each superblock, and then\n\t * we wouldn't need to use FreePageManager).\n\t *\n\t * We decide on a total segment size first, so that we produce tidy\n\t * power-of-two sized segments.  This is a good property to have if we\n\t * move to huge pages in the future.  Then we work back to the number of\n\t * pages we can fit.\n\t */\n\ttotal_size = DSA_INITIAL_SEGMENT_SIZE *\n\t\t((size_t) 1 << (new_index / DSA_NUM_SEGMENTS_AT_EACH_SIZE));\n\ttotal_size = Min(total_size, DSA_MAX_SEGMENT_SIZE);\n\ttotal_size = Min(total_size,\n\t\t\t\t\t area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size);\n\n\ttotal_pages = total_size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\tsizeof(dsa_pointer) * total_pages;\n\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tif (total_size <= metadata_bytes)\n\t\treturn NULL;\n\tusable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;\n\tAssert(metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size);\n\n\t/* See if that is enough... */\n\tif (requested_pages > usable_pages)\n\t{\n\t\t/*\n\t\t * We'll make an odd-sized segment, working forward from the requested\n\t\t * number of pages.\n\t\t */\n\t\tusable_pages = requested_pages;\n\t\tmetadata_bytes =\n\t\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\t\tusable_pages * sizeof(dsa_pointer);\n\n\t\t/* Add padding up to next page boundary. */\n\t\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\t\ttotal_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;\n\n\t\t/* Is that too large for dsa_pointer's addressing scheme? */\n\t\tif (total_size > DSA_MAX_SEGMENT_SIZE)\n\t\t\treturn NULL;\n\n\t\t/* Would that exceed the limit? */\n\t\tif (total_size > area->control->max_total_segment_size -\n\t\t\tarea->control->total_segment_size)\n\t\t\treturn NULL;\n\t}\n\n\t/* Create the segment. */\n\tsegment = dsm_create(total_size, 0);\n\tif (segment == NULL)\n\t\treturn NULL;\n\tdsm_pin_segment(segment);\n\tif (area->mapping_pinned)\n\t\tdsm_pin_mapping(segment);\n\n\t/* Store the handle in shared memory to be found by index. */\n\tarea->control->segment_handles[new_index] =\n\t\tdsm_segment_handle(segment);\n\t/* Track the highest segment index in the history of the area. */\n\tif (area->control->high_segment_index < new_index)\n\t\tarea->control->high_segment_index = new_index;\n\t/* Track the highest segment index this backend has ever mapped. */\n\tif (area->high_segment_index < new_index)\n\t\tarea->high_segment_index = new_index;\n\t/* Track total size of all segments. */\n\tarea->control->total_segment_size += total_size;\n\tAssert(area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size);\n\n\t/* Build a segment map for this segment in this backend. */\n\tsegment_map = &area->segment_maps[new_index];\n\tsegment_map->segment = segment;\n\tsegment_map->mapped_address = dsm_segment_address(segment);\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t   usable_pages);\n\n\t/* Set up the segment header and put it in the appropriate bin. */\n\tsegment_map->header->magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ new_index;\n\tsegment_map->header->usable_pages = usable_pages;\n\tsegment_map->header->size = total_size;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\tsegment_map->header->next =\n\t\tarea->control->segment_bins[segment_map->header->bin];\n\tsegment_map->header->freed = false;\n\tarea->control->segment_bins[segment_map->header->bin] = new_index;\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next =\n\t\tget_segment_by_index(area, segment_map->header->next);\n\n\t\tAssert(next->header->bin == segment_map->header->bin);\n\t\tnext->header->prev = new_index;\n\t}\n\n\treturn segment_map;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)",
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
            "#define DSA_MAX_SEGMENT_SIZE ((size_t) 1 << DSA_OFFSET_WIDTH)",
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))",
            "#define DSA_NUM_SEGMENTS_AT_EACH_SIZE 4",
            "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
          ],
          "globals_used": [
            "static dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);",
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *make_new_segment(dsa_area *area, size_t requested_pages);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENT_SIZE ((size_t) 1 << DSA_OFFSET_WIDTH)\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n#define DSA_NUM_SEGMENTS_AT_EACH_SIZE 4\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic dsa_segment_map *get_segment_by_index(dsa_area *area,\n\t\t\t\t\t dsa_segment_index index);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *make_new_segment(dsa_area *area, size_t requested_pages);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nmake_new_segment(dsa_area *area, size_t requested_pages)\n{\n\tdsa_segment_index new_index;\n\tsize_t\t\tmetadata_bytes;\n\tsize_t\t\ttotal_size;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tusable_pages;\n\tdsa_segment_map *segment_map;\n\tdsm_segment *segment;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\n\t/* Find a segment slot that is not in use (linearly for now). */\n\tfor (new_index = 1; new_index < DSA_MAX_SEGMENTS; ++new_index)\n\t{\n\t\tif (area->control->segment_handles[new_index] == DSM_HANDLE_INVALID)\n\t\t\tbreak;\n\t}\n\tif (new_index == DSA_MAX_SEGMENTS)\n\t\treturn NULL;\n\n\t/*\n\t * If the total size limit is already exceeded, then we exit early and\n\t * avoid arithmetic wraparound in the unsigned expressions below.\n\t */\n\tif (area->control->total_segment_size >=\n\t\tarea->control->max_total_segment_size)\n\t\treturn NULL;\n\n\t/*\n\t * The size should be at least as big as requested, and at least big\n\t * enough to follow a geometric series that approximately doubles the\n\t * total storage each time we create a new segment.  We use geometric\n\t * growth because the underlying DSM system isn't designed for large\n\t * numbers of segments (otherwise we might even consider just using one\n\t * DSM segment for each large allocation and for each superblock, and then\n\t * we wouldn't need to use FreePageManager).\n\t *\n\t * We decide on a total segment size first, so that we produce tidy\n\t * power-of-two sized segments.  This is a good property to have if we\n\t * move to huge pages in the future.  Then we work back to the number of\n\t * pages we can fit.\n\t */\n\ttotal_size = DSA_INITIAL_SEGMENT_SIZE *\n\t\t((size_t) 1 << (new_index / DSA_NUM_SEGMENTS_AT_EACH_SIZE));\n\ttotal_size = Min(total_size, DSA_MAX_SEGMENT_SIZE);\n\ttotal_size = Min(total_size,\n\t\t\t\t\t area->control->max_total_segment_size -\n\t\t\t\t\t area->control->total_segment_size);\n\n\ttotal_pages = total_size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\tsizeof(dsa_pointer) * total_pages;\n\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tif (total_size <= metadata_bytes)\n\t\treturn NULL;\n\tusable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;\n\tAssert(metadata_bytes + usable_pages * FPM_PAGE_SIZE <= total_size);\n\n\t/* See if that is enough... */\n\tif (requested_pages > usable_pages)\n\t{\n\t\t/*\n\t\t * We'll make an odd-sized segment, working forward from the requested\n\t\t * number of pages.\n\t\t */\n\t\tusable_pages = requested_pages;\n\t\tmetadata_bytes =\n\t\t\tMAXALIGN(sizeof(dsa_segment_header)) +\n\t\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\t\tusable_pages * sizeof(dsa_pointer);\n\n\t\t/* Add padding up to next page boundary. */\n\t\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\t\ttotal_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;\n\n\t\t/* Is that too large for dsa_pointer's addressing scheme? */\n\t\tif (total_size > DSA_MAX_SEGMENT_SIZE)\n\t\t\treturn NULL;\n\n\t\t/* Would that exceed the limit? */\n\t\tif (total_size > area->control->max_total_segment_size -\n\t\t\tarea->control->total_segment_size)\n\t\t\treturn NULL;\n\t}\n\n\t/* Create the segment. */\n\tsegment = dsm_create(total_size, 0);\n\tif (segment == NULL)\n\t\treturn NULL;\n\tdsm_pin_segment(segment);\n\tif (area->mapping_pinned)\n\t\tdsm_pin_mapping(segment);\n\n\t/* Store the handle in shared memory to be found by index. */\n\tarea->control->segment_handles[new_index] =\n\t\tdsm_segment_handle(segment);\n\t/* Track the highest segment index in the history of the area. */\n\tif (area->control->high_segment_index < new_index)\n\t\tarea->control->high_segment_index = new_index;\n\t/* Track the highest segment index this backend has ever mapped. */\n\tif (area->high_segment_index < new_index)\n\t\tarea->high_segment_index = new_index;\n\t/* Track total size of all segments. */\n\tarea->control->total_segment_size += total_size;\n\tAssert(area->control->total_segment_size <=\n\t\t   area->control->max_total_segment_size);\n\n\t/* Build a segment map for this segment in this backend. */\n\tsegment_map = &area->segment_maps[new_index];\n\tsegment_map->segment = segment;\n\tsegment_map->mapped_address = dsm_segment_address(segment);\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_segment_header)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t   usable_pages);\n\n\t/* Set up the segment header and put it in the appropriate bin. */\n\tsegment_map->header->magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ area->control->handle ^ new_index;\n\tsegment_map->header->usable_pages = usable_pages;\n\tsegment_map->header->size = total_size;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\tsegment_map->header->next =\n\t\tarea->control->segment_bins[segment_map->header->bin];\n\tsegment_map->header->freed = false;\n\tarea->control->segment_bins[segment_map->header->bin] = new_index;\n\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t{\n\t\tdsa_segment_map *next =\n\t\tget_segment_by_index(area, segment_map->header->next);\n\n\t\tAssert(next->header->bin == segment_map->header->bin);\n\t\tnext->header->prev = new_index;\n\t}\n\n\treturn segment_map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_best_segment",
          "args": [
            "area",
            "npages"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "get_best_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1969-2054",
          "snippet": "static dsa_segment_map *\nget_best_segment(dsa_area *area, size_t npages)\n{\n\tsize_t\t\tbin;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tcheck_for_freed_segments_locked(area);\n\n\t/*\n\t * Start searching from the first bin that *might* have enough contiguous\n\t * pages.\n\t */\n\tfor (bin = contiguous_pages_to_segment_bin(npages);\n\t\t bin < DSA_NUM_SEGMENT_BINS;\n\t\t ++bin)\n\t{\n\t\t/*\n\t\t * The minimum contiguous size that any segment in this bin should\n\t\t * have.  We'll re-bin if we see segments with fewer.\n\t\t */\n\t\tsize_t\t\tthreshold = (size_t) 1 << (bin - 1);\n\t\tdsa_segment_index segment_index;\n\n\t\t/* Search this bin for a segment with enough contiguous space. */\n\t\tsegment_index = area->control->segment_bins[bin];\n\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_map *segment_map;\n\t\t\tdsa_segment_index next_segment_index;\n\t\t\tsize_t\t\tcontiguous_pages;\n\n\t\t\tsegment_map = get_segment_by_index(area, segment_index);\n\t\t\tnext_segment_index = segment_map->header->next;\n\t\t\tcontiguous_pages = fpm_largest(segment_map->fpm);\n\n\t\t\t/* Not enough for the request, still enough for this bin. */\n\t\t\tif (contiguous_pages >= threshold && contiguous_pages < npages)\n\t\t\t{\n\t\t\t\tsegment_index = next_segment_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Re-bin it if it's no longer in the appropriate bin. */\n\t\t\tif (contiguous_pages < threshold)\n\t\t\t{\n\t\t\t\tsize_t\t\tnew_bin;\n\n\t\t\t\tnew_bin = contiguous_pages_to_segment_bin(contiguous_pages);\n\n\t\t\t\t/* Remove it from its current bin. */\n\t\t\t\tunlink_segment(area, segment_map);\n\n\t\t\t\t/* Push it onto the front of its new bin. */\n\t\t\t\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\t\t\t\tsegment_map->header->next =\n\t\t\t\t\tarea->control->segment_bins[new_bin];\n\t\t\t\tsegment_map->header->bin = new_bin;\n\t\t\t\tarea->control->segment_bins[new_bin] = segment_index;\n\t\t\t\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tdsa_segment_map *next;\n\n\t\t\t\t\tnext = get_segment_by_index(area,\n\t\t\t\t\t\t\t\t\t\t\t\tsegment_map->header->next);\n\t\t\t\t\tAssert(next->header->bin == new_bin);\n\t\t\t\t\tnext->header->prev = segment_index;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * But fall through to see if it's enough to satisfy this\n\t\t\t\t * request anyway....\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* Check if we are done. */\n\t\t\tif (contiguous_pages >= npages)\n\t\t\t\treturn segment_map;\n\n\t\t\t/* Continue searching the same bin. */\n\t\t\tsegment_index = next_segment_index;\n\t\t}\n\t}\n\n\t/* Not found. */\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_NUM_SEGMENT_BINS 16",
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_segment_map *\nget_best_segment(dsa_area *area, size_t npages)\n{\n\tsize_t\t\tbin;\n\n\tAssert(LWLockHeldByMe(DSA_AREA_LOCK(area)));\n\tcheck_for_freed_segments_locked(area);\n\n\t/*\n\t * Start searching from the first bin that *might* have enough contiguous\n\t * pages.\n\t */\n\tfor (bin = contiguous_pages_to_segment_bin(npages);\n\t\t bin < DSA_NUM_SEGMENT_BINS;\n\t\t ++bin)\n\t{\n\t\t/*\n\t\t * The minimum contiguous size that any segment in this bin should\n\t\t * have.  We'll re-bin if we see segments with fewer.\n\t\t */\n\t\tsize_t\t\tthreshold = (size_t) 1 << (bin - 1);\n\t\tdsa_segment_index segment_index;\n\n\t\t/* Search this bin for a segment with enough contiguous space. */\n\t\tsegment_index = area->control->segment_bins[bin];\n\t\twhile (segment_index != DSA_SEGMENT_INDEX_NONE)\n\t\t{\n\t\t\tdsa_segment_map *segment_map;\n\t\t\tdsa_segment_index next_segment_index;\n\t\t\tsize_t\t\tcontiguous_pages;\n\n\t\t\tsegment_map = get_segment_by_index(area, segment_index);\n\t\t\tnext_segment_index = segment_map->header->next;\n\t\t\tcontiguous_pages = fpm_largest(segment_map->fpm);\n\n\t\t\t/* Not enough for the request, still enough for this bin. */\n\t\t\tif (contiguous_pages >= threshold && contiguous_pages < npages)\n\t\t\t{\n\t\t\t\tsegment_index = next_segment_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Re-bin it if it's no longer in the appropriate bin. */\n\t\t\tif (contiguous_pages < threshold)\n\t\t\t{\n\t\t\t\tsize_t\t\tnew_bin;\n\n\t\t\t\tnew_bin = contiguous_pages_to_segment_bin(contiguous_pages);\n\n\t\t\t\t/* Remove it from its current bin. */\n\t\t\t\tunlink_segment(area, segment_map);\n\n\t\t\t\t/* Push it onto the front of its new bin. */\n\t\t\t\tsegment_map->header->prev = DSA_SEGMENT_INDEX_NONE;\n\t\t\t\tsegment_map->header->next =\n\t\t\t\t\tarea->control->segment_bins[new_bin];\n\t\t\t\tsegment_map->header->bin = new_bin;\n\t\t\t\tarea->control->segment_bins[new_bin] = segment_index;\n\t\t\t\tif (segment_map->header->next != DSA_SEGMENT_INDEX_NONE)\n\t\t\t\t{\n\t\t\t\t\tdsa_segment_map *next;\n\n\t\t\t\t\tnext = get_segment_by_index(area,\n\t\t\t\t\t\t\t\t\t\t\t\tsegment_map->header->next);\n\t\t\t\t\tAssert(next->header->bin == new_bin);\n\t\t\t\t\tnext->header->prev = segment_index;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * But fall through to see if it's enough to satisfy this\n\t\t\t\t * request anyway....\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* Check if we are done. */\n\t\t\tif (contiguous_pages >= npages)\n\t\t\t\treturn segment_map;\n\n\t\t\t/* Continue searching the same bin. */\n\t\t\tsegment_index = next_segment_index;\n\t\t}\n\t}\n\n\t/* Not found. */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "DSA_AREA_LOCK(area)",
            "LW_EXCLUSIVE"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA_AREA_LOCK",
          "args": [
            "area"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\",\n\t\t\t\t\t\t\t\t   size))"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DsaPointerIsValid",
          "args": [
            "span_pointer"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_size_to_pages",
          "args": [
            "size"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "dsa_size_classes"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "size"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocHugeSizeIsValid",
          "args": [
            "size"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "size > 0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SIZE_CLASS_MAP_QUANTUM\t8\n#define DSA_SCLASS_SPAN_LARGE\t\t\t1\n#define DSA_SCLASS_BLOCK_OF_SPANS\t\t0\n\nstatic const uint16 dsa_size_classes[] = {\n\tsizeof(dsa_area_span), 0,\t/* special size classes */\n\t8, 16, 24, 32, 40, 48, 56, 64,\t/* 8 classes separated by 8 bytes */\n\t80, 96, 112, 128,\t\t\t/* 4 classes separated by 16 bytes */\n\t160, 192, 224, 256,\t\t\t/* 4 classes separated by 32 bytes */\n\t320, 384, 448, 512,\t\t\t/* 4 classes separated by 64 bytes */\n\t640, 768, 896, 1024,\t\t/* 4 classes separated by 128 bytes */\n\t1280, 1560, 1816, 2048,\t\t/* 4 classes separated by ~256 bytes */\n\t2616, 3120, 3640, 4096,\t\t/* 4 classes separated by ~512 bytes */\n\t5456, 6552, 7280, 8192\t\t/* 4 classes separated by ~1024 bytes */\n};\nstatic char dsa_size_class_map[] = {\n\t2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n\t14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17,\n\t18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19,\n\t20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21,\n\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25\n};\nstatic void init_span(dsa_area *area, dsa_pointer span_pointer,\n\t\t  dsa_area_pool *pool, dsa_pointer start, size_t npages,\n\t\t  uint16 size_class);\nstatic inline dsa_pointer alloc_object(dsa_area *area, int size_class);\nstatic bool ensure_active_superblock(dsa_area *area, dsa_area_pool *pool,\n\t\t\t\t\t\t int size_class);\nstatic void destroy_superblock(dsa_area *area, dsa_pointer span_pointer);\nstatic void unlink_span(dsa_area *area, dsa_area_span *span);\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_segment_map *get_best_segment(dsa_area *area, size_t npages);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\ndsa_pointer\ndsa_allocate_extended(dsa_area *area, size_t size, int flags)\n{\n\tuint16\t\tsize_class;\n\tdsa_pointer start_pointer;\n\tdsa_segment_map *segment_map;\n\tdsa_pointer result;\n\n\tAssert(size > 0);\n\n\t/* Sanity check on huge individual allocation size. */\n\tif (((flags & DSA_ALLOC_HUGE) != 0 && !AllocHugeSizeIsValid(size)) ||\n\t\t((flags & DSA_ALLOC_HUGE) == 0 && !AllocSizeIsValid(size)))\n\t\telog(ERROR, \"invalid DSA memory alloc request size %zu\", size);\n\n\t/*\n\t * If bigger than the largest size class, just grab a run of pages from\n\t * the free page manager, instead of allocating an object from a pool.\n\t * There will still be a span, but it's a special class of span that\n\t * manages this whole allocation and simply gives all pages back to the\n\t * free page manager when dsa_free is called.\n\t */\n\tif (size > dsa_size_classes[lengthof(dsa_size_classes) - 1])\n\t{\n\t\tsize_t\t\tnpages = fpm_size_to_pages(size);\n\t\tsize_t\t\tfirst_page;\n\t\tdsa_pointer span_pointer;\n\t\tdsa_area_pool *pool = &area->control->pools[DSA_SCLASS_SPAN_LARGE];\n\n\t\t/* Obtain a span object. */\n\t\tspan_pointer = alloc_object(area, DSA_SCLASS_BLOCK_OF_SPANS);\n\t\tif (!DsaPointerIsValid(span_pointer))\n\t\t{\n\t\t\t/* Raise error unless asked not to. */\n\t\t\tif ((flags & DSA_ALLOC_NO_OOM) == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\",\n\t\t\t\t\t\t\t\t   size)));\n\t\t\treturn InvalidDsaPointer;\n\t\t}\n\n\t\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\n\t\t/* Find a segment from which to allocate. */\n\t\tsegment_map = get_best_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t\tsegment_map = make_new_segment(area, npages);\n\t\tif (segment_map == NULL)\n\t\t{\n\t\t\t/* Can't make any more segments: game over. */\n\t\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\t\t\tdsa_free(area, span_pointer);\n\n\t\t\t/* Raise error unless asked not to. */\n\t\t\tif ((flags & DSA_ALLOC_NO_OOM) == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\",\n\t\t\t\t\t\t\t\t   size)));\n\t\t\treturn InvalidDsaPointer;\n\t\t}\n\n\t\t/*\n\t\t * Ask the free page manager for a run of pages.  This should always\n\t\t * succeed, since both get_best_segment and make_new_segment should\n\t\t * only return a non-NULL pointer if it actually contains enough\n\t\t * contiguous freespace.  If it does fail, something in our backend\n\t\t * private state is out of whack, so use FATAL to kill the process.\n\t\t */\n\t\tif (!FreePageManagerGet(segment_map->fpm, npages, &first_page))\n\t\t\telog(FATAL,\n\t\t\t\t \"dsa_allocate could not find %zu free pages\", npages);\n\t\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\t\tstart_pointer = DSA_MAKE_POINTER(get_segment_index(area, segment_map),\n\t\t\t\t\t\t\t\t\t\t first_page * FPM_PAGE_SIZE);\n\n\t\t/* Initialize span and pagemap. */\n\t\tLWLockAcquire(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE),\n\t\t\t\t\t  LW_EXCLUSIVE);\n\t\tinit_span(area, span_pointer, pool, start_pointer, npages,\n\t\t\t\t  DSA_SCLASS_SPAN_LARGE);\n\t\tsegment_map->pagemap[first_page] = span_pointer;\n\t\tLWLockRelease(DSA_SCLASS_LOCK(area, DSA_SCLASS_SPAN_LARGE));\n\n\t\t/* Zero-initialize the memory if requested. */\n\t\tif ((flags & DSA_ALLOC_ZERO) != 0)\n\t\t\tmemset(dsa_get_address(area, start_pointer), 0, size);\n\n\t\treturn start_pointer;\n\t}\n\n\t/* Map allocation to a size class. */\n\tif (size < lengthof(dsa_size_class_map) * DSA_SIZE_CLASS_MAP_QUANTUM)\n\t{\n\t\tint\t\t\tmapidx;\n\n\t\t/* For smaller sizes we have a lookup table... */\n\t\tmapidx = ((size + DSA_SIZE_CLASS_MAP_QUANTUM - 1) /\n\t\t\t\t  DSA_SIZE_CLASS_MAP_QUANTUM) - 1;\n\t\tsize_class = dsa_size_class_map[mapidx];\n\t}\n\telse\n\t{\n\t\tuint16\t\tmin;\n\t\tuint16\t\tmax;\n\n\t\t/* ... and for the rest we search by binary chop. */\n\t\tmin = dsa_size_class_map[lengthof(dsa_size_class_map) - 1];\n\t\tmax = lengthof(dsa_size_classes) - 1;\n\n\t\twhile (min < max)\n\t\t{\n\t\t\tuint16\t\tmid = (min + max) / 2;\n\t\t\tuint16\t\tclass_size = dsa_size_classes[mid];\n\n\t\t\tif (class_size < size)\n\t\t\t\tmin = mid + 1;\n\t\t\telse\n\t\t\t\tmax = mid;\n\t\t}\n\n\t\tsize_class = min;\n\t}\n\tAssert(size <= dsa_size_classes[size_class]);\n\tAssert(size_class == 0 || size > dsa_size_classes[size_class - 1]);\n\n\t/* Attempt to allocate an object from the appropriate pool. */\n\tresult = alloc_object(area, size_class);\n\n\t/* Check for failure to allocate. */\n\tif (!DsaPointerIsValid(result))\n\t{\n\t\t/* Raise error unless asked not to. */\n\t\tif ((flags & DSA_ALLOC_NO_OOM) == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t\t errdetail(\"Failed on DSA request of size %zu.\", size)));\n\t\treturn InvalidDsaPointer;\n\t}\n\n\t/* Zero-initialize the memory if requested. */\n\tif ((flags & DSA_ALLOC_ZERO) != 0)\n\t\tmemset(dsa_get_address(area, result), 0, size);\n\n\treturn result;\n}"
  },
  {
    "function_name": "dsa_pin_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "630-641",
    "snippet": "void\ndsa_pin_mapping(dsa_area *area)\n{\n\tint\t\t\ti;\n\n\tAssert(!area->mapping_pinned);\n\tarea->mapping_pinned = true;\n\n\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\tif (area->segment_maps[i].segment != NULL)\n\t\t\tdsm_pin_mapping(area->segment_maps[i].segment);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsm_pin_mapping",
          "args": [
            "area->segment_maps[i].segment"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!area->mapping_pinned"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nvoid\ndsa_pin_mapping(dsa_area *area)\n{\n\tint\t\t\ti;\n\n\tAssert(!area->mapping_pinned);\n\tarea->mapping_pinned = true;\n\n\tfor (i = 0; i <= area->high_segment_index; ++i)\n\t\tif (area->segment_maps[i].segment != NULL)\n\t\t\tdsm_pin_mapping(area->segment_maps[i].segment);\n}"
  },
  {
    "function_name": "dsa_release_in_place",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "600-622",
    "snippet": "void\ndsa_release_in_place(void *place)\n{\n\tdsa_area_control *control = (dsa_area_control *) place;\n\tint\t\t\ti;\n\n\tLWLockAcquire(&control->lock, LW_EXCLUSIVE);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0));\n\tAssert(control->refcnt > 0);\n\tif (--control->refcnt == 0)\n\t{\n\t\tfor (i = 0; i <= control->high_segment_index; ++i)\n\t\t{\n\t\t\tdsm_handle\thandle;\n\n\t\t\thandle = control->segment_handles[i];\n\t\t\tif (handle != DSM_HANDLE_INVALID)\n\t\t\t\tdsm_unpin_segment(handle);\n\t\t}\n\t}\n\tLWLockRelease(&control->lock);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
    ],
    "globals_used": [
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "&control->lock"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_unpin_segment",
          "args": [
            "handle"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "control->refcnt > 0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "&control->lock",
            "LW_EXCLUSIVE"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\n\nvoid\ndsa_release_in_place(void *place)\n{\n\tdsa_area_control *control = (dsa_area_control *) place;\n\tint\t\t\ti;\n\n\tLWLockAcquire(&control->lock, LW_EXCLUSIVE);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0));\n\tAssert(control->refcnt > 0);\n\tif (--control->refcnt == 0)\n\t{\n\t\tfor (i = 0; i <= control->high_segment_index; ++i)\n\t\t{\n\t\t\tdsm_handle\thandle;\n\n\t\t\thandle = control->segment_handles[i];\n\t\t\tif (handle != DSM_HANDLE_INVALID)\n\t\t\t\tdsm_unpin_segment(handle);\n\t\t}\n\t}\n\tLWLockRelease(&control->lock);\n}"
  },
  {
    "function_name": "dsa_on_shmem_exit_release_in_place",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "585-589",
    "snippet": "void\ndsa_on_shmem_exit_release_in_place(int code, Datum place)\n{\n\tdsa_release_in_place(DatumGetPointer(place));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsa_release_in_place",
          "args": [
            "DatumGetPointer(place)"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_release_in_place",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "600-622",
          "snippet": "void\ndsa_release_in_place(void *place)\n{\n\tdsa_area_control *control = (dsa_area_control *) place;\n\tint\t\t\ti;\n\n\tLWLockAcquire(&control->lock, LW_EXCLUSIVE);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0));\n\tAssert(control->refcnt > 0);\n\tif (--control->refcnt == 0)\n\t{\n\t\tfor (i = 0; i <= control->high_segment_index; ++i)\n\t\t{\n\t\t\tdsm_handle\thandle;\n\n\t\t\thandle = control->segment_handles[i];\n\t\t\tif (handle != DSM_HANDLE_INVALID)\n\t\t\t\tdsm_unpin_segment(handle);\n\t\t}\n\t}\n\tLWLockRelease(&control->lock);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\n\nvoid\ndsa_release_in_place(void *place)\n{\n\tdsa_area_control *control = (dsa_area_control *) place;\n\tint\t\t\ti;\n\n\tLWLockAcquire(&control->lock, LW_EXCLUSIVE);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0));\n\tAssert(control->refcnt > 0);\n\tif (--control->refcnt == 0)\n\t{\n\t\tfor (i = 0; i <= control->high_segment_index; ++i)\n\t\t{\n\t\t\tdsm_handle\thandle;\n\n\t\t\thandle = control->segment_handles[i];\n\t\t\tif (handle != DSM_HANDLE_INVALID)\n\t\t\t\tdsm_unpin_segment(handle);\n\t\t}\n\t}\n\tLWLockRelease(&control->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "place"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nvoid\ndsa_on_shmem_exit_release_in_place(int code, Datum place)\n{\n\tdsa_release_in_place(DatumGetPointer(place));\n}"
  },
  {
    "function_name": "dsa_on_dsm_detach_release_in_place",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "571-575",
    "snippet": "void\ndsa_on_dsm_detach_release_in_place(dsm_segment *segment, Datum place)\n{\n\tdsa_release_in_place(DatumGetPointer(place));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dsa_release_in_place",
          "args": [
            "DatumGetPointer(place)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_release_in_place",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "600-622",
          "snippet": "void\ndsa_release_in_place(void *place)\n{\n\tdsa_area_control *control = (dsa_area_control *) place;\n\tint\t\t\ti;\n\n\tLWLockAcquire(&control->lock, LW_EXCLUSIVE);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0));\n\tAssert(control->refcnt > 0);\n\tif (--control->refcnt == 0)\n\t{\n\t\tfor (i = 0; i <= control->high_segment_index; ++i)\n\t\t{\n\t\t\tdsm_handle\thandle;\n\n\t\t\thandle = control->segment_handles[i];\n\t\t\tif (handle != DSM_HANDLE_INVALID)\n\t\t\t\tdsm_unpin_segment(handle);\n\t\t}\n\t}\n\tLWLockRelease(&control->lock);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608"
          ],
          "globals_used": [
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\n\nvoid\ndsa_release_in_place(void *place)\n{\n\tdsa_area_control *control = (dsa_area_control *) place;\n\tint\t\t\ti;\n\n\tLWLockAcquire(&control->lock, LW_EXCLUSIVE);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ control->handle ^ 0));\n\tAssert(control->refcnt > 0);\n\tif (--control->refcnt == 0)\n\t{\n\t\tfor (i = 0; i <= control->high_segment_index; ++i)\n\t\t{\n\t\t\tdsm_handle\thandle;\n\n\t\t\thandle = control->segment_handles[i];\n\t\t\tif (handle != DSM_HANDLE_INVALID)\n\t\t\t\tdsm_unpin_segment(handle);\n\t\t}\n\t}\n\tLWLockRelease(&control->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "place"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nvoid\ndsa_on_dsm_detach_release_in_place(dsm_segment *segment, Datum place)\n{\n\tdsa_release_in_place(DatumGetPointer(place));\n}"
  },
  {
    "function_name": "dsa_attach_in_place",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "540-556",
    "snippet": "dsa_area *\ndsa_attach_in_place(void *place, dsm_segment *segment)\n{\n\tdsa_area   *area;\n\n\tarea = attach_internal(place, NULL, DSM_HANDLE_INVALID);\n\n\t/*\n\t * Clean up when the control segment detaches, if a containing DSM segment\n\t * was provided.\n\t */\n\tif (segment != NULL)\n\t\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t\t  PointerGetDatum(place));\n\n\treturn area;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dsm_detach",
          "args": [
            "segment",
            "&dsa_on_dsm_detach_release_in_place",
            "PointerGetDatum(place)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "place"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_internal",
          "args": [
            "place",
            "NULL",
            "DSM_HANDLE_INVALID"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "attach_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1293-1339",
          "snippet": "static dsa_area *\nattach_internal(void *place, dsm_segment *segment, dsa_handle handle)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\n\tcontrol = (dsa_area_control *) place;\n\tAssert(control->handle == handle);\n\tAssert(control->segment_handles[0] == handle);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0));\n\n\t/* Build the backend-local area object. */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(&area->segment_maps[0], 0,\n\t\t   sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = segment; /* NULL for in-place */\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Bump the reference count. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (control->refcnt == 0)\n\t{\n\t\t/* We can't attach to a DSA area that has already been destroyed. */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\t}\n\t++control->refcnt;\n\tarea->freed_segment_counter = area->control->freed_segment_counter;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\treturn area;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_area *\nattach_internal(void *place, dsm_segment *segment, dsa_handle handle)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\n\tcontrol = (dsa_area_control *) place;\n\tAssert(control->handle == handle);\n\tAssert(control->segment_handles[0] == handle);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0));\n\n\t/* Build the backend-local area object. */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(&area->segment_maps[0], 0,\n\t\t   sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = segment; /* NULL for in-place */\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Bump the reference count. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (control->refcnt == 0)\n\t{\n\t\t/* We can't attach to a DSA area that has already been destroyed. */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\t}\n\t++control->refcnt;\n\tarea->freed_segment_counter = area->control->freed_segment_counter;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\ndsa_area *\ndsa_attach_in_place(void *place, dsm_segment *segment)\n{\n\tdsa_area   *area;\n\n\tarea = attach_internal(place, NULL, DSM_HANDLE_INVALID);\n\n\t/*\n\t * Clean up when the control segment detaches, if a containing DSM segment\n\t * was provided.\n\t */\n\tif (segment != NULL)\n\t\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t\t  PointerGetDatum(place));\n\n\treturn area;\n}"
  },
  {
    "function_name": "dsa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "505-528",
    "snippet": "dsa_area *\ndsa_attach(dsa_handle handle)\n{\n\tdsm_segment *segment;\n\tdsa_area   *area;\n\n\t/*\n\t * An area handle is really a DSM segment handle for the first segment, so\n\t * we go ahead and attach to that.\n\t */\n\tsegment = dsm_attach(handle);\n\tif (segment == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\n\tarea = attach_internal(dsm_segment_address(segment), segment, handle);\n\n\t/* Clean up when the control segment detaches. */\n\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t  PointerGetDatum(dsm_segment_address(segment)));\n\n\treturn area;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dsm_detach",
          "args": [
            "segment",
            "&dsa_on_dsm_detach_release_in_place",
            "PointerGetDatum(dsm_segment_address(segment))"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "dsm_segment_address(segment)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_address",
          "args": [
            "segment"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_internal",
          "args": [
            "dsm_segment_address(segment)",
            "segment",
            "handle"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "attach_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1293-1339",
          "snippet": "static dsa_area *\nattach_internal(void *place, dsm_segment *segment, dsa_handle handle)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\n\tcontrol = (dsa_area_control *) place;\n\tAssert(control->handle == handle);\n\tAssert(control->segment_handles[0] == handle);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0));\n\n\t/* Build the backend-local area object. */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(&area->segment_maps[0], 0,\n\t\t   sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = segment; /* NULL for in-place */\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Bump the reference count. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (control->refcnt == 0)\n\t{\n\t\t/* We can't attach to a DSA area that has already been destroyed. */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\t}\n\t++control->refcnt;\n\tarea->freed_segment_counter = area->control->freed_segment_counter;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\treturn area;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_area *\nattach_internal(void *place, dsm_segment *segment, dsa_handle handle)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\n\tcontrol = (dsa_area_control *) place;\n\tAssert(control->handle == handle);\n\tAssert(control->segment_handles[0] == handle);\n\tAssert(control->segment_header.magic ==\n\t\t   (DSA_SEGMENT_HEADER_MAGIC ^ handle ^ 0));\n\n\t/* Build the backend-local area object. */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(&area->segment_maps[0], 0,\n\t\t   sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = segment; /* NULL for in-place */\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) segment_map->mapped_address;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address + MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Bump the reference count. */\n\tLWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIVE);\n\tif (control->refcnt == 0)\n\t{\n\t\t/* We can't attach to a DSA area that has already been destroyed. */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\t}\n\t++control->refcnt;\n\tarea->freed_segment_counter = area->control->freed_segment_counter;\n\tLWLockRelease(DSA_AREA_LOCK(area));\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_segment_address",
          "args": [
            "segment"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\"))"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not attach to dynamic shared area\""
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_attach",
          "args": [
            "handle"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\ndsa_area *\ndsa_attach(dsa_handle handle)\n{\n\tdsm_segment *segment;\n\tdsa_area   *area;\n\n\t/*\n\t * An area handle is really a DSM segment handle for the first segment, so\n\t * we go ahead and attach to that.\n\t */\n\tsegment = dsm_attach(handle);\n\tif (segment == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not attach to dynamic shared area\")));\n\n\tarea = attach_internal(dsm_segment_address(segment), segment, handle);\n\n\t/* Clean up when the control segment detaches. */\n\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t  PointerGetDatum(dsm_segment_address(segment)));\n\n\treturn area;\n}"
  },
  {
    "function_name": "dsa_get_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "493-498",
    "snippet": "dsa_handle\ndsa_get_handle(dsa_area *area)\n{\n\tAssert(area->control->handle != DSM_HANDLE_INVALID);\n\treturn area->control->handle;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "area->control->handle != DSM_HANDLE_INVALID"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\ndsa_handle\ndsa_get_handle(dsa_area *area)\n{\n\tAssert(area->control->handle != DSM_HANDLE_INVALID);\n\treturn area->control->handle;\n}"
  },
  {
    "function_name": "dsa_create_in_place",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "468-486",
    "snippet": "dsa_area *\ndsa_create_in_place(void *place, size_t size,\n\t\t\t\t\tint tranche_id, dsm_segment *segment)\n{\n\tdsa_area   *area;\n\n\tarea = create_internal(place, size, tranche_id,\n\t\t\t\t\t\t   DSM_HANDLE_INVALID, NULL);\n\n\t/*\n\t * Clean up when the control segment detaches, if a containing DSM segment\n\t * was provided.\n\t */\n\tif (segment != NULL)\n\t\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t\t  PointerGetDatum(place));\n\n\treturn area;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dsm_detach",
          "args": [
            "segment",
            "&dsa_on_dsm_detach_release_in_place",
            "PointerGetDatum(place)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "place"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_internal",
          "args": [
            "place",
            "size",
            "tranche_id",
            "DSM_HANDLE_INVALID",
            "NULL"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1190-1288",
          "snippet": "static dsa_area *\ncreate_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\tsize_t\t\tusable_pages;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tmetadata_bytes;\n\tint\t\t\ti;\n\n\t/* Sanity check on the space we have to work in. */\n\tif (size < dsa_minimum_size())\n\t\telog(ERROR, \"dsa_area space must be at least %zu, but %zu provided\",\n\t\t\t dsa_minimum_size(), size);\n\n\t/* Now figure out how much space is usable */\n\ttotal_pages = size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\ttotal_pages * sizeof(dsa_pointer);\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tAssert(metadata_bytes <= size);\n\tusable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;\n\n\t/*\n\t * Initialize the dsa_area_control object located at the start of the\n\t * space.\n\t */\n\tcontrol = (dsa_area_control *) place;\n\tcontrol->segment_header.magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ control_handle ^ 0;\n\tcontrol->segment_header.next = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.prev = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.usable_pages = usable_pages;\n\tcontrol->segment_header.freed = false;\n\tcontrol->segment_header.size = DSA_INITIAL_SEGMENT_SIZE;\n\tcontrol->handle = control_handle;\n\tcontrol->max_total_segment_size = (size_t) -1;\n\tcontrol->total_segment_size = size;\n\tmemset(&control->segment_handles[0], 0,\n\t\t   sizeof(dsm_handle) * DSA_MAX_SEGMENTS);\n\tcontrol->segment_handles[0] = control_handle;\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t\tcontrol->segment_bins[i] = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->high_segment_index = 0;\n\tcontrol->refcnt = 1;\n\tcontrol->freed_segment_counter = 0;\n\tcontrol->lwlock_tranche_id = tranche_id;\n\n\t/*\n\t * Create the dsa_area object that this backend will use to access the\n\t * area.  Other backends will need to obtain their own dsa_area object by\n\t * attaching.\n\t */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(area->segment_maps, 0, sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\tarea->freed_segment_counter = 0;\n\tLWLockInitialize(&control->lock, control->lwlock_tranche_id);\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t\tLWLockInitialize(DSA_SCLASS_LOCK(area, i),\n\t\t\t\t\t\t control->lwlock_tranche_id);\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = control_segment;\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) place;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\t/* There can be 0 usable pages if size is dsa_minimum_size(). */\n\n\tif (usable_pages > 0)\n\t\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   usable_pages);\n\n\t/* Put this segment into the appropriate bin. */\n\tcontrol->segment_bins[contiguous_pages_to_segment_bin(usable_pages)] = 0;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\n\treturn area;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)",
            "#define DSA_NUM_SEGMENT_BINS 16",
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)",
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))",
            "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *create_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *create_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_area *\ncreate_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\tsize_t\t\tusable_pages;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tmetadata_bytes;\n\tint\t\t\ti;\n\n\t/* Sanity check on the space we have to work in. */\n\tif (size < dsa_minimum_size())\n\t\telog(ERROR, \"dsa_area space must be at least %zu, but %zu provided\",\n\t\t\t dsa_minimum_size(), size);\n\n\t/* Now figure out how much space is usable */\n\ttotal_pages = size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\ttotal_pages * sizeof(dsa_pointer);\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tAssert(metadata_bytes <= size);\n\tusable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;\n\n\t/*\n\t * Initialize the dsa_area_control object located at the start of the\n\t * space.\n\t */\n\tcontrol = (dsa_area_control *) place;\n\tcontrol->segment_header.magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ control_handle ^ 0;\n\tcontrol->segment_header.next = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.prev = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.usable_pages = usable_pages;\n\tcontrol->segment_header.freed = false;\n\tcontrol->segment_header.size = DSA_INITIAL_SEGMENT_SIZE;\n\tcontrol->handle = control_handle;\n\tcontrol->max_total_segment_size = (size_t) -1;\n\tcontrol->total_segment_size = size;\n\tmemset(&control->segment_handles[0], 0,\n\t\t   sizeof(dsm_handle) * DSA_MAX_SEGMENTS);\n\tcontrol->segment_handles[0] = control_handle;\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t\tcontrol->segment_bins[i] = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->high_segment_index = 0;\n\tcontrol->refcnt = 1;\n\tcontrol->freed_segment_counter = 0;\n\tcontrol->lwlock_tranche_id = tranche_id;\n\n\t/*\n\t * Create the dsa_area object that this backend will use to access the\n\t * area.  Other backends will need to obtain their own dsa_area object by\n\t * attaching.\n\t */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(area->segment_maps, 0, sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\tarea->freed_segment_counter = 0;\n\tLWLockInitialize(&control->lock, control->lwlock_tranche_id);\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t\tLWLockInitialize(DSA_SCLASS_LOCK(area, i),\n\t\t\t\t\t\t control->lwlock_tranche_id);\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = control_segment;\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) place;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\t/* There can be 0 usable pages if size is dsa_minimum_size(). */\n\n\tif (usable_pages > 0)\n\t\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   usable_pages);\n\n\t/* Put this segment into the appropriate bin. */\n\tcontrol->segment_bins[contiguous_pages_to_segment_bin(usable_pages)] = 0;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\ndsa_area *\ndsa_create_in_place(void *place, size_t size,\n\t\t\t\t\tint tranche_id, dsm_segment *segment)\n{\n\tdsa_area   *area;\n\n\tarea = create_internal(place, size, tranche_id,\n\t\t\t\t\t\t   DSM_HANDLE_INVALID, NULL);\n\n\t/*\n\t * Clean up when the control segment detaches, if a containing DSM segment\n\t * was provided.\n\t */\n\tif (segment != NULL)\n\t\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t\t  PointerGetDatum(place));\n\n\treturn area;\n}"
  },
  {
    "function_name": "dsa_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
    "lines": "419-450",
    "snippet": "dsa_area *\ndsa_create(int tranche_id)\n{\n\tdsm_segment *segment;\n\tdsa_area   *area;\n\n\t/*\n\t * Create the DSM segment that will hold the shared control object and the\n\t * first segment of usable space.\n\t */\n\tsegment = dsm_create(DSA_INITIAL_SEGMENT_SIZE, 0);\n\n\t/*\n\t * All segments backing this area are pinned, so that DSA can explicitly\n\t * control their lifetime (otherwise a newly created segment belonging to\n\t * this area might be freed when the only backend that happens to have it\n\t * mapped in ends, corrupting the area).\n\t */\n\tdsm_pin_segment(segment);\n\n\t/* Create a new DSA area with the control object in this segment. */\n\tarea = create_internal(dsm_segment_address(segment),\n\t\t\t\t\t\t   DSA_INITIAL_SEGMENT_SIZE,\n\t\t\t\t\t\t   tranche_id,\n\t\t\t\t\t\t   dsm_segment_handle(segment), segment);\n\n\t/* Clean up when the control segment detaches. */\n\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t  PointerGetDatum(dsm_segment_address(segment)));\n\n\treturn area;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"utils/dsa.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/dsm.h\"",
      "#include \"port/atomics.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
    ],
    "globals_used": [
      "static void check_for_freed_segments(dsa_area *area);",
      "static void check_for_freed_segments_locked(dsa_area *area);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dsm_detach",
          "args": [
            "segment",
            "&dsa_on_dsm_detach_release_in_place",
            "PointerGetDatum(dsm_segment_address(segment))"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "dsm_segment_address(segment)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_address",
          "args": [
            "segment"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_internal",
          "args": [
            "dsm_segment_address(segment)",
            "DSA_INITIAL_SEGMENT_SIZE",
            "tranche_id",
            "dsm_segment_handle(segment)",
            "segment"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/dsa.c",
          "lines": "1190-1288",
          "snippet": "static dsa_area *\ncreate_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\tsize_t\t\tusable_pages;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tmetadata_bytes;\n\tint\t\t\ti;\n\n\t/* Sanity check on the space we have to work in. */\n\tif (size < dsa_minimum_size())\n\t\telog(ERROR, \"dsa_area space must be at least %zu, but %zu provided\",\n\t\t\t dsa_minimum_size(), size);\n\n\t/* Now figure out how much space is usable */\n\ttotal_pages = size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\ttotal_pages * sizeof(dsa_pointer);\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tAssert(metadata_bytes <= size);\n\tusable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;\n\n\t/*\n\t * Initialize the dsa_area_control object located at the start of the\n\t * space.\n\t */\n\tcontrol = (dsa_area_control *) place;\n\tcontrol->segment_header.magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ control_handle ^ 0;\n\tcontrol->segment_header.next = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.prev = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.usable_pages = usable_pages;\n\tcontrol->segment_header.freed = false;\n\tcontrol->segment_header.size = DSA_INITIAL_SEGMENT_SIZE;\n\tcontrol->handle = control_handle;\n\tcontrol->max_total_segment_size = (size_t) -1;\n\tcontrol->total_segment_size = size;\n\tmemset(&control->segment_handles[0], 0,\n\t\t   sizeof(dsm_handle) * DSA_MAX_SEGMENTS);\n\tcontrol->segment_handles[0] = control_handle;\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t\tcontrol->segment_bins[i] = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->high_segment_index = 0;\n\tcontrol->refcnt = 1;\n\tcontrol->freed_segment_counter = 0;\n\tcontrol->lwlock_tranche_id = tranche_id;\n\n\t/*\n\t * Create the dsa_area object that this backend will use to access the\n\t * area.  Other backends will need to obtain their own dsa_area object by\n\t * attaching.\n\t */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(area->segment_maps, 0, sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\tarea->freed_segment_counter = 0;\n\tLWLockInitialize(&control->lock, control->lwlock_tranche_id);\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t\tLWLockInitialize(DSA_SCLASS_LOCK(area, i),\n\t\t\t\t\t\t control->lwlock_tranche_id);\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = control_segment;\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) place;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\t/* There can be 0 usable pages if size is dsa_minimum_size(). */\n\n\tif (usable_pages > 0)\n\t\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   usable_pages);\n\n\t/* Put this segment into the appropriate bin. */\n\tcontrol->segment_bins[contiguous_pages_to_segment_bin(usable_pages)] = 0;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\n\treturn area;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"utils/dsa.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/dsm.h\"",
            "#include \"port/atomics.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)",
            "#define DSA_NUM_SEGMENT_BINS 16",
            "#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)",
            "#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608",
            "#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))",
            "#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))"
          ],
          "globals_used": [
            "static void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);",
            "static dsa_area *create_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment);",
            "static dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);",
            "static void check_for_freed_segments(dsa_area *area);",
            "static void check_for_freed_segments_locked(dsa_area *area);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_NUM_SIZE_CLASSES\t\t\t\tlengthof(dsa_size_classes)\n#define DSA_NUM_SEGMENT_BINS 16\n#define DSA_SEGMENT_INDEX_NONE (~(dsa_segment_index)0)\n#define DSA_SEGMENT_HEADER_MAGIC 0x0ce26608\n#define DSA_MAX_SEGMENTS \\\n\tMin(1024, (1 << ((SIZEOF_DSA_POINTER * 8) - DSA_OFFSET_WIDTH)))\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic void unlink_segment(dsa_area *area, dsa_segment_map *segment_map);\nstatic dsa_area *create_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment);\nstatic dsa_area *attach_internal(void *place, dsm_segment *segment,\n\t\t\t\tdsa_handle handle);\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\nstatic dsa_area *\ncreate_internal(void *place, size_t size,\n\t\t\t\tint tranche_id,\n\t\t\t\tdsm_handle control_handle,\n\t\t\t\tdsm_segment *control_segment)\n{\n\tdsa_area_control *control;\n\tdsa_area   *area;\n\tdsa_segment_map *segment_map;\n\tsize_t\t\tusable_pages;\n\tsize_t\t\ttotal_pages;\n\tsize_t\t\tmetadata_bytes;\n\tint\t\t\ti;\n\n\t/* Sanity check on the space we have to work in. */\n\tif (size < dsa_minimum_size())\n\t\telog(ERROR, \"dsa_area space must be at least %zu, but %zu provided\",\n\t\t\t dsa_minimum_size(), size);\n\n\t/* Now figure out how much space is usable */\n\ttotal_pages = size / FPM_PAGE_SIZE;\n\tmetadata_bytes =\n\t\tMAXALIGN(sizeof(dsa_area_control)) +\n\t\tMAXALIGN(sizeof(FreePageManager)) +\n\t\ttotal_pages * sizeof(dsa_pointer);\n\t/* Add padding up to next page boundary. */\n\tif (metadata_bytes % FPM_PAGE_SIZE != 0)\n\t\tmetadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);\n\tAssert(metadata_bytes <= size);\n\tusable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;\n\n\t/*\n\t * Initialize the dsa_area_control object located at the start of the\n\t * space.\n\t */\n\tcontrol = (dsa_area_control *) place;\n\tcontrol->segment_header.magic =\n\t\tDSA_SEGMENT_HEADER_MAGIC ^ control_handle ^ 0;\n\tcontrol->segment_header.next = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.prev = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->segment_header.usable_pages = usable_pages;\n\tcontrol->segment_header.freed = false;\n\tcontrol->segment_header.size = DSA_INITIAL_SEGMENT_SIZE;\n\tcontrol->handle = control_handle;\n\tcontrol->max_total_segment_size = (size_t) -1;\n\tcontrol->total_segment_size = size;\n\tmemset(&control->segment_handles[0], 0,\n\t\t   sizeof(dsm_handle) * DSA_MAX_SEGMENTS);\n\tcontrol->segment_handles[0] = control_handle;\n\tfor (i = 0; i < DSA_NUM_SEGMENT_BINS; ++i)\n\t\tcontrol->segment_bins[i] = DSA_SEGMENT_INDEX_NONE;\n\tcontrol->high_segment_index = 0;\n\tcontrol->refcnt = 1;\n\tcontrol->freed_segment_counter = 0;\n\tcontrol->lwlock_tranche_id = tranche_id;\n\n\t/*\n\t * Create the dsa_area object that this backend will use to access the\n\t * area.  Other backends will need to obtain their own dsa_area object by\n\t * attaching.\n\t */\n\tarea = palloc(sizeof(dsa_area));\n\tarea->control = control;\n\tarea->mapping_pinned = false;\n\tmemset(area->segment_maps, 0, sizeof(dsa_segment_map) * DSA_MAX_SEGMENTS);\n\tarea->high_segment_index = 0;\n\tarea->freed_segment_counter = 0;\n\tLWLockInitialize(&control->lock, control->lwlock_tranche_id);\n\tfor (i = 0; i < DSA_NUM_SIZE_CLASSES; ++i)\n\t\tLWLockInitialize(DSA_SCLASS_LOCK(area, i),\n\t\t\t\t\t\t control->lwlock_tranche_id);\n\n\t/* Set up the segment map for this process's mapping. */\n\tsegment_map = &area->segment_maps[0];\n\tsegment_map->segment = control_segment;\n\tsegment_map->mapped_address = place;\n\tsegment_map->header = (dsa_segment_header *) place;\n\tsegment_map->fpm = (FreePageManager *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)));\n\tsegment_map->pagemap = (dsa_pointer *)\n\t\t(segment_map->mapped_address +\n\t\t MAXALIGN(sizeof(dsa_area_control)) +\n\t\t MAXALIGN(sizeof(FreePageManager)));\n\n\t/* Set up the free page map. */\n\tFreePageManagerInitialize(segment_map->fpm, segment_map->mapped_address);\n\t/* There can be 0 usable pages if size is dsa_minimum_size(). */\n\n\tif (usable_pages > 0)\n\t\tFreePageManagerPut(segment_map->fpm, metadata_bytes / FPM_PAGE_SIZE,\n\t\t\t\t\t\t   usable_pages);\n\n\t/* Put this segment into the appropriate bin. */\n\tcontrol->segment_bins[contiguous_pages_to_segment_bin(usable_pages)] = 0;\n\tsegment_map->header->bin = contiguous_pages_to_segment_bin(usable_pages);\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsm_segment_handle",
          "args": [
            "segment"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_segment_address",
          "args": [
            "segment"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_pin_segment",
          "args": [
            "segment"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsm_create",
          "args": [
            "DSA_INITIAL_SEGMENT_SIZE",
            "0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/freepage.h\"\n#include \"utils/dsa.h\"\n#include \"storage/shmem.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/ipc.h\"\n#include \"storage/dsm.h\"\n#include \"port/atomics.h\"\n#include \"postgres.h\"\n\n#define DSA_INITIAL_SEGMENT_SIZE ((size_t) (1 * 1024 * 1024))\n\nstatic void check_for_freed_segments(dsa_area *area);\nstatic void check_for_freed_segments_locked(dsa_area *area);\n\ndsa_area *\ndsa_create(int tranche_id)\n{\n\tdsm_segment *segment;\n\tdsa_area   *area;\n\n\t/*\n\t * Create the DSM segment that will hold the shared control object and the\n\t * first segment of usable space.\n\t */\n\tsegment = dsm_create(DSA_INITIAL_SEGMENT_SIZE, 0);\n\n\t/*\n\t * All segments backing this area are pinned, so that DSA can explicitly\n\t * control their lifetime (otherwise a newly created segment belonging to\n\t * this area might be freed when the only backend that happens to have it\n\t * mapped in ends, corrupting the area).\n\t */\n\tdsm_pin_segment(segment);\n\n\t/* Create a new DSA area with the control object in this segment. */\n\tarea = create_internal(dsm_segment_address(segment),\n\t\t\t\t\t\t   DSA_INITIAL_SEGMENT_SIZE,\n\t\t\t\t\t\t   tranche_id,\n\t\t\t\t\t\t   dsm_segment_handle(segment), segment);\n\n\t/* Clean up when the control segment detaches. */\n\ton_dsm_detach(segment, &dsa_on_dsm_detach_release_in_place,\n\t\t\t\t  PointerGetDatum(dsm_segment_address(segment)));\n\n\treturn area;\n}"
  }
]