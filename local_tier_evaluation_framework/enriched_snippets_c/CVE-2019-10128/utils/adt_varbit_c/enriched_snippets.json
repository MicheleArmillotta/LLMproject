[
  {
    "function_name": "bitgetbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1847-1873",
    "snippet": "Datum\nbitgetbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\tbitlen;\n\tbits8\t   *p;\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\n\tbitlen = VARBITLEN(arg1);\n\tif (n < 0 || n >= bitlen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"bit index %d out of valid range (0..%d)\",\n\t\t\t\t\t\tn, bitlen - 1)));\n\n\tp = VARBITS(arg1);\n\n\tbyteNo = n / BITS_PER_BYTE;\n\tbitNo = BITS_PER_BYTE - 1 - (n % BITS_PER_BYTE);\n\n\tif (p[byteNo] & (1 << bitNo))\n\t\tPG_RETURN_INT32(1);\n\telse\n\t\tPG_RETURN_INT32(0);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"bit index %d out of valid range (0..%d)\",\n\t\t\t\t\t\tn, bitlen - 1))"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bit index %d out of valid range (0..%d)\"",
            "n",
            "bitlen - 1"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitgetbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\tbitlen;\n\tbits8\t   *p;\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\n\tbitlen = VARBITLEN(arg1);\n\tif (n < 0 || n >= bitlen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"bit index %d out of valid range (0..%d)\",\n\t\t\t\t\t\tn, bitlen - 1)));\n\n\tp = VARBITS(arg1);\n\n\tbyteNo = n / BITS_PER_BYTE;\n\tbitNo = BITS_PER_BYTE - 1 - (n % BITS_PER_BYTE);\n\n\tif (p[byteNo] & (1 << bitNo))\n\t\tPG_RETURN_INT32(1);\n\telse\n\t\tPG_RETURN_INT32(0);\n}"
  },
  {
    "function_name": "bitsetbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1785-1836",
    "snippet": "Datum\nbitsetbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint32\t\tnewBit = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen;\n\tbits8\t   *r,\n\t\t\t   *p;\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\n\tbitlen = VARBITLEN(arg1);\n\tif (n < 0 || n >= bitlen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"bit index %d out of valid range (0..%d)\",\n\t\t\t\t\t\tn, bitlen - 1)));\n\n\t/*\n\t * sanity check!\n\t */\n\tif (newBit != 0 && newBit != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"new bit must be 0 or 1\")));\n\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen;\n\n\tp = VARBITS(arg1);\n\tr = VARBITS(result);\n\n\tmemcpy(r, p, VARBITBYTES(arg1));\n\n\tbyteNo = n / BITS_PER_BYTE;\n\tbitNo = BITS_PER_BYTE - 1 - (n % BITS_PER_BYTE);\n\n\t/*\n\t * Update the byte.\n\t */\n\tif (newBit == 0)\n\t\tr[byteNo] &= (~(1 << bitNo));\n\telse\n\t\tr[byteNo] |= (1 << bitNo);\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "p",
            "VARBITBYTES(arg1)"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg1"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"new bit must be 0 or 1\"))"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"new bit must be 0 or 1\""
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"bit index %d out of valid range (0..%d)\",\n\t\t\t\t\t\tn, bitlen - 1))"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitsetbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint32\t\tnewBit = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen;\n\tbits8\t   *r,\n\t\t\t   *p;\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\n\tbitlen = VARBITLEN(arg1);\n\tif (n < 0 || n >= bitlen)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"bit index %d out of valid range (0..%d)\",\n\t\t\t\t\t\tn, bitlen - 1)));\n\n\t/*\n\t * sanity check!\n\t */\n\tif (newBit != 0 && newBit != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"new bit must be 0 or 1\")));\n\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen;\n\n\tp = VARBITS(arg1);\n\tr = VARBITS(result);\n\n\tmemcpy(r, p, VARBITBYTES(arg1));\n\n\tbyteNo = n / BITS_PER_BYTE;\n\tbitNo = BITS_PER_BYTE - 1 - (n % BITS_PER_BYTE);\n\n\t/*\n\t * Update the byte.\n\t */\n\tif (newBit == 0)\n\t\tr[byteNo] &= (~(1 << bitNo));\n\telse\n\t\tr[byteNo] |= (1 << bitNo);\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bitposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1676-1772",
    "snippet": "Datum\nbitposition(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *str = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *substr = PG_GETARG_VARBIT_P(1);\n\tint\t\t\tsubstr_length,\n\t\t\t\tstr_length,\n\t\t\t\ti,\n\t\t\t\tis;\n\tbits8\t   *s,\t\t\t\t/* pointer into substring */\n\t\t\t   *p;\t\t\t\t/* pointer into str */\n\tbits8\t\tcmp,\t\t\t/* shifted substring byte to compare */\n\t\t\t\tmask1,\t\t\t/* mask for substring byte shifted right */\n\t\t\t\tmask2,\t\t\t/* mask for substring byte shifted left */\n\t\t\t\tend_mask,\t\t/* pad mask for last substring byte */\n\t\t\t\tstr_mask;\t\t/* pad mask for last string byte */\n\tbool\t\tis_match;\n\n\t/* Get the substring length */\n\tsubstr_length = VARBITLEN(substr);\n\tstr_length = VARBITLEN(str);\n\n\t/* String has zero length or substring longer than string, return 0 */\n\tif ((str_length == 0) || (substr_length > str_length))\n\t\tPG_RETURN_INT32(0);\n\n\t/* zero-length substring means return 1 */\n\tif (substr_length == 0)\n\t\tPG_RETURN_INT32(1);\n\n\t/* Initialise the padding masks */\n\tend_mask = BITMASK << VARBITPAD(substr);\n\tstr_mask = BITMASK << VARBITPAD(str);\n\tfor (i = 0; i < VARBITBYTES(str) - VARBITBYTES(substr) + 1; i++)\n\t{\n\t\tfor (is = 0; is < BITS_PER_BYTE; is++)\n\t\t{\n\t\t\tis_match = true;\n\t\t\tp = VARBITS(str) + i;\n\t\t\tmask1 = BITMASK >> is;\n\t\t\tmask2 = ~mask1;\n\t\t\tfor (s = VARBITS(substr);\n\t\t\t\t is_match && s < VARBITEND(substr); s++)\n\t\t\t{\n\t\t\t\tcmp = *s >> is;\n\t\t\t\tif (s == VARBITEND(substr) - 1)\n\t\t\t\t{\n\t\t\t\t\tmask1 &= end_mask >> is;\n\t\t\t\t\tif (p == VARBITEND(str) - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Check that there is enough of str left */\n\t\t\t\t\t\tif (mask1 & ~str_mask)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tis_match = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmask1 &= str_mask;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tis_match = ((cmp ^ *p) & mask1) == 0;\n\t\t\t\tif (!is_match)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Move on to the next byte */\n\t\t\t\tp++;\n\t\t\t\tif (p == VARBITEND(str))\n\t\t\t\t{\n\t\t\t\t\tmask2 = end_mask << (BITS_PER_BYTE - is);\n\t\t\t\t\tis_match = mask2 == 0;\n#if 0\n\t\t\t\t\telog(DEBUG4, \"S. %d %d em=%2x sm=%2x r=%d\",\n\t\t\t\t\t\t i, is, end_mask, mask2, is_match);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmp = *s << (BITS_PER_BYTE - is);\n\t\t\t\tif (s == VARBITEND(substr) - 1)\n\t\t\t\t{\n\t\t\t\t\tmask2 &= end_mask << (BITS_PER_BYTE - is);\n\t\t\t\t\tif (p == VARBITEND(str) - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mask2 & ~str_mask)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tis_match = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmask2 &= str_mask;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tis_match = ((cmp ^ *p) & mask2) == 0;\n\t\t\t}\n\t\t\t/* Have we found a match? */\n\t\t\tif (is_match)\n\t\t\t\tPG_RETURN_INT32(i * BITS_PER_BYTE + is + 1);\n\t\t}\n\t}\n\tPG_RETURN_INT32(0);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "i * BITS_PER_BYTE + is + 1"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "str"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "substr"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG4",
            "\"S. %d %d em=%2x sm=%2x r=%d\"",
            "i",
            "is",
            "end_mask",
            "mask2",
            "is_match"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "str"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "str"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "substr"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "substr"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "substr"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "str"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "substr"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "str"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "str"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "substr"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "str"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "substr"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitposition(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *str = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *substr = PG_GETARG_VARBIT_P(1);\n\tint\t\t\tsubstr_length,\n\t\t\t\tstr_length,\n\t\t\t\ti,\n\t\t\t\tis;\n\tbits8\t   *s,\t\t\t\t/* pointer into substring */\n\t\t\t   *p;\t\t\t\t/* pointer into str */\n\tbits8\t\tcmp,\t\t\t/* shifted substring byte to compare */\n\t\t\t\tmask1,\t\t\t/* mask for substring byte shifted right */\n\t\t\t\tmask2,\t\t\t/* mask for substring byte shifted left */\n\t\t\t\tend_mask,\t\t/* pad mask for last substring byte */\n\t\t\t\tstr_mask;\t\t/* pad mask for last string byte */\n\tbool\t\tis_match;\n\n\t/* Get the substring length */\n\tsubstr_length = VARBITLEN(substr);\n\tstr_length = VARBITLEN(str);\n\n\t/* String has zero length or substring longer than string, return 0 */\n\tif ((str_length == 0) || (substr_length > str_length))\n\t\tPG_RETURN_INT32(0);\n\n\t/* zero-length substring means return 1 */\n\tif (substr_length == 0)\n\t\tPG_RETURN_INT32(1);\n\n\t/* Initialise the padding masks */\n\tend_mask = BITMASK << VARBITPAD(substr);\n\tstr_mask = BITMASK << VARBITPAD(str);\n\tfor (i = 0; i < VARBITBYTES(str) - VARBITBYTES(substr) + 1; i++)\n\t{\n\t\tfor (is = 0; is < BITS_PER_BYTE; is++)\n\t\t{\n\t\t\tis_match = true;\n\t\t\tp = VARBITS(str) + i;\n\t\t\tmask1 = BITMASK >> is;\n\t\t\tmask2 = ~mask1;\n\t\t\tfor (s = VARBITS(substr);\n\t\t\t\t is_match && s < VARBITEND(substr); s++)\n\t\t\t{\n\t\t\t\tcmp = *s >> is;\n\t\t\t\tif (s == VARBITEND(substr) - 1)\n\t\t\t\t{\n\t\t\t\t\tmask1 &= end_mask >> is;\n\t\t\t\t\tif (p == VARBITEND(str) - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Check that there is enough of str left */\n\t\t\t\t\t\tif (mask1 & ~str_mask)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tis_match = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmask1 &= str_mask;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tis_match = ((cmp ^ *p) & mask1) == 0;\n\t\t\t\tif (!is_match)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Move on to the next byte */\n\t\t\t\tp++;\n\t\t\t\tif (p == VARBITEND(str))\n\t\t\t\t{\n\t\t\t\t\tmask2 = end_mask << (BITS_PER_BYTE - is);\n\t\t\t\t\tis_match = mask2 == 0;\n#if 0\n\t\t\t\t\telog(DEBUG4, \"S. %d %d em=%2x sm=%2x r=%d\",\n\t\t\t\t\t\t i, is, end_mask, mask2, is_match);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmp = *s << (BITS_PER_BYTE - is);\n\t\t\t\tif (s == VARBITEND(substr) - 1)\n\t\t\t\t{\n\t\t\t\t\tmask2 &= end_mask << (BITS_PER_BYTE - is);\n\t\t\t\t\tif (p == VARBITEND(str) - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mask2 & ~str_mask)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tis_match = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmask2 &= str_mask;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tis_match = ((cmp ^ *p) & mask2) == 0;\n\t\t\t}\n\t\t\t/* Have we found a match? */\n\t\t\tif (is_match)\n\t\t\t\tPG_RETURN_INT32(i * BITS_PER_BYTE + is + 1);\n\t\t}\n\t}\n\tPG_RETURN_INT32(0);\n}"
  },
  {
    "function_name": "bittoint8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1644-1667",
    "snippet": "Datum\nbittoint8(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tuint64\t\tresult;\n\tbits8\t   *r;\n\n\t/* Check that the bit string is not too long */\n\tif (VARBITLEN(arg) > sizeof(result) * BITS_PER_BYTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"bigint out of range\")));\n\n\tresult = 0;\n\tfor (r = VARBITS(arg); r < VARBITEND(arg); r++)\n\t{\n\t\tresult <<= BITS_PER_BYTE;\n\t\tresult |= *r;\n\t}\n\t/* Now shift the result to take account of the padding at the end */\n\tresult >>= VARBITPAD(arg);\n\n\tPG_RETURN_INT64(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "result"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "arg"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"bigint out of range\"))"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bigint out of range\""
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbittoint8(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tuint64\t\tresult;\n\tbits8\t   *r;\n\n\t/* Check that the bit string is not too long */\n\tif (VARBITLEN(arg) > sizeof(result) * BITS_PER_BYTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"bigint out of range\")));\n\n\tresult = 0;\n\tfor (r = VARBITS(arg); r < VARBITEND(arg); r++)\n\t{\n\t\tresult <<= BITS_PER_BYTE;\n\t\tresult |= *r;\n\t}\n\t/* Now shift the result to take account of the padding at the end */\n\tresult >>= VARBITPAD(arg);\n\n\tPG_RETURN_INT64(result);\n}"
  },
  {
    "function_name": "bitfromint8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1589-1642",
    "snippet": "Datum\nbitfromint8(PG_FUNCTION_ARGS)\n{\n\tint64\t\ta = PG_GETARG_INT64(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tbits8\t   *r;\n\tint\t\t\trlen;\n\tint\t\t\tdestbitsleft,\n\t\t\t\tsrcbitsleft;\n\n\tif (typmod <= 0 || typmod > VARBITMAXLEN)\n\t\ttypmod = 1;\t\t\t\t/* default bit length */\n\n\trlen = VARBITTOTALLEN(typmod);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = typmod;\n\n\tr = VARBITS(result);\n\tdestbitsleft = typmod;\n\tsrcbitsleft = 64;\n\t/* drop any input bits that don't fit */\n\tsrcbitsleft = Min(srcbitsleft, destbitsleft);\n\t/* sign-fill any excess bytes in output */\n\twhile (destbitsleft >= srcbitsleft + 8)\n\t{\n\t\t*r++ = (bits8) ((a < 0) ? BITMASK : 0);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store first fractional byte */\n\tif (destbitsleft > srcbitsleft)\n\t{\n\t\tunsigned int val = (unsigned int) (a >> (destbitsleft - 8));\n\n\t\t/* Force sign-fill in case the compiler implements >> as zero-fill */\n\t\tif (a < 0)\n\t\t\tval |= ((unsigned int) -1) << (srcbitsleft + 8 - destbitsleft);\n\t\t*r++ = (bits8) (val & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* Now srcbitsleft and destbitsleft are the same, need not track both */\n\t/* store whole bytes */\n\twhile (destbitsleft >= 8)\n\t{\n\t\t*r++ = (bits8) ((a >> (destbitsleft - 8)) & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store last fractional byte */\n\tif (destbitsleft > 0)\n\t\t*r = (bits8) ((a << (8 - destbitsleft)) & BITMASK);\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(a << (8 - destbitsleft)) & BITMASK"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(a >> (destbitsleft - 8)) & BITMASK"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "val & BITMASK"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(a < 0) ? BITMASK : 0"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "srcbitsleft",
            "destbitsleft"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "rlen"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "rlen"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "typmod"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitfromint8(PG_FUNCTION_ARGS)\n{\n\tint64\t\ta = PG_GETARG_INT64(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tbits8\t   *r;\n\tint\t\t\trlen;\n\tint\t\t\tdestbitsleft,\n\t\t\t\tsrcbitsleft;\n\n\tif (typmod <= 0 || typmod > VARBITMAXLEN)\n\t\ttypmod = 1;\t\t\t\t/* default bit length */\n\n\trlen = VARBITTOTALLEN(typmod);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = typmod;\n\n\tr = VARBITS(result);\n\tdestbitsleft = typmod;\n\tsrcbitsleft = 64;\n\t/* drop any input bits that don't fit */\n\tsrcbitsleft = Min(srcbitsleft, destbitsleft);\n\t/* sign-fill any excess bytes in output */\n\twhile (destbitsleft >= srcbitsleft + 8)\n\t{\n\t\t*r++ = (bits8) ((a < 0) ? BITMASK : 0);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store first fractional byte */\n\tif (destbitsleft > srcbitsleft)\n\t{\n\t\tunsigned int val = (unsigned int) (a >> (destbitsleft - 8));\n\n\t\t/* Force sign-fill in case the compiler implements >> as zero-fill */\n\t\tif (a < 0)\n\t\t\tval |= ((unsigned int) -1) << (srcbitsleft + 8 - destbitsleft);\n\t\t*r++ = (bits8) (val & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* Now srcbitsleft and destbitsleft are the same, need not track both */\n\t/* store whole bytes */\n\twhile (destbitsleft >= 8)\n\t{\n\t\t*r++ = (bits8) ((a >> (destbitsleft - 8)) & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store last fractional byte */\n\tif (destbitsleft > 0)\n\t\t*r = (bits8) ((a << (8 - destbitsleft)) & BITMASK);\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bittoint4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1564-1587",
    "snippet": "Datum\nbittoint4(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tuint32\t\tresult;\n\tbits8\t   *r;\n\n\t/* Check that the bit string is not too long */\n\tif (VARBITLEN(arg) > sizeof(result) * BITS_PER_BYTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\tresult = 0;\n\tfor (r = VARBITS(arg); r < VARBITEND(arg); r++)\n\t{\n\t\tresult <<= BITS_PER_BYTE;\n\t\tresult |= *r;\n\t}\n\t/* Now shift the result to take account of the padding at the end */\n\tresult >>= VARBITPAD(arg);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "arg"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"integer out of range\""
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbittoint4(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tuint32\t\tresult;\n\tbits8\t   *r;\n\n\t/* Check that the bit string is not too long */\n\tif (VARBITLEN(arg) > sizeof(result) * BITS_PER_BYTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\tresult = 0;\n\tfor (r = VARBITS(arg); r < VARBITEND(arg); r++)\n\t{\n\t\tresult <<= BITS_PER_BYTE;\n\t\tresult |= *r;\n\t}\n\t/* Now shift the result to take account of the padding at the end */\n\tresult >>= VARBITPAD(arg);\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "bitfromint4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1509-1562",
    "snippet": "Datum\nbitfromint4(PG_FUNCTION_ARGS)\n{\n\tint32\t\ta = PG_GETARG_INT32(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tbits8\t   *r;\n\tint\t\t\trlen;\n\tint\t\t\tdestbitsleft,\n\t\t\t\tsrcbitsleft;\n\n\tif (typmod <= 0 || typmod > VARBITMAXLEN)\n\t\ttypmod = 1;\t\t\t\t/* default bit length */\n\n\trlen = VARBITTOTALLEN(typmod);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = typmod;\n\n\tr = VARBITS(result);\n\tdestbitsleft = typmod;\n\tsrcbitsleft = 32;\n\t/* drop any input bits that don't fit */\n\tsrcbitsleft = Min(srcbitsleft, destbitsleft);\n\t/* sign-fill any excess bytes in output */\n\twhile (destbitsleft >= srcbitsleft + 8)\n\t{\n\t\t*r++ = (bits8) ((a < 0) ? BITMASK : 0);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store first fractional byte */\n\tif (destbitsleft > srcbitsleft)\n\t{\n\t\tunsigned int val = (unsigned int) (a >> (destbitsleft - 8));\n\n\t\t/* Force sign-fill in case the compiler implements >> as zero-fill */\n\t\tif (a < 0)\n\t\t\tval |= ((unsigned int) -1) << (srcbitsleft + 8 - destbitsleft);\n\t\t*r++ = (bits8) (val & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* Now srcbitsleft and destbitsleft are the same, need not track both */\n\t/* store whole bytes */\n\twhile (destbitsleft >= 8)\n\t{\n\t\t*r++ = (bits8) ((a >> (destbitsleft - 8)) & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store last fractional byte */\n\tif (destbitsleft > 0)\n\t\t*r = (bits8) ((a << (8 - destbitsleft)) & BITMASK);\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(a << (8 - destbitsleft)) & BITMASK"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(a >> (destbitsleft - 8)) & BITMASK"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "val & BITMASK"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(a < 0) ? BITMASK : 0"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "srcbitsleft",
            "destbitsleft"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "rlen"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "rlen"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "typmod"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitfromint4(PG_FUNCTION_ARGS)\n{\n\tint32\t\ta = PG_GETARG_INT32(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tbits8\t   *r;\n\tint\t\t\trlen;\n\tint\t\t\tdestbitsleft,\n\t\t\t\tsrcbitsleft;\n\n\tif (typmod <= 0 || typmod > VARBITMAXLEN)\n\t\ttypmod = 1;\t\t\t\t/* default bit length */\n\n\trlen = VARBITTOTALLEN(typmod);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = typmod;\n\n\tr = VARBITS(result);\n\tdestbitsleft = typmod;\n\tsrcbitsleft = 32;\n\t/* drop any input bits that don't fit */\n\tsrcbitsleft = Min(srcbitsleft, destbitsleft);\n\t/* sign-fill any excess bytes in output */\n\twhile (destbitsleft >= srcbitsleft + 8)\n\t{\n\t\t*r++ = (bits8) ((a < 0) ? BITMASK : 0);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store first fractional byte */\n\tif (destbitsleft > srcbitsleft)\n\t{\n\t\tunsigned int val = (unsigned int) (a >> (destbitsleft - 8));\n\n\t\t/* Force sign-fill in case the compiler implements >> as zero-fill */\n\t\tif (a < 0)\n\t\t\tval |= ((unsigned int) -1) << (srcbitsleft + 8 - destbitsleft);\n\t\t*r++ = (bits8) (val & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* Now srcbitsleft and destbitsleft are the same, need not track both */\n\t/* store whole bytes */\n\twhile (destbitsleft >= 8)\n\t{\n\t\t*r++ = (bits8) ((a >> (destbitsleft - 8)) & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t/* store last fractional byte */\n\tif (destbitsleft > 0)\n\t\t*r = (bits8) ((a << (8 - destbitsleft)) & BITMASK);\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bitshiftright",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1441-1503",
    "snippet": "Datum\nbitshiftright(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tshft = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tint\t\t\tbyte_shift,\n\t\t\t\tishift,\n\t\t\t\tlen;\n\tbits8\t   *p,\n\t\t\t   *r;\n\n\t/* Negative shift is a shift to the left */\n\tif (shft < 0)\n\t{\n\t\t/* Prevent integer overflow in negation */\n\t\tif (shft < -VARBITMAXLEN)\n\t\t\tshft = -VARBITMAXLEN;\n\t\tPG_RETURN_DATUM(DirectFunctionCall2(bitshiftleft,\n\t\t\t\t\t\t\t\t\t\t\tVarBitPGetDatum(arg),\n\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(-shft)));\n\t}\n\n\tresult = (VarBit *) palloc(VARSIZE(arg));\n\tSET_VARSIZE(result, VARSIZE(arg));\n\tVARBITLEN(result) = VARBITLEN(arg);\n\tr = VARBITS(result);\n\n\t/* If we shifted all the bits out, return an all-zero string */\n\tif (shft >= VARBITLEN(arg))\n\t{\n\t\tMemSet(r, 0, VARBITBYTES(arg));\n\t\tPG_RETURN_VARBIT_P(result);\n\t}\n\n\tbyte_shift = shft / BITS_PER_BYTE;\n\tishift = shft % BITS_PER_BYTE;\n\tp = VARBITS(arg);\n\n\t/* Set the first part of the result to 0 */\n\tMemSet(r, 0, byte_shift);\n\tr += byte_shift;\n\n\tif (ishift == 0)\n\t{\n\t\t/* Special case: we can do a memcpy */\n\t\tlen = VARBITBYTES(arg) - byte_shift;\n\t\tmemcpy(r, p, len);\n\t}\n\telse\n\t{\n\t\tif (r < VARBITEND(result))\n\t\t\t*r = 0;\t\t\t\t/* initialize first byte */\n\t\tfor (; r < VARBITEND(result); p++)\n\t\t{\n\t\t\t*r |= *p >> ishift;\n\t\t\tif ((++r) < VARBITEND(result))\n\t\t\t\t*r = (*p << (BITS_PER_BYTE - ishift)) & BITMASK;\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "result"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "result"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "result"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "p",
            "len"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "r",
            "0",
            "byte_shift"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "r",
            "0",
            "VARBITBYTES(arg)"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "VARSIZE(arg)"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARSIZE(arg)"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(bitshiftleft,\n\t\t\t\t\t\t\t\t\t\t\tVarBitPGetDatum(arg),\n\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(-shft))"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "bitshiftleft",
            "VarBitPGetDatum(arg)",
            "Int32GetDatum(-shft)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-shft"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VarBitPGetDatum",
          "args": [
            "arg"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitshiftright(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tshft = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tint\t\t\tbyte_shift,\n\t\t\t\tishift,\n\t\t\t\tlen;\n\tbits8\t   *p,\n\t\t\t   *r;\n\n\t/* Negative shift is a shift to the left */\n\tif (shft < 0)\n\t{\n\t\t/* Prevent integer overflow in negation */\n\t\tif (shft < -VARBITMAXLEN)\n\t\t\tshft = -VARBITMAXLEN;\n\t\tPG_RETURN_DATUM(DirectFunctionCall2(bitshiftleft,\n\t\t\t\t\t\t\t\t\t\t\tVarBitPGetDatum(arg),\n\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(-shft)));\n\t}\n\n\tresult = (VarBit *) palloc(VARSIZE(arg));\n\tSET_VARSIZE(result, VARSIZE(arg));\n\tVARBITLEN(result) = VARBITLEN(arg);\n\tr = VARBITS(result);\n\n\t/* If we shifted all the bits out, return an all-zero string */\n\tif (shft >= VARBITLEN(arg))\n\t{\n\t\tMemSet(r, 0, VARBITBYTES(arg));\n\t\tPG_RETURN_VARBIT_P(result);\n\t}\n\n\tbyte_shift = shft / BITS_PER_BYTE;\n\tishift = shft % BITS_PER_BYTE;\n\tp = VARBITS(arg);\n\n\t/* Set the first part of the result to 0 */\n\tMemSet(r, 0, byte_shift);\n\tr += byte_shift;\n\n\tif (ishift == 0)\n\t{\n\t\t/* Special case: we can do a memcpy */\n\t\tlen = VARBITBYTES(arg) - byte_shift;\n\t\tmemcpy(r, p, len);\n\t}\n\telse\n\t{\n\t\tif (r < VARBITEND(result))\n\t\t\t*r = 0;\t\t\t\t/* initialize first byte */\n\t\tfor (; r < VARBITEND(result); p++)\n\t\t{\n\t\t\t*r |= *p >> ishift;\n\t\t\tif ((++r) < VARBITEND(result))\n\t\t\t\t*r = (*p << (BITS_PER_BYTE - ishift)) & BITMASK;\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bitshiftleft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1376-1435",
    "snippet": "Datum\nbitshiftleft(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tshft = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tint\t\t\tbyte_shift,\n\t\t\t\tishift,\n\t\t\t\tlen;\n\tbits8\t   *p,\n\t\t\t   *r;\n\n\t/* Negative shift is a shift to the right */\n\tif (shft < 0)\n\t{\n\t\t/* Prevent integer overflow in negation */\n\t\tif (shft < -VARBITMAXLEN)\n\t\t\tshft = -VARBITMAXLEN;\n\t\tPG_RETURN_DATUM(DirectFunctionCall2(bitshiftright,\n\t\t\t\t\t\t\t\t\t\t\tVarBitPGetDatum(arg),\n\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(-shft)));\n\t}\n\n\tresult = (VarBit *) palloc(VARSIZE(arg));\n\tSET_VARSIZE(result, VARSIZE(arg));\n\tVARBITLEN(result) = VARBITLEN(arg);\n\tr = VARBITS(result);\n\n\t/* If we shifted all the bits out, return an all-zero string */\n\tif (shft >= VARBITLEN(arg))\n\t{\n\t\tMemSet(r, 0, VARBITBYTES(arg));\n\t\tPG_RETURN_VARBIT_P(result);\n\t}\n\n\tbyte_shift = shft / BITS_PER_BYTE;\n\tishift = shft % BITS_PER_BYTE;\n\tp = VARBITS(arg) + byte_shift;\n\n\tif (ishift == 0)\n\t{\n\t\t/* Special case: we can do a memcpy */\n\t\tlen = VARBITBYTES(arg) - byte_shift;\n\t\tmemcpy(r, p, len);\n\t\tMemSet(r + len, 0, byte_shift);\n\t}\n\telse\n\t{\n\t\tfor (; p < VARBITEND(arg); r++)\n\t\t{\n\t\t\t*r = *p << ishift;\n\t\t\tif ((++p) < VARBITEND(arg))\n\t\t\t\t*r |= *p >> (BITS_PER_BYTE - ishift);\n\t\t}\n\t\tfor (; r < VARBITEND(result); r++)\n\t\t\t*r = 0;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "result"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "r + len",
            "0",
            "byte_shift"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "p",
            "len"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "r",
            "0",
            "VARBITBYTES(arg)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "VARSIZE(arg)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARSIZE(arg)"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(bitshiftright,\n\t\t\t\t\t\t\t\t\t\t\tVarBitPGetDatum(arg),\n\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(-shft))"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "bitshiftright",
            "VarBitPGetDatum(arg)",
            "Int32GetDatum(-shft)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-shft"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VarBitPGetDatum",
          "args": [
            "arg"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitshiftleft(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tshft = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tint\t\t\tbyte_shift,\n\t\t\t\tishift,\n\t\t\t\tlen;\n\tbits8\t   *p,\n\t\t\t   *r;\n\n\t/* Negative shift is a shift to the right */\n\tif (shft < 0)\n\t{\n\t\t/* Prevent integer overflow in negation */\n\t\tif (shft < -VARBITMAXLEN)\n\t\t\tshft = -VARBITMAXLEN;\n\t\tPG_RETURN_DATUM(DirectFunctionCall2(bitshiftright,\n\t\t\t\t\t\t\t\t\t\t\tVarBitPGetDatum(arg),\n\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(-shft)));\n\t}\n\n\tresult = (VarBit *) palloc(VARSIZE(arg));\n\tSET_VARSIZE(result, VARSIZE(arg));\n\tVARBITLEN(result) = VARBITLEN(arg);\n\tr = VARBITS(result);\n\n\t/* If we shifted all the bits out, return an all-zero string */\n\tif (shft >= VARBITLEN(arg))\n\t{\n\t\tMemSet(r, 0, VARBITBYTES(arg));\n\t\tPG_RETURN_VARBIT_P(result);\n\t}\n\n\tbyte_shift = shft / BITS_PER_BYTE;\n\tishift = shft % BITS_PER_BYTE;\n\tp = VARBITS(arg) + byte_shift;\n\n\tif (ishift == 0)\n\t{\n\t\t/* Special case: we can do a memcpy */\n\t\tlen = VARBITBYTES(arg) - byte_shift;\n\t\tmemcpy(r, p, len);\n\t\tMemSet(r + len, 0, byte_shift);\n\t}\n\telse\n\t{\n\t\tfor (; p < VARBITEND(arg); r++)\n\t\t{\n\t\t\t*r = *p << ishift;\n\t\t\tif ((++p) < VARBITEND(arg))\n\t\t\t\t*r |= *p >> (BITS_PER_BYTE - ishift);\n\t\t}\n\t\tfor (; r < VARBITEND(result); r++)\n\t\t\t*r = 0;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bitnot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1343-1370",
    "snippet": "Datum\nbitnot(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *result;\n\tbits8\t   *p,\n\t\t\t   *r;\n\tbits8\t\tmask;\n\n\tresult = (VarBit *) palloc(VARSIZE(arg));\n\tSET_VARSIZE(result, VARSIZE(arg));\n\tVARBITLEN(result) = VARBITLEN(arg);\n\n\tp = VARBITS(arg);\n\tr = VARBITS(result);\n\tfor (; p < VARBITEND(arg); p++)\n\t\t*r++ = ~*p;\n\n\t/* Pad the result */\n\tmask = BITMASK << VARBITPAD(result);\n\tif (mask)\n\t{\n\t\tr--;\n\t\t*r &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "VARSIZE(arg)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARSIZE(arg)"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitnot(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *result;\n\tbits8\t   *p,\n\t\t\t   *r;\n\tbits8\t\tmask;\n\n\tresult = (VarBit *) palloc(VARSIZE(arg));\n\tSET_VARSIZE(result, VARSIZE(arg));\n\tVARBITLEN(result) = VARBITLEN(arg);\n\n\tp = VARBITS(arg);\n\tr = VARBITS(result);\n\tfor (; p < VARBITEND(arg); p++)\n\t\t*r++ = ~*p;\n\n\t/* Pad the result */\n\tmask = BITMASK << VARBITPAD(result);\n\tif (mask)\n\t{\n\t\tr--;\n\t\t*r &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bitxor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1295-1337",
    "snippet": "Datum\nbitxor(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\ti;\n\tbits8\t   *p1,\n\t\t\t   *p2,\n\t\t\t   *r;\n\tbits8\t\tmask;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 != bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot XOR bit strings of different sizes\")));\n\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen1;\n\n\tp1 = VARBITS(arg1);\n\tp2 = VARBITS(arg2);\n\tr = VARBITS(result);\n\tfor (i = 0; i < VARBITBYTES(arg1); i++)\n\t\t*r++ = *p1++ ^ *p2++;\n\n\t/* Pad the result */\n\tmask = BITMASK << VARBITPAD(result);\n\tif (mask)\n\t{\n\t\tr--;\n\t\t*r &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg2"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg1"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot XOR bit strings of different sizes\"))"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot XOR bit strings of different sizes\""
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_LENGTH_MISMATCH"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitxor(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\ti;\n\tbits8\t   *p1,\n\t\t\t   *p2,\n\t\t\t   *r;\n\tbits8\t\tmask;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 != bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot XOR bit strings of different sizes\")));\n\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen1;\n\n\tp1 = VARBITS(arg1);\n\tp2 = VARBITS(arg2);\n\tr = VARBITS(result);\n\tfor (i = 0; i < VARBITBYTES(arg1); i++)\n\t\t*r++ = *p1++ ^ *p2++;\n\n\t/* Pad the result */\n\tmask = BITMASK << VARBITPAD(result);\n\tif (mask)\n\t{\n\t\tr--;\n\t\t*r &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bit_or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1248-1289",
    "snippet": "Datum\nbit_or(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\ti;\n\tbits8\t   *p1,\n\t\t\t   *p2,\n\t\t\t   *r;\n\tbits8\t\tmask;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 != bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot OR bit strings of different sizes\")));\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen1;\n\n\tp1 = VARBITS(arg1);\n\tp2 = VARBITS(arg2);\n\tr = VARBITS(result);\n\tfor (i = 0; i < VARBITBYTES(arg1); i++)\n\t\t*r++ = *p1++ | *p2++;\n\n\t/* Pad the result */\n\tmask = BITMASK << VARBITPAD(result);\n\tif (mask)\n\t{\n\t\tr--;\n\t\t*r &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg2"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg1"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot OR bit strings of different sizes\"))"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot OR bit strings of different sizes\""
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_LENGTH_MISMATCH"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbit_or(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\ti;\n\tbits8\t   *p1,\n\t\t\t   *p2,\n\t\t\t   *r;\n\tbits8\t\tmask;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 != bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot OR bit strings of different sizes\")));\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen1;\n\n\tp1 = VARBITS(arg1);\n\tp2 = VARBITS(arg2);\n\tr = VARBITS(result);\n\tfor (i = 0; i < VARBITBYTES(arg1); i++)\n\t\t*r++ = *p1++ | *p2++;\n\n\t/* Pad the result */\n\tmask = BITMASK << VARBITPAD(result);\n\tif (mask)\n\t{\n\t\tr--;\n\t\t*r &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bit_and",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1207-1242",
    "snippet": "Datum\nbit_and(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\ti;\n\tbits8\t   *p1,\n\t\t\t   *p2,\n\t\t\t   *r;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 != bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot AND bit strings of different sizes\")));\n\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen1;\n\n\tp1 = VARBITS(arg1);\n\tp2 = VARBITS(arg2);\n\tr = VARBITS(result);\n\tfor (i = 0; i < VARBITBYTES(arg1); i++)\n\t\t*r++ = *p1++ & *p2++;\n\n\t/* Padding is not needed as & of 0 pad is 0 */\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg2"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg1"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot AND bit strings of different sizes\"))"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot AND bit strings of different sizes\""
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_LENGTH_MISMATCH"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbit_and(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\ti;\n\tbits8\t   *p1,\n\t\t\t   *p2,\n\t\t\t   *r;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 != bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"cannot AND bit strings of different sizes\")));\n\n\tlen = VARSIZE(arg1);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen1;\n\n\tp1 = VARBITS(arg1);\n\tp2 = VARBITS(arg2);\n\tr = VARBITS(result);\n\tfor (i = 0; i < VARBITBYTES(arg1); i++)\n\t\t*r++ = *p1++ & *p2++;\n\n\t/* Padding is not needed as & of 0 pad is 0 */\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bitoctetlength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1195-1201",
    "snippet": "Datum\nbitoctetlength(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\n\tPG_RETURN_INT32(VARBITBYTES(arg));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "VARBITBYTES(arg)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitoctetlength(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\n\tPG_RETURN_INT32(VARBITBYTES(arg));\n}"
  },
  {
    "function_name": "bitlength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1187-1193",
    "snippet": "Datum\nbitlength(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\n\tPG_RETURN_INT32(VARBITLEN(arg));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "VARBITLEN(arg)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitlength(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\n\tPG_RETURN_INT32(VARBITLEN(arg));\n}"
  },
  {
    "function_name": "bit_overlay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1153-1181",
    "snippet": "static VarBit *\nbit_overlay(VarBit *t1, VarBit *t2, int sp, int sl)\n{\n\tVarBit\t   *result;\n\tVarBit\t   *s1;\n\tVarBit\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bitsubstring(t1, 1, sp - 1, false);\n\ts2 = bitsubstring(t1, sp_pl_sl, -1, true);\n\tresult = bit_catenate(s1, t2);\n\tresult = bit_catenate(result, s2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bit_catenate",
          "args": [
            "result",
            "s2"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "bit_catenate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "956-1007",
          "snippet": "static VarBit *\nbit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic VarBit *\nbit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitsubstring",
          "args": [
            "t1",
            "sp_pl_sl",
            "-1",
            "true"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "bitsubstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "1032-1121",
          "snippet": "static VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);\n\nstatic VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"integer out of range\""
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "sp",
            "sl",
            "&sp_pl_sl"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);\n\nstatic VarBit *\nbit_overlay(VarBit *t1, VarBit *t2, int sp, int sl)\n{\n\tVarBit\t   *result;\n\tVarBit\t   *s1;\n\tVarBit\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bitsubstring(t1, 1, sp - 1, false);\n\ts2 = bitsubstring(t1, sp_pl_sl, -1, true);\n\tresult = bit_catenate(s1, t2);\n\tresult = bit_catenate(result, s2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "bitoverlay_no_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1141-1151",
    "snippet": "Datum\nbitoverlay_no_len(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *t1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *t2 = PG_GETARG_VARBIT_P(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl;\n\n\tsl = VARBITLEN(t2);\t\t\t/* defaults to length(t2) */\n\tPG_RETURN_VARBIT_P(bit_overlay(t1, t2, sp, sl));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "bit_overlay(t1, t2, sp, sl)"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_overlay",
          "args": [
            "t1",
            "t2",
            "sp",
            "sl"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "bit_overlay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "1153-1181",
          "snippet": "static VarBit *\nbit_overlay(VarBit *t1, VarBit *t2, int sp, int sl)\n{\n\tVarBit\t   *result;\n\tVarBit\t   *s1;\n\tVarBit\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bitsubstring(t1, 1, sp - 1, false);\n\ts2 = bitsubstring(t1, sp_pl_sl, -1, true);\n\tresult = bit_catenate(s1, t2);\n\tresult = bit_catenate(result, s2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);\n\nstatic VarBit *\nbit_overlay(VarBit *t1, VarBit *t2, int sp, int sl)\n{\n\tVarBit\t   *result;\n\tVarBit\t   *s1;\n\tVarBit\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bitsubstring(t1, 1, sp - 1, false);\n\ts2 = bitsubstring(t1, sp_pl_sl, -1, true);\n\tresult = bit_catenate(s1, t2);\n\tresult = bit_catenate(result, s2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "t2"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);\n\nDatum\nbitoverlay_no_len(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *t1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *t2 = PG_GETARG_VARBIT_P(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl;\n\n\tsl = VARBITLEN(t2);\t\t\t/* defaults to length(t2) */\n\tPG_RETURN_VARBIT_P(bit_overlay(t1, t2, sp, sl));\n}"
  },
  {
    "function_name": "bitoverlay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1130-1139",
    "snippet": "Datum\nbitoverlay(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *t1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *t2 = PG_GETARG_VARBIT_P(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl = PG_GETARG_INT32(3);\t/* substring length */\n\n\tPG_RETURN_VARBIT_P(bit_overlay(t1, t2, sp, sl));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "bit_overlay(t1, t2, sp, sl)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_overlay",
          "args": [
            "t1",
            "t2",
            "sp",
            "sl"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "bit_overlay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "1153-1181",
          "snippet": "static VarBit *\nbit_overlay(VarBit *t1, VarBit *t2, int sp, int sl)\n{\n\tVarBit\t   *result;\n\tVarBit\t   *s1;\n\tVarBit\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bitsubstring(t1, 1, sp - 1, false);\n\ts2 = bitsubstring(t1, sp_pl_sl, -1, true);\n\tresult = bit_catenate(s1, t2);\n\tresult = bit_catenate(result, s2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);\n\nstatic VarBit *\nbit_overlay(VarBit *t1, VarBit *t2, int sp, int sl)\n{\n\tVarBit\t   *result;\n\tVarBit\t   *s1;\n\tVarBit\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bitsubstring(t1, 1, sp - 1, false);\n\ts2 = bitsubstring(t1, sp_pl_sl, -1, true);\n\tresult = bit_catenate(s1, t2);\n\tresult = bit_catenate(result, s2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_overlay(VarBit *t1, VarBit *t2, int sp, int sl);\n\nDatum\nbitoverlay(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *t1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *t2 = PG_GETARG_VARBIT_P(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl = PG_GETARG_INT32(3);\t/* substring length */\n\n\tPG_RETURN_VARBIT_P(bit_overlay(t1, t2, sp, sl));\n}"
  },
  {
    "function_name": "bitsubstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1032-1121",
    "snippet": "static VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARBITS(result)",
            "VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE",
            "len"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "rbitlen"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "0"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "e",
            "bitlen + 1"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"negative substring length not allowed\""
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SUBSTRING_ERROR"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "s",
            "1"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);\n\nstatic VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "bitsubstr_no_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1024-1030",
    "snippet": "Datum\nbitsubstr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_VARBIT_P(bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitsubstring",
          "args": [
            "PG_GETARG_VARBIT_P(0)",
            "PG_GETARG_INT32(1)",
            "-1",
            "true"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "bitsubstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "1032-1121",
          "snippet": "static VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);\n\nstatic VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitsubstr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_VARBIT_P(bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true));\n}"
  },
  {
    "function_name": "bitsubstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "1015-1022",
    "snippet": "Datum\nbitsubstr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_VARBIT_P(bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitsubstring",
          "args": [
            "PG_GETARG_VARBIT_P(0)",
            "PG_GETARG_INT32(1)",
            "PG_GETARG_INT32(2)",
            "false"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "bitsubstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "1032-1121",
          "snippet": "static VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bitsubstring(VarBit *arg, int32 s, int32 l,\n\t\t\t bool length_not_specified);\n\nstatic VarBit *\nbitsubstring(VarBit *arg, int32 s, int32 l, bool length_not_specified)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen,\n\t\t\t\trbitlen,\n\t\t\t\tlen,\n\t\t\t\tipad = 0,\n\t\t\t\tishift,\n\t\t\t\ti;\n\tint\t\t\te,\n\t\t\t\ts1,\n\t\t\t\te1;\n\tbits8\t\tmask,\n\t\t\t   *r,\n\t\t\t   *ps;\n\n\tbitlen = VARBITLEN(arg);\n\ts1 = Max(s, 1);\n\t/* If we do not have an upper bound, use end of string */\n\tif (length_not_specified)\n\t{\n\t\te1 = bitlen + 1;\n\t}\n\telse\n\t{\n\t\te = s + l;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (e < s)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\t\te1 = Min(e, bitlen + 1);\n\t}\n\tif (s1 > bitlen || e1 <= s1)\n\t{\n\t\t/* Need to return a zero-length bitstring */\n\t\tlen = VARBITTOTALLEN(0);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * OK, we've got a true substring starting at position s1-1 and ending\n\t\t * at position e1-1\n\t\t */\n\t\trbitlen = e1 - s1;\n\t\tlen = VARBITTOTALLEN(rbitlen);\n\t\tresult = (VarBit *) palloc(len);\n\t\tSET_VARSIZE(result, len);\n\t\tVARBITLEN(result) = rbitlen;\n\t\tlen -= VARHDRSZ + VARBITHDRSZ;\n\t\t/* Are we copying from a byte boundary? */\n\t\tif ((s1 - 1) % BITS_PER_BYTE == 0)\n\t\t{\n\t\t\t/* Yep, we are copying bytes */\n\t\t\tmemcpy(VARBITS(result), VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE,\n\t\t\t\t   len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Figure out how much we need to shift the sequence by */\n\t\t\tishift = (s1 - 1) % BITS_PER_BYTE;\n\t\t\tr = VARBITS(result);\n\t\t\tps = VARBITS(arg) + (s1 - 1) / BITS_PER_BYTE;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\t*r = (*ps << ishift) & BITMASK;\n\t\t\t\tif ((++ps) < VARBITEND(arg))\n\t\t\t\t\t*r |= *ps >> (BITS_PER_BYTE - ishift);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t/* Do we need to pad at the end? */\n\t\tipad = VARBITPAD(result);\n\t\tif (ipad > 0)\n\t\t{\n\t\t\tmask = BITMASK << ipad;\n\t\t\t*(VARBITS(result) + len - 1) &= mask;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbitsubstr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_VARBIT_P(bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse));\n}"
  },
  {
    "function_name": "bit_catenate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "956-1007",
    "snippet": "static VarBit *\nbit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "result"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITEND",
          "args": [
            "arg2"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg2"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARBITS(result) + VARBITBYTES(arg1)",
            "VARBITS(arg2)",
            "VARBITBYTES(arg2)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg2"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg2"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "arg1"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARBITS(result)",
            "VARBITS(arg1)",
            "VARBITBYTES(arg1)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "bytelen"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "bytelen"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "bitlen1 + bitlen2"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN))"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bit string length exceeds the maximum allowed (%d)\"",
            "VARBITMAXLEN"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic VarBit *\nbit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "bitcat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "947-954",
    "snippet": "Datum\nbitcat(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\n\tPG_RETURN_VARBIT_P(bit_catenate(arg1, arg2));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "bit_catenate(arg1, arg2)"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_catenate",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "bit_catenate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "956-1007",
          "snippet": "static VarBit *\nbit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic VarBit *\nbit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitcat(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\n\tPG_RETURN_VARBIT_P(bit_catenate(arg1, arg2));\n}"
  },
  {
    "function_name": "bitcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "928-941",
    "snippet": "Datum\nbitcmp(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tint32\t\tresult;\n\n\tresult = bit_cmp(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitcmp(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tint32\t\tresult;\n\n\tresult = bit_cmp(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "bitge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "913-926",
    "snippet": "Datum\nbitge(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) >= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitge(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) >= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bitgt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "898-911",
    "snippet": "Datum\nbitgt(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) > 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitgt(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) > 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bitle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "883-896",
    "snippet": "Datum\nbitle(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) <= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitle(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) <= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bitlt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "868-881",
    "snippet": "Datum\nbitlt(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) < 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitlt(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\n\tresult = (bit_cmp(arg1, arg2) < 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bitne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "844-866",
    "snippet": "Datum\nbitne(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\t/* fast path for different-length inputs */\n\tif (bitlen1 != bitlen2)\n\t\tresult = true;\n\telse\n\t\tresult = (bit_cmp(arg1, arg2) != 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbitne(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\t/* fast path for different-length inputs */\n\tif (bitlen1 != bitlen2)\n\t\tresult = true;\n\telse\n\t\tresult = (bit_cmp(arg1, arg2) != 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "biteq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "820-842",
    "snippet": "Datum\nbiteq(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\t/* fast path for different-length inputs */\n\tif (bitlen1 != bitlen2)\n\t\tresult = false;\n\telse\n\t\tresult = (bit_cmp(arg1, arg2) == 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_cmp",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "bit_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "797-818",
          "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "1"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nDatum\nbiteq(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tbool\t\tresult;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2;\n\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\n\t/* fast path for different-length inputs */\n\tif (bitlen1 != bitlen2)\n\t\tresult = false;\n\telse\n\t\tresult = (bit_cmp(arg1, arg2) == 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bit_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "797-818",
    "snippet": "static int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg2"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg1"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARBITS(arg1)",
            "VARBITS(arg2)",
            "Min(bytelen1, bytelen2)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "bytelen1",
            "bytelen2"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg2"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg1"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg2"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg1"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic VarBit *bit_catenate(VarBit *arg1, VarBit *arg2);\n\nstatic int32\nbit_cmp(VarBit *arg1, VarBit *arg2)\n{\n\tint\t\t\tbitlen1,\n\t\t\t\tbytelen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen2;\n\tint32\t\tcmp;\n\n\tbytelen1 = VARBITBYTES(arg1);\n\tbytelen2 = VARBITBYTES(arg2);\n\n\tcmp = memcmp(VARBITS(arg1), VARBITS(arg2), Min(bytelen1, bytelen2));\n\tif (cmp == 0)\n\t{\n\t\tbitlen1 = VARBITLEN(arg1);\n\t\tbitlen2 = VARBITLEN(arg2);\n\t\tif (bitlen1 != bitlen2)\n\t\t\tcmp = (bitlen1 < bitlen2) ? -1 : 1;\n\t}\n\treturn cmp;\n}"
  },
  {
    "function_name": "varbittypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "761-767",
    "snippet": "Datum\nvarbittypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anybit_typmodout(typmod));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anybit_typmodout(typmod)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anybit_typmodout",
          "args": [
            "typmod"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "anybit_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "75-86",
          "snippet": "static char *\nanybit_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod >= 0)\n\t\tsnprintf(res, 64, \"(%d)\", typmod);\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *\nanybit_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod >= 0)\n\t\tsnprintf(res, 64, \"(%d)\", typmod);\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbittypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anybit_typmodout(typmod));\n}"
  },
  {
    "function_name": "varbittypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "753-759",
    "snippet": "Datum\nvarbittypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anybit_typmodin(ta, \"varbit\"));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anybit_typmodin(ta, \"varbit\")"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anybit_typmodin",
          "args": [
            "ta",
            "\"varbit\""
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "anybit_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "38-70",
          "snippet": "static int32\nanybit_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for BIT\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename)));\n\tif (*tl > (MaxAttrSize * BITS_PER_BYTE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE)));\n\n\ttypmod = *tl;\n\n\treturn typmod;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic int32\nanybit_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for BIT\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename)));\n\tif (*tl > (MaxAttrSize * BITS_PER_BYTE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE)));\n\n\ttypmod = *tl;\n\n\treturn typmod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbittypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anybit_typmodin(ta, \"varbit\"));\n}"
  },
  {
    "function_name": "varbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "714-751",
    "snippet": "Datum\nvarbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tVarBit\t   *result;\n\tint\t\t\trlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\t/* No work if typmod is invalid or supplied data matches it already */\n\tif (len <= 0 || len >= VARBITLEN(arg))\n\t\tPG_RETURN_VARBIT_P(arg);\n\n\tif (!isExplicit)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tlen)));\n\n\trlen = VARBITTOTALLEN(len);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = len;\n\n\tmemcpy(VARBITS(result), VARBITS(arg), VARBITBYTES(result));\n\n\t/* Make sure last byte is zero-padded if needed */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARBITS(result)",
            "VARBITS(arg)",
            "VARBITBYTES(result)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "rlen"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "rlen"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "len"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tlen))"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bit string too long for type bit varying(%d)\"",
            "len"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_RIGHT_TRUNCATION"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "arg"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tVarBit\t   *result;\n\tint\t\t\trlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\t/* No work if typmod is invalid or supplied data matches it already */\n\tif (len <= 0 || len >= VARBITLEN(arg))\n\t\tPG_RETURN_VARBIT_P(arg);\n\n\tif (!isExplicit)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tlen)));\n\n\trlen = VARBITTOTALLEN(len);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = len;\n\n\tmemcpy(VARBITS(result), VARBITS(arg), VARBITBYTES(result));\n\n\t/* Make sure last byte is zero-padded if needed */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "varbit_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "680-704",
    "snippet": "Datum\nvarbit_transform(PG_FUNCTION_ARGS)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, PG_GETARG_POINTER(0));\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\tnew_typmod = DatumGetInt32(((Const *) typmod)->constvalue);\n\t\tint32\t\told_max = exprTypmod(source);\n\t\tint32\t\tnew_max = new_typmod;\n\n\t\t/* Note: varbit() treats typmod 0 as invalid, so we do too */\n\t\tif (new_max <= 0 || (old_max > 0 && old_max <= new_max))\n\t\t\tret = relabel_to_typmod(source, new_typmod);\n\t}\n\n\tPG_RETURN_POINTER(ret);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "ret"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relabel_to_typmod",
          "args": [
            "source",
            "new_typmod"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprTypmod",
          "args": [
            "source"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "((Const *) typmod)->constvalue"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "expr->args"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "typmod",
            "Const"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "expr->args"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list_length(expr->args) >= 2"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "expr->args"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "FuncExpr",
            "PG_GETARG_POINTER(0)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_transform(PG_FUNCTION_ARGS)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, PG_GETARG_POINTER(0));\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\tnew_typmod = DatumGetInt32(((Const *) typmod)->constvalue);\n\t\tint32\t\told_max = exprTypmod(source);\n\t\tint32\t\tnew_max = new_typmod;\n\n\t\t/* Note: varbit() treats typmod 0 as invalid, so we do too */\n\t\tif (new_max <= 0 || (old_max > 0 && old_max <= new_max))\n\t\t\tret = relabel_to_typmod(source, new_typmod);\n\t}\n\n\tPG_RETURN_POINTER(ret);\n}"
  },
  {
    "function_name": "varbit_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "662-672",
    "snippet": "Datum\nvarbit_send(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, VARBITLEN(s));\n\tpq_sendbytes(&buf, (char *) VARBITS(s), VARBITBYTES(s));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbytes",
          "args": [
            "&buf",
            "(char *) VARBITS(s)",
            "VARBITBYTES(s)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "s"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "s"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "VARBITLEN(s)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "s"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_send(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, VARBITLEN(s));\n\tpq_sendbytes(&buf, (char *) VARBITS(s), VARBITBYTES(s));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "varbit_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "610-657",
    "snippet": "Datum\nvarbit_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\tbitlen = pq_getmsgint(buf, sizeof(int32));\n\tif (bitlen < 0 || bitlen > VARBITMAXLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid length in external bit string\")));\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod > 0 && bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen;\n\n\tpq_copymsgbytes(buf, (char *) VARBITS(result), VARBITBYTES(result));\n\n\t/* Make sure last byte is zero-padded if needed */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_copymsgbytes",
          "args": [
            "buf",
            "(char *) VARBITS(result)",
            "VARBITBYTES(result)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "bitlen"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod))"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bit string too long for type bit varying(%d)\"",
            "atttypmod"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_RIGHT_TRUNCATION"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid length in external bit string\"))"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int32)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\tbitlen = pq_getmsgint(buf, sizeof(int32));\n\tif (bitlen < 0 || bitlen > VARBITMAXLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid length in external bit string\")));\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod > 0 && bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen;\n\n\tpq_copymsgbytes(buf, (char *) VARBITS(result), VARBITBYTES(result));\n\n\t/* Make sure last byte is zero-padded if needed */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "varbit_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "564-603",
    "snippet": "Datum\nvarbit_out(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tchar\t   *result,\n\t\t\t   *r;\n\tbits8\t   *sp;\n\tbits8\t\tx;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tlen;\n\n\tlen = VARBITLEN(s);\n\tresult = (char *) palloc(len + 1);\n\tsp = VARBITS(s);\n\tr = result;\n\tfor (i = 0; i <= len - BITS_PER_BYTE; i += BITS_PER_BYTE, sp++)\n\t{\n\t\t/* print full bytes */\n\t\tx = *sp;\n\t\tfor (k = 0; k < BITS_PER_BYTE; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\tif (i < len)\n\t{\n\t\t/* print the last partial byte */\n\t\tx = *sp;\n\t\tfor (k = i; k < len; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\t*r = '\\0';\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "x"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "x"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "s"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 1"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "s"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_out(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tchar\t   *result,\n\t\t\t   *r;\n\tbits8\t   *sp;\n\tbits8\t\tx;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tlen;\n\n\tlen = VARBITLEN(s);\n\tresult = (char *) palloc(len + 1);\n\tsp = VARBITS(s);\n\tr = result;\n\tfor (i = 0; i <= len - BITS_PER_BYTE; i += BITS_PER_BYTE, sp++)\n\t{\n\t\t/* print full bytes */\n\t\tx = *sp;\n\t\tfor (k = 0; k < BITS_PER_BYTE; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\tif (i < len)\n\t{\n\t\t/* print the last partial byte */\n\t\tx = *sp;\n\t\tfor (k = i; k < len; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\t*r = '\\0';\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "varbit_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "429-555",
    "snippet": "Datum\nvarbit_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_string = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\t\t\t/* The resulting bit string\t\t\t  */\n\tchar\t   *sp;\t\t\t\t/* pointer into the character string  */\n\tbits8\t   *r;\t\t\t\t/* pointer into the result */\n\tint\t\t\tlen,\t\t\t/* Length of the whole data structure */\n\t\t\t\tbitlen,\t\t\t/* Number of bits in the bit string   */\n\t\t\t\tslen;\t\t\t/* Length of the input string\t\t  */\n\tbool\t\tbit_not_hex;\t/* false = hex string  true = bit string */\n\tint\t\t\tbc;\n\tbits8\t\tx = 0;\n\n\t/* Check that the first character is a b or an x */\n\tif (input_string[0] == 'b' || input_string[0] == 'B')\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string + 1;\n\t}\n\telse if (input_string[0] == 'x' || input_string[0] == 'X')\n\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\t/*\n\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n\t * input is small enough, but we must check hex input.\n\t */\n\tslen = strlen(sp);\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t{\n\t\tif (slen > VARBITMAXLEN / 4)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tVARBITMAXLEN)));\n\t\tbitlen = slen * 4;\n\t}\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\t/* set to 0 so that *r is always initialised and string is zero-padded */\n\tresult = (VarBit *) palloc0(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = Min(bitlen, atttypmod);\n\n\tr = VARBITS(result);\n\tif (bit_not_hex)\n\t{\n\t\t/* Parse the bit representation of the string */\n\t\t/* We know it fits, as bitlen was compared to atttypmod */\n\t\tx = HIGHBIT;\n\t\tfor (; *sp; sp++)\n\t\t{\n\t\t\tif (*sp == '1')\n\t\t\t\t*r |= x;\n\t\t\telse if (*sp != '0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tx >>= 1;\n\t\t\tif (x == 0)\n\t\t\t{\n\t\t\t\tx = HIGHBIT;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Parse the hex representation of the string */\n\t\tfor (bc = 0; *sp; sp++)\n\t\t{\n\t\t\tif (*sp >= '0' && *sp <= '9')\n\t\t\t\tx = (bits8) (*sp - '0');\n\t\t\telse if (*sp >= 'A' && *sp <= 'F')\n\t\t\t\tx = (bits8) (*sp - 'A') + 10;\n\t\t\telse if (*sp >= 'a' && *sp <= 'f')\n\t\t\t\tx = (bits8) (*sp - 'a') + 10;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tif (bc)\n\t\t\t{\n\t\t\t\t*r++ |= x;\n\t\t\t\tbc = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r = x << 4;\n\t\t\t\tbc = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp))"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"%c\\\" is not a valid hexadecimal digit\"",
            "*sp"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*sp - 'a'"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*sp - 'A'"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*sp - '0'"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp))"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "bitlen",
            "atttypmod"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "len"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "bitlen"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod))"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tVARBITMAXLEN))"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sp"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_string = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\t\t\t/* The resulting bit string\t\t\t  */\n\tchar\t   *sp;\t\t\t\t/* pointer into the character string  */\n\tbits8\t   *r;\t\t\t\t/* pointer into the result */\n\tint\t\t\tlen,\t\t\t/* Length of the whole data structure */\n\t\t\t\tbitlen,\t\t\t/* Number of bits in the bit string   */\n\t\t\t\tslen;\t\t\t/* Length of the input string\t\t  */\n\tbool\t\tbit_not_hex;\t/* false = hex string  true = bit string */\n\tint\t\t\tbc;\n\tbits8\t\tx = 0;\n\n\t/* Check that the first character is a b or an x */\n\tif (input_string[0] == 'b' || input_string[0] == 'B')\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string + 1;\n\t}\n\telse if (input_string[0] == 'x' || input_string[0] == 'X')\n\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\t/*\n\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n\t * input is small enough, but we must check hex input.\n\t */\n\tslen = strlen(sp);\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t{\n\t\tif (slen > VARBITMAXLEN / 4)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tVARBITMAXLEN)));\n\t\tbitlen = slen * 4;\n\t}\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\t/* set to 0 so that *r is always initialised and string is zero-padded */\n\tresult = (VarBit *) palloc0(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = Min(bitlen, atttypmod);\n\n\tr = VARBITS(result);\n\tif (bit_not_hex)\n\t{\n\t\t/* Parse the bit representation of the string */\n\t\t/* We know it fits, as bitlen was compared to atttypmod */\n\t\tx = HIGHBIT;\n\t\tfor (; *sp; sp++)\n\t\t{\n\t\t\tif (*sp == '1')\n\t\t\t\t*r |= x;\n\t\t\telse if (*sp != '0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tx >>= 1;\n\t\t\tif (x == 0)\n\t\t\t{\n\t\t\t\tx = HIGHBIT;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Parse the hex representation of the string */\n\t\tfor (bc = 0; *sp; sp++)\n\t\t{\n\t\t\tif (*sp >= '0' && *sp <= '9')\n\t\t\t\tx = (bits8) (*sp - '0');\n\t\t\telse if (*sp >= 'A' && *sp <= 'F')\n\t\t\t\tx = (bits8) (*sp - 'A') + 10;\n\t\t\telse if (*sp >= 'a' && *sp <= 'f')\n\t\t\t\tx = (bits8) (*sp - 'a') + 10;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tif (bc)\n\t\t\t{\n\t\t\t\t*r++ |= x;\n\t\t\t\tbc = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r = x << 4;\n\t\t\t\tbc = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bittypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "414-420",
    "snippet": "Datum\nbittypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anybit_typmodout(typmod));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anybit_typmodout(typmod)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anybit_typmodout",
          "args": [
            "typmod"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "anybit_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "75-86",
          "snippet": "static char *\nanybit_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod >= 0)\n\t\tsnprintf(res, 64, \"(%d)\", typmod);\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *\nanybit_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod >= 0)\n\t\tsnprintf(res, 64, \"(%d)\", typmod);\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbittypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anybit_typmodout(typmod));\n}"
  },
  {
    "function_name": "bittypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "406-412",
    "snippet": "Datum\nbittypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anybit_typmodin(ta, \"bit\"));\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anybit_typmodin(ta, \"bit\")"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anybit_typmodin",
          "args": [
            "ta",
            "\"bit\""
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "anybit_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "38-70",
          "snippet": "static int32\nanybit_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for BIT\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename)));\n\tif (*tl > (MaxAttrSize * BITS_PER_BYTE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE)));\n\n\ttypmod = *tl;\n\n\treturn typmod;\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic int32\nanybit_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for BIT\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename)));\n\tif (*tl > (MaxAttrSize * BITS_PER_BYTE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE)));\n\n\ttypmod = *tl;\n\n\treturn typmod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbittypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anybit_typmodin(ta, \"bit\"));\n}"
  },
  {
    "function_name": "bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "361-404",
    "snippet": "Datum\nbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tVarBit\t   *result;\n\tint\t\t\trlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\t/* No work if typmod is invalid or supplied data matches it already */\n\tif (len <= 0 || len > VARBITMAXLEN || len == VARBITLEN(arg))\n\t\tPG_RETURN_VARBIT_P(arg);\n\n\tif (!isExplicit)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tVARBITLEN(arg), len)));\n\n\trlen = VARBITTOTALLEN(len);\n\t/* set to 0 so that string is zero-padded */\n\tresult = (VarBit *) palloc0(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = len;\n\n\tmemcpy(VARBITS(result), VARBITS(arg),\n\t\t   Min(VARBITBYTES(result), VARBITBYTES(arg)));\n\n\t/*\n\t * Make sure last byte is zero-padded if needed.  This is useless but safe\n\t * if source data was shorter than target length (we assume the last byte\n\t * of the source data was itself correctly zero-padded).\n\t */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARBITS(result)",
            "VARBITS(arg)",
            "Min(VARBITBYTES(result), VARBITBYTES(arg))"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "VARBITBYTES(result)",
            "VARBITBYTES(arg)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "arg"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "arg"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "rlen"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "rlen"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "len"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tVARBITLEN(arg), len))"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bit string length %d does not match type bit(%d)\"",
            "VARBITLEN(arg)",
            "len"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_LENGTH_MISMATCH"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "arg"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "arg"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbit(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tVarBit\t   *result;\n\tint\t\t\trlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\t/* No work if typmod is invalid or supplied data matches it already */\n\tif (len <= 0 || len > VARBITMAXLEN || len == VARBITLEN(arg))\n\t\tPG_RETURN_VARBIT_P(arg);\n\n\tif (!isExplicit)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tVARBITLEN(arg), len)));\n\n\trlen = VARBITTOTALLEN(len);\n\t/* set to 0 so that string is zero-padded */\n\tresult = (VarBit *) palloc0(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = len;\n\n\tmemcpy(VARBITS(result), VARBITS(arg),\n\t\t   Min(VARBITBYTES(result), VARBITBYTES(arg)));\n\n\t/*\n\t * Make sure last byte is zero-padded if needed.  This is useless but safe\n\t * if source data was shorter than target length (we assume the last byte\n\t * of the source data was itself correctly zero-padded).\n\t */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bit_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "346-351",
    "snippet": "Datum\nbit_send(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as varbit_send, so share code */\n\treturn varbit_send(fcinfo);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "varbit_send",
          "args": [
            "fcinfo"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "varbit_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "662-672",
          "snippet": "Datum\nvarbit_send(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, VARBITLEN(s));\n\tpq_sendbytes(&buf, (char *) VARBITS(s), VARBITBYTES(s));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_send(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, VARBITLEN(s));\n\tpq_sendbytes(&buf, (char *) VARBITS(s), VARBITBYTES(s));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbit_send(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as varbit_send, so share code */\n\treturn varbit_send(fcinfo);\n}"
  },
  {
    "function_name": "bit_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "294-341",
    "snippet": "Datum\nbit_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\tbitlen = pq_getmsgint(buf, sizeof(int32));\n\tif (bitlen < 0 || bitlen > VARBITMAXLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid length in external bit string\")));\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod > 0 && bitlen != atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tbitlen, atttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen;\n\n\tpq_copymsgbytes(buf, (char *) VARBITS(result), VARBITBYTES(result));\n\n\t/* Make sure last byte is zero-padded if needed */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITPAD",
          "args": [
            "result"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_copymsgbytes",
          "args": [
            "buf",
            "(char *) VARBITS(result)",
            "VARBITBYTES(result)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITBYTES",
          "args": [
            "result"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "bitlen"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tbitlen, atttypmod))"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"bit string length %d does not match type bit(%d)\"",
            "bitlen",
            "atttypmod"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_LENGTH_MISMATCH"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid length in external bit string\"))"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int32)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbit_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\n\tint\t\t\tlen,\n\t\t\t\tbitlen;\n\tint\t\t\tipad;\n\tbits8\t\tmask;\n\n\tbitlen = pq_getmsgint(buf, sizeof(int32));\n\tif (bitlen < 0 || bitlen > VARBITMAXLEN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid length in external bit string\")));\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod > 0 && bitlen != atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tbitlen, atttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\tresult = (VarBit *) palloc(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = bitlen;\n\n\tpq_copymsgbytes(buf, (char *) VARBITS(result), VARBITBYTES(result));\n\n\t/* Make sure last byte is zero-padded if needed */\n\tipad = VARBITPAD(result);\n\tif (ipad > 0)\n\t{\n\t\tmask = BITMASK << ipad;\n\t\t*(VARBITS(result) + VARBITBYTES(result) - 1) &= mask;\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "bit_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "246-289",
    "snippet": "Datum\nbit_out(PG_FUNCTION_ARGS)\n{\n#if 1\n\t/* same as varbit output */\n\treturn varbit_out(fcinfo);\n#else\n\n\t/*\n\t * This is how one would print a hex string, in case someone wants to\n\t * write a formatting function.\n\t */\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tchar\t   *result,\n\t\t\t   *r;\n\tbits8\t   *sp;\n\tint\t\t\ti,\n\t\t\t\tlen,\n\t\t\t\tbitlen;\n\n\tbitlen = VARBITLEN(s);\n\tlen = (bitlen + 3) / 4;\n\tresult = (char *) palloc(len + 2);\n\tsp = VARBITS(s);\n\tr = result;\n\t*r++ = 'X';\n\t/* we cheat by knowing that we store full bytes zero padded */\n\tfor (i = 0; i < len; i += 2, sp++)\n\t{\n\t\t*r++ = HEXDIG((*sp) >> 4);\n\t\t*r++ = HEXDIG((*sp) & 0xF);\n\t}\n\n\t/*\n\t * Go back one step if we printed a hex number that was not part of the\n\t * bitstring anymore\n\t */\n\tif (i > len)\n\t\tr--;\n\t*r = '\\0';\n\n\tPG_RETURN_CSTRING(result);\n#endif\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEXDIG",
          "args": [
            "(*sp) & 0xF"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEXDIG",
          "args": [
            "(*sp) >> 4"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "s"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 2"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "s"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARBIT_P",
          "args": [
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varbit_out",
          "args": [
            "fcinfo"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "varbit_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
          "lines": "564-603",
          "snippet": "Datum\nvarbit_out(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tchar\t   *result,\n\t\t\t   *r;\n\tbits8\t   *sp;\n\tbits8\t\tx;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tlen;\n\n\tlen = VARBITLEN(s);\n\tresult = (char *) palloc(len + 1);\n\tsp = VARBITS(s);\n\tr = result;\n\tfor (i = 0; i <= len - BITS_PER_BYTE; i += BITS_PER_BYTE, sp++)\n\t{\n\t\t/* print full bytes */\n\t\tx = *sp;\n\t\tfor (k = 0; k < BITS_PER_BYTE; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\tif (i < len)\n\t{\n\t\t/* print the last partial byte */\n\t\tx = *sp;\n\t\tfor (k = i; k < len; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\t*r = '\\0';\n\n\tPG_RETURN_CSTRING(result);\n}",
          "includes": [
            "#include \"utils/varbit.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nvarbit_out(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tchar\t   *result,\n\t\t\t   *r;\n\tbits8\t   *sp;\n\tbits8\t\tx;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tlen;\n\n\tlen = VARBITLEN(s);\n\tresult = (char *) palloc(len + 1);\n\tsp = VARBITS(s);\n\tr = result;\n\tfor (i = 0; i <= len - BITS_PER_BYTE; i += BITS_PER_BYTE, sp++)\n\t{\n\t\t/* print full bytes */\n\t\tx = *sp;\n\t\tfor (k = 0; k < BITS_PER_BYTE; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\tif (i < len)\n\t{\n\t\t/* print the last partial byte */\n\t\tx = *sp;\n\t\tfor (k = i; k < len; k++)\n\t\t{\n\t\t\t*r++ = IS_HIGHBIT_SET(x) ? '1' : '0';\n\t\t\tx <<= 1;\n\t\t}\n\t}\n\t*r = '\\0';\n\n\tPG_RETURN_CSTRING(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbit_out(PG_FUNCTION_ARGS)\n{\n#if 1\n\t/* same as varbit output */\n\treturn varbit_out(fcinfo);\n#else\n\n\t/*\n\t * This is how one would print a hex string, in case someone wants to\n\t * write a formatting function.\n\t */\n\tVarBit\t   *s = PG_GETARG_VARBIT_P(0);\n\tchar\t   *result,\n\t\t\t   *r;\n\tbits8\t   *sp;\n\tint\t\t\ti,\n\t\t\t\tlen,\n\t\t\t\tbitlen;\n\n\tbitlen = VARBITLEN(s);\n\tlen = (bitlen + 3) / 4;\n\tresult = (char *) palloc(len + 2);\n\tsp = VARBITS(s);\n\tr = result;\n\t*r++ = 'X';\n\t/* we cheat by knowing that we store full bytes zero padded */\n\tfor (i = 0; i < len; i += 2, sp++)\n\t{\n\t\t*r++ = HEXDIG((*sp) >> 4);\n\t\t*r++ = HEXDIG((*sp) & 0xF);\n\t}\n\n\t/*\n\t * Go back one step if we printed a hex number that was not part of the\n\t * bitstring anymore\n\t */\n\tif (i > len)\n\t\tr--;\n\t*r = '\\0';\n\n\tPG_RETURN_CSTRING(result);\n#endif\n}"
  },
  {
    "function_name": "bit_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "113-243",
    "snippet": "Datum\nbit_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_string = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\t\t\t/* The resulting bit string\t\t\t  */\n\tchar\t   *sp;\t\t\t\t/* pointer into the character string  */\n\tbits8\t   *r;\t\t\t\t/* pointer into the result */\n\tint\t\t\tlen,\t\t\t/* Length of the whole data structure */\n\t\t\t\tbitlen,\t\t\t/* Number of bits in the bit string   */\n\t\t\t\tslen;\t\t\t/* Length of the input string\t\t  */\n\tbool\t\tbit_not_hex;\t/* false = hex string  true = bit string */\n\tint\t\t\tbc;\n\tbits8\t\tx = 0;\n\n\t/* Check that the first character is a b or an x */\n\tif (input_string[0] == 'b' || input_string[0] == 'B')\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string + 1;\n\t}\n\telse if (input_string[0] == 'x' || input_string[0] == 'X')\n\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise it's binary.  This allows things like cast('1001' as bit)\n\t\t * to work transparently.\n\t\t */\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\t/*\n\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n\t * input is small enough, but we must check hex input.\n\t */\n\tslen = strlen(sp);\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t{\n\t\tif (slen > VARBITMAXLEN / 4)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tVARBITMAXLEN)));\n\t\tbitlen = slen * 4;\n\t}\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen != atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tbitlen, atttypmod)));\n\n\tlen = VARBITTOTALLEN(atttypmod);\n\t/* set to 0 so that *r is always initialised and string is zero-padded */\n\tresult = (VarBit *) palloc0(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = atttypmod;\n\n\tr = VARBITS(result);\n\tif (bit_not_hex)\n\t{\n\t\t/* Parse the bit representation of the string */\n\t\t/* We know it fits, as bitlen was compared to atttypmod */\n\t\tx = HIGHBIT;\n\t\tfor (; *sp; sp++)\n\t\t{\n\t\t\tif (*sp == '1')\n\t\t\t\t*r |= x;\n\t\t\telse if (*sp != '0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tx >>= 1;\n\t\t\tif (x == 0)\n\t\t\t{\n\t\t\t\tx = HIGHBIT;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Parse the hex representation of the string */\n\t\tfor (bc = 0; *sp; sp++)\n\t\t{\n\t\t\tif (*sp >= '0' && *sp <= '9')\n\t\t\t\tx = (bits8) (*sp - '0');\n\t\t\telse if (*sp >= 'A' && *sp <= 'F')\n\t\t\t\tx = (bits8) (*sp - 'A') + 10;\n\t\t\telse if (*sp >= 'a' && *sp <= 'f')\n\t\t\t\tx = (bits8) (*sp - 'a') + 10;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tif (bc)\n\t\t\t{\n\t\t\t\t*r++ |= x;\n\t\t\t\tbc = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r = x << 4;\n\t\t\t\tbc = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARBIT_P",
          "args": [
            "result"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp))"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"%c\\\" is not a valid hexadecimal digit\"",
            "*sp"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*sp - 'a'"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*sp - 'A'"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*sp - '0'"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp))"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITS",
          "args": [
            "result"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARBITLEN",
          "args": [
            "result"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "len"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARBITTOTALLEN",
          "args": [
            "atttypmod"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tbitlen, atttypmod))"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tVARBITMAXLEN))"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nbit_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_string = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\t\t\t/* The resulting bit string\t\t\t  */\n\tchar\t   *sp;\t\t\t\t/* pointer into the character string  */\n\tbits8\t   *r;\t\t\t\t/* pointer into the result */\n\tint\t\t\tlen,\t\t\t/* Length of the whole data structure */\n\t\t\t\tbitlen,\t\t\t/* Number of bits in the bit string   */\n\t\t\t\tslen;\t\t\t/* Length of the input string\t\t  */\n\tbool\t\tbit_not_hex;\t/* false = hex string  true = bit string */\n\tint\t\t\tbc;\n\tbits8\t\tx = 0;\n\n\t/* Check that the first character is a b or an x */\n\tif (input_string[0] == 'b' || input_string[0] == 'B')\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string + 1;\n\t}\n\telse if (input_string[0] == 'x' || input_string[0] == 'X')\n\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise it's binary.  This allows things like cast('1001' as bit)\n\t\t * to work transparently.\n\t\t */\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\t/*\n\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n\t * input is small enough, but we must check hex input.\n\t */\n\tslen = strlen(sp);\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t{\n\t\tif (slen > VARBITMAXLEN / 4)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tVARBITMAXLEN)));\n\t\tbitlen = slen * 4;\n\t}\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen != atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_LENGTH_MISMATCH),\n\t\t\t\t errmsg(\"bit string length %d does not match type bit(%d)\",\n\t\t\t\t\t\tbitlen, atttypmod)));\n\n\tlen = VARBITTOTALLEN(atttypmod);\n\t/* set to 0 so that *r is always initialised and string is zero-padded */\n\tresult = (VarBit *) palloc0(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = atttypmod;\n\n\tr = VARBITS(result);\n\tif (bit_not_hex)\n\t{\n\t\t/* Parse the bit representation of the string */\n\t\t/* We know it fits, as bitlen was compared to atttypmod */\n\t\tx = HIGHBIT;\n\t\tfor (; *sp; sp++)\n\t\t{\n\t\t\tif (*sp == '1')\n\t\t\t\t*r |= x;\n\t\t\telse if (*sp != '0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tx >>= 1;\n\t\t\tif (x == 0)\n\t\t\t{\n\t\t\t\tx = HIGHBIT;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Parse the hex representation of the string */\n\t\tfor (bc = 0; *sp; sp++)\n\t\t{\n\t\t\tif (*sp >= '0' && *sp <= '9')\n\t\t\t\tx = (bits8) (*sp - '0');\n\t\t\telse if (*sp >= 'A' && *sp <= 'F')\n\t\t\t\tx = (bits8) (*sp - 'A') + 10;\n\t\t\telse if (*sp >= 'a' && *sp <= 'f')\n\t\t\t\tx = (bits8) (*sp - 'a') + 10;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tif (bc)\n\t\t\t{\n\t\t\t\t*r++ |= x;\n\t\t\t\tbc = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r = x << 4;\n\t\t\t\tbc = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}"
  },
  {
    "function_name": "anybit_typmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "75-86",
    "snippet": "static char *\nanybit_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod >= 0)\n\t\tsnprintf(res, 64, \"(%d)\", typmod);\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "res",
            "64",
            "\"(%d)\"",
            "typmod"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "64"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *\nanybit_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod >= 0)\n\t\tsnprintf(res, 64, \"(%d)\", typmod);\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}"
  },
  {
    "function_name": "anybit_typmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varbit.c",
    "lines": "38-70",
    "snippet": "static int32\nanybit_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for BIT\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename)));\n\tif (*tl > (MaxAttrSize * BITS_PER_BYTE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE)));\n\n\ttypmod = *tl;\n\n\treturn typmod;\n}",
    "includes": [
      "#include \"utils/varbit.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE))"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"length for type %s cannot exceed %d\"",
            "typename",
            "MaxAttrSize * BITS_PER_BYTE"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename))"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\"))"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetIntegerTypmods",
          "args": [
            "ta",
            "&n"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetIntegerTypmods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "199-235",
          "snippet": "int32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varbit.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic int32\nanybit_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for BIT\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\",\n\t\t\t\t\t\ttypename)));\n\tif (*tl > (MaxAttrSize * BITS_PER_BYTE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize * BITS_PER_BYTE)));\n\n\ttypmod = *tl;\n\n\treturn typmod;\n}"
  }
]