[
  {
    "function_name": "gin_tsquery_consistent_oldsig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "419-423",
    "snippet": "Datum\ngin_tsquery_consistent_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_tsquery_consistent(fcinfo);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gin_tsquery_consistent",
          "args": [
            "fcinfo"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "gin_tsquery_consistent_oldsig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "419-423",
          "snippet": "Datum\ngin_tsquery_consistent_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_tsquery_consistent(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_tsquery_consistent_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_tsquery_consistent(fcinfo);\n}"
  },
  {
    "function_name": "gin_extract_tsquery_oldsig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "409-413",
    "snippet": "Datum\ngin_extract_tsquery_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_extract_tsquery(fcinfo);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gin_extract_tsquery",
          "args": [
            "fcinfo"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "gin_extract_tsquery_oldsig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "409-413",
          "snippet": "Datum\ngin_extract_tsquery_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_extract_tsquery(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_tsquery_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_extract_tsquery(fcinfo);\n}"
  },
  {
    "function_name": "gin_tsquery_consistent_6args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "397-403",
    "snippet": "Datum\ngin_tsquery_consistent_6args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 8)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_tsquery_consistent requires eight arguments\");\n\treturn gin_tsquery_consistent(fcinfo);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gin_tsquery_consistent",
          "args": [
            "fcinfo"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "gin_tsquery_consistent_oldsig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "419-423",
          "snippet": "Datum\ngin_tsquery_consistent_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_tsquery_consistent(fcinfo);\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_tsquery_consistent_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_tsquery_consistent(fcinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"gin_tsquery_consistent requires eight arguments\""
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_tsquery_consistent_6args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 8)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_tsquery_consistent requires eight arguments\");\n\treturn gin_tsquery_consistent(fcinfo);\n}"
  },
  {
    "function_name": "gin_extract_tsquery_5args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "385-391",
    "snippet": "Datum\ngin_extract_tsquery_5args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 7)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_extract_tsquery requires seven arguments\");\n\treturn gin_extract_tsquery(fcinfo);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gin_extract_tsquery",
          "args": [
            "fcinfo"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "gin_extract_tsquery_oldsig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "409-413",
          "snippet": "Datum\ngin_extract_tsquery_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_extract_tsquery(fcinfo);\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_tsquery_oldsig(PG_FUNCTION_ARGS)\n{\n\treturn gin_extract_tsquery(fcinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"gin_extract_tsquery requires seven arguments\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_tsquery_5args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 7)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_extract_tsquery requires seven arguments\");\n\treturn gin_extract_tsquery(fcinfo);\n}"
  },
  {
    "function_name": "gin_extract_tsvector_2args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "373-379",
    "snippet": "Datum\ngin_extract_tsvector_2args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 3)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_extract_tsvector requires three arguments\");\n\treturn gin_extract_tsvector(fcinfo);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gin_extract_tsvector",
          "args": [
            "fcinfo"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "gin_extract_tsvector_2args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "373-379",
          "snippet": "Datum\ngin_extract_tsvector_2args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 3)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_extract_tsvector requires three arguments\");\n\treturn gin_extract_tsvector(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"gin_extract_tsvector requires three arguments\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_tsvector_2args(PG_FUNCTION_ARGS)\n{\n\tif (PG_NARGS() < 3)\t\t\t/* should not happen */\n\t\telog(ERROR, \"gin_extract_tsvector requires three arguments\");\n\treturn gin_extract_tsvector(fcinfo);\n}"
  },
  {
    "function_name": "gin_tsquery_triconsistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "327-363",
    "snippet": "Datum\ngin_tsquery_triconsistent(PG_FUNCTION_ARGS)\n{\n\tGinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0);\n\n\t/* StrategyNumber strategy = PG_GETARG_UINT16(1); */\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\n\t/* int32\tnkeys = PG_GETARG_INT32(3); */\n\tPointer    *extra_data = (Pointer *) PG_GETARG_POINTER(4);\n\tGinTernaryValue res = GIN_FALSE;\n\tbool\t\trecheck;\n\n\t/* Initially assume query doesn't require recheck */\n\trecheck = false;\n\n\tif (query->size > 0)\n\t{\n\t\tGinChkVal\tgcv;\n\n\t\t/*\n\t\t * check-parameter array has one entry for each value (operand) in the\n\t\t * query.\n\t\t */\n\t\tgcv.first_item = GETQUERY(query);\n\t\tgcv.check = check;\n\t\tgcv.map_item_operand = (int *) (extra_data[0]);\n\t\tgcv.need_recheck = &recheck;\n\n\t\tres = TS_execute_ternary(&gcv, GETQUERY(query), false);\n\n\t\tif (res == GIN_TRUE && recheck)\n\t\t\tres = GIN_MAYBE;\n\t}\n\n\tPG_RETURN_GIN_TERNARY_VALUE(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_GIN_TERNARY_VALUE",
          "args": [
            "res"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS_execute_ternary",
          "args": [
            "&gcv",
            "GETQUERY(query)",
            "false"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "TS_execute_ternary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "214-285",
          "snippet": "static GinTernaryValue\nTS_execute_ternary(GinChkVal *gcv, QueryItem *curitem, bool in_phrase)\n{\n\tGinTernaryValue val1,\n\t\t\t\tval2,\n\t\t\t\tresult;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn\n\t\t\tcheckcondition_gin_internal(gcv,\n\t\t\t\t\t\t\t\t\t\t(QueryOperand *) curitem,\n\t\t\t\t\t\t\t\t\t\tNULL /* don't have position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\t/* In phrase search, always return MAYBE since we lack positions */\n\t\t\tif (in_phrase)\n\t\t\t\treturn GIN_MAYBE;\n\t\t\tresult = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (result == GIN_MAYBE)\n\t\t\t\treturn result;\n\t\t\treturn !result;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * GIN doesn't contain any information about positions, so treat\n\t\t\t * OP_PHRASE as OP_AND with recheck requirement\n\t\t\t */\n\t\t\t*(gcv->need_recheck) = true;\n\t\t\t/* Pass down in_phrase == true in case there's a NOT below */\n\t\t\tin_phrase = true;\n\n\t\t\t/* FALL THRU */\n\n\t\tcase OP_AND:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tif (val1 == GIN_TRUE && val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tcase OP_OR:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tif (val1 == GIN_FALSE && val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic GinTernaryValue\nTS_execute_ternary(GinChkVal *gcv, QueryItem *curitem, bool in_phrase)\n{\n\tGinTernaryValue val1,\n\t\t\t\tval2,\n\t\t\t\tresult;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn\n\t\t\tcheckcondition_gin_internal(gcv,\n\t\t\t\t\t\t\t\t\t\t(QueryOperand *) curitem,\n\t\t\t\t\t\t\t\t\t\tNULL /* don't have position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\t/* In phrase search, always return MAYBE since we lack positions */\n\t\t\tif (in_phrase)\n\t\t\t\treturn GIN_MAYBE;\n\t\t\tresult = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (result == GIN_MAYBE)\n\t\t\t\treturn result;\n\t\t\treturn !result;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * GIN doesn't contain any information about positions, so treat\n\t\t\t * OP_PHRASE as OP_AND with recheck requirement\n\t\t\t */\n\t\t\t*(gcv->need_recheck) = true;\n\t\t\t/* Pass down in_phrase == true in case there's a NOT below */\n\t\t\tin_phrase = true;\n\n\t\t\t/* FALL THRU */\n\n\t\tcase OP_AND:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tif (val1 == GIN_TRUE && val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tcase OP_OR:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tif (val1 == GIN_FALSE && val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_tsquery_triconsistent(PG_FUNCTION_ARGS)\n{\n\tGinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0);\n\n\t/* StrategyNumber strategy = PG_GETARG_UINT16(1); */\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\n\t/* int32\tnkeys = PG_GETARG_INT32(3); */\n\tPointer    *extra_data = (Pointer *) PG_GETARG_POINTER(4);\n\tGinTernaryValue res = GIN_FALSE;\n\tbool\t\trecheck;\n\n\t/* Initially assume query doesn't require recheck */\n\trecheck = false;\n\n\tif (query->size > 0)\n\t{\n\t\tGinChkVal\tgcv;\n\n\t\t/*\n\t\t * check-parameter array has one entry for each value (operand) in the\n\t\t * query.\n\t\t */\n\t\tgcv.first_item = GETQUERY(query);\n\t\tgcv.check = check;\n\t\tgcv.map_item_operand = (int *) (extra_data[0]);\n\t\tgcv.need_recheck = &recheck;\n\n\t\tres = TS_execute_ternary(&gcv, GETQUERY(query), false);\n\n\t\tif (res == GIN_TRUE && recheck)\n\t\t\tres = GIN_MAYBE;\n\t}\n\n\tPG_RETURN_GIN_TERNARY_VALUE(res);\n}"
  },
  {
    "function_name": "gin_tsquery_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "287-325",
    "snippet": "Datum\ngin_tsquery_consistent(PG_FUNCTION_ARGS)\n{\n\tbool\t   *check = (bool *) PG_GETARG_POINTER(0);\n\n\t/* StrategyNumber strategy = PG_GETARG_UINT16(1); */\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\n\t/* int32\tnkeys = PG_GETARG_INT32(3); */\n\tPointer    *extra_data = (Pointer *) PG_GETARG_POINTER(4);\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(5);\n\tbool\t\tres = false;\n\n\t/* Initially assume query doesn't require recheck */\n\t*recheck = false;\n\n\tif (query->size > 0)\n\t{\n\t\tGinChkVal\tgcv;\n\n\t\t/*\n\t\t * check-parameter array has one entry for each value (operand) in the\n\t\t * query.\n\t\t */\n\t\tgcv.first_item = GETQUERY(query);\n\t\tStaticAssertStmt(sizeof(GinTernaryValue) == sizeof(bool),\n\t\t\t\t\t\t \"sizes of GinTernaryValue and bool are not equal\");\n\t\tgcv.check = (GinTernaryValue *) check;\n\t\tgcv.map_item_operand = (int *) (extra_data[0]);\n\t\tgcv.need_recheck = recheck;\n\n\t\tres = TS_execute(GETQUERY(query),\n\t\t\t\t\t\t &gcv,\n\t\t\t\t\t\t TS_EXEC_CALC_NOT | TS_EXEC_PHRASE_NO_POS,\n\t\t\t\t\t\t checkcondition_gin);\n\t}\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS_execute",
          "args": [
            "GETQUERY(query)",
            "&gcv",
            "TS_EXEC_CALC_NOT | TS_EXEC_PHRASE_NO_POS",
            "checkcondition_gin"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "TS_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1814-1854",
          "snippet": "bool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nbool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "sizeof(GinTernaryValue) == sizeof(bool)",
            "\"sizes of GinTernaryValue and bool are not equal\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "5"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_tsquery_consistent(PG_FUNCTION_ARGS)\n{\n\tbool\t   *check = (bool *) PG_GETARG_POINTER(0);\n\n\t/* StrategyNumber strategy = PG_GETARG_UINT16(1); */\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\n\t/* int32\tnkeys = PG_GETARG_INT32(3); */\n\tPointer    *extra_data = (Pointer *) PG_GETARG_POINTER(4);\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(5);\n\tbool\t\tres = false;\n\n\t/* Initially assume query doesn't require recheck */\n\t*recheck = false;\n\n\tif (query->size > 0)\n\t{\n\t\tGinChkVal\tgcv;\n\n\t\t/*\n\t\t * check-parameter array has one entry for each value (operand) in the\n\t\t * query.\n\t\t */\n\t\tgcv.first_item = GETQUERY(query);\n\t\tStaticAssertStmt(sizeof(GinTernaryValue) == sizeof(bool),\n\t\t\t\t\t\t \"sizes of GinTernaryValue and bool are not equal\");\n\t\tgcv.check = (GinTernaryValue *) check;\n\t\tgcv.map_item_operand = (int *) (extra_data[0]);\n\t\tgcv.need_recheck = recheck;\n\n\t\tres = TS_execute(GETQUERY(query),\n\t\t\t\t\t\t &gcv,\n\t\t\t\t\t\t TS_EXEC_CALC_NOT | TS_EXEC_PHRASE_NO_POS,\n\t\t\t\t\t\t checkcondition_gin);\n\t}\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "TS_execute_ternary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "214-285",
    "snippet": "static GinTernaryValue\nTS_execute_ternary(GinChkVal *gcv, QueryItem *curitem, bool in_phrase)\n{\n\tGinTernaryValue val1,\n\t\t\t\tval2,\n\t\t\t\tresult;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn\n\t\t\tcheckcondition_gin_internal(gcv,\n\t\t\t\t\t\t\t\t\t\t(QueryOperand *) curitem,\n\t\t\t\t\t\t\t\t\t\tNULL /* don't have position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\t/* In phrase search, always return MAYBE since we lack positions */\n\t\t\tif (in_phrase)\n\t\t\t\treturn GIN_MAYBE;\n\t\t\tresult = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (result == GIN_MAYBE)\n\t\t\t\treturn result;\n\t\t\treturn !result;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * GIN doesn't contain any information about positions, so treat\n\t\t\t * OP_PHRASE as OP_AND with recheck requirement\n\t\t\t */\n\t\t\t*(gcv->need_recheck) = true;\n\t\t\t/* Pass down in_phrase == true in case there's a NOT below */\n\t\t\tin_phrase = true;\n\n\t\t\t/* FALL THRU */\n\n\t\tcase OP_AND:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tif (val1 == GIN_TRUE && val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tcase OP_OR:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tif (val1 == GIN_FALSE && val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized operator: %d\"",
            "curitem->qoperator.oper"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TS_execute_ternary",
          "args": [
            "gcv",
            "curitem + 1",
            "in_phrase"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "TS_execute_ternary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "214-285",
          "snippet": "static GinTernaryValue\nTS_execute_ternary(GinChkVal *gcv, QueryItem *curitem, bool in_phrase)\n{\n\tGinTernaryValue val1,\n\t\t\t\tval2,\n\t\t\t\tresult;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn\n\t\t\tcheckcondition_gin_internal(gcv,\n\t\t\t\t\t\t\t\t\t\t(QueryOperand *) curitem,\n\t\t\t\t\t\t\t\t\t\tNULL /* don't have position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\t/* In phrase search, always return MAYBE since we lack positions */\n\t\t\tif (in_phrase)\n\t\t\t\treturn GIN_MAYBE;\n\t\t\tresult = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (result == GIN_MAYBE)\n\t\t\t\treturn result;\n\t\t\treturn !result;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * GIN doesn't contain any information about positions, so treat\n\t\t\t * OP_PHRASE as OP_AND with recheck requirement\n\t\t\t */\n\t\t\t*(gcv->need_recheck) = true;\n\t\t\t/* Pass down in_phrase == true in case there's a NOT below */\n\t\t\tin_phrase = true;\n\n\t\t\t/* FALL THRU */\n\n\t\tcase OP_AND:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tif (val1 == GIN_TRUE && val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tcase OP_OR:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tif (val1 == GIN_FALSE && val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "checkcondition_gin_internal",
          "args": [
            "gcv",
            "(QueryOperand *) curitem",
            "NULL/* don't have position info */"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "checkcondition_gin_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "181-198",
          "snippet": "static GinTernaryValue\ncheckcondition_gin_internal(GinChkVal *gcv, QueryOperand *val, ExecPhraseData *data)\n{\n\tint\t\t\tj;\n\n\t/*\n\t * if any val requiring a weight is used or caller needs position\n\t * information then set recheck flag\n\t */\n\tif (val->weight != 0 || data != NULL)\n\t\t*(gcv->need_recheck) = true;\n\n\t/* convert item's number to corresponding entry's (operand's) number */\n\tj = gcv->map_item_operand[((QueryItem *) val) - gcv->first_item];\n\n\t/* return presence of current entry in indexed value */\n\treturn gcv->check[j];\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic GinTernaryValue\ncheckcondition_gin_internal(GinChkVal *gcv, QueryOperand *val, ExecPhraseData *data)\n{\n\tint\t\t\tj;\n\n\t/*\n\t * if any val requiring a weight is used or caller needs position\n\t * information then set recheck flag\n\t */\n\tif (val->weight != 0 || data != NULL)\n\t\t*(gcv->need_recheck) = true;\n\n\t/* convert item's number to corresponding entry's (operand's) number */\n\tj = gcv->map_item_operand[((QueryItem *) val) - gcv->first_item];\n\n\t/* return presence of current entry in indexed value */\n\treturn gcv->check[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic GinTernaryValue\nTS_execute_ternary(GinChkVal *gcv, QueryItem *curitem, bool in_phrase)\n{\n\tGinTernaryValue val1,\n\t\t\t\tval2,\n\t\t\t\tresult;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn\n\t\t\tcheckcondition_gin_internal(gcv,\n\t\t\t\t\t\t\t\t\t\t(QueryOperand *) curitem,\n\t\t\t\t\t\t\t\t\t\tNULL /* don't have position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\t/* In phrase search, always return MAYBE since we lack positions */\n\t\t\tif (in_phrase)\n\t\t\t\treturn GIN_MAYBE;\n\t\t\tresult = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (result == GIN_MAYBE)\n\t\t\t\treturn result;\n\t\t\treturn !result;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * GIN doesn't contain any information about positions, so treat\n\t\t\t * OP_PHRASE as OP_AND with recheck requirement\n\t\t\t */\n\t\t\t*(gcv->need_recheck) = true;\n\t\t\t/* Pass down in_phrase == true in case there's a NOT below */\n\t\t\tin_phrase = true;\n\n\t\t\t/* FALL THRU */\n\n\t\tcase OP_AND:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\tif (val1 == GIN_TRUE && val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tcase OP_OR:\n\t\t\tval1 = TS_execute_ternary(gcv, curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t  in_phrase);\n\t\t\tif (val1 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tval2 = TS_execute_ternary(gcv, curitem + 1, in_phrase);\n\t\t\tif (val2 == GIN_TRUE)\n\t\t\t\treturn GIN_TRUE;\n\t\t\tif (val1 == GIN_FALSE && val2 == GIN_FALSE)\n\t\t\t\treturn GIN_FALSE;\n\t\t\telse\n\t\t\t\treturn GIN_MAYBE;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
  },
  {
    "function_name": "checkcondition_gin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "203-209",
    "snippet": "static bool\ncheckcondition_gin(void *checkval, QueryOperand *val, ExecPhraseData *data)\n{\n\treturn checkcondition_gin_internal((GinChkVal *) checkval,\n\t\t\t\t\t\t\t\t\t   val,\n\t\t\t\t\t\t\t\t\t   data) != GIN_FALSE;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkcondition_gin_internal",
          "args": [
            "(GinChkVal *) checkval",
            "val",
            "data"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "checkcondition_gin_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
          "lines": "181-198",
          "snippet": "static GinTernaryValue\ncheckcondition_gin_internal(GinChkVal *gcv, QueryOperand *val, ExecPhraseData *data)\n{\n\tint\t\t\tj;\n\n\t/*\n\t * if any val requiring a weight is used or caller needs position\n\t * information then set recheck flag\n\t */\n\tif (val->weight != 0 || data != NULL)\n\t\t*(gcv->need_recheck) = true;\n\n\t/* convert item's number to corresponding entry's (operand's) number */\n\tj = gcv->map_item_operand[((QueryItem *) val) - gcv->first_item];\n\n\t/* return presence of current entry in indexed value */\n\treturn gcv->check[j];\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic GinTernaryValue\ncheckcondition_gin_internal(GinChkVal *gcv, QueryOperand *val, ExecPhraseData *data)\n{\n\tint\t\t\tj;\n\n\t/*\n\t * if any val requiring a weight is used or caller needs position\n\t * information then set recheck flag\n\t */\n\tif (val->weight != 0 || data != NULL)\n\t\t*(gcv->need_recheck) = true;\n\n\t/* convert item's number to corresponding entry's (operand's) number */\n\tj = gcv->map_item_operand[((QueryItem *) val) - gcv->first_item];\n\n\t/* return presence of current entry in indexed value */\n\treturn gcv->check[j];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic bool\ncheckcondition_gin(void *checkval, QueryOperand *val, ExecPhraseData *data)\n{\n\treturn checkcondition_gin_internal((GinChkVal *) checkval,\n\t\t\t\t\t\t\t\t\t   val,\n\t\t\t\t\t\t\t\t\t   data) != GIN_FALSE;\n}"
  },
  {
    "function_name": "checkcondition_gin_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "181-198",
    "snippet": "static GinTernaryValue\ncheckcondition_gin_internal(GinChkVal *gcv, QueryOperand *val, ExecPhraseData *data)\n{\n\tint\t\t\tj;\n\n\t/*\n\t * if any val requiring a weight is used or caller needs position\n\t * information then set recheck flag\n\t */\n\tif (val->weight != 0 || data != NULL)\n\t\t*(gcv->need_recheck) = true;\n\n\t/* convert item's number to corresponding entry's (operand's) number */\n\tj = gcv->map_item_operand[((QueryItem *) val) - gcv->first_item];\n\n\t/* return presence of current entry in indexed value */\n\treturn gcv->check[j];\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic GinTernaryValue\ncheckcondition_gin_internal(GinChkVal *gcv, QueryOperand *val, ExecPhraseData *data)\n{\n\tint\t\t\tj;\n\n\t/*\n\t * if any val requiring a weight is used or caller needs position\n\t * information then set recheck flag\n\t */\n\tif (val->weight != 0 || data != NULL)\n\t\t*(gcv->need_recheck) = true;\n\n\t/* convert item's number to corresponding entry's (operand's) number */\n\tj = gcv->map_item_operand[((QueryItem *) val) - gcv->first_item];\n\n\t/* return presence of current entry in indexed value */\n\treturn gcv->check[j];\n}"
  },
  {
    "function_name": "gin_extract_tsquery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "94-171",
    "snippet": "Datum\ngin_extract_tsquery(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\n\t/* StrategyNumber strategy = PG_GETARG_UINT16(2); */\n\tbool\t  **ptr_partialmatch = (bool **) PG_GETARG_POINTER(3);\n\tPointer   **extra_data = (Pointer **) PG_GETARG_POINTER(4);\n\n\t/* bool   **nullFlags = (bool **) PG_GETARG_POINTER(5); */\n\tint32\t   *searchMode = (int32 *) PG_GETARG_POINTER(6);\n\tDatum\t   *entries = NULL;\n\n\t*nentries = 0;\n\n\tif (query->size > 0)\n\t{\n\t\tQueryItem  *item = GETQUERY(query);\n\t\tint32\t\ti,\n\t\t\t\t\tj;\n\t\tbool\t   *partialmatch;\n\t\tint\t\t   *map_item_operand;\n\n\t\t/*\n\t\t * If the query doesn't have any required positive matches (for\n\t\t * instance, it's something like '! foo'), we have to do a full index\n\t\t * scan.\n\t\t */\n\t\tif (tsquery_requires_match(item))\n\t\t\t*searchMode = GIN_SEARCH_MODE_DEFAULT;\n\t\telse\n\t\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\n\t\t/* count number of VAL items */\n\t\tj = 0;\n\t\tfor (i = 0; i < query->size; i++)\n\t\t{\n\t\t\tif (item[i].type == QI_VAL)\n\t\t\t\tj++;\n\t\t}\n\t\t*nentries = j;\n\n\t\tentries = (Datum *) palloc(sizeof(Datum) * j);\n\t\tpartialmatch = *ptr_partialmatch = (bool *) palloc(sizeof(bool) * j);\n\n\t\t/*\n\t\t * Make map to convert item's number to corresponding operand's (the\n\t\t * same, entry's) number. Entry's number is used in check array in\n\t\t * consistent method. We use the same map for each entry.\n\t\t */\n\t\t*extra_data = (Pointer *) palloc(sizeof(Pointer) * j);\n\t\tmap_item_operand = (int *) palloc0(sizeof(int) * query->size);\n\n\t\t/* Now rescan the VAL items and fill in the arrays */\n\t\tj = 0;\n\t\tfor (i = 0; i < query->size; i++)\n\t\t{\n\t\t\tif (item[i].type == QI_VAL)\n\t\t\t{\n\t\t\t\tQueryOperand *val = &item[i].qoperand;\n\t\t\t\ttext\t   *txt;\n\n\t\t\t\ttxt = cstring_to_text_with_len(GETOPERAND(query) + val->distance,\n\t\t\t\t\t\t\t\t\t\t\t   val->length);\n\t\t\t\tentries[j] = PointerGetDatum(txt);\n\t\t\t\tpartialmatch[j] = val->prefix;\n\t\t\t\t(*extra_data)[j] = (Pointer) map_item_operand;\n\t\t\t\tmap_item_operand[i] = j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\n\tPG_RETURN_POINTER(entries);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "entries"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "txt"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "GETOPERAND(query) + val->distance",
            "val->length"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(int) * query->size"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Pointer) * j"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsquery_requires_match",
          "args": [
            "item"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "tsquery_requires_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1864-1909",
          "snippet": "bool\ntsquery_requires_match(QueryItem *curitem)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn true;\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Assume there are no required matches underneath a NOT.  For\n\t\t\t * some cases with nested NOTs, we could prove there's a required\n\t\t\t * match, but it seems unlikely to be worth the trouble.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * Treat OP_PHRASE as OP_AND here\n\t\t\t */\n\t\tcase OP_AND:\n\t\t\t/* If either side requires a match, we're good */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\n\t\tcase OP_OR:\n\t\t\t/* Both sides must require a match */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nbool\ntsquery_requires_match(QueryItem *curitem)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn true;\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Assume there are no required matches underneath a NOT.  For\n\t\t\t * some cases with nested NOTs, we could prove there's a required\n\t\t\t * match, but it seems unlikely to be worth the trouble.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * Treat OP_PHRASE as OP_AND here\n\t\t\t */\n\t\tcase OP_AND:\n\t\t\t/* If either side requires a match, we're good */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\n\t\tcase OP_OR:\n\t\t\t/* Both sides must require a match */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "6"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "3"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_tsquery(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\n\t/* StrategyNumber strategy = PG_GETARG_UINT16(2); */\n\tbool\t  **ptr_partialmatch = (bool **) PG_GETARG_POINTER(3);\n\tPointer   **extra_data = (Pointer **) PG_GETARG_POINTER(4);\n\n\t/* bool   **nullFlags = (bool **) PG_GETARG_POINTER(5); */\n\tint32\t   *searchMode = (int32 *) PG_GETARG_POINTER(6);\n\tDatum\t   *entries = NULL;\n\n\t*nentries = 0;\n\n\tif (query->size > 0)\n\t{\n\t\tQueryItem  *item = GETQUERY(query);\n\t\tint32\t\ti,\n\t\t\t\t\tj;\n\t\tbool\t   *partialmatch;\n\t\tint\t\t   *map_item_operand;\n\n\t\t/*\n\t\t * If the query doesn't have any required positive matches (for\n\t\t * instance, it's something like '! foo'), we have to do a full index\n\t\t * scan.\n\t\t */\n\t\tif (tsquery_requires_match(item))\n\t\t\t*searchMode = GIN_SEARCH_MODE_DEFAULT;\n\t\telse\n\t\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\n\t\t/* count number of VAL items */\n\t\tj = 0;\n\t\tfor (i = 0; i < query->size; i++)\n\t\t{\n\t\t\tif (item[i].type == QI_VAL)\n\t\t\t\tj++;\n\t\t}\n\t\t*nentries = j;\n\n\t\tentries = (Datum *) palloc(sizeof(Datum) * j);\n\t\tpartialmatch = *ptr_partialmatch = (bool *) palloc(sizeof(bool) * j);\n\n\t\t/*\n\t\t * Make map to convert item's number to corresponding operand's (the\n\t\t * same, entry's) number. Entry's number is used in check array in\n\t\t * consistent method. We use the same map for each entry.\n\t\t */\n\t\t*extra_data = (Pointer *) palloc(sizeof(Pointer) * j);\n\t\tmap_item_operand = (int *) palloc0(sizeof(int) * query->size);\n\n\t\t/* Now rescan the VAL items and fill in the arrays */\n\t\tj = 0;\n\t\tfor (i = 0; i < query->size; i++)\n\t\t{\n\t\t\tif (item[i].type == QI_VAL)\n\t\t\t{\n\t\t\t\tQueryOperand *val = &item[i].qoperand;\n\t\t\t\ttext\t   *txt;\n\n\t\t\t\ttxt = cstring_to_text_with_len(GETOPERAND(query) + val->distance,\n\t\t\t\t\t\t\t\t\t\t\t   val->length);\n\t\t\t\tentries[j] = PointerGetDatum(txt);\n\t\t\t\tpartialmatch[j] = val->prefix;\n\t\t\t\t(*extra_data)[j] = (Pointer) map_item_operand;\n\t\t\t\tmap_item_operand[i] = j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\n\tPG_RETURN_POINTER(entries);\n}"
  },
  {
    "function_name": "gin_extract_tsvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "64-92",
    "snippet": "Datum\ngin_extract_tsvector(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvector = PG_GETARG_TSVECTOR(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tDatum\t   *entries = NULL;\n\n\t*nentries = vector->size;\n\tif (vector->size > 0)\n\t{\n\t\tint\t\t\ti;\n\t\tWordEntry  *we = ARRPTR(vector);\n\n\t\tentries = (Datum *) palloc(sizeof(Datum) * vector->size);\n\n\t\tfor (i = 0; i < vector->size; i++)\n\t\t{\n\t\t\ttext\t   *txt;\n\n\t\t\ttxt = cstring_to_text_with_len(STRPTR(vector) + we->pos, we->len);\n\t\t\tentries[i] = PointerGetDatum(txt);\n\n\t\t\twe++;\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(vector, 0);\n\tPG_RETURN_POINTER(entries);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "entries"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "vector",
            "0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "txt"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "STRPTR(vector) + we->pos",
            "we->len"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vector"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Datum) * vector->size"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "vector"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_tsvector(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvector = PG_GETARG_TSVECTOR(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tDatum\t   *entries = NULL;\n\n\t*nentries = vector->size;\n\tif (vector->size > 0)\n\t{\n\t\tint\t\t\ti;\n\t\tWordEntry  *we = ARRPTR(vector);\n\n\t\tentries = (Datum *) palloc(sizeof(Datum) * vector->size);\n\n\t\tfor (i = 0; i < vector->size; i++)\n\t\t{\n\t\t\ttext\t   *txt;\n\n\t\t\ttxt = cstring_to_text_with_len(STRPTR(vector) + we->pos, we->len);\n\t\t\tentries[i] = PointerGetDatum(txt);\n\n\t\t\twe++;\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(vector, 0);\n\tPG_RETURN_POINTER(entries);\n}"
  },
  {
    "function_name": "gin_cmp_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "40-62",
    "snippet": "Datum\ngin_cmp_prefix(PG_FUNCTION_ARGS)\n{\n\ttext\t   *a = PG_GETARG_TEXT_PP(0);\n\ttext\t   *b = PG_GETARG_TEXT_PP(1);\n\n#ifdef NOT_USED\n\tStrategyNumber strategy = PG_GETARG_UINT16(2);\n\tPointer\t\textra_data = PG_GETARG_POINTER(3);\n#endif\n\tint\t\t\tcmp;\n\n\tcmp = tsCompareString(VARDATA_ANY(a), VARSIZE_ANY_EXHDR(a),\n\t\t\t\t\t\t  VARDATA_ANY(b), VARSIZE_ANY_EXHDR(b),\n\t\t\t\t\t\t  true);\n\n\tif (cmp < 0)\n\t\tcmp = 1;\t\t\t\t/* prevent continue scan */\n\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\tPG_RETURN_INT32(cmp);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "cmp"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "VARDATA_ANY(a)",
            "VARSIZE_ANY_EXHDR(a)",
            "VARDATA_ANY(b)",
            "VARSIZE_ANY_EXHDR(b)",
            "true"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "b"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "b"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "a"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "a"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "3"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "2"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_cmp_prefix(PG_FUNCTION_ARGS)\n{\n\ttext\t   *a = PG_GETARG_TEXT_PP(0);\n\ttext\t   *b = PG_GETARG_TEXT_PP(1);\n\n#ifdef NOT_USED\n\tStrategyNumber strategy = PG_GETARG_UINT16(2);\n\tPointer\t\textra_data = PG_GETARG_POINTER(3);\n#endif\n\tint\t\t\tcmp;\n\n\tcmp = tsCompareString(VARDATA_ANY(a), VARSIZE_ANY_EXHDR(a),\n\t\t\t\t\t\t  VARDATA_ANY(b), VARSIZE_ANY_EXHDR(b),\n\t\t\t\t\t\t  true);\n\n\tif (cmp < 0)\n\t\tcmp = 1;\t\t\t\t/* prevent continue scan */\n\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\tPG_RETURN_INT32(cmp);\n}"
  },
  {
    "function_name": "gin_cmp_tslexeme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsginidx.c",
    "lines": "24-38",
    "snippet": "Datum\ngin_cmp_tslexeme(PG_FUNCTION_ARGS)\n{\n\ttext\t   *a = PG_GETARG_TEXT_PP(0);\n\ttext\t   *b = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tcmp;\n\n\tcmp = tsCompareString(VARDATA_ANY(a), VARSIZE_ANY_EXHDR(a),\n\t\t\t\t\t\t  VARDATA_ANY(b), VARSIZE_ANY_EXHDR(b),\n\t\t\t\t\t\t  false);\n\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\tPG_RETURN_INT32(cmp);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "cmp"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "VARDATA_ANY(a)",
            "VARSIZE_ANY_EXHDR(a)",
            "VARDATA_ANY(b)",
            "VARSIZE_ANY_EXHDR(b)",
            "false"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "b"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "b"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "a"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "a"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_type.h\"\n#include \"miscadmin.h\"\n#include \"access/stratnum.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_cmp_tslexeme(PG_FUNCTION_ARGS)\n{\n\ttext\t   *a = PG_GETARG_TEXT_PP(0);\n\ttext\t   *b = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tcmp;\n\n\tcmp = tsCompareString(VARDATA_ANY(a), VARSIZE_ANY_EXHDR(a),\n\t\t\t\t\t\t  VARDATA_ANY(b), VARSIZE_ANY_EXHDR(b),\n\t\t\t\t\t\t  false);\n\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\tPG_RETURN_INT32(cmp);\n}"
  }
]