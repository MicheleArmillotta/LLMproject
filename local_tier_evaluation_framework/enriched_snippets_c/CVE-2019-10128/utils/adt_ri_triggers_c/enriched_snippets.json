[
  {
    "function_name": "RI_FKey_trigger_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "3163-3186",
    "snippet": "int\nRI_FKey_trigger_type(Oid tgfoid)\n{\n\tswitch (tgfoid)\n\t{\n\t\tcase F_RI_FKEY_CASCADE_DEL:\n\t\tcase F_RI_FKEY_CASCADE_UPD:\n\t\tcase F_RI_FKEY_RESTRICT_DEL:\n\t\tcase F_RI_FKEY_RESTRICT_UPD:\n\t\tcase F_RI_FKEY_SETNULL_DEL:\n\t\tcase F_RI_FKEY_SETNULL_UPD:\n\t\tcase F_RI_FKEY_SETDEFAULT_DEL:\n\t\tcase F_RI_FKEY_SETDEFAULT_UPD:\n\t\tcase F_RI_FKEY_NOACTION_DEL:\n\t\tcase F_RI_FKEY_NOACTION_UPD:\n\t\t\treturn RI_TRIGGER_PK;\n\n\t\tcase F_RI_FKEY_CHECK_INS:\n\t\tcase F_RI_FKEY_CHECK_UPD:\n\t\t\treturn RI_TRIGGER_FK;\n\t}\n\n\treturn RI_TRIGGER_NONE;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nRI_FKey_trigger_type(Oid tgfoid)\n{\n\tswitch (tgfoid)\n\t{\n\t\tcase F_RI_FKEY_CASCADE_DEL:\n\t\tcase F_RI_FKEY_CASCADE_UPD:\n\t\tcase F_RI_FKEY_RESTRICT_DEL:\n\t\tcase F_RI_FKEY_RESTRICT_UPD:\n\t\tcase F_RI_FKEY_SETNULL_DEL:\n\t\tcase F_RI_FKEY_SETNULL_UPD:\n\t\tcase F_RI_FKEY_SETDEFAULT_DEL:\n\t\tcase F_RI_FKEY_SETDEFAULT_UPD:\n\t\tcase F_RI_FKEY_NOACTION_DEL:\n\t\tcase F_RI_FKEY_NOACTION_UPD:\n\t\t\treturn RI_TRIGGER_PK;\n\n\t\tcase F_RI_FKEY_CHECK_INS:\n\t\tcase F_RI_FKEY_CHECK_UPD:\n\t\t\treturn RI_TRIGGER_FK;\n\t}\n\n\treturn RI_TRIGGER_NONE;\n}"
  },
  {
    "function_name": "ri_HashCompareOp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "3070-3156",
    "snippet": "static RI_CompareHashEntry *\nri_HashCompareOp(Oid eq_opr, Oid typeid)\n{\n\tRI_CompareKey key;\n\tRI_CompareHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_compare_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  Note we're assuming RI_CompareKey\n\t * contains no struct padding.\n\t */\n\tkey.eq_opr = eq_opr;\n\tkey.typeid = typeid;\n\tentry = (RI_CompareHashEntry *) hash_search(ri_compare_cache,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (!found)\n\t\tentry->valid = false;\n\n\t/*\n\t * If not already initialized, do so.  Since we'll keep this hash entry\n\t * for the life of the backend, put any subsidiary info for the function\n\t * cache structs into TopMemoryContext.\n\t */\n\tif (!entry->valid)\n\t{\n\t\tOid\t\t\tlefttype,\n\t\t\t\t\trighttype,\n\t\t\t\t\tcastfunc;\n\t\tCoercionPathType pathtype;\n\n\t\t/* We always need to know how to call the equality operator */\n\t\tfmgr_info_cxt(get_opcode(eq_opr), &entry->eq_opr_finfo,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/*\n\t\t * If we chose to use a cast from FK to PK type, we may have to apply\n\t\t * the cast function to get to the operator's input type.\n\t\t *\n\t\t * XXX eventually it would be good to support array-coercion cases\n\t\t * here and in ri_AttributesEqual().  At the moment there is no point\n\t\t * because cases involving nonidentical array types will be rejected\n\t\t * at constraint creation time.\n\t\t *\n\t\t * XXX perhaps also consider supporting CoerceViaIO?  No need at the\n\t\t * moment since that will never be generated for implicit coercions.\n\t\t */\n\t\top_input_types(eq_opr, &lefttype, &righttype);\n\t\tAssert(lefttype == righttype);\n\t\tif (typeid == lefttype)\n\t\t\tcastfunc = InvalidOid;\t/* simplest case */\n\t\telse\n\t\t{\n\t\t\tpathtype = find_coercion_pathway(lefttype, typeid,\n\t\t\t\t\t\t\t\t\t\t\t COERCION_IMPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t &castfunc);\n\t\t\tif (pathtype != COERCION_PATH_FUNC &&\n\t\t\t\tpathtype != COERCION_PATH_RELABELTYPE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The declared input type of the eq_opr might be a\n\t\t\t\t * polymorphic type such as ANYARRAY or ANYENUM, or other\n\t\t\t\t * special cases such as RECORD; find_coercion_pathway\n\t\t\t\t * currently doesn't subsume these special cases.\n\t\t\t\t */\n\t\t\t\tif (!IsBinaryCoercible(typeid, lefttype))\n\t\t\t\t\telog(ERROR, \"no conversion function from %s to %s\",\n\t\t\t\t\t\t format_type_be(typeid),\n\t\t\t\t\t\t format_type_be(lefttype));\n\t\t\t}\n\t\t}\n\t\tif (OidIsValid(castfunc))\n\t\t\tfmgr_info_cxt(castfunc, &entry->cast_func_finfo,\n\t\t\t\t\t\t  TopMemoryContext);\n\t\telse\n\t\t\tentry->cast_func_finfo.fn_oid = InvalidOid;\n\t\tentry->valid = true;\n\t}\n\n\treturn entry;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *ri_compare_cache = NULL;",
      "static void ri_InitHashTables(void);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "castfunc",
            "&entry->cast_func_finfo",
            "TopMemoryContext"
          ],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "castfunc"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no conversion function from %s to %s\"",
            "format_type_be(typeid)",
            "format_type_be(lefttype)"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "lefttype"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBinaryCoercible",
          "args": [
            "typeid",
            "lefttype"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_coercion_pathway",
          "args": [
            "lefttype",
            "typeid",
            "COERCION_IMPLICIT",
            "&castfunc"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lefttype == righttype"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_input_types",
          "args": [
            "eq_opr",
            "&lefttype",
            "&righttype"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "op_input_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1151-1164",
          "snippet": "void\nop_input_types(Oid opno, Oid *lefttype, Oid *righttype)\n{\n\tHeapTuple\ttp;\n\tForm_pg_operator optup;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (!HeapTupleIsValid(tp))\t/* shouldn't happen */\n\t\telog(ERROR, \"cache lookup failed for operator %u\", opno);\n\toptup = (Form_pg_operator) GETSTRUCT(tp);\n\t*lefttype = optup->oprleft;\n\t*righttype = optup->oprright;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nop_input_types(Oid opno, Oid *lefttype, Oid *righttype)\n{\n\tHeapTuple\ttp;\n\tForm_pg_operator optup;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (!HeapTupleIsValid(tp))\t/* shouldn't happen */\n\t\telog(ERROR, \"cache lookup failed for operator %u\", opno);\n\toptup = (Form_pg_operator) GETSTRUCT(tp);\n\t*lefttype = optup->oprleft;\n\t*righttype = optup->oprright;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "eq_opr"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "ri_compare_cache",
            "(void *) &key",
            "HASH_ENTER",
            "&found"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_InitHashTables",
          "args": [],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "ri_InitHashTables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2848-2878",
          "snippet": "static void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)",
            "#define RI_INIT_CONSTRAINTHASHSIZE\t\t64"
          ],
          "globals_used": [
            "static HTAB *ri_constraint_cache = NULL;",
            "static HTAB *ri_query_cache = NULL;",
            "static HTAB *ri_compare_cache = NULL;",
            "static void ri_InitHashTables(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)\n#define RI_INIT_CONSTRAINTHASHSIZE\t\t64\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic HTAB *ri_query_cache = NULL;\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\n\nstatic void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);\n\nstatic RI_CompareHashEntry *\nri_HashCompareOp(Oid eq_opr, Oid typeid)\n{\n\tRI_CompareKey key;\n\tRI_CompareHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_compare_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  Note we're assuming RI_CompareKey\n\t * contains no struct padding.\n\t */\n\tkey.eq_opr = eq_opr;\n\tkey.typeid = typeid;\n\tentry = (RI_CompareHashEntry *) hash_search(ri_compare_cache,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (!found)\n\t\tentry->valid = false;\n\n\t/*\n\t * If not already initialized, do so.  Since we'll keep this hash entry\n\t * for the life of the backend, put any subsidiary info for the function\n\t * cache structs into TopMemoryContext.\n\t */\n\tif (!entry->valid)\n\t{\n\t\tOid\t\t\tlefttype,\n\t\t\t\t\trighttype,\n\t\t\t\t\tcastfunc;\n\t\tCoercionPathType pathtype;\n\n\t\t/* We always need to know how to call the equality operator */\n\t\tfmgr_info_cxt(get_opcode(eq_opr), &entry->eq_opr_finfo,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/*\n\t\t * If we chose to use a cast from FK to PK type, we may have to apply\n\t\t * the cast function to get to the operator's input type.\n\t\t *\n\t\t * XXX eventually it would be good to support array-coercion cases\n\t\t * here and in ri_AttributesEqual().  At the moment there is no point\n\t\t * because cases involving nonidentical array types will be rejected\n\t\t * at constraint creation time.\n\t\t *\n\t\t * XXX perhaps also consider supporting CoerceViaIO?  No need at the\n\t\t * moment since that will never be generated for implicit coercions.\n\t\t */\n\t\top_input_types(eq_opr, &lefttype, &righttype);\n\t\tAssert(lefttype == righttype);\n\t\tif (typeid == lefttype)\n\t\t\tcastfunc = InvalidOid;\t/* simplest case */\n\t\telse\n\t\t{\n\t\t\tpathtype = find_coercion_pathway(lefttype, typeid,\n\t\t\t\t\t\t\t\t\t\t\t COERCION_IMPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t &castfunc);\n\t\t\tif (pathtype != COERCION_PATH_FUNC &&\n\t\t\t\tpathtype != COERCION_PATH_RELABELTYPE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The declared input type of the eq_opr might be a\n\t\t\t\t * polymorphic type such as ANYARRAY or ANYENUM, or other\n\t\t\t\t * special cases such as RECORD; find_coercion_pathway\n\t\t\t\t * currently doesn't subsume these special cases.\n\t\t\t\t */\n\t\t\t\tif (!IsBinaryCoercible(typeid, lefttype))\n\t\t\t\t\telog(ERROR, \"no conversion function from %s to %s\",\n\t\t\t\t\t\t format_type_be(typeid),\n\t\t\t\t\t\t format_type_be(lefttype));\n\t\t\t}\n\t\t}\n\t\tif (OidIsValid(castfunc))\n\t\t\tfmgr_info_cxt(castfunc, &entry->cast_func_finfo,\n\t\t\t\t\t\t  TopMemoryContext);\n\t\telse\n\t\t\tentry->cast_func_finfo.fn_oid = InvalidOid;\n\t\tentry->valid = true;\n\t}\n\n\treturn entry;\n}"
  },
  {
    "function_name": "ri_AttributesEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "3036-3061",
    "snippet": "static bool\nri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue)\n{\n\tRI_CompareHashEntry *entry = ri_HashCompareOp(eq_opr, typeid);\n\n\t/* Do we need to cast the values? */\n\tif (OidIsValid(entry->cast_func_finfo.fn_oid))\n\t{\n\t\toldvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t oldvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t\tnewvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t newvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t}\n\n\t/*\n\t * Apply the comparison operator.  We assume it doesn't care about\n\t * collations.\n\t */\n\treturn DatumGetBool(FunctionCall2(&entry->eq_opr_finfo,\n\t\t\t\t\t\t\t\t\t  oldvalue, newvalue));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
      "static RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2(&entry->eq_opr_finfo,\n\t\t\t\t\t\t\t\t\t  oldvalue, newvalue)"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2",
          "args": [
            "&entry->eq_opr_finfo",
            "oldvalue",
            "newvalue"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall3",
          "args": [
            "&entry->cast_func_finfo",
            "newvalue",
            "Int32GetDatum(-1)",
            "/* typmod */BoolGetDatum(false)"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall3",
          "args": [
            "&entry->cast_func_finfo",
            "oldvalue",
            "Int32GetDatum(-1)",
            "/* typmod */BoolGetDatum(false)"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "entry->cast_func_finfo.fn_oid"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_HashCompareOp",
          "args": [
            "eq_opr",
            "typeid"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "ri_HashCompareOp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "3070-3156",
          "snippet": "static RI_CompareHashEntry *\nri_HashCompareOp(Oid eq_opr, Oid typeid)\n{\n\tRI_CompareKey key;\n\tRI_CompareHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_compare_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  Note we're assuming RI_CompareKey\n\t * contains no struct padding.\n\t */\n\tkey.eq_opr = eq_opr;\n\tkey.typeid = typeid;\n\tentry = (RI_CompareHashEntry *) hash_search(ri_compare_cache,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (!found)\n\t\tentry->valid = false;\n\n\t/*\n\t * If not already initialized, do so.  Since we'll keep this hash entry\n\t * for the life of the backend, put any subsidiary info for the function\n\t * cache structs into TopMemoryContext.\n\t */\n\tif (!entry->valid)\n\t{\n\t\tOid\t\t\tlefttype,\n\t\t\t\t\trighttype,\n\t\t\t\t\tcastfunc;\n\t\tCoercionPathType pathtype;\n\n\t\t/* We always need to know how to call the equality operator */\n\t\tfmgr_info_cxt(get_opcode(eq_opr), &entry->eq_opr_finfo,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/*\n\t\t * If we chose to use a cast from FK to PK type, we may have to apply\n\t\t * the cast function to get to the operator's input type.\n\t\t *\n\t\t * XXX eventually it would be good to support array-coercion cases\n\t\t * here and in ri_AttributesEqual().  At the moment there is no point\n\t\t * because cases involving nonidentical array types will be rejected\n\t\t * at constraint creation time.\n\t\t *\n\t\t * XXX perhaps also consider supporting CoerceViaIO?  No need at the\n\t\t * moment since that will never be generated for implicit coercions.\n\t\t */\n\t\top_input_types(eq_opr, &lefttype, &righttype);\n\t\tAssert(lefttype == righttype);\n\t\tif (typeid == lefttype)\n\t\t\tcastfunc = InvalidOid;\t/* simplest case */\n\t\telse\n\t\t{\n\t\t\tpathtype = find_coercion_pathway(lefttype, typeid,\n\t\t\t\t\t\t\t\t\t\t\t COERCION_IMPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t &castfunc);\n\t\t\tif (pathtype != COERCION_PATH_FUNC &&\n\t\t\t\tpathtype != COERCION_PATH_RELABELTYPE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The declared input type of the eq_opr might be a\n\t\t\t\t * polymorphic type such as ANYARRAY or ANYENUM, or other\n\t\t\t\t * special cases such as RECORD; find_coercion_pathway\n\t\t\t\t * currently doesn't subsume these special cases.\n\t\t\t\t */\n\t\t\t\tif (!IsBinaryCoercible(typeid, lefttype))\n\t\t\t\t\telog(ERROR, \"no conversion function from %s to %s\",\n\t\t\t\t\t\t format_type_be(typeid),\n\t\t\t\t\t\t format_type_be(lefttype));\n\t\t\t}\n\t\t}\n\t\tif (OidIsValid(castfunc))\n\t\t\tfmgr_info_cxt(castfunc, &entry->cast_func_finfo,\n\t\t\t\t\t\t  TopMemoryContext);\n\t\telse\n\t\t\tentry->cast_func_finfo.fn_oid = InvalidOid;\n\t\tentry->valid = true;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_compare_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);\n\nstatic RI_CompareHashEntry *\nri_HashCompareOp(Oid eq_opr, Oid typeid)\n{\n\tRI_CompareKey key;\n\tRI_CompareHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_compare_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  Note we're assuming RI_CompareKey\n\t * contains no struct padding.\n\t */\n\tkey.eq_opr = eq_opr;\n\tkey.typeid = typeid;\n\tentry = (RI_CompareHashEntry *) hash_search(ri_compare_cache,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (!found)\n\t\tentry->valid = false;\n\n\t/*\n\t * If not already initialized, do so.  Since we'll keep this hash entry\n\t * for the life of the backend, put any subsidiary info for the function\n\t * cache structs into TopMemoryContext.\n\t */\n\tif (!entry->valid)\n\t{\n\t\tOid\t\t\tlefttype,\n\t\t\t\t\trighttype,\n\t\t\t\t\tcastfunc;\n\t\tCoercionPathType pathtype;\n\n\t\t/* We always need to know how to call the equality operator */\n\t\tfmgr_info_cxt(get_opcode(eq_opr), &entry->eq_opr_finfo,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/*\n\t\t * If we chose to use a cast from FK to PK type, we may have to apply\n\t\t * the cast function to get to the operator's input type.\n\t\t *\n\t\t * XXX eventually it would be good to support array-coercion cases\n\t\t * here and in ri_AttributesEqual().  At the moment there is no point\n\t\t * because cases involving nonidentical array types will be rejected\n\t\t * at constraint creation time.\n\t\t *\n\t\t * XXX perhaps also consider supporting CoerceViaIO?  No need at the\n\t\t * moment since that will never be generated for implicit coercions.\n\t\t */\n\t\top_input_types(eq_opr, &lefttype, &righttype);\n\t\tAssert(lefttype == righttype);\n\t\tif (typeid == lefttype)\n\t\t\tcastfunc = InvalidOid;\t/* simplest case */\n\t\telse\n\t\t{\n\t\t\tpathtype = find_coercion_pathway(lefttype, typeid,\n\t\t\t\t\t\t\t\t\t\t\t COERCION_IMPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t &castfunc);\n\t\t\tif (pathtype != COERCION_PATH_FUNC &&\n\t\t\t\tpathtype != COERCION_PATH_RELABELTYPE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The declared input type of the eq_opr might be a\n\t\t\t\t * polymorphic type such as ANYARRAY or ANYENUM, or other\n\t\t\t\t * special cases such as RECORD; find_coercion_pathway\n\t\t\t\t * currently doesn't subsume these special cases.\n\t\t\t\t */\n\t\t\t\tif (!IsBinaryCoercible(typeid, lefttype))\n\t\t\t\t\telog(ERROR, \"no conversion function from %s to %s\",\n\t\t\t\t\t\t format_type_be(typeid),\n\t\t\t\t\t\t format_type_be(lefttype));\n\t\t\t}\n\t\t}\n\t\tif (OidIsValid(castfunc))\n\t\t\tfmgr_info_cxt(castfunc, &entry->cast_func_finfo,\n\t\t\t\t\t\t  TopMemoryContext);\n\t\telse\n\t\t\tentry->cast_func_finfo.fn_oid = InvalidOid;\n\t\tentry->valid = true;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);\n\nstatic bool\nri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue)\n{\n\tRI_CompareHashEntry *entry = ri_HashCompareOp(eq_opr, typeid);\n\n\t/* Do we need to cast the values? */\n\tif (OidIsValid(entry->cast_func_finfo.fn_oid))\n\t{\n\t\toldvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t oldvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t\tnewvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t newvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t}\n\n\t/*\n\t * Apply the comparison operator.  We assume it doesn't care about\n\t * collations.\n\t */\n\treturn DatumGetBool(FunctionCall2(&entry->eq_opr_finfo,\n\t\t\t\t\t\t\t\t\t  oldvalue, newvalue));\n}"
  },
  {
    "function_name": "ri_KeysEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2976-3025",
    "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void quoteRelationName(char *buffer, Relation rel);",
      "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
      "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_AttributesEqual",
          "args": [
            "eq_oprs[i]",
            "RIAttType(rel, attnums[i])",
            "oldvalue",
            "newvalue"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "ri_AttributesEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "3036-3061",
          "snippet": "static bool\nri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue)\n{\n\tRI_CompareHashEntry *entry = ri_HashCompareOp(eq_opr, typeid);\n\n\t/* Do we need to cast the values? */\n\tif (OidIsValid(entry->cast_func_finfo.fn_oid))\n\t{\n\t\toldvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t oldvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t\tnewvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t newvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t}\n\n\t/*\n\t * Apply the comparison operator.  We assume it doesn't care about\n\t * collations.\n\t */\n\treturn DatumGetBool(FunctionCall2(&entry->eq_opr_finfo,\n\t\t\t\t\t\t\t\t\t  oldvalue, newvalue));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic RI_CompareHashEntry *ri_HashCompareOp(Oid eq_opr, Oid typeid);\n\nstatic bool\nri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue)\n{\n\tRI_CompareHashEntry *entry = ri_HashCompareOp(eq_opr, typeid);\n\n\t/* Do we need to cast the values? */\n\tif (OidIsValid(entry->cast_func_finfo.fn_oid))\n\t{\n\t\toldvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t oldvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t\tnewvalue = FunctionCall3(&entry->cast_func_finfo,\n\t\t\t\t\t\t\t\t newvalue,\n\t\t\t\t\t\t\t\t Int32GetDatum(-1), /* typmod */\n\t\t\t\t\t\t\t\t BoolGetDatum(false));\t/* implicit coercion */\n\t}\n\n\t/*\n\t * Apply the comparison operator.  We assume it doesn't care about\n\t * collations.\n\t */\n\treturn DatumGetBool(FunctionCall2(&entry->eq_opr_finfo,\n\t\t\t\t\t\t\t\t\t  oldvalue, newvalue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "rel",
            "attnums[i]"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "newtup",
            "attnums[i]",
            "tupdesc",
            "&isnull"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "oldtup",
            "attnums[i]",
            "tupdesc",
            "&isnull"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rel"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "ri_HashPreparedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2941-2962",
    "snippet": "static void\nri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan)\n{\n\tRI_QueryHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Add the new plan.  We might be overwriting an entry previously found\n\t * invalid by ri_FetchPreparedPlan.\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\tAssert(!found || entry->plan == NULL);\n\tentry->plan = plan;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *ri_query_cache = NULL;",
      "static void ri_InitHashTables(void);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!found || entry->plan == NULL"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "ri_query_cache",
            "(void *) key",
            "HASH_ENTER",
            "&found"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_InitHashTables",
          "args": [],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "ri_InitHashTables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2848-2878",
          "snippet": "static void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)",
            "#define RI_INIT_CONSTRAINTHASHSIZE\t\t64"
          ],
          "globals_used": [
            "static HTAB *ri_constraint_cache = NULL;",
            "static HTAB *ri_query_cache = NULL;",
            "static HTAB *ri_compare_cache = NULL;",
            "static void ri_InitHashTables(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)\n#define RI_INIT_CONSTRAINTHASHSIZE\t\t64\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic HTAB *ri_query_cache = NULL;\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\n\nstatic void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic void\nri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan)\n{\n\tRI_QueryHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Add the new plan.  We might be overwriting an entry previously found\n\t * invalid by ri_FetchPreparedPlan.\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\tAssert(!found || entry->plan == NULL);\n\tentry->plan = plan;\n}"
  },
  {
    "function_name": "ri_FetchPreparedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2888-2932",
    "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *ri_query_cache = NULL;",
      "static void ri_InitHashTables(void);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPI_freeplan",
          "args": [
            "plan"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_plan_is_valid",
          "args": [
            "plan"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "ri_query_cache",
            "(void *) key",
            "HASH_FIND",
            "NULL"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_InitHashTables",
          "args": [],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "ri_InitHashTables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2848-2878",
          "snippet": "static void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)",
            "#define RI_INIT_CONSTRAINTHASHSIZE\t\t64"
          ],
          "globals_used": [
            "static HTAB *ri_constraint_cache = NULL;",
            "static HTAB *ri_query_cache = NULL;",
            "static HTAB *ri_compare_cache = NULL;",
            "static void ri_InitHashTables(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)\n#define RI_INIT_CONSTRAINTHASHSIZE\t\t64\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic HTAB *ri_query_cache = NULL;\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\n\nstatic void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ri_InitHashTables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2848-2878",
    "snippet": "static void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)",
      "#define RI_INIT_CONSTRAINTHASHSIZE\t\t64"
    ],
    "globals_used": [
      "static HTAB *ri_constraint_cache = NULL;",
      "static HTAB *ri_query_cache = NULL;",
      "static HTAB *ri_compare_cache = NULL;",
      "static void ri_InitHashTables(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"RI compare cache\"",
            "RI_INIT_QUERYHASHSIZE",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CacheRegisterSyscacheCallback",
          "args": [
            "CONSTROID",
            "InvalidateConstraintCacheCallBack",
            "(Datum) 0"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterSyscacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1425-1456",
          "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_SYSCACHE_CALLBACKS 64"
          ],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];",
            "static int\tsyscache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)\n#define RI_INIT_CONSTRAINTHASHSIZE\t\t64\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic HTAB *ri_query_cache = NULL;\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\n\nstatic void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}"
  },
  {
    "function_name": "ri_NullCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2809-2839",
    "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "tup",
            "attnums[i]",
            "tupDesc"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
  },
  {
    "function_name": "ri_ReportViolation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2675-2798",
    "snippet": "static void\nri_ReportViolation(const RI_ConstraintInfo *riinfo,\n\t\t\t\t   Relation pk_rel, Relation fk_rel,\n\t\t\t\t   HeapTuple violator, TupleDesc tupdesc,\n\t\t\t\t   int queryno)\n{\n\tStringInfoData key_names;\n\tStringInfoData key_values;\n\tbool\t\tonfk;\n\tconst int16 *attnums;\n\tint\t\t\tidx;\n\tOid\t\t\trel_oid;\n\tAclResult\taclresult;\n\tbool\t\thas_perm = true;\n\n\t/*\n\t * Determine which relation to complain about.  If tupdesc wasn't passed\n\t * by caller, assume the violator tuple came from there.\n\t */\n\tonfk = (queryno == RI_PLAN_CHECK_LOOKUPPK);\n\tif (onfk)\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\trel_oid = fk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = fk_rel->rd_att;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\trel_oid = pk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = pk_rel->rd_att;\n\t}\n\n\t/*\n\t * Check permissions- if the user does not have access to view the data in\n\t * any of the key columns then we don't include the errdetail() below.\n\t *\n\t * Check if RLS is enabled on the relation first.  If so, we don't return\n\t * any specifics to avoid leaking data.\n\t *\n\t * Check table-level permissions next and, failing that, column-level\n\t * privileges.\n\t */\n\n\tif (check_enable_rls(rel_oid, InvalidOid, true) != RLS_ENABLED)\n\t{\n\t\taclresult = pg_class_aclcheck(rel_oid, GetUserId(), ACL_SELECT);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t{\n\t\t\t/* Try for column-level permissions */\n\t\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t\t{\n\t\t\t\taclresult = pg_attribute_aclcheck(rel_oid, attnums[idx],\n\t\t\t\t\t\t\t\t\t\t\t\t  GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t  ACL_SELECT);\n\n\t\t\t\t/* No access to the key */\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t{\n\t\t\t\t\thas_perm = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\thas_perm = false;\n\n\tif (has_perm)\n\t{\n\t\t/* Get printable versions of the keys involved */\n\t\tinitStringInfo(&key_names);\n\t\tinitStringInfo(&key_values);\n\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t{\n\t\t\tint\t\t\tfnum = attnums[idx];\n\t\t\tchar\t   *name,\n\t\t\t\t\t   *val;\n\n\t\t\tname = SPI_fname(tupdesc, fnum);\n\t\t\tval = SPI_getvalue(violator, tupdesc, fnum);\n\t\t\tif (!val)\n\t\t\t\tval = \"null\";\n\n\t\t\tif (idx > 0)\n\t\t\t{\n\t\t\t\tappendStringInfoString(&key_names, \", \");\n\t\t\t\tappendStringInfoString(&key_values, \", \");\n\t\t\t}\n\t\t\tappendStringInfoString(&key_names, name);\n\t\t\tappendStringInfoString(&key_values, val);\n\t\t}\n\t}\n\n\tif (onfk)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void quoteOneName(char *buffer, const char *name);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname)))"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errtableconstraint",
          "args": [
            "fk_rel",
            "NameStr(riinfo->conname)"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "errtableconstraint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5336-5343",
          "snippet": "int\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Key is still referenced from table \\\"%s\\\".\"",
            "RelationGetRelationName(fk_rel)"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\"",
            "RelationGetRelationName(pk_rel)",
            "NameStr(riinfo->conname)",
            "RelationGetRelationName(fk_rel)"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "pk_rel"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FOREIGN_KEY_VIOLATION"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname)))"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "pk_rel"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "pk_rel"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&key_values",
            "val"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&key_names",
            "name"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&key_values",
            "\", \""
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&key_names",
            "\", \""
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getvalue",
          "args": [
            "violator",
            "tupdesc",
            "fnum"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_fname",
          "args": [
            "tupdesc",
            "fnum"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&key_values"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&key_names"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_attribute_aclcheck",
          "args": [
            "rel_oid",
            "attnums[idx]",
            "GetUserId()",
            "ACL_SELECT"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_class_aclcheck",
          "args": [
            "rel_oid",
            "GetUserId()",
            "ACL_SELECT"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_enable_rls",
          "args": [
            "rel_oid",
            "InvalidOid",
            "true"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "check_enable_rls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/rls.c",
          "lines": "51-133",
          "snippet": "int\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rls.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nint\ncheck_enable_rls(Oid relid, Oid checkAsUser, bool noError)\n{\n\tOid\t\t\tuser_id = checkAsUser ? checkAsUser : GetUserId();\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\tbool\t\trelrowsecurity;\n\tbool\t\trelforcerowsecurity;\n\tbool\t\tamowner;\n\n\t/* Nothing to do for built-in relations */\n\tif (relid < (Oid) FirstNormalObjectId)\n\t\treturn RLS_NONE;\n\n\t/* Fetch relation's relrowsecurity and relforcerowsecurity flags */\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn RLS_NONE;\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\trelrowsecurity = classform->relrowsecurity;\n\trelforcerowsecurity = classform->relforcerowsecurity;\n\n\tReleaseSysCache(tuple);\n\n\t/* Nothing to do if the relation does not have RLS */\n\tif (!relrowsecurity)\n\t\treturn RLS_NONE;\n\n\t/*\n\t * BYPASSRLS users always bypass RLS.  Note that superusers are always\n\t * considered to have BYPASSRLS.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tif (has_bypassrls_privilege(user_id))\n\t\treturn RLS_NONE_ENV;\n\n\t/*\n\t * Table owners generally bypass RLS, except if the table has been set (by\n\t * an owner) to FORCE ROW SECURITY, and this is not a referential\n\t * integrity check.\n\t *\n\t * Return RLS_NONE_ENV to indicate that this decision depends on the\n\t * environment (in this case, the user_id).\n\t */\n\tamowner = pg_class_ownercheck(relid, user_id);\n\tif (amowner)\n\t{\n\t\t/*\n\t\t * If FORCE ROW LEVEL SECURITY has been set on the relation then we\n\t\t * should return RLS_ENABLED to indicate that RLS should be applied.\n\t\t * If not, or if we are in an InNoForceRLSOperation context, we return\n\t\t * RLS_NONE_ENV.\n\t\t *\n\t\t * InNoForceRLSOperation indicates that we should not apply RLS even\n\t\t * if the table has FORCE RLS set - IF the current user is the owner.\n\t\t * This is specifically to ensure that referential integrity checks\n\t\t * are able to still run correctly.\n\t\t *\n\t\t * This is intentionally only done after we have checked that the user\n\t\t * is the table owner, which should always be the case for referential\n\t\t * integrity checks.\n\t\t */\n\t\tif (!relforcerowsecurity || InNoForceRLSOperation())\n\t\t\treturn RLS_NONE_ENV;\n\t}\n\n\t/*\n\t * We should apply RLS.  However, the user may turn off the row_security\n\t * GUC to get a forced error instead.\n\t */\n\tif (!row_security && !noError)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"query would be affected by row-level security policy for table \\\"%s\\\"\",\n\t\t\t\t\t\tget_rel_name(relid)),\n\t\t\t\t amowner ? errhint(\"To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.\") : 0));\n\n\t/* RLS should be fully enabled for this relation. */\n\treturn RLS_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteOneName(char *buffer, const char *name);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_ReportViolation(const RI_ConstraintInfo *riinfo,\n\t\t\t\t   Relation pk_rel, Relation fk_rel,\n\t\t\t\t   HeapTuple violator, TupleDesc tupdesc,\n\t\t\t\t   int queryno)\n{\n\tStringInfoData key_names;\n\tStringInfoData key_values;\n\tbool\t\tonfk;\n\tconst int16 *attnums;\n\tint\t\t\tidx;\n\tOid\t\t\trel_oid;\n\tAclResult\taclresult;\n\tbool\t\thas_perm = true;\n\n\t/*\n\t * Determine which relation to complain about.  If tupdesc wasn't passed\n\t * by caller, assume the violator tuple came from there.\n\t */\n\tonfk = (queryno == RI_PLAN_CHECK_LOOKUPPK);\n\tif (onfk)\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\trel_oid = fk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = fk_rel->rd_att;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\trel_oid = pk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = pk_rel->rd_att;\n\t}\n\n\t/*\n\t * Check permissions- if the user does not have access to view the data in\n\t * any of the key columns then we don't include the errdetail() below.\n\t *\n\t * Check if RLS is enabled on the relation first.  If so, we don't return\n\t * any specifics to avoid leaking data.\n\t *\n\t * Check table-level permissions next and, failing that, column-level\n\t * privileges.\n\t */\n\n\tif (check_enable_rls(rel_oid, InvalidOid, true) != RLS_ENABLED)\n\t{\n\t\taclresult = pg_class_aclcheck(rel_oid, GetUserId(), ACL_SELECT);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t{\n\t\t\t/* Try for column-level permissions */\n\t\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t\t{\n\t\t\t\taclresult = pg_attribute_aclcheck(rel_oid, attnums[idx],\n\t\t\t\t\t\t\t\t\t\t\t\t  GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t  ACL_SELECT);\n\n\t\t\t\t/* No access to the key */\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t{\n\t\t\t\t\thas_perm = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\thas_perm = false;\n\n\tif (has_perm)\n\t{\n\t\t/* Get printable versions of the keys involved */\n\t\tinitStringInfo(&key_names);\n\t\tinitStringInfo(&key_values);\n\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t{\n\t\t\tint\t\t\tfnum = attnums[idx];\n\t\t\tchar\t   *name,\n\t\t\t\t\t   *val;\n\n\t\t\tname = SPI_fname(tupdesc, fnum);\n\t\t\tval = SPI_getvalue(violator, tupdesc, fnum);\n\t\t\tif (!val)\n\t\t\t\tval = \"null\";\n\n\t\t\tif (idx > 0)\n\t\t\t{\n\t\t\t\tappendStringInfoString(&key_names, \", \");\n\t\t\t\tappendStringInfoString(&key_values, \", \");\n\t\t\t}\n\t\t\tappendStringInfoString(&key_names, name);\n\t\t\tappendStringInfoString(&key_values, val);\n\t\t}\n\t}\n\n\tif (onfk)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n}"
  },
  {
    "function_name": "ri_ExtractValues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2643-2664",
    "snippet": "static void\nri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls)\n{\n\tTupleDesc\ttupdesc = rel->rd_att;\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tisnull;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tvals[i] = heap_getattr(tup, attnums[i], tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\tnulls[i] = isnull ? 'n' : ' ';\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void quoteRelationName(char *buffer, Relation rel);",
      "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
      "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tup",
            "attnums[i]",
            "tupdesc",
            "&isnull"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic void\nri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls)\n{\n\tTupleDesc\ttupdesc = rel->rd_att;\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tisnull;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tvals[i] = heap_getattr(tup, attnums[i], tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\tnulls[i] = isnull ? 'n' : ' ';\n\t}\n}"
  },
  {
    "function_name": "ri_PerformCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2506-2638",
    "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
      "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
      "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
      "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_ReportViolation",
          "args": [
            "riinfo",
            "pk_rel",
            "fk_rel",
            "new_tuple ? new_tuple : old_tuple",
            "NULL",
            "qkey->constr_queryno"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "ri_ReportViolation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2675-2798",
          "snippet": "static void\nri_ReportViolation(const RI_ConstraintInfo *riinfo,\n\t\t\t\t   Relation pk_rel, Relation fk_rel,\n\t\t\t\t   HeapTuple violator, TupleDesc tupdesc,\n\t\t\t\t   int queryno)\n{\n\tStringInfoData key_names;\n\tStringInfoData key_values;\n\tbool\t\tonfk;\n\tconst int16 *attnums;\n\tint\t\t\tidx;\n\tOid\t\t\trel_oid;\n\tAclResult\taclresult;\n\tbool\t\thas_perm = true;\n\n\t/*\n\t * Determine which relation to complain about.  If tupdesc wasn't passed\n\t * by caller, assume the violator tuple came from there.\n\t */\n\tonfk = (queryno == RI_PLAN_CHECK_LOOKUPPK);\n\tif (onfk)\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\trel_oid = fk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = fk_rel->rd_att;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\trel_oid = pk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = pk_rel->rd_att;\n\t}\n\n\t/*\n\t * Check permissions- if the user does not have access to view the data in\n\t * any of the key columns then we don't include the errdetail() below.\n\t *\n\t * Check if RLS is enabled on the relation first.  If so, we don't return\n\t * any specifics to avoid leaking data.\n\t *\n\t * Check table-level permissions next and, failing that, column-level\n\t * privileges.\n\t */\n\n\tif (check_enable_rls(rel_oid, InvalidOid, true) != RLS_ENABLED)\n\t{\n\t\taclresult = pg_class_aclcheck(rel_oid, GetUserId(), ACL_SELECT);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t{\n\t\t\t/* Try for column-level permissions */\n\t\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t\t{\n\t\t\t\taclresult = pg_attribute_aclcheck(rel_oid, attnums[idx],\n\t\t\t\t\t\t\t\t\t\t\t\t  GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t  ACL_SELECT);\n\n\t\t\t\t/* No access to the key */\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t{\n\t\t\t\t\thas_perm = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\thas_perm = false;\n\n\tif (has_perm)\n\t{\n\t\t/* Get printable versions of the keys involved */\n\t\tinitStringInfo(&key_names);\n\t\tinitStringInfo(&key_values);\n\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t{\n\t\t\tint\t\t\tfnum = attnums[idx];\n\t\t\tchar\t   *name,\n\t\t\t\t\t   *val;\n\n\t\t\tname = SPI_fname(tupdesc, fnum);\n\t\t\tval = SPI_getvalue(violator, tupdesc, fnum);\n\t\t\tif (!val)\n\t\t\t\tval = \"null\";\n\n\t\t\tif (idx > 0)\n\t\t\t{\n\t\t\t\tappendStringInfoString(&key_names, \", \");\n\t\t\t\tappendStringInfoString(&key_values, \", \");\n\t\t\t}\n\t\t\tappendStringInfoString(&key_names, name);\n\t\t\tappendStringInfoString(&key_values, val);\n\t\t}\n\t}\n\n\tif (onfk)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteOneName(char *buffer, const char *name);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteOneName(char *buffer, const char *name);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_ReportViolation(const RI_ConstraintInfo *riinfo,\n\t\t\t\t   Relation pk_rel, Relation fk_rel,\n\t\t\t\t   HeapTuple violator, TupleDesc tupdesc,\n\t\t\t\t   int queryno)\n{\n\tStringInfoData key_names;\n\tStringInfoData key_values;\n\tbool\t\tonfk;\n\tconst int16 *attnums;\n\tint\t\t\tidx;\n\tOid\t\t\trel_oid;\n\tAclResult\taclresult;\n\tbool\t\thas_perm = true;\n\n\t/*\n\t * Determine which relation to complain about.  If tupdesc wasn't passed\n\t * by caller, assume the violator tuple came from there.\n\t */\n\tonfk = (queryno == RI_PLAN_CHECK_LOOKUPPK);\n\tif (onfk)\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\trel_oid = fk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = fk_rel->rd_att;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\trel_oid = pk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = pk_rel->rd_att;\n\t}\n\n\t/*\n\t * Check permissions- if the user does not have access to view the data in\n\t * any of the key columns then we don't include the errdetail() below.\n\t *\n\t * Check if RLS is enabled on the relation first.  If so, we don't return\n\t * any specifics to avoid leaking data.\n\t *\n\t * Check table-level permissions next and, failing that, column-level\n\t * privileges.\n\t */\n\n\tif (check_enable_rls(rel_oid, InvalidOid, true) != RLS_ENABLED)\n\t{\n\t\taclresult = pg_class_aclcheck(rel_oid, GetUserId(), ACL_SELECT);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t{\n\t\t\t/* Try for column-level permissions */\n\t\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t\t{\n\t\t\t\taclresult = pg_attribute_aclcheck(rel_oid, attnums[idx],\n\t\t\t\t\t\t\t\t\t\t\t\t  GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t  ACL_SELECT);\n\n\t\t\t\t/* No access to the key */\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t{\n\t\t\t\t\thas_perm = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\thas_perm = false;\n\n\tif (has_perm)\n\t{\n\t\t/* Get printable versions of the keys involved */\n\t\tinitStringInfo(&key_names);\n\t\tinitStringInfo(&key_values);\n\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t{\n\t\t\tint\t\t\tfnum = attnums[idx];\n\t\t\tchar\t   *name,\n\t\t\t\t\t   *val;\n\n\t\t\tname = SPI_fname(tupdesc, fnum);\n\t\t\tval = SPI_getvalue(violator, tupdesc, fnum);\n\t\t\tif (!val)\n\t\t\t\tval = \"null\";\n\n\t\t\tif (idx > 0)\n\t\t\t{\n\t\t\t\tappendStringInfoString(&key_names, \", \");\n\t\t\t\tappendStringInfoString(&key_values, \", \");\n\t\t\t}\n\t\t\tappendStringInfoString(&key_names, name);\n\t\t\tappendStringInfoString(&key_values, val);\n\t\t}\n\t}\n\n\tif (onfk)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\"))"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"This is most likely due to a rule having rewritten the query.\""
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\"",
            "RelationGetRelationName(pk_rel)",
            "NameStr(riinfo->conname)",
            "RelationGetRelationName(fk_rel)"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "pk_rel"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INTERNAL_ERROR"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_execute_snapshot returned %s\"",
            "SPI_result_code_string(spi_result)"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_result_code_string",
          "args": [
            "spi_result"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetUserIdAndSecContext",
          "args": [
            "save_userid",
            "save_sec_context"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "SetUserIdAndSecContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "498-503",
          "snippet": "void\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_execute_snapshot",
          "args": [
            "qplan",
            "vals",
            "nulls",
            "test_snapshot",
            "crosscheck_snapshot",
            "false",
            "false",
            "limit"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetForm",
          "args": [
            "query_rel"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserIdAndSecContext",
          "args": [
            "&save_userid",
            "&save_sec_context"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserIdAndSecContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "491-496",
          "snippet": "void\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTransactionSnapshot",
          "args": [],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "303-371",
          "snippet": "Snapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot HistoricSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot HistoricSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLatestSnapshot",
          "args": [],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "GetLatestSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "378-402",
          "snippet": "Snapshot\nGetLatestSnapshot(void)\n{\n\t/*\n\t * We might be able to relax this, but nothing that could otherwise work\n\t * needs it.\n\t */\n\tif (IsInParallelMode())\n\t\telog(ERROR,\n\t\t\t \"cannot update SecondarySnapshot during a parallel operation\");\n\n\t/*\n\t * So far there are no cases requiring support for GetLatestSnapshot()\n\t * during logical decoding, but it wouldn't be hard to add if required.\n\t */\n\tAssert(!HistoricSnapshotActive());\n\n\t/* If first call in transaction, go ahead and set the xact snapshot */\n\tif (!FirstSnapshotSet)\n\t\treturn GetTransactionSnapshot();\n\n\tSecondarySnapshot = GetSnapshotData(&SecondarySnapshotData);\n\n\treturn SecondarySnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData SecondarySnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot SecondarySnapshot = NULL;",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData SecondarySnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot SecondarySnapshot = NULL;\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetLatestSnapshot(void)\n{\n\t/*\n\t * We might be able to relax this, but nothing that could otherwise work\n\t * needs it.\n\t */\n\tif (IsInParallelMode())\n\t\telog(ERROR,\n\t\t\t \"cannot update SecondarySnapshot during a parallel operation\");\n\n\t/*\n\t * So far there are no cases requiring support for GetLatestSnapshot()\n\t * during logical decoding, but it wouldn't be hard to add if required.\n\t */\n\tAssert(!HistoricSnapshotActive());\n\n\t/* If first call in transaction, go ahead and set the xact snapshot */\n\tif (!FirstSnapshotSet)\n\t\treturn GetTransactionSnapshot();\n\n\tSecondarySnapshot = GetSnapshotData(&SecondarySnapshotData);\n\n\treturn SecondarySnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CommandCounterIncrement",
          "args": [],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationUsesXactSnapshot",
          "args": [],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_ExtractValues",
          "args": [
            "source_rel",
            "old_tuple",
            "riinfo",
            "source_is_pk",
            "vals",
            "nulls"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ri_ExtractValues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2643-2664",
          "snippet": "static void\nri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls)\n{\n\tTupleDesc\ttupdesc = rel->rd_att;\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tisnull;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tvals[i] = heap_getattr(tup, attnums[i], tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\tnulls[i] = isnull ? 'n' : ' ';\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic void\nri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls)\n{\n\tTupleDesc\ttupdesc = rel->rd_att;\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tisnull;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tvals[i] = heap_getattr(tup, attnums[i], tupdesc,\n\t\t\t\t\t\t\t   &isnull);\n\t\tnulls[i] = isnull ? 'n' : ' ';\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
  },
  {
    "function_name": "ri_PlanCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2459-2501",
    "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
    ],
    "globals_used": [
      "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
      "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_HashPreparedPlan",
          "args": [
            "qkey",
            "qplan"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "ri_HashPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2941-2962",
          "snippet": "static void\nri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan)\n{\n\tRI_QueryHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Add the new plan.  We might be overwriting an entry previously found\n\t * invalid by ri_FetchPreparedPlan.\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\tAssert(!found || entry->plan == NULL);\n\tentry->plan = plan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic void\nri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan)\n{\n\tRI_QueryHashEntry *entry;\n\tbool\t\tfound;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Add the new plan.  We might be overwriting an entry previously found\n\t * invalid by ri_FetchPreparedPlan.\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\tAssert(!found || entry->plan == NULL);\n\tentry->plan = plan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_keepplan",
          "args": [
            "qplan"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetUserIdAndSecContext",
          "args": [
            "save_userid",
            "save_sec_context"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "SetUserIdAndSecContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "498-503",
          "snippet": "void\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_prepare returned %s for %s\"",
            "SPI_result_code_string(SPI_result)",
            "querystr"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_result_code_string",
          "args": [
            "SPI_result"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_prepare",
          "args": [
            "querystr",
            "nargs",
            "argtypes"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetForm",
          "args": [
            "query_rel"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserIdAndSecContext",
          "args": [
            "&save_userid",
            "&save_sec_context"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserIdAndSecContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "491-496",
          "snippet": "void\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
  },
  {
    "function_name": "InvalidateConstraintCacheCallBack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2421-2450",
    "snippet": "static void\nInvalidateConstraintCacheCallBack(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tdlist_mutable_iter iter;\n\n\tAssert(ri_constraint_cache != NULL);\n\n\t/*\n\t * If the list of currently valid entries gets excessively large, we mark\n\t * them all invalid so we can empty the list.  This arrangement avoids\n\t * O(N^2) behavior in situations where a session touches many foreign keys\n\t * and also does many ALTER TABLEs, such as a restore from pg_dump.\n\t */\n\tif (ri_constraint_cache_valid_count > 1000)\n\t\thashvalue = 0;\t\t\t/* pretend it's a cache reset */\n\n\tdlist_foreach_modify(iter, &ri_constraint_cache_valid_list)\n\t{\n\t\tRI_ConstraintInfo *riinfo = dlist_container(RI_ConstraintInfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalid_link, iter.cur);\n\n\t\tif (hashvalue == 0 || riinfo->oidHashValue == hashvalue)\n\t\t{\n\t\t\triinfo->valid = false;\n\t\t\t/* Remove invalidated entries from the list, too */\n\t\t\tdlist_delete(iter.cur);\n\t\t\tri_constraint_cache_valid_count--;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *ri_constraint_cache = NULL;",
      "static dlist_head ri_constraint_cache_valid_list;",
      "static int\tri_constraint_cache_valid_count = 0;",
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void InvalidateConstraintCacheCallBack(Datum arg, int cacheid, uint32 hashvalue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "iter.cur"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "RI_ConstraintInfo",
            "valid_link",
            "iter.cur"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "iter",
            "&ri_constraint_cache_valid_list"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ri_constraint_cache != NULL"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic dlist_head ri_constraint_cache_valid_list;\nstatic int\tri_constraint_cache_valid_count = 0;\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void InvalidateConstraintCacheCallBack(Datum arg, int cacheid, uint32 hashvalue);\n\nstatic void\nInvalidateConstraintCacheCallBack(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tdlist_mutable_iter iter;\n\n\tAssert(ri_constraint_cache != NULL);\n\n\t/*\n\t * If the list of currently valid entries gets excessively large, we mark\n\t * them all invalid so we can empty the list.  This arrangement avoids\n\t * O(N^2) behavior in situations where a session touches many foreign keys\n\t * and also does many ALTER TABLEs, such as a restore from pg_dump.\n\t */\n\tif (ri_constraint_cache_valid_count > 1000)\n\t\thashvalue = 0;\t\t\t/* pretend it's a cache reset */\n\n\tdlist_foreach_modify(iter, &ri_constraint_cache_valid_list)\n\t{\n\t\tRI_ConstraintInfo *riinfo = dlist_container(RI_ConstraintInfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalid_link, iter.cur);\n\n\t\tif (hashvalue == 0 || riinfo->oidHashValue == hashvalue)\n\t\t{\n\t\t\triinfo->valid = false;\n\t\t\t/* Remove invalidated entries from the list, too */\n\t\t\tdlist_delete(iter.cur);\n\t\t\tri_constraint_cache_valid_count--;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ri_LoadConstraintInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2337-2405",
    "snippet": "static const RI_ConstraintInfo *\nri_LoadConstraintInfo(Oid constraintOid)\n{\n\tRI_ConstraintInfo *riinfo;\n\tbool\t\tfound;\n\tHeapTuple\ttup;\n\tForm_pg_constraint conForm;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_constraint_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  If we find a valid one, just return it.\n\t */\n\triinfo = (RI_ConstraintInfo *) hash_search(ri_constraint_cache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &constraintOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\tif (!found)\n\t\triinfo->valid = false;\n\telse if (riinfo->valid)\n\t\treturn riinfo;\n\n\t/*\n\t * Fetch the pg_constraint row so we can fill in the entry.\n\t */\n\ttup = SearchSysCache1(CONSTROID, ObjectIdGetDatum(constraintOid));\n\tif (!HeapTupleIsValid(tup)) /* should not happen */\n\t\telog(ERROR, \"cache lookup failed for constraint %u\", constraintOid);\n\tconForm = (Form_pg_constraint) GETSTRUCT(tup);\n\n\tif (conForm->contype != CONSTRAINT_FOREIGN) /* should not happen */\n\t\telog(ERROR, \"constraint %u is not a foreign key constraint\",\n\t\t\t constraintOid);\n\n\t/* And extract data */\n\tAssert(riinfo->constraint_id == constraintOid);\n\triinfo->oidHashValue = GetSysCacheHashValue1(CONSTROID,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(constraintOid));\n\tmemcpy(&riinfo->conname, &conForm->conname, sizeof(NameData));\n\triinfo->pk_relid = conForm->confrelid;\n\triinfo->fk_relid = conForm->conrelid;\n\triinfo->confupdtype = conForm->confupdtype;\n\triinfo->confdeltype = conForm->confdeltype;\n\triinfo->confmatchtype = conForm->confmatchtype;\n\n\tDeconstructFkConstraintRow(tup,\n\t\t\t\t\t\t\t   &riinfo->nkeys,\n\t\t\t\t\t\t\t   riinfo->fk_attnums,\n\t\t\t\t\t\t\t   riinfo->pk_attnums,\n\t\t\t\t\t\t\t   riinfo->pf_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->pp_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->ff_eq_oprs);\n\n\tReleaseSysCache(tup);\n\n\t/*\n\t * For efficient processing of invalidation messages below, we keep a\n\t * doubly-linked list, and a count, of all currently valid entries.\n\t */\n\tdlist_push_tail(&ri_constraint_cache_valid_list, &riinfo->valid_link);\n\tri_constraint_cache_valid_count++;\n\n\triinfo->valid = true;\n\n\treturn riinfo;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *ri_constraint_cache = NULL;",
      "static dlist_head ri_constraint_cache_valid_list;",
      "static int\tri_constraint_cache_valid_count = 0;",
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void ri_InitHashTables(void);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlist_push_tail",
          "args": [
            "&ri_constraint_cache_valid_list",
            "&riinfo->valid_link"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeconstructFkConstraintRow",
          "args": [
            "tup",
            "&riinfo->nkeys",
            "riinfo->fk_attnums",
            "riinfo->pk_attnums",
            "riinfo->pf_eq_oprs",
            "riinfo->pp_eq_oprs",
            "riinfo->ff_eq_oprs"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&riinfo->conname",
            "&conForm->conname",
            "sizeof(NameData)"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSysCacheHashValue1",
          "args": [
            "CONSTROID",
            "ObjectIdGetDatum(constraintOid)"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "constraintOid"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "riinfo->constraint_id == constraintOid"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"constraint %u is not a foreign key constraint\"",
            "constraintOid"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "CONSTROID",
            "ObjectIdGetDatum(constraintOid)"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "constraintOid"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "ri_constraint_cache",
            "(void *) &constraintOid",
            "HASH_ENTER",
            "&found"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_InitHashTables",
          "args": [],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "ri_InitHashTables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2848-2878",
          "snippet": "static void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)",
            "#define RI_INIT_CONSTRAINTHASHSIZE\t\t64"
          ],
          "globals_used": [
            "static HTAB *ri_constraint_cache = NULL;",
            "static HTAB *ri_query_cache = NULL;",
            "static HTAB *ri_compare_cache = NULL;",
            "static void ri_InitHashTables(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_INIT_QUERYHASHSIZE\t\t\t(RI_INIT_CONSTRAINTHASHSIZE * 4)\n#define RI_INIT_CONSTRAINTHASHSIZE\t\t64\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic HTAB *ri_query_cache = NULL;\nstatic HTAB *ri_compare_cache = NULL;\nstatic void ri_InitHashTables(void);\n\nstatic void\nri_InitHashTables(void)\n{\n\tHASHCTL\t\tctl;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RI_ConstraintInfo);\n\tri_constraint_cache = hash_create(\"RI constraint cache\",\n\t\t\t\t\t\t\t\t\t  RI_INIT_CONSTRAINTHASHSIZE,\n\t\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/* Arrange to flush cache on pg_constraint changes */\n\tCacheRegisterSyscacheCallback(CONSTROID,\n\t\t\t\t\t\t\t\t  InvalidateConstraintCacheCallBack,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_QueryKey);\n\tctl.entrysize = sizeof(RI_QueryHashEntry);\n\tri_query_cache = hash_create(\"RI query cache\",\n\t\t\t\t\t\t\t\t RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t &ctl, HASH_ELEM | HASH_BLOBS);\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RI_CompareKey);\n\tctl.entrysize = sizeof(RI_CompareHashEntry);\n\tri_compare_cache = hash_create(\"RI compare cache\",\n\t\t\t\t\t\t\t\t   RI_INIT_QUERYHASHSIZE,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic dlist_head ri_constraint_cache_valid_list;\nstatic int\tri_constraint_cache_valid_count = 0;\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_LoadConstraintInfo(Oid constraintOid)\n{\n\tRI_ConstraintInfo *riinfo;\n\tbool\t\tfound;\n\tHeapTuple\ttup;\n\tForm_pg_constraint conForm;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_constraint_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  If we find a valid one, just return it.\n\t */\n\triinfo = (RI_ConstraintInfo *) hash_search(ri_constraint_cache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &constraintOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\tif (!found)\n\t\triinfo->valid = false;\n\telse if (riinfo->valid)\n\t\treturn riinfo;\n\n\t/*\n\t * Fetch the pg_constraint row so we can fill in the entry.\n\t */\n\ttup = SearchSysCache1(CONSTROID, ObjectIdGetDatum(constraintOid));\n\tif (!HeapTupleIsValid(tup)) /* should not happen */\n\t\telog(ERROR, \"cache lookup failed for constraint %u\", constraintOid);\n\tconForm = (Form_pg_constraint) GETSTRUCT(tup);\n\n\tif (conForm->contype != CONSTRAINT_FOREIGN) /* should not happen */\n\t\telog(ERROR, \"constraint %u is not a foreign key constraint\",\n\t\t\t constraintOid);\n\n\t/* And extract data */\n\tAssert(riinfo->constraint_id == constraintOid);\n\triinfo->oidHashValue = GetSysCacheHashValue1(CONSTROID,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(constraintOid));\n\tmemcpy(&riinfo->conname, &conForm->conname, sizeof(NameData));\n\triinfo->pk_relid = conForm->confrelid;\n\triinfo->fk_relid = conForm->conrelid;\n\triinfo->confupdtype = conForm->confupdtype;\n\triinfo->confdeltype = conForm->confdeltype;\n\triinfo->confmatchtype = conForm->confmatchtype;\n\n\tDeconstructFkConstraintRow(tup,\n\t\t\t\t\t\t\t   &riinfo->nkeys,\n\t\t\t\t\t\t\t   riinfo->fk_attnums,\n\t\t\t\t\t\t\t   riinfo->pk_attnums,\n\t\t\t\t\t\t\t   riinfo->pf_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->pp_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->ff_eq_oprs);\n\n\tReleaseSysCache(tup);\n\n\t/*\n\t * For efficient processing of invalidation messages below, we keep a\n\t * doubly-linked list, and a count, of all currently valid entries.\n\t */\n\tdlist_push_tail(&ri_constraint_cache_valid_list, &riinfo->valid_link);\n\tri_constraint_cache_valid_count++;\n\n\triinfo->valid = true;\n\n\treturn riinfo;\n}"
  },
  {
    "function_name": "ri_FetchConstraintInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2294-2332",
    "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
      "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
      "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\"",
            "trigger->tgname",
            "RelationGetRelationName(trig_rel)"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "trig_rel"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "trig_rel"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "trig_rel"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "trig_rel"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_LoadConstraintInfo",
          "args": [
            "constraintOid"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "ri_LoadConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2337-2405",
          "snippet": "static const RI_ConstraintInfo *\nri_LoadConstraintInfo(Oid constraintOid)\n{\n\tRI_ConstraintInfo *riinfo;\n\tbool\t\tfound;\n\tHeapTuple\ttup;\n\tForm_pg_constraint conForm;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_constraint_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  If we find a valid one, just return it.\n\t */\n\triinfo = (RI_ConstraintInfo *) hash_search(ri_constraint_cache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &constraintOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\tif (!found)\n\t\triinfo->valid = false;\n\telse if (riinfo->valid)\n\t\treturn riinfo;\n\n\t/*\n\t * Fetch the pg_constraint row so we can fill in the entry.\n\t */\n\ttup = SearchSysCache1(CONSTROID, ObjectIdGetDatum(constraintOid));\n\tif (!HeapTupleIsValid(tup)) /* should not happen */\n\t\telog(ERROR, \"cache lookup failed for constraint %u\", constraintOid);\n\tconForm = (Form_pg_constraint) GETSTRUCT(tup);\n\n\tif (conForm->contype != CONSTRAINT_FOREIGN) /* should not happen */\n\t\telog(ERROR, \"constraint %u is not a foreign key constraint\",\n\t\t\t constraintOid);\n\n\t/* And extract data */\n\tAssert(riinfo->constraint_id == constraintOid);\n\triinfo->oidHashValue = GetSysCacheHashValue1(CONSTROID,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(constraintOid));\n\tmemcpy(&riinfo->conname, &conForm->conname, sizeof(NameData));\n\triinfo->pk_relid = conForm->confrelid;\n\triinfo->fk_relid = conForm->conrelid;\n\triinfo->confupdtype = conForm->confupdtype;\n\triinfo->confdeltype = conForm->confdeltype;\n\triinfo->confmatchtype = conForm->confmatchtype;\n\n\tDeconstructFkConstraintRow(tup,\n\t\t\t\t\t\t\t   &riinfo->nkeys,\n\t\t\t\t\t\t\t   riinfo->fk_attnums,\n\t\t\t\t\t\t\t   riinfo->pk_attnums,\n\t\t\t\t\t\t\t   riinfo->pf_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->pp_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->ff_eq_oprs);\n\n\tReleaseSysCache(tup);\n\n\t/*\n\t * For efficient processing of invalidation messages below, we keep a\n\t * doubly-linked list, and a count, of all currently valid entries.\n\t */\n\tdlist_push_tail(&ri_constraint_cache_valid_list, &riinfo->valid_link);\n\tri_constraint_cache_valid_count++;\n\n\triinfo->valid = true;\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_constraint_cache = NULL;",
            "static dlist_head ri_constraint_cache_valid_list;",
            "static int\tri_constraint_cache_valid_count = 0;",
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_constraint_cache = NULL;\nstatic dlist_head ri_constraint_cache_valid_list;\nstatic int\tri_constraint_cache_valid_count = 0;\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_LoadConstraintInfo(Oid constraintOid)\n{\n\tRI_ConstraintInfo *riinfo;\n\tbool\t\tfound;\n\tHeapTuple\ttup;\n\tForm_pg_constraint conForm;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_constraint_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Find or create a hash entry.  If we find a valid one, just return it.\n\t */\n\triinfo = (RI_ConstraintInfo *) hash_search(ri_constraint_cache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &constraintOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\tif (!found)\n\t\triinfo->valid = false;\n\telse if (riinfo->valid)\n\t\treturn riinfo;\n\n\t/*\n\t * Fetch the pg_constraint row so we can fill in the entry.\n\t */\n\ttup = SearchSysCache1(CONSTROID, ObjectIdGetDatum(constraintOid));\n\tif (!HeapTupleIsValid(tup)) /* should not happen */\n\t\telog(ERROR, \"cache lookup failed for constraint %u\", constraintOid);\n\tconForm = (Form_pg_constraint) GETSTRUCT(tup);\n\n\tif (conForm->contype != CONSTRAINT_FOREIGN) /* should not happen */\n\t\telog(ERROR, \"constraint %u is not a foreign key constraint\",\n\t\t\t constraintOid);\n\n\t/* And extract data */\n\tAssert(riinfo->constraint_id == constraintOid);\n\triinfo->oidHashValue = GetSysCacheHashValue1(CONSTROID,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(constraintOid));\n\tmemcpy(&riinfo->conname, &conForm->conname, sizeof(NameData));\n\triinfo->pk_relid = conForm->confrelid;\n\triinfo->fk_relid = conForm->conrelid;\n\triinfo->confupdtype = conForm->confupdtype;\n\triinfo->confdeltype = conForm->confdeltype;\n\triinfo->confmatchtype = conForm->confmatchtype;\n\n\tDeconstructFkConstraintRow(tup,\n\t\t\t\t\t\t\t   &riinfo->nkeys,\n\t\t\t\t\t\t\t   riinfo->fk_attnums,\n\t\t\t\t\t\t\t   riinfo->pk_attnums,\n\t\t\t\t\t\t\t   riinfo->pf_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->pp_eq_oprs,\n\t\t\t\t\t\t\t   riinfo->ff_eq_oprs);\n\n\tReleaseSysCache(tup);\n\n\t/*\n\t * For efficient processing of invalidation messages below, we keep a\n\t * doubly-linked list, and a count, of all currently valid entries.\n\t */\n\tdlist_push_tail(&ri_constraint_cache_valid_list, &riinfo->valid_link);\n\tri_constraint_cache_valid_count++;\n\n\triinfo->valid = true;\n\n\treturn riinfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\"))"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\""
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\"",
            "trigger->tgname",
            "RelationGetRelationName(trig_rel)"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "trig_rel"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_OBJECT_DEFINITION"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "constraintOid"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
  },
  {
    "function_name": "ri_CheckTrigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2248-2288",
    "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_DELETE 3",
      "#define RI_TRIGTYPE_UPDATE 2",
      "#define RI_TRIGTYPE_INSERT 1"
    ],
    "globals_used": [
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname))"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"%s\\\" must be fired for DELETE\"",
            "funcname"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_DELETE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname))"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_UPDATE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname))"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_INSERT",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname))"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_FOR_ROW",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_AFTER",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname))"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CALLED_AS_TRIGGER",
          "args": [
            "fcinfo"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ri_BuildQueryKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2233-2243",
    "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
  },
  {
    "function_name": "ri_GenerateQualCollation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2192-2220",
    "snippet": "static void\nri_GenerateQualCollation(StringInfo buf, Oid collation)\n{\n\tHeapTuple\ttp;\n\tForm_pg_collation colltup;\n\tchar\t   *collname;\n\tchar\t\tonename[MAX_QUOTED_NAME_LEN];\n\n\t/* Nothing to do if it's a noncollatable data type */\n\tif (!OidIsValid(collation))\n\t\treturn;\n\n\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\tcolltup = (Form_pg_collation) GETSTRUCT(tp);\n\tcollname = NameStr(colltup->collname);\n\n\t/*\n\t * We qualify the name always, for simplicity and to ensure the query is\n\t * not search-path-dependent.\n\t */\n\tquoteOneName(onename, get_namespace_name(colltup->collnamespace));\n\tappendStringInfo(buf, \" COLLATE %s\", onename);\n\tquoteOneName(onename, collname);\n\tappendStringInfo(buf, \".%s\", onename);\n\n\tReleaseSysCache(tp);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)"
    ],
    "globals_used": [
      "static void quoteOneName(char *buffer, const char *name);",
      "static void ri_GenerateQualCollation(StringInfo buf, Oid collation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\".%s\"",
            "onename"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "onename",
            "collname"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" COLLATE %s\"",
            "onename"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "colltup->collnamespace"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "colltup->collname"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tp"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for collation %u\"",
            "collation"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "COLLOID",
            "ObjectIdGetDatum(collation)"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "collation"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collation"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n\nstatic void quoteOneName(char *buffer, const char *name);\nstatic void ri_GenerateQualCollation(StringInfo buf, Oid collation);\n\nstatic void\nri_GenerateQualCollation(StringInfo buf, Oid collation)\n{\n\tHeapTuple\ttp;\n\tForm_pg_collation colltup;\n\tchar\t   *collname;\n\tchar\t\tonename[MAX_QUOTED_NAME_LEN];\n\n\t/* Nothing to do if it's a noncollatable data type */\n\tif (!OidIsValid(collation))\n\t\treturn;\n\n\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\tcolltup = (Form_pg_collation) GETSTRUCT(tp);\n\tcollname = NameStr(colltup->collname);\n\n\t/*\n\t * We qualify the name always, for simplicity and to ensure the query is\n\t * not search-path-dependent.\n\t */\n\tquoteOneName(onename, get_namespace_name(colltup->collnamespace));\n\tappendStringInfo(buf, \" COLLATE %s\", onename);\n\tquoteOneName(onename, collname);\n\tappendStringInfo(buf, \".%s\", onename);\n\n\tReleaseSysCache(tp);\n}"
  },
  {
    "function_name": "ri_GenerateQual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2163-2173",
    "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generate_operator_clause",
          "args": [
            "buf",
            "leftop",
            "leftoptype",
            "opoid",
            "rightop",
            "rightoptype"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "generate_operator_clause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10964-10994",
          "snippet": "void\ngenerate_operator_clause(StringInfo buf,\n\t\t\t\t\t\t const char *leftop, Oid leftoptype,\n\t\t\t\t\t\t Oid opoid,\n\t\t\t\t\t\t const char *rightop, Oid rightoptype)\n{\n\tHeapTuple\topertup;\n\tForm_pg_operator operform;\n\tchar\t   *oprname;\n\tchar\t   *nspname;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));\n\tif (!HeapTupleIsValid(opertup))\n\t\telog(ERROR, \"cache lookup failed for operator %u\", opoid);\n\toperform = (Form_pg_operator) GETSTRUCT(opertup);\n\tAssert(operform->oprkind == 'b');\n\toprname = NameStr(operform->oprname);\n\n\tnspname = get_namespace_name(operform->oprnamespace);\n\n\tappendStringInfoString(buf, leftop);\n\tif (leftoptype != operform->oprleft)\n\t\tadd_cast_to(buf, operform->oprleft);\n\tappendStringInfo(buf, \" OPERATOR(%s.\", quote_identifier(nspname));\n\tappendStringInfoString(buf, oprname);\n\tappendStringInfo(buf, \") %s\", rightop);\n\tif (rightoptype != operform->oprright)\n\t\tadd_cast_to(buf, operform->oprright);\n\n\tReleaseSysCache(opertup);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nvoid\ngenerate_operator_clause(StringInfo buf,\n\t\t\t\t\t\t const char *leftop, Oid leftoptype,\n\t\t\t\t\t\t Oid opoid,\n\t\t\t\t\t\t const char *rightop, Oid rightoptype)\n{\n\tHeapTuple\topertup;\n\tForm_pg_operator operform;\n\tchar\t   *oprname;\n\tchar\t   *nspname;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));\n\tif (!HeapTupleIsValid(opertup))\n\t\telog(ERROR, \"cache lookup failed for operator %u\", opoid);\n\toperform = (Form_pg_operator) GETSTRUCT(opertup);\n\tAssert(operform->oprkind == 'b');\n\toprname = NameStr(operform->oprname);\n\n\tnspname = get_namespace_name(operform->oprnamespace);\n\n\tappendStringInfoString(buf, leftop);\n\tif (leftoptype != operform->oprleft)\n\t\tadd_cast_to(buf, operform->oprleft);\n\tappendStringInfo(buf, \" OPERATOR(%s.\", quote_identifier(nspname));\n\tappendStringInfoString(buf, oprname);\n\tappendStringInfo(buf, \") %s\", rightop);\n\tif (rightoptype != operform->oprright)\n\t\tadd_cast_to(buf, operform->oprright);\n\n\tReleaseSysCache(opertup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" %s \"",
            "sep"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
  },
  {
    "function_name": "quoteRelationName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2146-2153",
    "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void quoteRelationName(char *buffer, Relation rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "buffer",
            "RelationGetRelationName(rel)"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "RelationGetNamespace(rel)"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetNamespace",
          "args": [
            "rel"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
  },
  {
    "function_name": "quoteOneName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "2126-2139",
    "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void quoteOneName(char *buffer, const char *name);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
  },
  {
    "function_name": "RI_Initial_Check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1848-2112",
    "snippet": "bool\nRI_Initial_Check(Trigger *trigger, Relation fk_rel, Relation pk_rel)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tStringInfoData querybuf;\n\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\tchar\t\tpkattname[MAX_QUOTED_NAME_LEN + 3];\n\tchar\t\tfkattname[MAX_QUOTED_NAME_LEN + 3];\n\tRangeTblEntry *pkrte;\n\tRangeTblEntry *fkrte;\n\tconst char *sep;\n\tconst char *fk_only;\n\tint\t\t\ti;\n\tint\t\t\tsave_nestlevel;\n\tchar\t\tworkmembuf[32];\n\tint\t\t\tspi_result;\n\tSPIPlanPtr\tqplan;\n\n\t/* Fetch constraint info. */\n\triinfo = ri_FetchConstraintInfo(trigger, fk_rel, false);\n\n\t/*\n\t * Check to make sure current user has enough permissions to do the test\n\t * query.  (If not, caller can fall back to the trigger method, which\n\t * works because it changes user IDs on the fly.)\n\t *\n\t * XXX are there any other show-stopper conditions to check?\n\t */\n\tpkrte = makeNode(RangeTblEntry);\n\tpkrte->rtekind = RTE_RELATION;\n\tpkrte->relid = RelationGetRelid(pk_rel);\n\tpkrte->relkind = pk_rel->rd_rel->relkind;\n\tpkrte->requiredPerms = ACL_SELECT;\n\n\tfkrte = makeNode(RangeTblEntry);\n\tfkrte->rtekind = RTE_RELATION;\n\tfkrte->relid = RelationGetRelid(fk_rel);\n\tfkrte->relkind = fk_rel->rd_rel->relkind;\n\tfkrte->requiredPerms = ACL_SELECT;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tint\t\t\tattno;\n\n\t\tattno = riinfo->pk_attnums[i] - FirstLowInvalidHeapAttributeNumber;\n\t\tpkrte->selectedCols = bms_add_member(pkrte->selectedCols, attno);\n\n\t\tattno = riinfo->fk_attnums[i] - FirstLowInvalidHeapAttributeNumber;\n\t\tfkrte->selectedCols = bms_add_member(fkrte->selectedCols, attno);\n\t}\n\n\tif (!ExecCheckRTPerms(list_make2(fkrte, pkrte), false))\n\t\treturn false;\n\n\t/*\n\t * Also punt if RLS is enabled on either table unless this role has the\n\t * bypassrls right or is the table owner of the table(s) involved which\n\t * have RLS enabled.\n\t */\n\tif (!has_bypassrls_privilege(GetUserId()) &&\n\t\t((pk_rel->rd_rel->relrowsecurity &&\n\t\t  !pg_class_ownercheck(pkrte->relid, GetUserId())) ||\n\t\t (fk_rel->rd_rel->relrowsecurity &&\n\t\t  !pg_class_ownercheck(fkrte->relid, GetUserId()))))\n\t\treturn false;\n\n\t/*----------\n\t * The query string built is:\n\t *\tSELECT fk.keycols FROM [ONLY] relname fk\n\t *\t LEFT OUTER JOIN ONLY pkrelname pk\n\t *\t ON (pk.pkkeycol1=fk.keycol1 [AND ...])\n\t *\t WHERE pk.pkkeycol1 IS NULL AND\n\t * For MATCH SIMPLE:\n\t *\t (fk.keycol1 IS NOT NULL [AND ...])\n\t * For MATCH FULL:\n\t *\t (fk.keycol1 IS NOT NULL [OR ...])\n\t *\n\t * We attach COLLATE clauses to the operators when comparing columns\n\t * that have different collations.\n\t *----------\n\t */\n\tinitStringInfo(&querybuf);\n\tappendStringInfoString(&querybuf, \"SELECT \");\n\tsep = \"\";\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tquoteOneName(fkattname,\n\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\tappendStringInfo(&querybuf, \"%sfk.%s\", sep, fkattname);\n\t\tsep = \", \";\n\t}\n\n\tquoteRelationName(pkrelname, pk_rel);\n\tquoteRelationName(fkrelname, fk_rel);\n\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\"\" : \"ONLY \";\n\tappendStringInfo(&querybuf,\n\t\t\t\t\t \" FROM %s%s fk LEFT OUTER JOIN ONLY %s pk ON\",\n\t\t\t\t\t fk_only, fkrelname, pkrelname);\n\n\tstrcpy(pkattname, \"pk.\");\n\tstrcpy(fkattname, \"fk.\");\n\tsep = \"(\";\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\t\tOid\t\t\tpk_coll = RIAttCollation(pk_rel, riinfo->pk_attnums[i]);\n\t\tOid\t\t\tfk_coll = RIAttCollation(fk_rel, riinfo->fk_attnums[i]);\n\n\t\tquoteOneName(pkattname + 3,\n\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\tquoteOneName(fkattname + 3,\n\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\tri_GenerateQual(&querybuf, sep,\n\t\t\t\t\t\tpkattname, pk_type,\n\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\tfkattname, fk_type);\n\t\tif (pk_coll != fk_coll)\n\t\t\tri_GenerateQualCollation(&querybuf, pk_coll);\n\t\tsep = \"AND\";\n\t}\n\n\t/*\n\t * It's sufficient to test any one pk attribute for null to detect a join\n\t * failure.\n\t */\n\tquoteOneName(pkattname, RIAttName(pk_rel, riinfo->pk_attnums[0]));\n\tappendStringInfo(&querybuf, \") WHERE pk.%s IS NULL AND (\", pkattname);\n\n\tsep = \"\";\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tquoteOneName(fkattname, RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t \"%sfk.%s IS NOT NULL\",\n\t\t\t\t\t\t sep, fkattname);\n\t\tswitch (riinfo->confmatchtype)\n\t\t{\n\t\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\t\t\tsep = \" AND \";\n\t\t\t\tbreak;\n\t\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\t\tsep = \" OR \";\n\t\t\t\tbreak;\n\t\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t\t riinfo->confmatchtype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoChar(&querybuf, ')');\n\n\t/*\n\t * Temporarily increase work_mem so that the check query can be executed\n\t * more efficiently.  It seems okay to do this because the query is simple\n\t * enough to not use a multiple of work_mem, and one typically would not\n\t * have many large foreign-key validations happening concurrently.  So\n\t * this seems to meet the criteria for being considered a \"maintenance\"\n\t * operation, and accordingly we use maintenance_work_mem.\n\t *\n\t * We use the equivalent of a function SET option to allow the setting to\n\t * persist for exactly the duration of the check query.  guc.c also takes\n\t * care of undoing the setting on error.\n\t */\n\tsave_nestlevel = NewGUCNestLevel();\n\n\tsnprintf(workmembuf, sizeof(workmembuf), \"%d\", maintenance_work_mem);\n\t(void) set_config_option(\"work_mem\", workmembuf,\n\t\t\t\t\t\t\t PGC_USERSET, PGC_S_SESSION,\n\t\t\t\t\t\t\t GUC_ACTION_SAVE, true, 0, false);\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Generate the plan.  We don't need to cache it, and there are no\n\t * arguments to the plan.\n\t */\n\tqplan = SPI_prepare(querybuf.data, 0, NULL);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\",\n\t\t\t SPI_result_code_string(SPI_result), querybuf.data);\n\n\t/*\n\t * Run the plan.  For safety we force a current snapshot to be used. (In\n\t * transaction-snapshot mode, this arguably violates transaction isolation\n\t * rules, but we really haven't got much choice.) We don't need to\n\t * register the snapshot, because SPI_execute_snapshot will see to it. We\n\t * need at most one tuple returned, so pass limit = 1.\n\t */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  NULL, NULL,\n\t\t\t\t\t\t\t\t\t  GetLatestSnapshot(),\n\t\t\t\t\t\t\t\t\t  InvalidSnapshot,\n\t\t\t\t\t\t\t\t\t  true, false, 1);\n\n\t/* Check result */\n\tif (spi_result != SPI_OK_SELECT)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\t/* Did we find a tuple violating the constraint? */\n\tif (SPI_processed > 0)\n\t{\n\t\tHeapTuple\ttuple = SPI_tuptable->vals[0];\n\t\tTupleDesc\ttupdesc = SPI_tuptable->tupdesc;\n\t\tRI_ConstraintInfo fake_riinfo;\n\n\t\t/*\n\t\t * The columns to look at in the result tuple are 1..N, not whatever\n\t\t * they are in the fk_rel.  Hack up riinfo so that the subroutines\n\t\t * called here will behave properly.\n\t\t *\n\t\t * In addition to this, we have to pass the correct tupdesc to\n\t\t * ri_ReportViolation, overriding its normal habit of using the pk_rel\n\t\t * or fk_rel's tupdesc.\n\t\t */\n\t\tmemcpy(&fake_riinfo, riinfo, sizeof(RI_ConstraintInfo));\n\t\tfor (i = 0; i < fake_riinfo.nkeys; i++)\n\t\t\tfake_riinfo.fk_attnums[i] = i + 1;\n\n\t\t/*\n\t\t * If it's MATCH FULL, and there are any nulls in the FK keys,\n\t\t * complain about that rather than the lack of a match.  MATCH FULL\n\t\t * disallows partially-null FK rows.\n\t\t */\n\t\tif (fake_riinfo.confmatchtype == FKCONSTR_MATCH_FULL &&\n\t\t\tri_NullCheck(tupdesc, tuple, &fake_riinfo, false) != RI_KEYS_NONE_NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\t\tNameStr(fake_riinfo.conname)),\n\t\t\t\t\t errdetail(\"MATCH FULL does not allow mixing of null and nonnull key values.\"),\n\t\t\t\t\t errtableconstraint(fk_rel,\n\t\t\t\t\t\t\t\t\t\tNameStr(fake_riinfo.conname))));\n\n\t\t/*\n\t\t * We tell ri_ReportViolation we were doing the RI_PLAN_CHECK_LOOKUPPK\n\t\t * query, which isn't true, but will cause it to use\n\t\t * fake_riinfo.fk_attnums as we need.\n\t\t */\n\t\tri_ReportViolation(&fake_riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   tuple, tupdesc,\n\t\t\t\t\t\t   RI_PLAN_CHECK_LOOKUPPK);\n\t}\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\t/*\n\t * Restore work_mem.\n\t */\n\tAtEOXact_GUC(true, save_nestlevel);\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
      "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AtEOXact_GUC",
          "args": [
            "true",
            "save_nestlevel"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "AtEOXact_GUC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "5331-5606",
          "snippet": "void\nAtEOXact_GUC(bool isCommit, int nestLevel)\n{\n\tbool\t\tstill_dirty;\n\tint\t\t\ti;\n\n\t/*\n\t * Note: it's possible to get here with GUCNestLevel == nestLevel-1 during\n\t * abort, if there is a failure during transaction start before\n\t * AtStart_GUC is called.\n\t */\n\tAssert(nestLevel > 0 &&\n\t\t   (nestLevel <= GUCNestLevel ||\n\t\t\t(nestLevel == GUCNestLevel + 1 && !isCommit)));\n\n\t/* Quick exit if nothing's changed in this transaction */\n\tif (!guc_dirty)\n\t{\n\t\tGUCNestLevel = nestLevel - 1;\n\t\treturn;\n\t}\n\n\tstill_dirty = false;\n\tfor (i = 0; i < num_guc_variables; i++)\n\t{\n\t\tstruct config_generic *gconf = guc_variables[i];\n\t\tGucStack   *stack;\n\n\t\t/*\n\t\t * Process and pop each stack entry within the nest level. To simplify\n\t\t * fmgr_security_definer() and other places that use GUC_ACTION_SAVE,\n\t\t * we allow failure exit from code that uses a local nest level to be\n\t\t * recovered at the surrounding transaction or subtransaction abort;\n\t\t * so there could be more than one stack entry to pop.\n\t\t */\n\t\twhile ((stack = gconf->stack) != NULL &&\n\t\t\t   stack->nest_level >= nestLevel)\n\t\t{\n\t\t\tGucStack   *prev = stack->prev;\n\t\t\tbool\t\trestorePrior = false;\n\t\t\tbool\t\trestoreMasked = false;\n\t\t\tbool\t\tchanged;\n\n\t\t\t/*\n\t\t\t * In this next bit, if we don't set either restorePrior or\n\t\t\t * restoreMasked, we must \"discard\" any unwanted fields of the\n\t\t\t * stack entries to avoid leaking memory.  If we do set one of\n\t\t\t * those flags, unused fields will be cleaned up after restoring.\n\t\t\t */\n\t\t\tif (!isCommit)\t\t/* if abort, always restore prior value */\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->state == GUC_SAVE)\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->nest_level == 1)\n\t\t\t{\n\t\t\t\t/* transaction commit */\n\t\t\t\tif (stack->state == GUC_SET_LOCAL)\n\t\t\t\t\trestoreMasked = true;\n\t\t\t\telse if (stack->state == GUC_SET)\n\t\t\t\t{\n\t\t\t\t\t/* we keep the current active value */\n\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t}\n\t\t\t\telse\t\t\t/* must be GUC_LOCAL */\n\t\t\t\t\trestorePrior = true;\n\t\t\t}\n\t\t\telse if (prev == NULL ||\n\t\t\t\t\t prev->nest_level < stack->nest_level - 1)\n\t\t\t{\n\t\t\t\t/* decrement entry's level and do not pop it */\n\t\t\t\tstack->nest_level--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We have to merge this stack entry into prev. See README for\n\t\t\t\t * discussion of this bit.\n\t\t\t\t */\n\t\t\t\tswitch (stack->state)\n\t\t\t\t{\n\t\t\t\t\tcase GUC_SAVE:\n\t\t\t\t\t\tAssert(false);\t/* can't get here */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET:\n\t\t\t\t\t\t/* next level always becomes SET */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->state = GUC_SET;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_LOCAL:\n\t\t\t\t\t\tif (prev->state == GUC_SET)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* LOCAL migrates down */\n\t\t\t\t\t\t\tprev->masked_scontext = stack->scontext;\n\t\t\t\t\t\t\tprev->masked = stack->prior;\n\t\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* else just forget this stack level */\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET_LOCAL:\n\t\t\t\t\t\t/* prior state at this level no longer wanted */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t/* copy down the masked state */\n\t\t\t\t\t\tprev->masked_scontext = stack->masked_scontext;\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->masked = stack->masked;\n\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanged = false;\n\n\t\t\tif (restorePrior || restoreMasked)\n\t\t\t{\n\t\t\t\t/* Perform appropriate restoration of the stacked value */\n\t\t\t\tconfig_var_value newvalue;\n\t\t\t\tGucSource\tnewsource;\n\t\t\t\tGucContext\tnewscontext;\n\n\t\t\t\tif (restoreMasked)\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->masked;\n\t\t\t\t\tnewsource = PGC_S_SESSION;\n\t\t\t\t\tnewscontext = stack->masked_scontext;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->prior;\n\t\t\t\t\tnewsource = stack->source;\n\t\t\t\t\tnewscontext = stack->scontext;\n\t\t\t\t}\n\n\t\t\t\tswitch (gconf->vartype)\n\t\t\t\t{\n\t\t\t\t\tcase PGC_BOOL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_bool *conf = (struct config_bool *) gconf;\n\t\t\t\t\t\t\tbool\t\tnewval = newvalue.val.boolval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_INT:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_int *conf = (struct config_int *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.intval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_REAL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_real *conf = (struct config_real *) gconf;\n\t\t\t\t\t\t\tdouble\t\tnewval = newvalue.val.realval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_STRING:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_string *conf = (struct config_string *) gconf;\n\t\t\t\t\t\t\tchar\t   *newval = newvalue.val.stringval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\tset_string_field(conf, conf->variable, newval);\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Release stacked values if not used anymore. We\n\t\t\t\t\t\t\t * could use discard_stack_value() here, but since\n\t\t\t\t\t\t\t * we have type-specific code anyway, might as\n\t\t\t\t\t\t\t * well inline it.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tset_string_field(conf, &stack->prior.val.stringval, NULL);\n\t\t\t\t\t\t\tset_string_field(conf, &stack->masked.val.stringval, NULL);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_ENUM:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_enum *conf = (struct config_enum *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.enumval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Release stacked extra values if not used anymore.\n\t\t\t\t */\n\t\t\t\tset_extra_field(gconf, &(stack->prior.extra), NULL);\n\t\t\t\tset_extra_field(gconf, &(stack->masked.extra), NULL);\n\n\t\t\t\t/* And restore source information */\n\t\t\t\tgconf->source = newsource;\n\t\t\t\tgconf->scontext = newscontext;\n\t\t\t}\n\n\t\t\t/* Finish popping the state stack */\n\t\t\tgconf->stack = prev;\n\t\t\tpfree(stack);\n\n\t\t\t/* Report new value if we changed it */\n\t\t\tif (changed && (gconf->flags & GUC_REPORT))\n\t\t\t\tReportGUCOption(gconf);\n\t\t}\t\t\t\t\t\t/* end of stack-popping loop */\n\n\t\tif (stack != NULL)\n\t\t\tstill_dirty = true;\n\t}\n\n\t/* If there are no remaining stack entries, we can reset guc_dirty */\n\tguc_dirty = still_dirty;\n\n\t/* Update nesting level */\n\tGUCNestLevel = nestLevel - 1;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define newval (newval_union.enumval)",
            "#define newval (newval_union.stringval)",
            "#define newval (newval_union.realval)",
            "#define newval (newval_union.intval)",
            "#define newval (newval_union.boolval)"
          ],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static void assign_log_destination(const char *newval, void *extra);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static void assign_wal_consistency_checking(const char *newval, void *extra);",
            "static void assign_syslog_facility(int newval, void *extra);",
            "static void assign_syslog_ident(const char *newval, void *extra);",
            "static void assign_session_replication_role(int newval, void *extra);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static void assign_timezone_abbreviations(const char *newval, void *extra);",
            "static void assign_tcp_keepalives_idle(int newval, void *extra);",
            "static void assign_tcp_keepalives_interval(int newval, void *extra);",
            "static void assign_tcp_keepalives_count(int newval, void *extra);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static void assign_effective_io_concurrency(int newval, void *extra);",
            "static void assign_pgstat_temp_directory(const char *newval, void *extra);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static void assign_application_name(const char *newval, void *extra);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static struct config_generic **guc_variables;",
            "static int\tnum_guc_variables;",
            "static bool guc_dirty;",
            "static int\tGUCNestLevel = 0;",
            "static void InitializeOneGUCOption(struct config_generic *gconf);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define newval (newval_union.enumval)\n#define newval (newval_union.stringval)\n#define newval (newval_union.realval)\n#define newval (newval_union.intval)\n#define newval (newval_union.boolval)\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic void assign_log_destination(const char *newval, void *extra);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic void assign_wal_consistency_checking(const char *newval, void *extra);\nstatic void assign_syslog_facility(int newval, void *extra);\nstatic void assign_syslog_ident(const char *newval, void *extra);\nstatic void assign_session_replication_role(int newval, void *extra);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic void assign_timezone_abbreviations(const char *newval, void *extra);\nstatic void assign_tcp_keepalives_idle(int newval, void *extra);\nstatic void assign_tcp_keepalives_interval(int newval, void *extra);\nstatic void assign_tcp_keepalives_count(int newval, void *extra);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic void assign_effective_io_concurrency(int newval, void *extra);\nstatic void assign_pgstat_temp_directory(const char *newval, void *extra);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic void assign_application_name(const char *newval, void *extra);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic struct config_generic **guc_variables;\nstatic int\tnum_guc_variables;\nstatic bool guc_dirty;\nstatic int\tGUCNestLevel = 0;\nstatic void InitializeOneGUCOption(struct config_generic *gconf);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nAtEOXact_GUC(bool isCommit, int nestLevel)\n{\n\tbool\t\tstill_dirty;\n\tint\t\t\ti;\n\n\t/*\n\t * Note: it's possible to get here with GUCNestLevel == nestLevel-1 during\n\t * abort, if there is a failure during transaction start before\n\t * AtStart_GUC is called.\n\t */\n\tAssert(nestLevel > 0 &&\n\t\t   (nestLevel <= GUCNestLevel ||\n\t\t\t(nestLevel == GUCNestLevel + 1 && !isCommit)));\n\n\t/* Quick exit if nothing's changed in this transaction */\n\tif (!guc_dirty)\n\t{\n\t\tGUCNestLevel = nestLevel - 1;\n\t\treturn;\n\t}\n\n\tstill_dirty = false;\n\tfor (i = 0; i < num_guc_variables; i++)\n\t{\n\t\tstruct config_generic *gconf = guc_variables[i];\n\t\tGucStack   *stack;\n\n\t\t/*\n\t\t * Process and pop each stack entry within the nest level. To simplify\n\t\t * fmgr_security_definer() and other places that use GUC_ACTION_SAVE,\n\t\t * we allow failure exit from code that uses a local nest level to be\n\t\t * recovered at the surrounding transaction or subtransaction abort;\n\t\t * so there could be more than one stack entry to pop.\n\t\t */\n\t\twhile ((stack = gconf->stack) != NULL &&\n\t\t\t   stack->nest_level >= nestLevel)\n\t\t{\n\t\t\tGucStack   *prev = stack->prev;\n\t\t\tbool\t\trestorePrior = false;\n\t\t\tbool\t\trestoreMasked = false;\n\t\t\tbool\t\tchanged;\n\n\t\t\t/*\n\t\t\t * In this next bit, if we don't set either restorePrior or\n\t\t\t * restoreMasked, we must \"discard\" any unwanted fields of the\n\t\t\t * stack entries to avoid leaking memory.  If we do set one of\n\t\t\t * those flags, unused fields will be cleaned up after restoring.\n\t\t\t */\n\t\t\tif (!isCommit)\t\t/* if abort, always restore prior value */\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->state == GUC_SAVE)\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->nest_level == 1)\n\t\t\t{\n\t\t\t\t/* transaction commit */\n\t\t\t\tif (stack->state == GUC_SET_LOCAL)\n\t\t\t\t\trestoreMasked = true;\n\t\t\t\telse if (stack->state == GUC_SET)\n\t\t\t\t{\n\t\t\t\t\t/* we keep the current active value */\n\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t}\n\t\t\t\telse\t\t\t/* must be GUC_LOCAL */\n\t\t\t\t\trestorePrior = true;\n\t\t\t}\n\t\t\telse if (prev == NULL ||\n\t\t\t\t\t prev->nest_level < stack->nest_level - 1)\n\t\t\t{\n\t\t\t\t/* decrement entry's level and do not pop it */\n\t\t\t\tstack->nest_level--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We have to merge this stack entry into prev. See README for\n\t\t\t\t * discussion of this bit.\n\t\t\t\t */\n\t\t\t\tswitch (stack->state)\n\t\t\t\t{\n\t\t\t\t\tcase GUC_SAVE:\n\t\t\t\t\t\tAssert(false);\t/* can't get here */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET:\n\t\t\t\t\t\t/* next level always becomes SET */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->state = GUC_SET;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_LOCAL:\n\t\t\t\t\t\tif (prev->state == GUC_SET)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* LOCAL migrates down */\n\t\t\t\t\t\t\tprev->masked_scontext = stack->scontext;\n\t\t\t\t\t\t\tprev->masked = stack->prior;\n\t\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* else just forget this stack level */\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET_LOCAL:\n\t\t\t\t\t\t/* prior state at this level no longer wanted */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t/* copy down the masked state */\n\t\t\t\t\t\tprev->masked_scontext = stack->masked_scontext;\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->masked = stack->masked;\n\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanged = false;\n\n\t\t\tif (restorePrior || restoreMasked)\n\t\t\t{\n\t\t\t\t/* Perform appropriate restoration of the stacked value */\n\t\t\t\tconfig_var_value newvalue;\n\t\t\t\tGucSource\tnewsource;\n\t\t\t\tGucContext\tnewscontext;\n\n\t\t\t\tif (restoreMasked)\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->masked;\n\t\t\t\t\tnewsource = PGC_S_SESSION;\n\t\t\t\t\tnewscontext = stack->masked_scontext;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->prior;\n\t\t\t\t\tnewsource = stack->source;\n\t\t\t\t\tnewscontext = stack->scontext;\n\t\t\t\t}\n\n\t\t\t\tswitch (gconf->vartype)\n\t\t\t\t{\n\t\t\t\t\tcase PGC_BOOL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_bool *conf = (struct config_bool *) gconf;\n\t\t\t\t\t\t\tbool\t\tnewval = newvalue.val.boolval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_INT:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_int *conf = (struct config_int *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.intval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_REAL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_real *conf = (struct config_real *) gconf;\n\t\t\t\t\t\t\tdouble\t\tnewval = newvalue.val.realval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_STRING:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_string *conf = (struct config_string *) gconf;\n\t\t\t\t\t\t\tchar\t   *newval = newvalue.val.stringval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\tset_string_field(conf, conf->variable, newval);\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Release stacked values if not used anymore. We\n\t\t\t\t\t\t\t * could use discard_stack_value() here, but since\n\t\t\t\t\t\t\t * we have type-specific code anyway, might as\n\t\t\t\t\t\t\t * well inline it.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tset_string_field(conf, &stack->prior.val.stringval, NULL);\n\t\t\t\t\t\t\tset_string_field(conf, &stack->masked.val.stringval, NULL);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_ENUM:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_enum *conf = (struct config_enum *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.enumval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Release stacked extra values if not used anymore.\n\t\t\t\t */\n\t\t\t\tset_extra_field(gconf, &(stack->prior.extra), NULL);\n\t\t\t\tset_extra_field(gconf, &(stack->masked.extra), NULL);\n\n\t\t\t\t/* And restore source information */\n\t\t\t\tgconf->source = newsource;\n\t\t\t\tgconf->scontext = newscontext;\n\t\t\t}\n\n\t\t\t/* Finish popping the state stack */\n\t\t\tgconf->stack = prev;\n\t\t\tpfree(stack);\n\n\t\t\t/* Report new value if we changed it */\n\t\t\tif (changed && (gconf->flags & GUC_REPORT))\n\t\t\t\tReportGUCOption(gconf);\n\t\t}\t\t\t\t\t\t/* end of stack-popping loop */\n\n\t\tif (stack != NULL)\n\t\t\tstill_dirty = true;\n\t}\n\n\t/* If there are no remaining stack entries, we can reset guc_dirty */\n\tguc_dirty = still_dirty;\n\n\t/* Update nesting level */\n\tGUCNestLevel = nestLevel - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_finish failed\""
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_ReportViolation",
          "args": [
            "&fake_riinfo",
            "pk_rel",
            "fk_rel",
            "tuple",
            "tupdesc",
            "RI_PLAN_CHECK_LOOKUPPK"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "ri_ReportViolation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2675-2798",
          "snippet": "static void\nri_ReportViolation(const RI_ConstraintInfo *riinfo,\n\t\t\t\t   Relation pk_rel, Relation fk_rel,\n\t\t\t\t   HeapTuple violator, TupleDesc tupdesc,\n\t\t\t\t   int queryno)\n{\n\tStringInfoData key_names;\n\tStringInfoData key_values;\n\tbool\t\tonfk;\n\tconst int16 *attnums;\n\tint\t\t\tidx;\n\tOid\t\t\trel_oid;\n\tAclResult\taclresult;\n\tbool\t\thas_perm = true;\n\n\t/*\n\t * Determine which relation to complain about.  If tupdesc wasn't passed\n\t * by caller, assume the violator tuple came from there.\n\t */\n\tonfk = (queryno == RI_PLAN_CHECK_LOOKUPPK);\n\tif (onfk)\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\trel_oid = fk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = fk_rel->rd_att;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\trel_oid = pk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = pk_rel->rd_att;\n\t}\n\n\t/*\n\t * Check permissions- if the user does not have access to view the data in\n\t * any of the key columns then we don't include the errdetail() below.\n\t *\n\t * Check if RLS is enabled on the relation first.  If so, we don't return\n\t * any specifics to avoid leaking data.\n\t *\n\t * Check table-level permissions next and, failing that, column-level\n\t * privileges.\n\t */\n\n\tif (check_enable_rls(rel_oid, InvalidOid, true) != RLS_ENABLED)\n\t{\n\t\taclresult = pg_class_aclcheck(rel_oid, GetUserId(), ACL_SELECT);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t{\n\t\t\t/* Try for column-level permissions */\n\t\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t\t{\n\t\t\t\taclresult = pg_attribute_aclcheck(rel_oid, attnums[idx],\n\t\t\t\t\t\t\t\t\t\t\t\t  GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t  ACL_SELECT);\n\n\t\t\t\t/* No access to the key */\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t{\n\t\t\t\t\thas_perm = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\thas_perm = false;\n\n\tif (has_perm)\n\t{\n\t\t/* Get printable versions of the keys involved */\n\t\tinitStringInfo(&key_names);\n\t\tinitStringInfo(&key_values);\n\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t{\n\t\t\tint\t\t\tfnum = attnums[idx];\n\t\t\tchar\t   *name,\n\t\t\t\t\t   *val;\n\n\t\t\tname = SPI_fname(tupdesc, fnum);\n\t\t\tval = SPI_getvalue(violator, tupdesc, fnum);\n\t\t\tif (!val)\n\t\t\t\tval = \"null\";\n\n\t\t\tif (idx > 0)\n\t\t\t{\n\t\t\t\tappendStringInfoString(&key_names, \", \");\n\t\t\t\tappendStringInfoString(&key_values, \", \");\n\t\t\t}\n\t\t\tappendStringInfoString(&key_names, name);\n\t\t\tappendStringInfoString(&key_values, val);\n\t\t}\n\t}\n\n\tif (onfk)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteOneName(char *buffer, const char *name);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteOneName(char *buffer, const char *name);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_ReportViolation(const RI_ConstraintInfo *riinfo,\n\t\t\t\t   Relation pk_rel, Relation fk_rel,\n\t\t\t\t   HeapTuple violator, TupleDesc tupdesc,\n\t\t\t\t   int queryno)\n{\n\tStringInfoData key_names;\n\tStringInfoData key_values;\n\tbool\t\tonfk;\n\tconst int16 *attnums;\n\tint\t\t\tidx;\n\tOid\t\t\trel_oid;\n\tAclResult\taclresult;\n\tbool\t\thas_perm = true;\n\n\t/*\n\t * Determine which relation to complain about.  If tupdesc wasn't passed\n\t * by caller, assume the violator tuple came from there.\n\t */\n\tonfk = (queryno == RI_PLAN_CHECK_LOOKUPPK);\n\tif (onfk)\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\trel_oid = fk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = fk_rel->rd_att;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\trel_oid = pk_rel->rd_id;\n\t\tif (tupdesc == NULL)\n\t\t\ttupdesc = pk_rel->rd_att;\n\t}\n\n\t/*\n\t * Check permissions- if the user does not have access to view the data in\n\t * any of the key columns then we don't include the errdetail() below.\n\t *\n\t * Check if RLS is enabled on the relation first.  If so, we don't return\n\t * any specifics to avoid leaking data.\n\t *\n\t * Check table-level permissions next and, failing that, column-level\n\t * privileges.\n\t */\n\n\tif (check_enable_rls(rel_oid, InvalidOid, true) != RLS_ENABLED)\n\t{\n\t\taclresult = pg_class_aclcheck(rel_oid, GetUserId(), ACL_SELECT);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t{\n\t\t\t/* Try for column-level permissions */\n\t\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t\t{\n\t\t\t\taclresult = pg_attribute_aclcheck(rel_oid, attnums[idx],\n\t\t\t\t\t\t\t\t\t\t\t\t  GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t  ACL_SELECT);\n\n\t\t\t\t/* No access to the key */\n\t\t\t\tif (aclresult != ACLCHECK_OK)\n\t\t\t\t{\n\t\t\t\t\thas_perm = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\thas_perm = false;\n\n\tif (has_perm)\n\t{\n\t\t/* Get printable versions of the keys involved */\n\t\tinitStringInfo(&key_names);\n\t\tinitStringInfo(&key_values);\n\t\tfor (idx = 0; idx < riinfo->nkeys; idx++)\n\t\t{\n\t\t\tint\t\t\tfnum = attnums[idx];\n\t\t\tchar\t   *name,\n\t\t\t\t\t   *val;\n\n\t\t\tname = SPI_fname(tupdesc, fnum);\n\t\t\tval = SPI_getvalue(violator, tupdesc, fnum);\n\t\t\tif (!val)\n\t\t\t\tval = \"null\";\n\n\t\t\tif (idx > 0)\n\t\t\t{\n\t\t\t\tappendStringInfoString(&key_names, \", \");\n\t\t\t\tappendStringInfoString(&key_values, \", \");\n\t\t\t}\n\t\t\tappendStringInfoString(&key_names, name);\n\t\t\tappendStringInfoString(&key_values, val);\n\t\t}\n\t}\n\n\tif (onfk)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)) :\n\t\t\t\t errdetail(\"Key is not present in table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(pk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t errmsg(\"update or delete on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t has_perm ?\n\t\t\t\t errdetail(\"Key (%s)=(%s) is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   key_names.data, key_values.data,\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)) :\n\t\t\t\t errdetail(\"Key is still referenced from table \\\"%s\\\".\",\n\t\t\t\t\t\t   RelationGetRelationName(fk_rel)),\n\t\t\t\t errtableconstraint(fk_rel, NameStr(riinfo->conname))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\t\tNameStr(fake_riinfo.conname)),\n\t\t\t\t\t errdetail(\"MATCH FULL does not allow mixing of null and nonnull key values.\"),\n\t\t\t\t\t errtableconstraint(fk_rel,\n\t\t\t\t\t\t\t\t\t\tNameStr(fake_riinfo.conname)))"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errtableconstraint",
          "args": [
            "fk_rel",
            "NameStr(fake_riinfo.conname)"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "errtableconstraint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5336-5343",
          "snippet": "int\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "fake_riinfo.conname"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"MATCH FULL does not allow mixing of null and nonnull key values.\""
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\"",
            "RelationGetRelationName(fk_rel)",
            "NameStr(fake_riinfo.conname)"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "fake_riinfo.conname"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FOREIGN_KEY_VIOLATION"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "tupdesc",
            "tuple",
            "&fake_riinfo",
            "false"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fake_riinfo",
            "riinfo",
            "sizeof(RI_ConstraintInfo)"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_result_code_string",
          "args": [
            "spi_result"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_execute_snapshot",
          "args": [
            "qplan",
            "NULL",
            "NULL",
            "GetLatestSnapshot()",
            "InvalidSnapshot",
            "true",
            "false",
            "1"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLatestSnapshot",
          "args": [],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "GetLatestSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "378-402",
          "snippet": "Snapshot\nGetLatestSnapshot(void)\n{\n\t/*\n\t * We might be able to relax this, but nothing that could otherwise work\n\t * needs it.\n\t */\n\tif (IsInParallelMode())\n\t\telog(ERROR,\n\t\t\t \"cannot update SecondarySnapshot during a parallel operation\");\n\n\t/*\n\t * So far there are no cases requiring support for GetLatestSnapshot()\n\t * during logical decoding, but it wouldn't be hard to add if required.\n\t */\n\tAssert(!HistoricSnapshotActive());\n\n\t/* If first call in transaction, go ahead and set the xact snapshot */\n\tif (!FirstSnapshotSet)\n\t\treturn GetTransactionSnapshot();\n\n\tSecondarySnapshot = GetSnapshotData(&SecondarySnapshotData);\n\n\treturn SecondarySnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData SecondarySnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot SecondarySnapshot = NULL;",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData SecondarySnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot SecondarySnapshot = NULL;\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetLatestSnapshot(void)\n{\n\t/*\n\t * We might be able to relax this, but nothing that could otherwise work\n\t * needs it.\n\t */\n\tif (IsInParallelMode())\n\t\telog(ERROR,\n\t\t\t \"cannot update SecondarySnapshot during a parallel operation\");\n\n\t/*\n\t * So far there are no cases requiring support for GetLatestSnapshot()\n\t * during logical decoding, but it wouldn't be hard to add if required.\n\t */\n\tAssert(!HistoricSnapshotActive());\n\n\t/* If first call in transaction, go ahead and set the xact snapshot */\n\tif (!FirstSnapshotSet)\n\t\treturn GetTransactionSnapshot();\n\n\tSecondarySnapshot = GetSnapshotData(&SecondarySnapshotData);\n\n\treturn SecondarySnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_result_code_string",
          "args": [
            "SPI_result"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_prepare",
          "args": [
            "querybuf.data",
            "0",
            "NULL"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_config_option",
          "args": [
            "\"work_mem\"",
            "workmembuf",
            "PGC_USERSET",
            "PGC_S_SESSION",
            "GUC_ACTION_SAVE",
            "true",
            "0",
            "false"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "set_config_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "6165-6890",
          "snippet": "int\nset_config_option(const char *name, const char *value,\n\t\t\t\t  GucContext context, GucSource source,\n\t\t\t\t  GucAction action, bool changeVal, int elevel,\n\t\t\t\t  bool is_reload)\n{\n\tstruct config_generic *record;\n\tunion config_var_val newval_union;\n\tvoid\t   *newextra = NULL;\n\tbool\t\tprohibitValueChange = false;\n\tbool\t\tmakeDefault;\n\n\tif (elevel == 0)\n\t{\n\t\tif (source == PGC_S_DEFAULT || source == PGC_S_FILE)\n\t\t{\n\t\t\t/*\n\t\t\t * To avoid cluttering the log, only the postmaster bleats loudly\n\t\t\t * about problems with the config file.\n\t\t\t */\n\t\t\televel = IsUnderPostmaster ? DEBUG3 : LOG;\n\t\t}\n\t\telse if (source == PGC_S_GLOBAL ||\n\t\t\t\t source == PGC_S_DATABASE ||\n\t\t\t\t source == PGC_S_USER ||\n\t\t\t\t source == PGC_S_DATABASE_USER)\n\t\t\televel = WARNING;\n\t\telse\n\t\t\televel = ERROR;\n\t}\n\n\t/*\n\t * GUC_ACTION_SAVE changes are acceptable during a parallel operation,\n\t * because the current worker will also pop the change.  We're probably\n\t * dealing with a function having a proconfig entry.  Only the function's\n\t * body should observe the change, and peer workers do not share in the\n\t * execution of a function call started by this worker.\n\t *\n\t * Other changes might need to affect other workers, so forbid them.\n\t */\n\tif (IsInParallelMode() && changeVal && action != GUC_ACTION_SAVE)\n\t\tereport(elevel,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot set parameters during a parallel operation\")));\n\n\trecord = find_option(name, true, elevel);\n\tif (record == NULL)\n\t{\n\t\tereport(elevel,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"unrecognized configuration parameter \\\"%s\\\"\", name)));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if the option can be set at this time. See guc.h for the precise\n\t * rules.\n\t */\n\tswitch (record->context)\n\t{\n\t\tcase PGC_INTERNAL:\n\t\t\tif (context != PGC_INTERNAL)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_POSTMASTER:\n\t\t\tif (context == PGC_SIGHUP)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are re-reading a PGC_POSTMASTER variable from\n\t\t\t\t * postgresql.conf.  We can't change the setting, so we should\n\t\t\t\t * give a warning if the DBA tries to change it.  However,\n\t\t\t\t * because of variant formats, canonicalization by check\n\t\t\t\t * hooks, etc, we can't just compare the given string directly\n\t\t\t\t * to what's stored.  Set a flag to check below after we have\n\t\t\t\t * the final storable value.\n\t\t\t\t */\n\t\t\t\tprohibitValueChange = true;\n\t\t\t}\n\t\t\telse if (context != PGC_POSTMASTER)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_SIGHUP:\n\t\t\tif (context != PGC_SIGHUP && context != PGC_POSTMASTER)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed now\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Hmm, the idea of the SIGHUP context is \"ought to be global, but\n\t\t\t * can be changed after postmaster start\". But there's nothing\n\t\t\t * that prevents a crafty administrator from sending SIGHUP\n\t\t\t * signals to individual backends only.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PGC_SU_BACKEND:\n\t\t\t/* Reject if we're connecting but user is not superuser */\n\t\t\tif (context == PGC_BACKEND)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t errmsg(\"permission denied to set parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* fall through to process the same as PGC_BACKEND */\n\t\t\t/* FALLTHROUGH */\n\t\tcase PGC_BACKEND:\n\t\t\tif (context == PGC_SIGHUP)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If a PGC_BACKEND or PGC_SU_BACKEND parameter is changed in\n\t\t\t\t * the config file, we want to accept the new value in the\n\t\t\t\t * postmaster (whence it will propagate to\n\t\t\t\t * subsequently-started backends), but ignore it in existing\n\t\t\t\t * backends.  This is a tad klugy, but necessary because we\n\t\t\t\t * don't re-read the config file during backend start.\n\t\t\t\t *\n\t\t\t\t * In EXEC_BACKEND builds, this works differently: we load all\n\t\t\t\t * non-default settings from the CONFIG_EXEC_PARAMS file\n\t\t\t\t * during backend start.  In that case we must accept\n\t\t\t\t * PGC_SIGHUP settings, so as to have the same value as if\n\t\t\t\t * we'd forked from the postmaster.  This can also happen when\n\t\t\t\t * using RestoreGUCState() within a background worker that\n\t\t\t\t * needs to have the same settings as the user backend that\n\t\t\t\t * started it. is_reload will be true when either situation\n\t\t\t\t * applies.\n\t\t\t\t */\n\t\t\t\tif (IsUnderPostmaster && !is_reload)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (context != PGC_POSTMASTER &&\n\t\t\t\t\t context != PGC_BACKEND &&\n\t\t\t\t\t context != PGC_SU_BACKEND &&\n\t\t\t\t\t source != PGC_S_CLIENT)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be set after connection start\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_SUSET:\n\t\t\tif (context == PGC_USERSET || context == PGC_BACKEND)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t errmsg(\"permission denied to set parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_USERSET:\n\t\t\t/* always okay */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Disallow changing GUC_NOT_WHILE_SEC_REST values if we are inside a\n\t * security restriction context.  We can reject this regardless of the GUC\n\t * context or source, mainly because sources that it might be reasonable\n\t * to override for won't be seen while inside a function.\n\t *\n\t * Note: variables marked GUC_NOT_WHILE_SEC_REST should usually be marked\n\t * GUC_NO_RESET_ALL as well, because ResetAllOptions() doesn't check this.\n\t * An exception might be made if the reset value is assumed to be \"safe\".\n\t *\n\t * Note: this flag is currently used for \"session_authorization\" and\n\t * \"role\".  We need to prohibit changing these inside a local userid\n\t * context because when we exit it, GUC won't be notified, leaving things\n\t * out of sync.  (This could be fixed by forcing a new GUC nesting level,\n\t * but that would change behavior in possibly-undesirable ways.)  Also, we\n\t * prohibit changing these in a security-restricted operation because\n\t * otherwise RESET could be used to regain the session user's privileges.\n\t */\n\tif (record->flags & GUC_NOT_WHILE_SEC_REST)\n\t{\n\t\tif (InLocalUserIdChange())\n\t\t{\n\t\t\t/*\n\t\t\t * Phrasing of this error message is historical, but it's the most\n\t\t\t * common case.\n\t\t\t */\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-definer function\",\n\t\t\t\t\t\t\tname)));\n\t\t\treturn 0;\n\t\t}\n\t\tif (InSecurityRestrictedOperation())\n\t\t{\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-restricted operation\",\n\t\t\t\t\t\t\tname)));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Should we set reset/stacked values?\t(If so, the behavior is not\n\t * transactional.)\tThis is done either when we get a default value from\n\t * the database's/user's/client's default settings or when we reset a\n\t * value to its default.\n\t */\n\tmakeDefault = changeVal && (source <= PGC_S_OVERRIDE) &&\n\t\t((value != NULL) || source == PGC_S_DEFAULT);\n\n\t/*\n\t * Ignore attempted set if overridden by previously processed setting.\n\t * However, if changeVal is false then plow ahead anyway since we are\n\t * trying to find out if the value is potentially good, not actually use\n\t * it. Also keep going if makeDefault is true, since we may want to set\n\t * the reset/stacked values even if we can't set the variable itself.\n\t */\n\tif (record->source > source)\n\t{\n\t\tif (changeVal && !makeDefault)\n\t\t{\n\t\t\telog(DEBUG3, \"\\\"%s\\\": setting ignored because previous source is higher priority\",\n\t\t\t\t name);\n\t\t\treturn -1;\n\t\t}\n\t\tchangeVal = false;\n\t}\n\n\t/*\n\t * Evaluate value and set variable.\n\t */\n\tswitch (record->vartype)\n\t{\n\t\tcase PGC_BOOL:\n\t\t\t{\n\t\t\t\tstruct config_bool *conf = (struct config_bool *) record;\n\n#define newval (newval_union.boolval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_bool_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t  source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.boolval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_INT:\n\t\t\t{\n\t\t\t\tstruct config_int *conf = (struct config_int *) record;\n\n#define newval (newval_union.intval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_int_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.intval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_REAL:\n\t\t\t{\n\t\t\t\tstruct config_real *conf = (struct config_real *) record;\n\n#define newval (newval_union.realval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_real_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t  source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.realval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_STRING:\n\t\t\t{\n\t\t\t\tstruct config_string *conf = (struct config_string *) record;\n\n#define newval (newval_union.stringval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\t/* non-NULL boot_val must always get strdup'd */\n\t\t\t\t\tif (conf->boot_val != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewval = guc_strdup(elevel, conf->boot_val);\n\t\t\t\t\t\tif (newval == NULL)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnewval = NULL;\n\n\t\t\t\t\tif (!call_string_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t\tsource, elevel))\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(newval);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * strdup not needed, since reset_val is already under\n\t\t\t\t\t * guc.c's control\n\t\t\t\t\t */\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\t/* newval shouldn't be NULL, so we're a bit sloppy here */\n\t\t\t\t\tif (*conf->variable == NULL || newval == NULL ||\n\t\t\t\t\t\tstrcmp(*conf->variable, newval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\tset_string_field(conf, conf->variable, newval);\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tset_string_field(conf, &conf->reset_val, newval);\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tset_string_field(conf, &stack->prior.val.stringval,\n\t\t\t\t\t\t\t\t\t\t\t newval);\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newval anywhere */\n\t\t\t\tif (newval && !string_field_used(conf, newval))\n\t\t\t\t\tfree(newval);\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_ENUM:\n\t\t\t{\n\t\t\t\tstruct config_enum *conf = (struct config_enum *) record;\n\n#define newval (newval_union.enumval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_enum_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t  source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.enumval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\t}\n\n\tif (changeVal && (record->flags & GUC_REPORT))\n\t\tReportGUCOption(record);\n\n\treturn changeVal ? 1 : -1;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define newval (newval_union.enumval)",
            "#define newval (newval_union.stringval)",
            "#define newval (newval_union.realval)",
            "#define newval (newval_union.intval)",
            "#define newval (newval_union.boolval)",
            "#define CONFIG_EXEC_PARAMS \"global/config_exec_params\""
          ],
          "globals_used": [
            "static bool call_bool_check_hook(struct config_bool *conf, bool *newval,\n\t\t\t\t\t void **extra, GucSource source, int elevel);",
            "static bool call_int_check_hook(struct config_int *conf, int *newval,\n\t\t\t\t\tvoid **extra, GucSource source, int elevel);",
            "static bool call_real_check_hook(struct config_real *conf, double *newval,\n\t\t\t\t\t void **extra, GucSource source, int elevel);",
            "static bool call_string_check_hook(struct config_string *conf, char **newval,\n\t\t\t\t\t   void **extra, GucSource source, int elevel);",
            "static bool call_enum_check_hook(struct config_enum *conf, int *newval,\n\t\t\t\t\t void **extra, GucSource source, int elevel);",
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static void assign_log_destination(const char *newval, void *extra);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static void assign_wal_consistency_checking(const char *newval, void *extra);",
            "static void assign_syslog_facility(int newval, void *extra);",
            "static void assign_syslog_ident(const char *newval, void *extra);",
            "static void assign_session_replication_role(int newval, void *extra);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static void assign_timezone_abbreviations(const char *newval, void *extra);",
            "static void assign_tcp_keepalives_idle(int newval, void *extra);",
            "static void assign_tcp_keepalives_interval(int newval, void *extra);",
            "static void assign_tcp_keepalives_count(int newval, void *extra);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static void assign_effective_io_concurrency(int newval, void *extra);",
            "static void assign_pgstat_temp_directory(const char *newval, void *extra);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static void assign_application_name(const char *newval, void *extra);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static ConfigVariable *ProcessConfigFileInternal(GucContext context,\n\t\t\t\t\t\t  bool applySettings, int elevel);",
            "static void push_old_value(struct config_generic *gconf, GucAction action);",
            "static void ReportGUCOption(struct config_generic *record);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define newval (newval_union.enumval)\n#define newval (newval_union.stringval)\n#define newval (newval_union.realval)\n#define newval (newval_union.intval)\n#define newval (newval_union.boolval)\n#define CONFIG_EXEC_PARAMS \"global/config_exec_params\"\n\nstatic bool call_bool_check_hook(struct config_bool *conf, bool *newval,\n\t\t\t\t\t void **extra, GucSource source, int elevel);\nstatic bool call_int_check_hook(struct config_int *conf, int *newval,\n\t\t\t\t\tvoid **extra, GucSource source, int elevel);\nstatic bool call_real_check_hook(struct config_real *conf, double *newval,\n\t\t\t\t\t void **extra, GucSource source, int elevel);\nstatic bool call_string_check_hook(struct config_string *conf, char **newval,\n\t\t\t\t\t   void **extra, GucSource source, int elevel);\nstatic bool call_enum_check_hook(struct config_enum *conf, int *newval,\n\t\t\t\t\t void **extra, GucSource source, int elevel);\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic void assign_log_destination(const char *newval, void *extra);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic void assign_wal_consistency_checking(const char *newval, void *extra);\nstatic void assign_syslog_facility(int newval, void *extra);\nstatic void assign_syslog_ident(const char *newval, void *extra);\nstatic void assign_session_replication_role(int newval, void *extra);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic void assign_timezone_abbreviations(const char *newval, void *extra);\nstatic void assign_tcp_keepalives_idle(int newval, void *extra);\nstatic void assign_tcp_keepalives_interval(int newval, void *extra);\nstatic void assign_tcp_keepalives_count(int newval, void *extra);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic void assign_effective_io_concurrency(int newval, void *extra);\nstatic void assign_pgstat_temp_directory(const char *newval, void *extra);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic void assign_application_name(const char *newval, void *extra);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic ConfigVariable *ProcessConfigFileInternal(GucContext context,\n\t\t\t\t\t\t  bool applySettings, int elevel);\nstatic void push_old_value(struct config_generic *gconf, GucAction action);\nstatic void ReportGUCOption(struct config_generic *record);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nint\nset_config_option(const char *name, const char *value,\n\t\t\t\t  GucContext context, GucSource source,\n\t\t\t\t  GucAction action, bool changeVal, int elevel,\n\t\t\t\t  bool is_reload)\n{\n\tstruct config_generic *record;\n\tunion config_var_val newval_union;\n\tvoid\t   *newextra = NULL;\n\tbool\t\tprohibitValueChange = false;\n\tbool\t\tmakeDefault;\n\n\tif (elevel == 0)\n\t{\n\t\tif (source == PGC_S_DEFAULT || source == PGC_S_FILE)\n\t\t{\n\t\t\t/*\n\t\t\t * To avoid cluttering the log, only the postmaster bleats loudly\n\t\t\t * about problems with the config file.\n\t\t\t */\n\t\t\televel = IsUnderPostmaster ? DEBUG3 : LOG;\n\t\t}\n\t\telse if (source == PGC_S_GLOBAL ||\n\t\t\t\t source == PGC_S_DATABASE ||\n\t\t\t\t source == PGC_S_USER ||\n\t\t\t\t source == PGC_S_DATABASE_USER)\n\t\t\televel = WARNING;\n\t\telse\n\t\t\televel = ERROR;\n\t}\n\n\t/*\n\t * GUC_ACTION_SAVE changes are acceptable during a parallel operation,\n\t * because the current worker will also pop the change.  We're probably\n\t * dealing with a function having a proconfig entry.  Only the function's\n\t * body should observe the change, and peer workers do not share in the\n\t * execution of a function call started by this worker.\n\t *\n\t * Other changes might need to affect other workers, so forbid them.\n\t */\n\tif (IsInParallelMode() && changeVal && action != GUC_ACTION_SAVE)\n\t\tereport(elevel,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot set parameters during a parallel operation\")));\n\n\trecord = find_option(name, true, elevel);\n\tif (record == NULL)\n\t{\n\t\tereport(elevel,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"unrecognized configuration parameter \\\"%s\\\"\", name)));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if the option can be set at this time. See guc.h for the precise\n\t * rules.\n\t */\n\tswitch (record->context)\n\t{\n\t\tcase PGC_INTERNAL:\n\t\t\tif (context != PGC_INTERNAL)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_POSTMASTER:\n\t\t\tif (context == PGC_SIGHUP)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are re-reading a PGC_POSTMASTER variable from\n\t\t\t\t * postgresql.conf.  We can't change the setting, so we should\n\t\t\t\t * give a warning if the DBA tries to change it.  However,\n\t\t\t\t * because of variant formats, canonicalization by check\n\t\t\t\t * hooks, etc, we can't just compare the given string directly\n\t\t\t\t * to what's stored.  Set a flag to check below after we have\n\t\t\t\t * the final storable value.\n\t\t\t\t */\n\t\t\t\tprohibitValueChange = true;\n\t\t\t}\n\t\t\telse if (context != PGC_POSTMASTER)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_SIGHUP:\n\t\t\tif (context != PGC_SIGHUP && context != PGC_POSTMASTER)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed now\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Hmm, the idea of the SIGHUP context is \"ought to be global, but\n\t\t\t * can be changed after postmaster start\". But there's nothing\n\t\t\t * that prevents a crafty administrator from sending SIGHUP\n\t\t\t * signals to individual backends only.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PGC_SU_BACKEND:\n\t\t\t/* Reject if we're connecting but user is not superuser */\n\t\t\tif (context == PGC_BACKEND)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t errmsg(\"permission denied to set parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* fall through to process the same as PGC_BACKEND */\n\t\t\t/* FALLTHROUGH */\n\t\tcase PGC_BACKEND:\n\t\t\tif (context == PGC_SIGHUP)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If a PGC_BACKEND or PGC_SU_BACKEND parameter is changed in\n\t\t\t\t * the config file, we want to accept the new value in the\n\t\t\t\t * postmaster (whence it will propagate to\n\t\t\t\t * subsequently-started backends), but ignore it in existing\n\t\t\t\t * backends.  This is a tad klugy, but necessary because we\n\t\t\t\t * don't re-read the config file during backend start.\n\t\t\t\t *\n\t\t\t\t * In EXEC_BACKEND builds, this works differently: we load all\n\t\t\t\t * non-default settings from the CONFIG_EXEC_PARAMS file\n\t\t\t\t * during backend start.  In that case we must accept\n\t\t\t\t * PGC_SIGHUP settings, so as to have the same value as if\n\t\t\t\t * we'd forked from the postmaster.  This can also happen when\n\t\t\t\t * using RestoreGUCState() within a background worker that\n\t\t\t\t * needs to have the same settings as the user backend that\n\t\t\t\t * started it. is_reload will be true when either situation\n\t\t\t\t * applies.\n\t\t\t\t */\n\t\t\t\tif (IsUnderPostmaster && !is_reload)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (context != PGC_POSTMASTER &&\n\t\t\t\t\t context != PGC_BACKEND &&\n\t\t\t\t\t context != PGC_SU_BACKEND &&\n\t\t\t\t\t source != PGC_S_CLIENT)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be set after connection start\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_SUSET:\n\t\t\tif (context == PGC_USERSET || context == PGC_BACKEND)\n\t\t\t{\n\t\t\t\tereport(elevel,\n\t\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t\t errmsg(\"permission denied to set parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tname)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PGC_USERSET:\n\t\t\t/* always okay */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Disallow changing GUC_NOT_WHILE_SEC_REST values if we are inside a\n\t * security restriction context.  We can reject this regardless of the GUC\n\t * context or source, mainly because sources that it might be reasonable\n\t * to override for won't be seen while inside a function.\n\t *\n\t * Note: variables marked GUC_NOT_WHILE_SEC_REST should usually be marked\n\t * GUC_NO_RESET_ALL as well, because ResetAllOptions() doesn't check this.\n\t * An exception might be made if the reset value is assumed to be \"safe\".\n\t *\n\t * Note: this flag is currently used for \"session_authorization\" and\n\t * \"role\".  We need to prohibit changing these inside a local userid\n\t * context because when we exit it, GUC won't be notified, leaving things\n\t * out of sync.  (This could be fixed by forcing a new GUC nesting level,\n\t * but that would change behavior in possibly-undesirable ways.)  Also, we\n\t * prohibit changing these in a security-restricted operation because\n\t * otherwise RESET could be used to regain the session user's privileges.\n\t */\n\tif (record->flags & GUC_NOT_WHILE_SEC_REST)\n\t{\n\t\tif (InLocalUserIdChange())\n\t\t{\n\t\t\t/*\n\t\t\t * Phrasing of this error message is historical, but it's the most\n\t\t\t * common case.\n\t\t\t */\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-definer function\",\n\t\t\t\t\t\t\tname)));\n\t\t\treturn 0;\n\t\t}\n\t\tif (InSecurityRestrictedOperation())\n\t\t{\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-restricted operation\",\n\t\t\t\t\t\t\tname)));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Should we set reset/stacked values?\t(If so, the behavior is not\n\t * transactional.)\tThis is done either when we get a default value from\n\t * the database's/user's/client's default settings or when we reset a\n\t * value to its default.\n\t */\n\tmakeDefault = changeVal && (source <= PGC_S_OVERRIDE) &&\n\t\t((value != NULL) || source == PGC_S_DEFAULT);\n\n\t/*\n\t * Ignore attempted set if overridden by previously processed setting.\n\t * However, if changeVal is false then plow ahead anyway since we are\n\t * trying to find out if the value is potentially good, not actually use\n\t * it. Also keep going if makeDefault is true, since we may want to set\n\t * the reset/stacked values even if we can't set the variable itself.\n\t */\n\tif (record->source > source)\n\t{\n\t\tif (changeVal && !makeDefault)\n\t\t{\n\t\t\telog(DEBUG3, \"\\\"%s\\\": setting ignored because previous source is higher priority\",\n\t\t\t\t name);\n\t\t\treturn -1;\n\t\t}\n\t\tchangeVal = false;\n\t}\n\n\t/*\n\t * Evaluate value and set variable.\n\t */\n\tswitch (record->vartype)\n\t{\n\t\tcase PGC_BOOL:\n\t\t\t{\n\t\t\t\tstruct config_bool *conf = (struct config_bool *) record;\n\n#define newval (newval_union.boolval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_bool_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t  source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.boolval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_INT:\n\t\t\t{\n\t\t\t\tstruct config_int *conf = (struct config_int *) record;\n\n#define newval (newval_union.intval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_int_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.intval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_REAL:\n\t\t\t{\n\t\t\t\tstruct config_real *conf = (struct config_real *) record;\n\n#define newval (newval_union.realval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_real_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t  source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.realval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_STRING:\n\t\t\t{\n\t\t\t\tstruct config_string *conf = (struct config_string *) record;\n\n#define newval (newval_union.stringval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\t/* non-NULL boot_val must always get strdup'd */\n\t\t\t\t\tif (conf->boot_val != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewval = guc_strdup(elevel, conf->boot_val);\n\t\t\t\t\t\tif (newval == NULL)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnewval = NULL;\n\n\t\t\t\t\tif (!call_string_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t\tsource, elevel))\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(newval);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * strdup not needed, since reset_val is already under\n\t\t\t\t\t * guc.c's control\n\t\t\t\t\t */\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\t/* newval shouldn't be NULL, so we're a bit sloppy here */\n\t\t\t\t\tif (*conf->variable == NULL || newval == NULL ||\n\t\t\t\t\t\tstrcmp(*conf->variable, newval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\tset_string_field(conf, conf->variable, newval);\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tset_string_field(conf, &conf->reset_val, newval);\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tset_string_field(conf, &stack->prior.val.stringval,\n\t\t\t\t\t\t\t\t\t\t\t newval);\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newval anywhere */\n\t\t\t\tif (newval && !string_field_used(conf, newval))\n\t\t\t\t\tfree(newval);\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\n\t\tcase PGC_ENUM:\n\t\t\t{\n\t\t\t\tstruct config_enum *conf = (struct config_enum *) record;\n\n#define newval (newval_union.enumval)\n\n\t\t\t\tif (value)\n\t\t\t\t{\n\t\t\t\t\tif (!parse_and_validate_value(record, name, value,\n\t\t\t\t\t\t\t\t\t\t\t\t  source, elevel,\n\t\t\t\t\t\t\t\t\t\t\t\t  &newval_union, &newextra))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse if (source == PGC_S_DEFAULT)\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->boot_val;\n\t\t\t\t\tif (!call_enum_check_hook(conf, &newval, &newextra,\n\t\t\t\t\t\t\t\t\t\t\t  source, elevel))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewval = conf->reset_val;\n\t\t\t\t\tnewextra = conf->reset_extra;\n\t\t\t\t\tsource = conf->gen.reset_source;\n\t\t\t\t\tcontext = conf->gen.reset_scontext;\n\t\t\t\t}\n\n\t\t\t\tif (prohibitValueChange)\n\t\t\t\t{\n\t\t\t\t\tif (*conf->variable != newval)\n\t\t\t\t\t{\n\t\t\t\t\t\trecord->status |= GUC_PENDING_RESTART;\n\t\t\t\t\t\tereport(elevel,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\n\t\t\t\t\t\t\t\t errmsg(\"parameter \\\"%s\\\" cannot be changed without restarting the server\",\n\t\t\t\t\t\t\t\t\t\tname)));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\trecord->status &= ~GUC_PENDING_RESTART;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (changeVal)\n\t\t\t\t{\n\t\t\t\t\t/* Save old value to support transaction abort */\n\t\t\t\t\tif (!makeDefault)\n\t\t\t\t\t\tpush_old_value(&conf->gen, action);\n\n\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\tconf->gen.source = source;\n\t\t\t\t\tconf->gen.scontext = context;\n\t\t\t\t}\n\t\t\t\tif (makeDefault)\n\t\t\t\t{\n\t\t\t\t\tGucStack   *stack;\n\n\t\t\t\t\tif (conf->gen.reset_source <= source)\n\t\t\t\t\t{\n\t\t\t\t\t\tconf->reset_val = newval;\n\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->reset_extra,\n\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\tconf->gen.reset_source = source;\n\t\t\t\t\t\tconf->gen.reset_scontext = context;\n\t\t\t\t\t}\n\t\t\t\t\tfor (stack = conf->gen.stack; stack; stack = stack->prev)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stack->source <= source)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstack->prior.val.enumval = newval;\n\t\t\t\t\t\t\tset_extra_field(&conf->gen, &stack->prior.extra,\n\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\tstack->source = source;\n\t\t\t\t\t\t\tstack->scontext = context;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Perhaps we didn't install newextra anywhere */\n\t\t\t\tif (newextra && !extra_field_used(&conf->gen, newextra))\n\t\t\t\t\tfree(newextra);\n\t\t\t\tbreak;\n\n#undef newval\n\t\t\t}\n\t}\n\n\tif (changeVal && (record->flags & GUC_REPORT))\n\t\tReportGUCOption(record);\n\n\treturn changeVal ? 1 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "workmembuf",
            "sizeof(workmembuf)",
            "\"%d\"",
            "maintenance_work_mem"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewGUCNestLevel",
          "args": [],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "NewGUCNestLevel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "5317-5321",
          "snippet": "int\nNewGUCNestLevel(void)\n{\n\treturn ++GUCNestLevel;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGUCNestLevel = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGUCNestLevel = 0;\n\nint\nNewGUCNestLevel(void)\n{\n\treturn ++GUCNestLevel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&querybuf",
            "')'"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"%sfk.%s IS NOT NULL\"",
            "sep",
            "fkattname"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "fkattname",
            "RIAttName(fk_rel, riinfo->fk_attnums[i])"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\") WHERE pk.%s IS NULL AND (\"",
            "pkattname"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[0]"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQualCollation",
          "args": [
            "&querybuf",
            "pk_coll"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQualCollation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2192-2220",
          "snippet": "static void\nri_GenerateQualCollation(StringInfo buf, Oid collation)\n{\n\tHeapTuple\ttp;\n\tForm_pg_collation colltup;\n\tchar\t   *collname;\n\tchar\t\tonename[MAX_QUOTED_NAME_LEN];\n\n\t/* Nothing to do if it's a noncollatable data type */\n\tif (!OidIsValid(collation))\n\t\treturn;\n\n\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\tcolltup = (Form_pg_collation) GETSTRUCT(tp);\n\tcollname = NameStr(colltup->collname);\n\n\t/*\n\t * We qualify the name always, for simplicity and to ensure the query is\n\t * not search-path-dependent.\n\t */\n\tquoteOneName(onename, get_namespace_name(colltup->collnamespace));\n\tappendStringInfo(buf, \" COLLATE %s\", onename);\n\tquoteOneName(onename, collname);\n\tappendStringInfo(buf, \".%s\", onename);\n\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)"
          ],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);",
            "static void ri_GenerateQualCollation(StringInfo buf, Oid collation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n\nstatic void quoteOneName(char *buffer, const char *name);\nstatic void ri_GenerateQualCollation(StringInfo buf, Oid collation);\n\nstatic void\nri_GenerateQualCollation(StringInfo buf, Oid collation)\n{\n\tHeapTuple\ttp;\n\tForm_pg_collation colltup;\n\tchar\t   *collname;\n\tchar\t\tonename[MAX_QUOTED_NAME_LEN];\n\n\t/* Nothing to do if it's a noncollatable data type */\n\tif (!OidIsValid(collation))\n\t\treturn;\n\n\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for collation %u\", collation);\n\tcolltup = (Form_pg_collation) GETSTRUCT(tp);\n\tcollname = NameStr(colltup->collname);\n\n\t/*\n\t * We qualify the name always, for simplicity and to ensure the query is\n\t * not search-path-dependent.\n\t */\n\tquoteOneName(onename, get_namespace_name(colltup->collnamespace));\n\tappendStringInfo(buf, \" COLLATE %s\", onename);\n\tquoteOneName(onename, collname);\n\tappendStringInfo(buf, \".%s\", onename);\n\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&querybuf",
            "sep",
            "pkattname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "fkattname",
            "fk_type"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttCollation",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttCollation",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fkattname",
            "\"fk.\""
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\" FROM %s%s fk LEFT OUTER JOIN ONLY %s pk ON\"",
            "fk_only",
            "fkrelname",
            "pkrelname"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "fkrelname",
            "fk_rel"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"%sfk.%s\"",
            "sep",
            "fkattname"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "\"SELECT \""
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_class_ownercheck",
          "args": [
            "fkrte->relid",
            "GetUserId()"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_class_ownercheck",
          "args": [
            "pkrte->relid",
            "GetUserId()"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_bypassrls_privilege",
          "args": [
            "GetUserId()"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecCheckRTPerms",
          "args": [
            "list_make2(fkrte, pkrte)",
            "false"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "fkrte",
            "pkrte"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "fkrte->selectedCols",
            "attno"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "pkrte->selectedCols",
            "attno"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "fk_rel"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "RangeTblEntry"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "pk_rel"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "RangeTblEntry"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigger",
            "fk_rel",
            "false"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nbool\nRI_Initial_Check(Trigger *trigger, Relation fk_rel, Relation pk_rel)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tStringInfoData querybuf;\n\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\tchar\t\tpkattname[MAX_QUOTED_NAME_LEN + 3];\n\tchar\t\tfkattname[MAX_QUOTED_NAME_LEN + 3];\n\tRangeTblEntry *pkrte;\n\tRangeTblEntry *fkrte;\n\tconst char *sep;\n\tconst char *fk_only;\n\tint\t\t\ti;\n\tint\t\t\tsave_nestlevel;\n\tchar\t\tworkmembuf[32];\n\tint\t\t\tspi_result;\n\tSPIPlanPtr\tqplan;\n\n\t/* Fetch constraint info. */\n\triinfo = ri_FetchConstraintInfo(trigger, fk_rel, false);\n\n\t/*\n\t * Check to make sure current user has enough permissions to do the test\n\t * query.  (If not, caller can fall back to the trigger method, which\n\t * works because it changes user IDs on the fly.)\n\t *\n\t * XXX are there any other show-stopper conditions to check?\n\t */\n\tpkrte = makeNode(RangeTblEntry);\n\tpkrte->rtekind = RTE_RELATION;\n\tpkrte->relid = RelationGetRelid(pk_rel);\n\tpkrte->relkind = pk_rel->rd_rel->relkind;\n\tpkrte->requiredPerms = ACL_SELECT;\n\n\tfkrte = makeNode(RangeTblEntry);\n\tfkrte->rtekind = RTE_RELATION;\n\tfkrte->relid = RelationGetRelid(fk_rel);\n\tfkrte->relkind = fk_rel->rd_rel->relkind;\n\tfkrte->requiredPerms = ACL_SELECT;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tint\t\t\tattno;\n\n\t\tattno = riinfo->pk_attnums[i] - FirstLowInvalidHeapAttributeNumber;\n\t\tpkrte->selectedCols = bms_add_member(pkrte->selectedCols, attno);\n\n\t\tattno = riinfo->fk_attnums[i] - FirstLowInvalidHeapAttributeNumber;\n\t\tfkrte->selectedCols = bms_add_member(fkrte->selectedCols, attno);\n\t}\n\n\tif (!ExecCheckRTPerms(list_make2(fkrte, pkrte), false))\n\t\treturn false;\n\n\t/*\n\t * Also punt if RLS is enabled on either table unless this role has the\n\t * bypassrls right or is the table owner of the table(s) involved which\n\t * have RLS enabled.\n\t */\n\tif (!has_bypassrls_privilege(GetUserId()) &&\n\t\t((pk_rel->rd_rel->relrowsecurity &&\n\t\t  !pg_class_ownercheck(pkrte->relid, GetUserId())) ||\n\t\t (fk_rel->rd_rel->relrowsecurity &&\n\t\t  !pg_class_ownercheck(fkrte->relid, GetUserId()))))\n\t\treturn false;\n\n\t/*----------\n\t * The query string built is:\n\t *\tSELECT fk.keycols FROM [ONLY] relname fk\n\t *\t LEFT OUTER JOIN ONLY pkrelname pk\n\t *\t ON (pk.pkkeycol1=fk.keycol1 [AND ...])\n\t *\t WHERE pk.pkkeycol1 IS NULL AND\n\t * For MATCH SIMPLE:\n\t *\t (fk.keycol1 IS NOT NULL [AND ...])\n\t * For MATCH FULL:\n\t *\t (fk.keycol1 IS NOT NULL [OR ...])\n\t *\n\t * We attach COLLATE clauses to the operators when comparing columns\n\t * that have different collations.\n\t *----------\n\t */\n\tinitStringInfo(&querybuf);\n\tappendStringInfoString(&querybuf, \"SELECT \");\n\tsep = \"\";\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tquoteOneName(fkattname,\n\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\tappendStringInfo(&querybuf, \"%sfk.%s\", sep, fkattname);\n\t\tsep = \", \";\n\t}\n\n\tquoteRelationName(pkrelname, pk_rel);\n\tquoteRelationName(fkrelname, fk_rel);\n\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\"\" : \"ONLY \";\n\tappendStringInfo(&querybuf,\n\t\t\t\t\t \" FROM %s%s fk LEFT OUTER JOIN ONLY %s pk ON\",\n\t\t\t\t\t fk_only, fkrelname, pkrelname);\n\n\tstrcpy(pkattname, \"pk.\");\n\tstrcpy(fkattname, \"fk.\");\n\tsep = \"(\";\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\t\tOid\t\t\tpk_coll = RIAttCollation(pk_rel, riinfo->pk_attnums[i]);\n\t\tOid\t\t\tfk_coll = RIAttCollation(fk_rel, riinfo->fk_attnums[i]);\n\n\t\tquoteOneName(pkattname + 3,\n\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\tquoteOneName(fkattname + 3,\n\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\tri_GenerateQual(&querybuf, sep,\n\t\t\t\t\t\tpkattname, pk_type,\n\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\tfkattname, fk_type);\n\t\tif (pk_coll != fk_coll)\n\t\t\tri_GenerateQualCollation(&querybuf, pk_coll);\n\t\tsep = \"AND\";\n\t}\n\n\t/*\n\t * It's sufficient to test any one pk attribute for null to detect a join\n\t * failure.\n\t */\n\tquoteOneName(pkattname, RIAttName(pk_rel, riinfo->pk_attnums[0]));\n\tappendStringInfo(&querybuf, \") WHERE pk.%s IS NULL AND (\", pkattname);\n\n\tsep = \"\";\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tquoteOneName(fkattname, RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t \"%sfk.%s IS NOT NULL\",\n\t\t\t\t\t\t sep, fkattname);\n\t\tswitch (riinfo->confmatchtype)\n\t\t{\n\t\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\t\t\tsep = \" AND \";\n\t\t\t\tbreak;\n\t\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\t\tsep = \" OR \";\n\t\t\t\tbreak;\n\t\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t\t riinfo->confmatchtype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoChar(&querybuf, ')');\n\n\t/*\n\t * Temporarily increase work_mem so that the check query can be executed\n\t * more efficiently.  It seems okay to do this because the query is simple\n\t * enough to not use a multiple of work_mem, and one typically would not\n\t * have many large foreign-key validations happening concurrently.  So\n\t * this seems to meet the criteria for being considered a \"maintenance\"\n\t * operation, and accordingly we use maintenance_work_mem.\n\t *\n\t * We use the equivalent of a function SET option to allow the setting to\n\t * persist for exactly the duration of the check query.  guc.c also takes\n\t * care of undoing the setting on error.\n\t */\n\tsave_nestlevel = NewGUCNestLevel();\n\n\tsnprintf(workmembuf, sizeof(workmembuf), \"%d\", maintenance_work_mem);\n\t(void) set_config_option(\"work_mem\", workmembuf,\n\t\t\t\t\t\t\t PGC_USERSET, PGC_S_SESSION,\n\t\t\t\t\t\t\t GUC_ACTION_SAVE, true, 0, false);\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Generate the plan.  We don't need to cache it, and there are no\n\t * arguments to the plan.\n\t */\n\tqplan = SPI_prepare(querybuf.data, 0, NULL);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\",\n\t\t\t SPI_result_code_string(SPI_result), querybuf.data);\n\n\t/*\n\t * Run the plan.  For safety we force a current snapshot to be used. (In\n\t * transaction-snapshot mode, this arguably violates transaction isolation\n\t * rules, but we really haven't got much choice.) We don't need to\n\t * register the snapshot, because SPI_execute_snapshot will see to it. We\n\t * need at most one tuple returned, so pass limit = 1.\n\t */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  NULL, NULL,\n\t\t\t\t\t\t\t\t\t  GetLatestSnapshot(),\n\t\t\t\t\t\t\t\t\t  InvalidSnapshot,\n\t\t\t\t\t\t\t\t\t  true, false, 1);\n\n\t/* Check result */\n\tif (spi_result != SPI_OK_SELECT)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\t/* Did we find a tuple violating the constraint? */\n\tif (SPI_processed > 0)\n\t{\n\t\tHeapTuple\ttuple = SPI_tuptable->vals[0];\n\t\tTupleDesc\ttupdesc = SPI_tuptable->tupdesc;\n\t\tRI_ConstraintInfo fake_riinfo;\n\n\t\t/*\n\t\t * The columns to look at in the result tuple are 1..N, not whatever\n\t\t * they are in the fk_rel.  Hack up riinfo so that the subroutines\n\t\t * called here will behave properly.\n\t\t *\n\t\t * In addition to this, we have to pass the correct tupdesc to\n\t\t * ri_ReportViolation, overriding its normal habit of using the pk_rel\n\t\t * or fk_rel's tupdesc.\n\t\t */\n\t\tmemcpy(&fake_riinfo, riinfo, sizeof(RI_ConstraintInfo));\n\t\tfor (i = 0; i < fake_riinfo.nkeys; i++)\n\t\t\tfake_riinfo.fk_attnums[i] = i + 1;\n\n\t\t/*\n\t\t * If it's MATCH FULL, and there are any nulls in the FK keys,\n\t\t * complain about that rather than the lack of a match.  MATCH FULL\n\t\t * disallows partially-null FK rows.\n\t\t */\n\t\tif (fake_riinfo.confmatchtype == FKCONSTR_MATCH_FULL &&\n\t\t\tri_NullCheck(tupdesc, tuple, &fake_riinfo, false) != RI_KEYS_NONE_NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\t\tNameStr(fake_riinfo.conname)),\n\t\t\t\t\t errdetail(\"MATCH FULL does not allow mixing of null and nonnull key values.\"),\n\t\t\t\t\t errtableconstraint(fk_rel,\n\t\t\t\t\t\t\t\t\t\tNameStr(fake_riinfo.conname))));\n\n\t\t/*\n\t\t * We tell ri_ReportViolation we were doing the RI_PLAN_CHECK_LOOKUPPK\n\t\t * query, which isn't true, but will cause it to use\n\t\t * fake_riinfo.fk_attnums as we need.\n\t\t */\n\t\tri_ReportViolation(&fake_riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   tuple, tupdesc,\n\t\t\t\t\t\t   RI_PLAN_CHECK_LOOKUPPK);\n\t}\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\t/*\n\t * Restore work_mem.\n\t */\n\tAtEOXact_GUC(true, save_nestlevel);\n\n\treturn true;\n}"
  },
  {
    "function_name": "RI_FKey_fk_upd_check_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1735-1828",
    "snippet": "bool\nRI_FKey_fk_upd_check_required(Trigger *trigger, Relation fk_rel,\n\t\t\t\t\t\t\t  HeapTuple old_row, HeapTuple new_row)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigger, fk_rel, false);\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\n\t\t\t/*\n\t\t\t * If any new key value is NULL, the row must satisfy the\n\t\t\t * constraint, so no check is needed.\n\t\t\t */\n\t\t\tif (ri_NullCheck(RelationGetDescr(fk_rel), new_row, riinfo, false) != RI_KEYS_NONE_NULL)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If the original row was inserted by our own transaction, we\n\t\t\t * must fire the trigger whether or not the keys are equal.  This\n\t\t\t * is because our UPDATE will invalidate the INSERT so that the\n\t\t\t * INSERT RI trigger will not do anything; so we had better do the\n\t\t\t * UPDATE check.  (We could skip this if we knew the INSERT\n\t\t\t * trigger already fired, but there is no easy way to know that.)\n\t\t\t */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(old_row->t_data)))\n\t\t\t\treturn true;\n\n\t\t\t/* If all old and new key values are equal, no check is needed */\n\t\t\tif (ri_KeysEqual(fk_rel, old_row, new_row, riinfo, false))\n\t\t\t\treturn false;\n\n\t\t\t/* Else we need to fire the trigger. */\n\t\t\treturn true;\n\n\t\tcase FKCONSTR_MATCH_FULL:\n\n\t\t\t/*\n\t\t\t * If all new key values are NULL, the row must satisfy the\n\t\t\t * constraint, so no check is needed.  On the other hand, if only\n\t\t\t * some of them are NULL, the row must fail the constraint.  We\n\t\t\t * must not throw error here, because the row might get\n\t\t\t * invalidated before the constraint is to be checked, but we\n\t\t\t * should queue the event to apply the check later.\n\t\t\t */\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(fk_rel), new_row, riinfo, false))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\t\treturn false;\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\t\t\t\t\treturn true;\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\t\t\t\t\tbreak;\t\t/* continue with the check */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the original row was inserted by our own transaction, we\n\t\t\t * must fire the trigger whether or not the keys are equal.  This\n\t\t\t * is because our UPDATE will invalidate the INSERT so that the\n\t\t\t * INSERT RI trigger will not do anything; so we had better do the\n\t\t\t * UPDATE check.  (We could skip this if we knew the INSERT\n\t\t\t * trigger already fired, but there is no easy way to know that.)\n\t\t\t */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(old_row->t_data)))\n\t\t\t\treturn true;\n\n\t\t\t/* If all old and new key values are equal, no check is needed */\n\t\t\tif (ri_KeysEqual(fk_rel, old_row, new_row, riinfo, false))\n\t\t\t\treturn false;\n\n\t\t\t/* Else we need to fire the trigger. */\n\t\t\treturn true;\n\n\t\t\t/* Handle MATCH PARTIAL check. */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_KeysEqual",
          "args": [
            "fk_rel",
            "old_row",
            "new_row",
            "riinfo",
            "false"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "ri_KeysEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2976-3025",
          "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetXmin(old_row->t_data)"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXmin",
          "args": [
            "old_row->t_data"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(fk_rel)",
            "new_row",
            "riinfo",
            "false"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "fk_rel"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetXmin(old_row->t_data)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXmin",
          "args": [
            "old_row->t_data"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "fk_rel"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigger",
            "fk_rel",
            "false"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nbool\nRI_FKey_fk_upd_check_required(Trigger *trigger, Relation fk_rel,\n\t\t\t\t\t\t\t  HeapTuple old_row, HeapTuple new_row)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigger, fk_rel, false);\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\n\t\t\t/*\n\t\t\t * If any new key value is NULL, the row must satisfy the\n\t\t\t * constraint, so no check is needed.\n\t\t\t */\n\t\t\tif (ri_NullCheck(RelationGetDescr(fk_rel), new_row, riinfo, false) != RI_KEYS_NONE_NULL)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If the original row was inserted by our own transaction, we\n\t\t\t * must fire the trigger whether or not the keys are equal.  This\n\t\t\t * is because our UPDATE will invalidate the INSERT so that the\n\t\t\t * INSERT RI trigger will not do anything; so we had better do the\n\t\t\t * UPDATE check.  (We could skip this if we knew the INSERT\n\t\t\t * trigger already fired, but there is no easy way to know that.)\n\t\t\t */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(old_row->t_data)))\n\t\t\t\treturn true;\n\n\t\t\t/* If all old and new key values are equal, no check is needed */\n\t\t\tif (ri_KeysEqual(fk_rel, old_row, new_row, riinfo, false))\n\t\t\t\treturn false;\n\n\t\t\t/* Else we need to fire the trigger. */\n\t\t\treturn true;\n\n\t\tcase FKCONSTR_MATCH_FULL:\n\n\t\t\t/*\n\t\t\t * If all new key values are NULL, the row must satisfy the\n\t\t\t * constraint, so no check is needed.  On the other hand, if only\n\t\t\t * some of them are NULL, the row must fail the constraint.  We\n\t\t\t * must not throw error here, because the row might get\n\t\t\t * invalidated before the constraint is to be checked, but we\n\t\t\t * should queue the event to apply the check later.\n\t\t\t */\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(fk_rel), new_row, riinfo, false))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\t\treturn false;\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\t\t\t\t\treturn true;\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\t\t\t\t\tbreak;\t\t/* continue with the check */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the original row was inserted by our own transaction, we\n\t\t\t * must fire the trigger whether or not the keys are equal.  This\n\t\t\t * is because our UPDATE will invalidate the INSERT so that the\n\t\t\t * INSERT RI trigger will not do anything; so we had better do the\n\t\t\t * UPDATE check.  (We could skip this if we knew the INSERT\n\t\t\t * trigger already fired, but there is no easy way to know that.)\n\t\t\t */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(old_row->t_data)))\n\t\t\t\treturn true;\n\n\t\t\t/* If all old and new key values are equal, no check is needed */\n\t\t\tif (ri_KeysEqual(fk_rel, old_row, new_row, riinfo, false))\n\t\t\t\treturn false;\n\n\t\t\t/* Else we need to fire the trigger. */\n\t\t\treturn true;\n\n\t\t\t/* Handle MATCH PARTIAL check. */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn false;\n}"
  },
  {
    "function_name": "RI_FKey_pk_upd_check_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1678-1723",
    "snippet": "bool\nRI_FKey_pk_upd_check_required(Trigger *trigger, Relation pk_rel,\n\t\t\t\t\t\t\t  HeapTuple old_row, HeapTuple new_row)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigger, pk_rel, true);\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\n\t\t\t/*\n\t\t\t * If any old key value is NULL, the row could not have been\n\t\t\t * referenced by an FK row, so no check is needed.\n\t\t\t */\n\t\t\tif (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) != RI_KEYS_NONE_NULL)\n\t\t\t\treturn false;\n\n\t\t\t/* If all old and new key values are equal, no check is needed */\n\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\treturn false;\n\n\t\t\t/* Else we need to fire the trigger. */\n\t\t\treturn true;\n\n\t\t\t/* Handle MATCH PARTIAL check. */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_KEYS_NONE_NULL\t\t\t\t2"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_KeysEqual",
          "args": [
            "pk_rel",
            "old_row",
            "new_row",
            "riinfo",
            "true"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "ri_KeysEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2976-3025",
          "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigger",
            "pk_rel",
            "true"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nbool\nRI_FKey_pk_upd_check_required(Trigger *trigger, Relation pk_rel,\n\t\t\t\t\t\t\t  HeapTuple old_row, HeapTuple new_row)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigger, pk_rel, true);\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\n\t\t\t/*\n\t\t\t * If any old key value is NULL, the row could not have been\n\t\t\t * referenced by an FK row, so no check is needed.\n\t\t\t */\n\t\t\tif (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) != RI_KEYS_NONE_NULL)\n\t\t\t\treturn false;\n\n\t\t\t/* If all old and new key values are equal, no check is needed */\n\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\treturn false;\n\n\t\t\t/* Else we need to fire the trigger. */\n\t\t\treturn true;\n\n\t\t\t/* Handle MATCH PARTIAL check. */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn false;\n}"
  },
  {
    "function_name": "ri_setdefault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1479-1665",
    "snippet": "static Datum\nri_setdefault(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET DEFAULT\n\t\t\t *\tGeneral rules 10) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET DEFAULT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set default operation\n\t\t\t * (it's the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETDEFAULT_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = DEFAULT [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = DEFAULT\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\t/*\n\t\t\t * If we just deleted or updated the PK row whose key was equal to\n\t\t\t * the FK columns' default values, and a referencing row exists in\n\t\t\t * the FK table, we would have updated that row to the same values\n\t\t\t * it already had --- and RI_FKey_fk_upd_check_required would\n\t\t\t * hence believe no check is necessary.  So we need to do another\n\t\t\t * lookup now and in case a reference still exists, abort the\n\t\t\t * operation.  That is already implemented in the NO ACTION\n\t\t\t * trigger, so just run it.  (This recheck is only needed in the\n\t\t\t * SET DEFAULT case, since CASCADE would remove such rows in case\n\t\t\t * of a DELETE operation or would change the FK key values in case\n\t\t\t * of an UPDATE, while SET NULL is certain to result in rows that\n\t\t\t * satisfy the FK constraint.)\n\t\t\t */\n\t\t\treturn ri_restrict(trigdata, true);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set default delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_SETDEFAULT_DOUPDATE\t\t7",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_restrict",
          "args": [
            "trigdata",
            "true"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "ri_restrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "687-864",
          "snippet": "static Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_RESTRICT_CHECKREF\t\t5",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_restrict(TriggerData *trigdata, bool is_no_action);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_RESTRICT_CHECKREF\t\t5\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_restrict(TriggerData *trigdata, bool is_no_action);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "old_row",
            "NULL",
            "true",
            "/* must detect new rows */SPI_OK_UPDATE"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "qualbuf.data"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&qualbuf",
            "qualsep",
            "paramname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "attname",
            "fk_type"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "i + 1"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"%s %s = DEFAULT\"",
            "querysep",
            "attname"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(fk_rel, riinfo->fk_attnums[i])"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"UPDATE %s%s SET\"",
            "fk_only",
            "fkrelname"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "fkrelname",
            "fk_rel"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&qualbuf"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_SETDEFAULT_DOUPDATE"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_KeysEqual",
          "args": [
            "pk_rel",
            "old_row",
            "new_row",
            "riinfo",
            "true"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "ri_KeysEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2976-3025",
          "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_UPDATE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "riinfo->fk_relid",
            "RowExclusiveLock"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigdata->tg_trigger",
            "trigdata->tg_relation",
            "true"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_SETDEFAULT_DOUPDATE\t\t7\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_setdefault(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET DEFAULT\n\t\t\t *\tGeneral rules 10) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET DEFAULT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set default operation\n\t\t\t * (it's the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETDEFAULT_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = DEFAULT [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = DEFAULT\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\t/*\n\t\t\t * If we just deleted or updated the PK row whose key was equal to\n\t\t\t * the FK columns' default values, and a referencing row exists in\n\t\t\t * the FK table, we would have updated that row to the same values\n\t\t\t * it already had --- and RI_FKey_fk_upd_check_required would\n\t\t\t * hence believe no check is necessary.  So we need to do another\n\t\t\t * lookup now and in case a reference still exists, abort the\n\t\t\t * operation.  That is already implemented in the NO ACTION\n\t\t\t * trigger, so just run it.  (This recheck is only needed in the\n\t\t\t * SET DEFAULT case, since CASCADE would remove such rows in case\n\t\t\t * of a DELETE operation or would change the FK key values in case\n\t\t\t * of an UPDATE, while SET NULL is certain to result in rows that\n\t\t\t * satisfy the FK constraint.)\n\t\t\t */\n\t\t\treturn ri_restrict(trigdata, true);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set default delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
  },
  {
    "function_name": "RI_FKey_setdefault_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1459-1471",
    "snippet": "Datum\nRI_FKey_setdefault_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setdefault_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with DELETE case\n\t */\n\treturn ri_setdefault((TriggerData *) fcinfo->context);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_UPDATE 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_setdefault",
          "args": [
            "(TriggerData *) fcinfo->context"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ri_setdefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "1479-1665",
          "snippet": "static Datum\nri_setdefault(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET DEFAULT\n\t\t\t *\tGeneral rules 10) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET DEFAULT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set default operation\n\t\t\t * (it's the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETDEFAULT_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = DEFAULT [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = DEFAULT\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\t/*\n\t\t\t * If we just deleted or updated the PK row whose key was equal to\n\t\t\t * the FK columns' default values, and a referencing row exists in\n\t\t\t * the FK table, we would have updated that row to the same values\n\t\t\t * it already had --- and RI_FKey_fk_upd_check_required would\n\t\t\t * hence believe no check is necessary.  So we need to do another\n\t\t\t * lookup now and in case a reference still exists, abort the\n\t\t\t * operation.  That is already implemented in the NO ACTION\n\t\t\t * trigger, so just run it.  (This recheck is only needed in the\n\t\t\t * SET DEFAULT case, since CASCADE would remove such rows in case\n\t\t\t * of a DELETE operation or would change the FK key values in case\n\t\t\t * of an UPDATE, while SET NULL is certain to result in rows that\n\t\t\t * satisfy the FK constraint.)\n\t\t\t */\n\t\t\treturn ri_restrict(trigdata, true);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set default delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_SETDEFAULT_DOUPDATE\t\t7",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_SETDEFAULT_DOUPDATE\t\t7\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_setdefault(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET DEFAULT\n\t\t\t *\tGeneral rules 10) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET DEFAULT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set default operation\n\t\t\t * (it's the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETDEFAULT_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = DEFAULT [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = DEFAULT\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\t/*\n\t\t\t * If we just deleted or updated the PK row whose key was equal to\n\t\t\t * the FK columns' default values, and a referencing row exists in\n\t\t\t * the FK table, we would have updated that row to the same values\n\t\t\t * it already had --- and RI_FKey_fk_upd_check_required would\n\t\t\t * hence believe no check is necessary.  So we need to do another\n\t\t\t * lookup now and in case a reference still exists, abort the\n\t\t\t * operation.  That is already implemented in the NO ACTION\n\t\t\t * trigger, so just run it.  (This recheck is only needed in the\n\t\t\t * SET DEFAULT case, since CASCADE would remove such rows in case\n\t\t\t * of a DELETE operation or would change the FK key values in case\n\t\t\t * of an UPDATE, while SET NULL is certain to result in rows that\n\t\t\t * satisfy the FK constraint.)\n\t\t\t */\n\t\t\treturn ri_restrict(trigdata, true);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set default delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_setdefault_upd\"",
            "RI_TRIGTYPE_UPDATE"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n\nDatum\nRI_FKey_setdefault_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setdefault_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with DELETE case\n\t */\n\treturn ri_setdefault((TriggerData *) fcinfo->context);\n}"
  },
  {
    "function_name": "RI_FKey_setdefault_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1439-1451",
    "snippet": "Datum\nRI_FKey_setdefault_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setdefault_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with UPDATE case\n\t */\n\treturn ri_setdefault((TriggerData *) fcinfo->context);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_DELETE 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_setdefault",
          "args": [
            "(TriggerData *) fcinfo->context"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "ri_setdefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "1479-1665",
          "snippet": "static Datum\nri_setdefault(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET DEFAULT\n\t\t\t *\tGeneral rules 10) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET DEFAULT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set default operation\n\t\t\t * (it's the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETDEFAULT_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = DEFAULT [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = DEFAULT\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\t/*\n\t\t\t * If we just deleted or updated the PK row whose key was equal to\n\t\t\t * the FK columns' default values, and a referencing row exists in\n\t\t\t * the FK table, we would have updated that row to the same values\n\t\t\t * it already had --- and RI_FKey_fk_upd_check_required would\n\t\t\t * hence believe no check is necessary.  So we need to do another\n\t\t\t * lookup now and in case a reference still exists, abort the\n\t\t\t * operation.  That is already implemented in the NO ACTION\n\t\t\t * trigger, so just run it.  (This recheck is only needed in the\n\t\t\t * SET DEFAULT case, since CASCADE would remove such rows in case\n\t\t\t * of a DELETE operation or would change the FK key values in case\n\t\t\t * of an UPDATE, while SET NULL is certain to result in rows that\n\t\t\t * satisfy the FK constraint.)\n\t\t\t */\n\t\t\treturn ri_restrict(trigdata, true);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set default delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_SETDEFAULT_DOUPDATE\t\t7",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_SETDEFAULT_DOUPDATE\t\t7\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_setdefault(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET DEFAULT\n\t\t\t *\tGeneral rules 10) a) iii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET DEFAULT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set default operation\n\t\t\t * (it's the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETDEFAULT_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = DEFAULT [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = DEFAULT\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\t/*\n\t\t\t * If we just deleted or updated the PK row whose key was equal to\n\t\t\t * the FK columns' default values, and a referencing row exists in\n\t\t\t * the FK table, we would have updated that row to the same values\n\t\t\t * it already had --- and RI_FKey_fk_upd_check_required would\n\t\t\t * hence believe no check is necessary.  So we need to do another\n\t\t\t * lookup now and in case a reference still exists, abort the\n\t\t\t * operation.  That is already implemented in the NO ACTION\n\t\t\t * trigger, so just run it.  (This recheck is only needed in the\n\t\t\t * SET DEFAULT case, since CASCADE would remove such rows in case\n\t\t\t * of a DELETE operation or would change the FK key values in case\n\t\t\t * of an UPDATE, while SET NULL is certain to result in rows that\n\t\t\t * satisfy the FK constraint.)\n\t\t\t */\n\t\t\treturn ri_restrict(trigdata, true);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set default delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_setdefault_del\"",
            "RI_TRIGTYPE_DELETE"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n\nDatum\nRI_FKey_setdefault_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setdefault_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with UPDATE case\n\t */\n\treturn ri_setdefault((TriggerData *) fcinfo->context);\n}"
  },
  {
    "function_name": "ri_setnull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1258-1430",
    "snippet": "static Datum\nri_setnull(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET NULL\n\t\t\t *\tGeneral rules 10) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET NULL\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set null operation (it's\n\t\t\t * the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETNULL_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tconst char *fk_only;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = NULL [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = NULL\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set null delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_SETNULL_DOUPDATE\t\t6",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "old_row",
            "NULL",
            "true",
            "/* must detect new rows */SPI_OK_UPDATE"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "qualbuf.data"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&qualbuf",
            "qualsep",
            "paramname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "attname",
            "fk_type"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "i + 1"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"%s %s = NULL\"",
            "querysep",
            "attname"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(fk_rel, riinfo->fk_attnums[i])"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"UPDATE %s%s SET\"",
            "fk_only",
            "fkrelname"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "fkrelname",
            "fk_rel"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&qualbuf"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_SETNULL_DOUPDATE"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_KeysEqual",
          "args": [
            "pk_rel",
            "old_row",
            "new_row",
            "riinfo",
            "true"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ri_KeysEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2976-3025",
          "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_UPDATE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "riinfo->fk_relid",
            "RowExclusiveLock"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigdata->tg_trigger",
            "trigdata->tg_relation",
            "true"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_SETNULL_DOUPDATE\t\t6\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_setnull(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET NULL\n\t\t\t *\tGeneral rules 10) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET NULL\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set null operation (it's\n\t\t\t * the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETNULL_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tconst char *fk_only;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = NULL [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = NULL\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set null delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
  },
  {
    "function_name": "RI_FKey_setnull_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1238-1250",
    "snippet": "Datum\nRI_FKey_setnull_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setnull_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with DELETE case\n\t */\n\treturn ri_setnull((TriggerData *) fcinfo->context);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_UPDATE 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_setnull",
          "args": [
            "(TriggerData *) fcinfo->context"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "ri_setnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "1258-1430",
          "snippet": "static Datum\nri_setnull(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET NULL\n\t\t\t *\tGeneral rules 10) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET NULL\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set null operation (it's\n\t\t\t * the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETNULL_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tconst char *fk_only;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = NULL [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = NULL\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set null delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_SETNULL_DOUPDATE\t\t6",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_SETNULL_DOUPDATE\t\t6\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_setnull(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET NULL\n\t\t\t *\tGeneral rules 10) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET NULL\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set null operation (it's\n\t\t\t * the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETNULL_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tconst char *fk_only;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = NULL [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = NULL\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set null delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_setnull_upd\"",
            "RI_TRIGTYPE_UPDATE"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n\nDatum\nRI_FKey_setnull_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setnull_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with DELETE case\n\t */\n\treturn ri_setnull((TriggerData *) fcinfo->context);\n}"
  },
  {
    "function_name": "RI_FKey_setnull_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1218-1230",
    "snippet": "Datum\nRI_FKey_setnull_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setnull_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with UPDATE case\n\t */\n\treturn ri_setnull((TriggerData *) fcinfo->context);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_DELETE 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_setnull",
          "args": [
            "(TriggerData *) fcinfo->context"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ri_setnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "1258-1430",
          "snippet": "static Datum\nri_setnull(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET NULL\n\t\t\t *\tGeneral rules 10) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET NULL\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set null operation (it's\n\t\t\t * the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETNULL_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tconst char *fk_only;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = NULL [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = NULL\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set null delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_SETNULL_DOUPDATE\t\t6",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_SETNULL_DOUPDATE\t\t6\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_setnull(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE SET NULL\n\t\t\t *\tGeneral rules 10) a) ii):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE SET NULL\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the set null operation (it's\n\t\t\t * the same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_SETNULL_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tconst char *fk_only;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = NULL [, ...]\n\t\t\t\t *\t\t\tWHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = NULL\",\n\t\t\t\t\t\t\t\t\t querysep, attname);\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL set null delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_setnull_del\"",
            "RI_TRIGTYPE_DELETE"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n\nDatum\nRI_FKey_setnull_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_setnull_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with UPDATE case\n\t */\n\treturn ri_setnull((TriggerData *) fcinfo->context);\n}"
  },
  {
    "function_name": "RI_FKey_cascade_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "1033-1209",
    "snippet": "Datum\nRI_FKey_cascade_upd(PG_FUNCTION_ARGS)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\tnew_row;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_cascade_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the new and\n\t * old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\tnew_row = trigdata->tg_newtuple;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 10) a) i):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE CASCADE\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * No need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the cascaded update\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CASCADE_UPD_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS * 2];\n\t\t\t\tconst char *fk_only;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = $1 [, ...]\n\t\t\t\t *\t\t\tWHERE $n = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.  Note that we are assuming\n\t\t\t\t * there is an assignment cast from the PK to the FK type;\n\t\t\t\t * else the parser will fail.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0, j = riinfo->nkeys; i < riinfo->nkeys; i++, j++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = $%d\",\n\t\t\t\t\t\t\t\t\t querysep, attname, i + 1);\n\t\t\t\t\tsprintf(paramname, \"$%d\", j + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t\tqueryoids[j] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys * 2, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, new_row,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL cascade update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_UPDATE 2",
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_CASCADE_UPD_DOUPDATE\t4",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "old_row",
            "new_row",
            "true",
            "/* must detect new rows */SPI_OK_UPDATE"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys * 2",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "qualbuf.data"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&qualbuf",
            "qualsep",
            "paramname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "attname",
            "fk_type"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "j + 1"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"%s %s = $%d\"",
            "querysep",
            "attname",
            "i + 1"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(fk_rel, riinfo->fk_attnums[i])"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"UPDATE %s%s SET\"",
            "fk_only",
            "fkrelname"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "fkrelname",
            "fk_rel"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&qualbuf"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_CASCADE_UPD_DOUPDATE"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_KeysEqual",
          "args": [
            "pk_rel",
            "old_row",
            "new_row",
            "riinfo",
            "true"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ri_KeysEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2976-3025",
          "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "riinfo->fk_relid",
            "RowExclusiveLock"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigdata->tg_trigger",
            "trigdata->tg_relation",
            "true"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_cascade_upd\"",
            "RI_TRIGTYPE_UPDATE"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_CASCADE_UPD_DOUPDATE\t4\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nDatum\nRI_FKey_cascade_upd(PG_FUNCTION_ARGS)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\tnew_row;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_cascade_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the new and\n\t * old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual UPDATE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\tnew_row = trigdata->tg_newtuple;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 10) a) i):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE CASCADE\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * No need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the cascaded update\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CASCADE_UPD_DOUPDATE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tStringInfoData qualbuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tconst char *qualsep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS * 2];\n\t\t\t\tconst char *fk_only;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tUPDATE [ONLY] <fktable> SET fkatt1 = $1 [, ...]\n\t\t\t\t *\t\t\tWHERE $n = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.  Note that we are assuming\n\t\t\t\t * there is an assignment cast from the PK to the FK type;\n\t\t\t\t * else the parser will fail.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tinitStringInfo(&qualbuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"UPDATE %s%s SET\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"\";\n\t\t\t\tqualsep = \"WHERE\";\n\t\t\t\tfor (i = 0, j = riinfo->nkeys; i < riinfo->nkeys; i++, j++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tappendStringInfo(&querybuf,\n\t\t\t\t\t\t\t\t\t \"%s %s = $%d\",\n\t\t\t\t\t\t\t\t\t querysep, attname, i + 1);\n\t\t\t\t\tsprintf(paramname, \"$%d\", j + 1);\n\t\t\t\t\tri_GenerateQual(&qualbuf, qualsep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \",\";\n\t\t\t\t\tqualsep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t\tqueryoids[j] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, qualbuf.data);\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys * 2, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to update the existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, new_row,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_UPDATE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL cascade update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
  },
  {
    "function_name": "RI_FKey_cascade_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "873-1024",
    "snippet": "Datum\nRI_FKey_cascade_del(PG_FUNCTION_ARGS)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_cascade_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual DELETE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) i):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE CASCADE\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the cascaded delete\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CASCADE_DEL_DODELETE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tDELETE FROM [ONLY] <fktable> WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"DELETE FROM %s%s\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Build up the arguments from the key values\n\t\t\t * in the deleted PK tuple and delete the referencing rows\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_DELETE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL cascaded delete.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_DELETE 3",
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_CASCADE_DEL_DODELETE\t3",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "old_row",
            "NULL",
            "true",
            "/* must detect new rows */SPI_OK_DELETE"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&querybuf",
            "querysep",
            "paramname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "attname",
            "fk_type"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "i + 1"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(fk_rel, riinfo->fk_attnums[i])"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"DELETE FROM %s%s\"",
            "fk_only",
            "fkrelname"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "fkrelname",
            "fk_rel"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_CASCADE_DEL_DODELETE"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowExclusiveLock"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "riinfo->fk_relid",
            "RowExclusiveLock"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigdata->tg_trigger",
            "trigdata->tg_relation",
            "true"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_cascade_del\"",
            "RI_TRIGTYPE_DELETE"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_CASCADE_DEL_DODELETE\t3\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nDatum\nRI_FKey_cascade_del(PG_FUNCTION_ARGS)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_cascade_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowExclusiveLock mode since that's what our\n\t * eventual DELETE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowExclusiveLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) i):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE CASCADE\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowExclusiveLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the cascaded delete\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CASCADE_DEL_DODELETE);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tDELETE FROM [ONLY] <fktable> WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"DELETE FROM %s%s\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Build up the arguments from the key values\n\t\t\t * in the deleted PK tuple and delete the referencing rows\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_DELETE);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowExclusiveLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL cascaded delete.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
  },
  {
    "function_name": "ri_restrict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "687-864",
    "snippet": "static Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_RESTRICT_CHECKREF\t\t5",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static Datum ri_restrict(TriggerData *trigdata, bool is_no_action);",
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized confmatchtype: %d\"",
            "riinfo->confmatchtype"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowShareLock"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "old_row",
            "NULL",
            "true",
            "/* must detect new rows */SPI_OK_SELECT"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "\" FOR KEY SHARE OF x\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&querybuf",
            "querysep",
            "paramname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "attname",
            "fk_type"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "i + 1"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(fk_rel, riinfo->fk_attnums[i])"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"SELECT 1 FROM %s%s x\"",
            "fk_only",
            "fkrelname"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "fkrelname",
            "fk_rel"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_RESTRICT_CHECKREF"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowShareLock"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_Check_Pk_Match",
          "args": [
            "pk_rel",
            "fk_rel",
            "old_row",
            "riinfo"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ri_Check_Pk_Match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "506-583",
          "snippet": "static bool\nri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo)\n{\n\tSPIPlanPtr\tqplan;\n\tRI_QueryKey qkey;\n\tint\t\t\ti;\n\tbool\t\tresult;\n\n\t/* Only called for non-null rows */\n\tAssert(ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) == RI_KEYS_NONE_NULL);\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Fetch or prepare a saved plan for checking PK table with values coming\n\t * from a PK row\n\t */\n\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CHECK_LOOKUPPK_FROM_PK);\n\n\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t{\n\t\tStringInfoData querybuf;\n\t\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\tchar\t\tparamname[16];\n\t\tconst char *querysep;\n\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t/* ----------\n\t\t * The query string built is\n\t\t *\tSELECT 1 FROM ONLY <pktable> x WHERE pkatt1 = $1 [AND ...]\n\t\t *\t\t   FOR KEY SHARE OF x\n\t\t * The type id's for the $ parameters are those of the\n\t\t * PK attributes themselves.\n\t\t * ----------\n\t\t */\n\t\tinitStringInfo(&querybuf);\n\t\tquoteRelationName(pkrelname, pk_rel);\n\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM ONLY %s x\", pkrelname);\n\t\tquerysep = \"WHERE\";\n\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t{\n\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\n\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\tattname, pk_type,\n\t\t\t\t\t\t\triinfo->pp_eq_oprs[i],\n\t\t\t\t\t\t\tparamname, pk_type);\n\t\t\tquerysep = \"AND\";\n\t\t\tqueryoids[i] = pk_type;\n\t\t}\n\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t/* Prepare and save the plan */\n\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t}\n\n\t/*\n\t * We have a plan now. Run it.\n\t */\n\tresult = ri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\t fk_rel, pk_rel,\n\t\t\t\t\t\t\t old_row, NULL,\n\t\t\t\t\t\t\t true,\t/* treat like update */\n\t\t\t\t\t\t\t SPI_OK_SELECT);\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic bool\nri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo)\n{\n\tSPIPlanPtr\tqplan;\n\tRI_QueryKey qkey;\n\tint\t\t\ti;\n\tbool\t\tresult;\n\n\t/* Only called for non-null rows */\n\tAssert(ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) == RI_KEYS_NONE_NULL);\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Fetch or prepare a saved plan for checking PK table with values coming\n\t * from a PK row\n\t */\n\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CHECK_LOOKUPPK_FROM_PK);\n\n\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t{\n\t\tStringInfoData querybuf;\n\t\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\tchar\t\tparamname[16];\n\t\tconst char *querysep;\n\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t/* ----------\n\t\t * The query string built is\n\t\t *\tSELECT 1 FROM ONLY <pktable> x WHERE pkatt1 = $1 [AND ...]\n\t\t *\t\t   FOR KEY SHARE OF x\n\t\t * The type id's for the $ parameters are those of the\n\t\t * PK attributes themselves.\n\t\t * ----------\n\t\t */\n\t\tinitStringInfo(&querybuf);\n\t\tquoteRelationName(pkrelname, pk_rel);\n\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM ONLY %s x\", pkrelname);\n\t\tquerysep = \"WHERE\";\n\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t{\n\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\n\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\tattname, pk_type,\n\t\t\t\t\t\t\triinfo->pp_eq_oprs[i],\n\t\t\t\t\t\t\tparamname, pk_type);\n\t\t\tquerysep = \"AND\";\n\t\t\tqueryoids[i] = pk_type;\n\t\t}\n\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t/* Prepare and save the plan */\n\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t}\n\n\t/*\n\t * We have a plan now. Run it.\n\t */\n\tresult = ri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\t fk_rel, pk_rel,\n\t\t\t\t\t\t\t old_row, NULL,\n\t\t\t\t\t\t\t true,\t/* treat like update */\n\t\t\t\t\t\t\t SPI_OK_SELECT);\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowShareLock"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_KeysEqual",
          "args": [
            "pk_rel",
            "old_row",
            "new_row",
            "riinfo",
            "true"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ri_KeysEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2976-3025",
          "snippet": "static bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void quoteRelationName(char *buffer, Relation rel);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void quoteRelationName(char *buffer, Relation rel);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_AttributesEqual(Oid eq_opr, Oid typeid,\n\t\t\t\t   Datum oldvalue, Datum newvalue);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic bool\nri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tTupleDesc\ttupdesc = RelationGetDescr(rel);\n\tconst int16 *attnums;\n\tconst Oid  *eq_oprs;\n\tint\t\t\ti;\n\n\tif (rel_is_pk)\n\t{\n\t\tattnums = riinfo->pk_attnums;\n\t\teq_oprs = riinfo->pp_eq_oprs;\n\t}\n\telse\n\t{\n\t\tattnums = riinfo->fk_attnums;\n\t\teq_oprs = riinfo->ff_eq_oprs;\n\t}\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tDatum\t\toldvalue;\n\t\tDatum\t\tnewvalue;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Get one attribute's oldvalue. If it is NULL - they're not equal.\n\t\t */\n\t\toldvalue = heap_getattr(oldtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Get one attribute's newvalue. If it is NULL - they're not equal.\n\t\t */\n\t\tnewvalue = heap_getattr(newtup, attnums[i], tupdesc, &isnull);\n\t\tif (isnull)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Compare them with the appropriate equality operator.\n\t\t */\n\t\tif (!ri_AttributesEqual(eq_oprs[i], RIAttType(rel, attnums[i]),\n\t\t\t\t\t\t\t\toldvalue, newvalue))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_UPDATE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "fk_rel",
            "RowShareLock"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "riinfo->fk_relid",
            "RowShareLock"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigdata->tg_trigger",
            "trigdata->tg_relation",
            "true"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_RESTRICT_CHECKREF\t\t5\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_restrict(TriggerData *trigdata, bool is_no_action);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
  },
  {
    "function_name": "RI_FKey_restrict_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "666-678",
    "snippet": "Datum\nRI_FKey_restrict_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_restrict_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with NO ACTION/DELETE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, false);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_UPDATE 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_restrict",
          "args": [
            "(TriggerData *) fcinfo->context",
            "false"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ri_restrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "687-864",
          "snippet": "static Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_RESTRICT_CHECKREF\t\t5",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_restrict(TriggerData *trigdata, bool is_no_action);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_RESTRICT_CHECKREF\t\t5\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_restrict(TriggerData *trigdata, bool is_no_action);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_restrict_upd\"",
            "RI_TRIGTYPE_UPDATE"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n\nDatum\nRI_FKey_restrict_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_restrict_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with NO ACTION/DELETE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, false);\n}"
  },
  {
    "function_name": "RI_FKey_noaction_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "641-653",
    "snippet": "Datum\nRI_FKey_noaction_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_noaction_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with RESTRICT/DELETE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, true);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_UPDATE 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_restrict",
          "args": [
            "(TriggerData *) fcinfo->context",
            "true"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ri_restrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "687-864",
          "snippet": "static Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_RESTRICT_CHECKREF\t\t5",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_restrict(TriggerData *trigdata, bool is_no_action);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_RESTRICT_CHECKREF\t\t5\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_restrict(TriggerData *trigdata, bool is_no_action);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_noaction_upd\"",
            "RI_TRIGTYPE_UPDATE"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n\nDatum\nRI_FKey_noaction_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_noaction_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with RESTRICT/DELETE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, true);\n}"
  },
  {
    "function_name": "RI_FKey_restrict_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "619-631",
    "snippet": "Datum\nRI_FKey_restrict_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_restrict_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with NO ACTION/UPDATE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, false);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_DELETE 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_restrict",
          "args": [
            "(TriggerData *) fcinfo->context",
            "false"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ri_restrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "687-864",
          "snippet": "static Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_RESTRICT_CHECKREF\t\t5",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_restrict(TriggerData *trigdata, bool is_no_action);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_RESTRICT_CHECKREF\t\t5\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_restrict(TriggerData *trigdata, bool is_no_action);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_restrict_del\"",
            "RI_TRIGTYPE_DELETE"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n\nDatum\nRI_FKey_restrict_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_restrict_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with NO ACTION/UPDATE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, false);\n}"
  },
  {
    "function_name": "RI_FKey_noaction_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "594-606",
    "snippet": "Datum\nRI_FKey_noaction_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_noaction_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with RESTRICT/UPDATE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, true);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_DELETE 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ri_restrict",
          "args": [
            "(TriggerData *) fcinfo->context",
            "true"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ri_restrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "687-864",
          "snippet": "static Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
            "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
            "#define RI_PLAN_RESTRICT_CHECKREF\t\t5",
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static Datum ri_restrict(TriggerData *trigdata, bool is_no_action);",
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_RESTRICT_CHECKREF\t\t5\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_restrict(TriggerData *trigdata, bool is_no_action);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nri_restrict(TriggerData *trigdata, bool is_no_action)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\told_row;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, true);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables and the old tuple.\n\t *\n\t * fk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = heap_open(riinfo->fk_relid, RowShareLock);\n\tpk_rel = trigdata->tg_relation;\n\told_row = trigdata->tg_trigtuple;\n\n\tswitch (riinfo->confmatchtype)\n\t{\n\t\t\t/* ----------\n\t\t\t * SQL:2008 15.17 <Execution of referential actions>\n\t\t\t *\tGeneral rules 9) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON DELETE RESTRICT\n\t\t\t *\tGeneral rules 10) a) iv):\n\t\t\t *\t\tMATCH SIMPLE/FULL\n\t\t\t *\t\t\t... ON UPDATE RESTRICT\n\t\t\t * ----------\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_SIMPLE:\n\t\tcase FKCONSTR_MATCH_FULL:\n\t\t\tswitch (ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true))\n\t\t\t{\n\t\t\t\tcase RI_KEYS_ALL_NULL:\n\t\t\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * No check needed - there cannot be any reference to old\n\t\t\t\t\t * key if it contains a NULL\n\t\t\t\t\t */\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Have a full qualified key - continue below\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In UPDATE, no need to do anything if old and new keys are equal\n\t\t\t */\n\t\t\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t{\n\t\t\t\tHeapTuple\tnew_row = trigdata->tg_newtuple;\n\n\t\t\t\tif (ri_KeysEqual(pk_rel, old_row, new_row, riinfo, true))\n\t\t\t\t{\n\t\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If another PK row now exists providing the old key values, we\n\t\t\t * should not do anything.  However, this check should only be\n\t\t\t * made in the NO ACTION case; in RESTRICT cases we don't wish to\n\t\t\t * allow another row to be substituted.\n\t\t\t */\n\t\t\tif (is_no_action &&\n\t\t\t\tri_Check_Pk_Match(pk_rel, fk_rel, old_row, riinfo))\n\t\t\t{\n\t\t\t\theap_close(fk_rel, RowShareLock);\n\t\t\t\treturn PointerGetDatum(NULL);\n\t\t\t}\n\n\t\t\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\t\t\telog(ERROR, \"SPI_connect failed\");\n\n\t\t\t/*\n\t\t\t * Fetch or prepare a saved plan for the restrict lookup (it's the\n\t\t\t * same query for delete and update cases)\n\t\t\t */\n\t\t\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_RESTRICT_CHECKREF);\n\n\t\t\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t\t\t{\n\t\t\t\tStringInfoData querybuf;\n\t\t\t\tchar\t\tfkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\t\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\t\t\tchar\t\tparamname[16];\n\t\t\t\tconst char *querysep;\n\t\t\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\t\t\t\tconst char *fk_only;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/* ----------\n\t\t\t\t * The query string built is\n\t\t\t\t *\tSELECT 1 FROM [ONLY] <fktable> x WHERE $1 = fkatt1 [AND ...]\n\t\t\t\t *\t\t   FOR KEY SHARE OF x\n\t\t\t\t * The type id's for the $ parameters are those of the\n\t\t\t\t * corresponding PK attributes.\n\t\t\t\t * ----------\n\t\t\t\t */\n\t\t\t\tinitStringInfo(&querybuf);\n\t\t\t\tfk_only = fk_rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE ?\n\t\t\t\t\t\"\" : \"ONLY \";\n\t\t\t\tquoteRelationName(fkrelname, fk_rel);\n\t\t\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM %s%s x\",\n\t\t\t\t\t\t\t\t fk_only, fkrelname);\n\t\t\t\tquerysep = \"WHERE\";\n\t\t\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t\t\t RIAttName(fk_rel, riinfo->fk_attnums[i]));\n\t\t\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\t\t\tparamname, pk_type,\n\t\t\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\t\t\tattname, fk_type);\n\t\t\t\t\tquerysep = \"AND\";\n\t\t\t\t\tqueryoids[i] = pk_type;\n\t\t\t\t}\n\t\t\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t\t\t/* Prepare and save the plan */\n\t\t\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have a plan now. Run it to check for existing references.\n\t\t\t */\n\t\t\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\t\t\told_row, NULL,\n\t\t\t\t\t\t\ttrue,\t/* must detect new rows */\n\t\t\t\t\t\t\tSPI_OK_SELECT);\n\n\t\t\tif (SPI_finish() != SPI_OK_FINISH)\n\t\t\t\telog(ERROR, \"SPI_finish failed\");\n\n\t\t\theap_close(fk_rel, RowShareLock);\n\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t/*\n\t\t\t * Handle MATCH PARTIAL restrict delete or update.\n\t\t\t */\n\t\tcase FKCONSTR_MATCH_PARTIAL:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t riinfo->confmatchtype);\n\t\t\tbreak;\n\t}\n\n\t/* Never reached */\n\treturn PointerGetDatum(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_noaction_del\"",
            "RI_TRIGTYPE_DELETE"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n\nDatum\nRI_FKey_noaction_del(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_noaction_del\", RI_TRIGTYPE_DELETE);\n\n\t/*\n\t * Share code with RESTRICT/UPDATE cases.\n\t */\n\treturn ri_restrict((TriggerData *) fcinfo->context, true);\n}"
  },
  {
    "function_name": "ri_Check_Pk_Match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "506-583",
    "snippet": "static bool\nri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo)\n{\n\tSPIPlanPtr\tqplan;\n\tRI_QueryKey qkey;\n\tint\t\t\ti;\n\tbool\t\tresult;\n\n\t/* Only called for non-null rows */\n\tAssert(ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) == RI_KEYS_NONE_NULL);\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Fetch or prepare a saved plan for checking PK table with values coming\n\t * from a PK row\n\t */\n\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CHECK_LOOKUPPK_FROM_PK);\n\n\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t{\n\t\tStringInfoData querybuf;\n\t\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\tchar\t\tparamname[16];\n\t\tconst char *querysep;\n\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t/* ----------\n\t\t * The query string built is\n\t\t *\tSELECT 1 FROM ONLY <pktable> x WHERE pkatt1 = $1 [AND ...]\n\t\t *\t\t   FOR KEY SHARE OF x\n\t\t * The type id's for the $ parameters are those of the\n\t\t * PK attributes themselves.\n\t\t * ----------\n\t\t */\n\t\tinitStringInfo(&querybuf);\n\t\tquoteRelationName(pkrelname, pk_rel);\n\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM ONLY %s x\", pkrelname);\n\t\tquerysep = \"WHERE\";\n\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t{\n\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\n\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\tattname, pk_type,\n\t\t\t\t\t\t\triinfo->pp_eq_oprs[i],\n\t\t\t\t\t\t\tparamname, pk_type);\n\t\t\tquerysep = \"AND\";\n\t\t\tqueryoids[i] = pk_type;\n\t\t}\n\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t/* Prepare and save the plan */\n\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t}\n\n\t/*\n\t * We have a plan now. Run it.\n\t */\n\tresult = ri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\t fk_rel, pk_rel,\n\t\t\t\t\t\t\t old_row, NULL,\n\t\t\t\t\t\t\t true,\t/* treat like update */\n\t\t\t\t\t\t\t SPI_OK_SELECT);\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_finish failed\""
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "old_row",
            "NULL",
            "true",
            "/* treat like update */SPI_OK_SELECT"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "\" FOR KEY SHARE OF x\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&querybuf",
            "querysep",
            "attname",
            "pk_type",
            "riinfo->pp_eq_oprs[i]",
            "paramname",
            "pk_type"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "i + 1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(pk_rel, riinfo->pk_attnums[i])"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"SELECT 1 FROM ONLY %s x\"",
            "pkrelname"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "pkrelname",
            "pk_rel"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) == RI_KEYS_NONE_NULL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(pk_rel)",
            "old_row",
            "riinfo",
            "true"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "pk_rel"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic bool\nri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo)\n{\n\tSPIPlanPtr\tqplan;\n\tRI_QueryKey qkey;\n\tint\t\t\ti;\n\tbool\t\tresult;\n\n\t/* Only called for non-null rows */\n\tAssert(ri_NullCheck(RelationGetDescr(pk_rel), old_row, riinfo, true) == RI_KEYS_NONE_NULL);\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Fetch or prepare a saved plan for checking PK table with values coming\n\t * from a PK row\n\t */\n\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CHECK_LOOKUPPK_FROM_PK);\n\n\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t{\n\t\tStringInfoData querybuf;\n\t\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\tchar\t\tparamname[16];\n\t\tconst char *querysep;\n\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t/* ----------\n\t\t * The query string built is\n\t\t *\tSELECT 1 FROM ONLY <pktable> x WHERE pkatt1 = $1 [AND ...]\n\t\t *\t\t   FOR KEY SHARE OF x\n\t\t * The type id's for the $ parameters are those of the\n\t\t * PK attributes themselves.\n\t\t * ----------\n\t\t */\n\t\tinitStringInfo(&querybuf);\n\t\tquoteRelationName(pkrelname, pk_rel);\n\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM ONLY %s x\", pkrelname);\n\t\tquerysep = \"WHERE\";\n\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t{\n\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\n\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\tattname, pk_type,\n\t\t\t\t\t\t\triinfo->pp_eq_oprs[i],\n\t\t\t\t\t\t\tparamname, pk_type);\n\t\t\tquerysep = \"AND\";\n\t\t\tqueryoids[i] = pk_type;\n\t\t}\n\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t/* Prepare and save the plan */\n\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t}\n\n\t/*\n\t * We have a plan now. Run it.\n\t */\n\tresult = ri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\t\t\t fk_rel, pk_rel,\n\t\t\t\t\t\t\t old_row, NULL,\n\t\t\t\t\t\t\t true,\t/* treat like update */\n\t\t\t\t\t\t\t SPI_OK_SELECT);\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\treturn result;\n}"
  },
  {
    "function_name": "RI_FKey_check_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "480-492",
    "snippet": "Datum\nRI_FKey_check_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with INSERT case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_UPDATE 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RI_FKey_check",
          "args": [
            "(TriggerData *) fcinfo->context"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "RI_FKey_check_upd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "480-492",
          "snippet": "Datum\nRI_FKey_check_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with INSERT case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_check_upd\"",
            "RI_TRIGTYPE_UPDATE"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n\nDatum\nRI_FKey_check_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with INSERT case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}"
  },
  {
    "function_name": "RI_FKey_check_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "459-471",
    "snippet": "Datum\nRI_FKey_check_ins(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_ins\", RI_TRIGTYPE_INSERT);\n\n\t/*\n\t * Share code with UPDATE case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RI_TRIGTYPE_INSERT 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RI_FKey_check",
          "args": [
            "(TriggerData *) fcinfo->context"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "RI_FKey_check_upd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "480-492",
          "snippet": "Datum\nRI_FKey_check_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with INSERT case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_UPDATE 2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_UPDATE 2\n\nDatum\nRI_FKey_check_upd(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_upd\", RI_TRIGTYPE_UPDATE);\n\n\t/*\n\t * Share code with INSERT case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_CheckTrigger",
          "args": [
            "fcinfo",
            "\"RI_FKey_check_ins\"",
            "RI_TRIGTYPE_INSERT"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "ri_CheckTrigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2248-2288",
          "snippet": "static void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_TRIGTYPE_DELETE 3",
            "#define RI_TRIGTYPE_UPDATE 2",
            "#define RI_TRIGTYPE_INSERT 1"
          ],
          "globals_used": [
            "static Datum ri_setnull(TriggerData *trigdata);",
            "static Datum ri_setdefault(TriggerData *trigdata);",
            "static void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_DELETE 3\n#define RI_TRIGTYPE_UPDATE 2\n#define RI_TRIGTYPE_INSERT 1\n\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic void ri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tint tgkind);\n\nstatic void\nri_CheckTrigger(FunctionCallInfo fcinfo, const char *funcname, int tgkind)\n{\n\tTriggerData *trigdata = (TriggerData *) fcinfo->context;\n\n\tif (!CALLED_AS_TRIGGER(fcinfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" was not called by trigger manager\", funcname)));\n\n\t/*\n\t * Check proper event\n\t */\n\tif (!TRIGGER_FIRED_AFTER(trigdata->tg_event) ||\n\t\t!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired AFTER ROW\", funcname)));\n\n\tswitch (tgkind)\n\t{\n\t\tcase RI_TRIGTYPE_INSERT:\n\t\t\tif (!TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for INSERT\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_UPDATE:\n\t\t\tif (!TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for UPDATE\", funcname)));\n\t\t\tbreak;\n\t\tcase RI_TRIGTYPE_DELETE:\n\t\t\tif (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),\n\t\t\t\t\t\t errmsg(\"function \\\"%s\\\" must be fired for DELETE\", funcname)));\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_TRIGTYPE_INSERT 1\n\nDatum\nRI_FKey_check_ins(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * Check that this is a valid trigger call on the right time and event.\n\t */\n\tri_CheckTrigger(fcinfo, \"RI_FKey_check_ins\", RI_TRIGTYPE_INSERT);\n\n\t/*\n\t * Share code with UPDATE case.\n\t */\n\treturn RI_FKey_check((TriggerData *) fcinfo->context);\n}"
  },
  {
    "function_name": "RI_FKey_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
    "lines": "251-450",
    "snippet": "static Datum\nRI_FKey_check(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\tnew_row;\n\tBuffer\t\tnew_row_buf;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, false);\n\n\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t{\n\t\tnew_row = trigdata->tg_newtuple;\n\t\tnew_row_buf = trigdata->tg_newtuplebuf;\n\t}\n\telse\n\t{\n\t\tnew_row = trigdata->tg_trigtuple;\n\t\tnew_row_buf = trigdata->tg_trigtuplebuf;\n\t}\n\n\t/*\n\t * We should not even consider checking the row if it is no longer valid,\n\t * since it was either deleted (so the deferred check should be skipped)\n\t * or updated (in which case only the latest version of the row should be\n\t * checked).  Test its liveness according to SnapshotSelf.  We need pin\n\t * and lock on the buffer to call HeapTupleSatisfiesVisibility.  Caller\n\t * should be holding pin, but not lock.\n\t */\n\tLockBuffer(new_row_buf, BUFFER_LOCK_SHARE);\n\tif (!HeapTupleSatisfiesVisibility(new_row, SnapshotSelf, new_row_buf))\n\t{\n\t\tLockBuffer(new_row_buf, BUFFER_LOCK_UNLOCK);\n\t\treturn PointerGetDatum(NULL);\n\t}\n\tLockBuffer(new_row_buf, BUFFER_LOCK_UNLOCK);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables.\n\t *\n\t * pk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = trigdata->tg_relation;\n\tpk_rel = heap_open(riinfo->pk_relid, RowShareLock);\n\n\tif (riinfo->confmatchtype == FKCONSTR_MATCH_PARTIAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\n\tswitch (ri_NullCheck(RelationGetDescr(fk_rel), new_row, riinfo, false))\n\t{\n\t\tcase RI_KEYS_ALL_NULL:\n\n\t\t\t/*\n\t\t\t * No further check needed - an all-NULL key passes every type of\n\t\t\t * foreign key constraint.\n\t\t\t */\n\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t/*\n\t\t\t * This is the only case that differs between the three kinds of\n\t\t\t * MATCH.\n\t\t\t */\n\t\t\tswitch (riinfo->confmatchtype)\n\t\t\t{\n\t\t\t\tcase FKCONSTR_MATCH_FULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Not allowed - MATCH FULL says either all or none of the\n\t\t\t\t\t * attributes can be NULLs\n\t\t\t\t\t */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t\t\t\t errdetail(\"MATCH FULL does not allow mixing of null and nonnull key values.\"),\n\t\t\t\t\t\t\t errtableconstraint(fk_rel,\n\t\t\t\t\t\t\t\t\t\t\t\tNameStr(riinfo->conname))));\n\t\t\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase FKCONSTR_MATCH_SIMPLE:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * MATCH SIMPLE - if ANY column is null, the key passes\n\t\t\t\t\t * the constraint.\n\t\t\t\t\t */\n\t\t\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase FKCONSTR_MATCH_PARTIAL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * MATCH PARTIAL - all non-null columns must match. (not\n\t\t\t\t\t * implemented, can be done by modifying the query below\n\t\t\t\t\t * to only include non-null columns, or by writing a\n\t\t\t\t\t * special version here)\n\t\t\t\t\t */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t\t\t riinfo->confmatchtype);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t/*\n\t\t\t * Have a full qualified key - continue below for all three kinds\n\t\t\t * of MATCH.\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Fetch or prepare a saved plan for the real check\n\t */\n\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CHECK_LOOKUPPK);\n\n\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t{\n\t\tStringInfoData querybuf;\n\t\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\tchar\t\tparamname[16];\n\t\tconst char *querysep;\n\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t/* ----------\n\t\t * The query string built is\n\t\t *\tSELECT 1 FROM ONLY <pktable> x WHERE pkatt1 = $1 [AND ...]\n\t\t *\t\t   FOR KEY SHARE OF x\n\t\t * The type id's for the $ parameters are those of the\n\t\t * corresponding FK attributes.\n\t\t * ----------\n\t\t */\n\t\tinitStringInfo(&querybuf);\n\t\tquoteRelationName(pkrelname, pk_rel);\n\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM ONLY %s x\", pkrelname);\n\t\tquerysep = \"WHERE\";\n\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t{\n\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\tattname, pk_type,\n\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\tparamname, fk_type);\n\t\t\tquerysep = \"AND\";\n\t\t\tqueryoids[i] = fk_type;\n\t\t}\n\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t/* Prepare and save the plan */\n\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t}\n\n\t/*\n\t * Now check that foreign key exists in PK table\n\t */\n\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\tNULL, new_row,\n\t\t\t\t\tfalse,\n\t\t\t\t\tSPI_OK_SELECT);\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\theap_close(pk_rel, RowShareLock);\n\n\treturn PointerGetDatum(NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"miscadmin.h\"",
      "#include \"parser/parse_relation.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"executor/spi.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)",
      "#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)",
      "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
      "#define RI_KEYS_NONE_NULL\t\t\t\t2",
      "#define RI_KEYS_SOME_NULL\t\t\t\t1",
      "#define RI_KEYS_ALL_NULL\t\t\t\t0",
      "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
    ],
    "globals_used": [
      "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
      "static Datum ri_setnull(TriggerData *trigdata);",
      "static Datum ri_setdefault(TriggerData *trigdata);",
      "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
      "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pk_rel",
            "RowShareLock"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_finish failed\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_PerformCheck",
          "args": [
            "riinfo",
            "&qkey",
            "qplan",
            "fk_rel",
            "pk_rel",
            "NULL",
            "new_row",
            "false",
            "SPI_OK_SELECT"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PerformCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2506-2638",
          "snippet": "static bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK",
            "#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2",
            "#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1",
            "#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);",
            "static void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n#define RI_PLAN_CHECK_LOOKUPPK_FROM_PK\t2\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic bool ri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK);\nstatic void ri_ExtractValues(Relation rel, HeapTuple tup,\n\t\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk,\n\t\t\t\t Datum *vals, char *nulls);\n\nstatic bool\nri_PerformCheck(const RI_ConstraintInfo *riinfo,\n\t\t\t\tRI_QueryKey *qkey, SPIPlanPtr qplan,\n\t\t\t\tRelation fk_rel, Relation pk_rel,\n\t\t\t\tHeapTuple old_tuple, HeapTuple new_tuple,\n\t\t\t\tbool detectNewRows, int expect_OK)\n{\n\tRelation\tquery_rel,\n\t\t\t\tsource_rel;\n\tbool\t\tsource_is_pk;\n\tSnapshot\ttest_snapshot;\n\tSnapshot\tcrosscheck_snapshot;\n\tint\t\t\tlimit;\n\tint\t\t\tspi_result;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tDatum\t\tvals[RI_MAX_NUMKEYS * 2];\n\tchar\t\tnulls[RI_MAX_NUMKEYS * 2];\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/*\n\t * The values for the query are taken from the table on which the trigger\n\t * is called - it is normally the other one with respect to query_rel. An\n\t * exception is ri_Check_Pk_Match(), which uses the PK table for both (and\n\t * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually\n\t * need some less klugy way to determine this.\n\t */\n\tif (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK)\n\t{\n\t\tsource_rel = fk_rel;\n\t\tsource_is_pk = false;\n\t}\n\telse\n\t{\n\t\tsource_rel = pk_rel;\n\t\tsource_is_pk = true;\n\t}\n\n\t/* Extract the parameters to be passed into the query */\n\tif (new_tuple)\n\t{\n\t\tri_ExtractValues(source_rel, new_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t\tif (old_tuple)\n\t\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t\t vals + riinfo->nkeys, nulls + riinfo->nkeys);\n\t}\n\telse\n\t{\n\t\tri_ExtractValues(source_rel, old_tuple, riinfo, source_is_pk,\n\t\t\t\t\t\t vals, nulls);\n\t}\n\n\t/*\n\t * In READ COMMITTED mode, we just need to use an up-to-date regular\n\t * snapshot, and we will see all rows that could be interesting. But in\n\t * transaction-snapshot mode, we can't change the transaction snapshot. If\n\t * the caller passes detectNewRows == false then it's okay to do the query\n\t * with the transaction snapshot; otherwise we use a current snapshot, and\n\t * tell the executor to error out if it finds any rows under the current\n\t * snapshot that wouldn't be visible per the transaction snapshot.  Note\n\t * that SPI_execute_snapshot will register the snapshots, so we don't need\n\t * to bother here.\n\t */\n\tif (IsolationUsesXactSnapshot() && detectNewRows)\n\t{\n\t\tCommandCounterIncrement();\t/* be sure all my own work is visible */\n\t\ttest_snapshot = GetLatestSnapshot();\n\t\tcrosscheck_snapshot = GetTransactionSnapshot();\n\t}\n\telse\n\t{\n\t\t/* the default SPI behavior is okay */\n\t\ttest_snapshot = InvalidSnapshot;\n\t\tcrosscheck_snapshot = InvalidSnapshot;\n\t}\n\n\t/*\n\t * If this is a select query (e.g., for a 'no action' or 'restrict'\n\t * trigger), we only need to see if there is a single row in the table,\n\t * matching the key.  Otherwise, limit = 0 - because we want the query to\n\t * affect ALL the matching rows.\n\t */\n\tlimit = (expect_OK == SPI_OK_SELECT) ? 1 : 0;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Finally we can run the query. */\n\tspi_result = SPI_execute_snapshot(qplan,\n\t\t\t\t\t\t\t\t\t  vals, nulls,\n\t\t\t\t\t\t\t\t\t  test_snapshot, crosscheck_snapshot,\n\t\t\t\t\t\t\t\t\t  false, false, limit);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Check result */\n\tif (spi_result < 0)\n\t\telog(ERROR, \"SPI_execute_snapshot returned %s\", SPI_result_code_string(spi_result));\n\n\tif (expect_OK >= 0 && spi_result != expect_OK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"referential integrity query on \\\"%s\\\" from constraint \\\"%s\\\" on \\\"%s\\\" gave unexpected result\",\n\t\t\t\t\t\tRelationGetRelationName(pk_rel),\n\t\t\t\t\t\tNameStr(riinfo->conname),\n\t\t\t\t\t\tRelationGetRelationName(fk_rel)),\n\t\t\t\t errhint(\"This is most likely due to a rule having rewritten the query.\")));\n\n\t/* XXX wouldn't it be clearer to do this part at the caller? */\n\tif (qkey->constr_queryno != RI_PLAN_CHECK_LOOKUPPK_FROM_PK &&\n\t\texpect_OK == SPI_OK_SELECT &&\n\t\t(SPI_processed == 0) == (qkey->constr_queryno == RI_PLAN_CHECK_LOOKUPPK))\n\t\tri_ReportViolation(riinfo,\n\t\t\t\t\t\t   pk_rel, fk_rel,\n\t\t\t\t\t\t   new_tuple ? new_tuple : old_tuple,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   qkey->constr_queryno);\n\n\treturn SPI_processed != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_PlanCheck",
          "args": [
            "querybuf.data",
            "riinfo->nkeys",
            "queryoids",
            "&qkey",
            "fk_rel",
            "pk_rel",
            "true"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ri_PlanCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2459-2501",
          "snippet": "static SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK"
          ],
          "globals_used": [
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);",
            "static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_PLAN_LAST_ON_PK\t\t\t\tRI_PLAN_CHECK_LOOKUPPK_FROM_PK\n\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\nstatic SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan);\n\nstatic SPIPlanPtr\nri_PlanCheck(const char *querystr, int nargs, Oid *argtypes,\n\t\t\t RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel,\n\t\t\t bool cache_plan)\n{\n\tSPIPlanPtr\tqplan;\n\tRelation\tquery_rel;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\n\t/*\n\t * Use the query type code to determine whether the query is run against\n\t * the PK or FK table; we'll do the check as that table's owner\n\t */\n\tif (qkey->constr_queryno <= RI_PLAN_LAST_ON_PK)\n\t\tquery_rel = pk_rel;\n\telse\n\t\tquery_rel = fk_rel;\n\n\t/* Switch to proper UID to perform check as */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tSetUserIdAndSecContext(RelationGetForm(query_rel)->relowner,\n\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE |\n\t\t\t\t\t\t   SECURITY_NOFORCE_RLS);\n\n\t/* Create the plan */\n\tqplan = SPI_prepare(querystr, nargs, argtypes);\n\n\tif (qplan == NULL)\n\t\telog(ERROR, \"SPI_prepare returned %s for %s\", SPI_result_code_string(SPI_result), querystr);\n\n\t/* Restore UID and security context */\n\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\n\t/* Save the plan if requested */\n\tif (cache_plan)\n\t{\n\t\tSPI_keepplan(qplan);\n\t\tri_HashPreparedPlan(qkey, qplan);\n\t}\n\n\treturn qplan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&querybuf",
            "\" FOR KEY SHARE OF x\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_GenerateQual",
          "args": [
            "&querybuf",
            "querysep",
            "attname",
            "pk_type",
            "riinfo->pf_eq_oprs[i]",
            "paramname",
            "fk_type"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ri_GenerateQual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2163-2173",
          "snippet": "static void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void ri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype);\n\nstatic void\nri_GenerateQual(StringInfo buf,\n\t\t\t\tconst char *sep,\n\t\t\t\tconst char *leftop, Oid leftoptype,\n\t\t\t\tOid opoid,\n\t\t\t\tconst char *rightop, Oid rightoptype)\n{\n\tappendStringInfo(buf, \" %s \", sep);\n\tgenerate_operator_clause(buf, leftop, leftoptype, opoid,\n\t\t\t\t\t\t\t rightop, rightoptype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "paramname",
            "\"$%d\"",
            "i + 1"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteOneName",
          "args": [
            "attname",
            "RIAttName(pk_rel, riinfo->pk_attnums[i])"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "quoteOneName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2126-2139",
          "snippet": "static void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteOneName(char *buffer, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteOneName(char *buffer, const char *name);\n\nstatic void\nquoteOneName(char *buffer, const char *name)\n{\n\t/* Rather than trying to be smart, just always quote it. */\n\t*buffer++ = '\"';\n\twhile (*name)\n\t{\n\t\tif (*name == '\"')\n\t\t\t*buffer++ = '\"';\n\t\t*buffer++ = *name++;\n\t}\n\t*buffer++ = '\"';\n\t*buffer = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "RIAttName",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "fk_rel",
            "riinfo->fk_attnums[i]"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIAttType",
          "args": [
            "pk_rel",
            "riinfo->pk_attnums[i]"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&querybuf",
            "\"SELECT 1 FROM ONLY %s x\"",
            "pkrelname"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quoteRelationName",
          "args": [
            "pkrelname",
            "pk_rel"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "quoteRelationName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2146-2153",
          "snippet": "static void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void quoteRelationName(char *buffer, Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void quoteRelationName(char *buffer, Relation rel);\n\nstatic void\nquoteRelationName(char *buffer, Relation rel)\n{\n\tquoteOneName(buffer, get_namespace_name(RelationGetNamespace(rel)));\n\tbuffer += strlen(buffer);\n\t*buffer++ = '.';\n\tquoteOneName(buffer, RelationGetRelationName(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&querybuf"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchPreparedPlan",
          "args": [
            "&qkey"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchPreparedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2888-2932",
          "snippet": "static SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *ri_query_cache = NULL;",
            "static void ri_InitHashTables(void);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);",
            "static void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic HTAB *ri_query_cache = NULL;\nstatic void ri_InitHashTables(void);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic SPIPlanPtr\nri_FetchPreparedPlan(RI_QueryKey *key)\n{\n\tRI_QueryHashEntry *entry;\n\tSPIPlanPtr\tplan;\n\n\t/*\n\t * On the first call initialize the hashtable\n\t */\n\tif (!ri_query_cache)\n\t\tri_InitHashTables();\n\n\t/*\n\t * Lookup for the key\n\t */\n\tentry = (RI_QueryHashEntry *) hash_search(ri_query_cache,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) key,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * Check whether the plan is still valid.  If it isn't, we don't want to\n\t * simply rely on plancache.c to regenerate it; rather we should start\n\t * from scratch and rebuild the query text too.  This is to cover cases\n\t * such as table/column renames.  We depend on the plancache machinery to\n\t * detect possible invalidations, though.\n\t *\n\t * CAUTION: this check is only trustworthy if the caller has already\n\t * locked both FK and PK rels.\n\t */\n\tplan = entry->plan;\n\tif (plan && SPI_plan_is_valid(plan))\n\t\treturn plan;\n\n\t/*\n\t * Otherwise we might as well flush the cached plan now, to free a little\n\t * memory space before we make a new one.\n\t */\n\tentry->plan = NULL;\n\tif (plan)\n\t\tSPI_freeplan(plan);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ri_BuildQueryKey",
          "args": [
            "&qkey",
            "riinfo",
            "RI_PLAN_CHECK_LOOKUPPK"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ri_BuildQueryKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2233-2243",
          "snippet": "static void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);",
            "static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic void ri_BuildQueryKey(RI_QueryKey *key,\n\t\t\t\t const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\n\nstatic void\nri_BuildQueryKey(RI_QueryKey *key, const RI_ConstraintInfo *riinfo,\n\t\t\t\t int32 constr_queryno)\n{\n\t/*\n\t * We assume struct RI_QueryKey contains no padding bytes, else we'd need\n\t * to use memset to clear them.\n\t */\n\tkey->constr_id = riinfo->constraint_id;\n\tkey->constr_queryno = constr_queryno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pk_rel",
            "RowShareLock"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"MATCH PARTIAL not yet implemented\""
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pk_rel",
            "RowShareLock"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pk_rel",
            "RowShareLock"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t\t\t\t errdetail(\"MATCH FULL does not allow mixing of null and nonnull key values.\"),\n\t\t\t\t\t\t\t errtableconstraint(fk_rel,\n\t\t\t\t\t\t\t\t\t\t\t\tNameStr(riinfo->conname)))"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errtableconstraint",
          "args": [
            "fk_rel",
            "NameStr(riinfo->conname)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "errtableconstraint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5336-5343",
          "snippet": "int\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"MATCH FULL does not allow mixing of null and nonnull key values.\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "riinfo->conname"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "fk_rel"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pk_rel",
            "RowShareLock"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_NullCheck",
          "args": [
            "RelationGetDescr(fk_rel)",
            "new_row",
            "riinfo",
            "false"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ri_NullCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2809-2839",
          "snippet": "static int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RI_KEYS_NONE_NULL\t\t\t\t2",
            "#define RI_KEYS_SOME_NULL\t\t\t\t1",
            "#define RI_KEYS_ALL_NULL\t\t\t\t0"
          ],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\n\nstatic int\nri_NullCheck(TupleDesc tupDesc,\n\t\t\t HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk)\n{\n\tconst int16 *attnums;\n\tint\t\t\ti;\n\tbool\t\tallnull = true;\n\tbool\t\tnonenull = true;\n\n\tif (rel_is_pk)\n\t\tattnums = riinfo->pk_attnums;\n\telse\n\t\tattnums = riinfo->fk_attnums;\n\n\tfor (i = 0; i < riinfo->nkeys; i++)\n\t{\n\t\tif (heap_attisnull(tup, attnums[i], tupDesc))\n\t\t\tnonenull = false;\n\t\telse\n\t\t\tallnull = false;\n\t}\n\n\tif (allnull)\n\t\treturn RI_KEYS_ALL_NULL;\n\n\tif (nonenull)\n\t\treturn RI_KEYS_NONE_NULL;\n\n\treturn RI_KEYS_SOME_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "fk_rel"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\"))"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "riinfo->pk_relid",
            "RowShareLock"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockBuffer",
          "args": [
            "new_row_buf",
            "BUFFER_LOCK_UNLOCK"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockBuffer",
          "args": [
            "new_row_buf",
            "BUFFER_LOCK_UNLOCK"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleSatisfiesVisibility",
          "args": [
            "new_row",
            "SnapshotSelf",
            "new_row_buf"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockBuffer",
          "args": [
            "new_row_buf",
            "BUFFER_LOCK_SHARE"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_UPDATE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri_FetchConstraintInfo",
          "args": [
            "trigdata->tg_trigger",
            "trigdata->tg_relation",
            "false"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ri_FetchConstraintInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ri_triggers.c",
          "lines": "2294-2332",
          "snippet": "static const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"miscadmin.h\"",
            "#include \"parser/parse_relation.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"executor/spi.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);",
            "static int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);",
            "static const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic int ri_NullCheck(TupleDesc tupdesc, HeapTuple tup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic bool ri_KeysEqual(Relation rel, HeapTuple oldtup, HeapTuple newtup,\n\t\t\t const RI_ConstraintInfo *riinfo, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_FetchConstraintInfo(Trigger *trigger,\n\t\t\t\t\t   Relation trig_rel, bool rel_is_pk);\nstatic const RI_ConstraintInfo *ri_LoadConstraintInfo(Oid constraintOid);\n\nstatic const RI_ConstraintInfo *\nri_FetchConstraintInfo(Trigger *trigger, Relation trig_rel, bool rel_is_pk)\n{\n\tOid\t\t\tconstraintOid = trigger->tgconstraint;\n\tconst RI_ConstraintInfo *riinfo;\n\n\t/*\n\t * Check that the FK constraint's OID is available; it might not be if\n\t * we've been invoked via an ordinary trigger or an old-style \"constraint\n\t * trigger\".\n\t */\n\tif (!OidIsValid(constraintOid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t errmsg(\"no pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t\t\ttrigger->tgname, RelationGetRelationName(trig_rel)),\n\t\t\t\t errhint(\"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT.\")));\n\n\t/* Find or create a hashtable entry for the constraint */\n\triinfo = ri_LoadConstraintInfo(constraintOid);\n\n\t/* Do some easy cross-checks against the trigger call data */\n\tif (rel_is_pk)\n\t{\n\t\tif (riinfo->fk_relid != trigger->tgconstrrelid ||\n\t\t\triinfo->pk_relid != RelationGetRelid(trig_rel))\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\telse\n\t{\n\t\tif (riinfo->fk_relid != RelationGetRelid(trig_rel) ||\n\t\t\triinfo->pk_relid != trigger->tgconstrrelid)\n\t\t\telog(ERROR, \"wrong pg_constraint entry for trigger \\\"%s\\\" on table \\\"%s\\\"\",\n\t\t\t\t trigger->tgname, RelationGetRelationName(trig_rel));\n\t}\n\n\treturn riinfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/bufmgr.h\"\n#include \"miscadmin.h\"\n#include \"parser/parse_relation.h\"\n#include \"parser/parse_coerce.h\"\n#include \"lib/ilist.h\"\n#include \"executor/spi.h\"\n#include \"executor/executor.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/xact.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define MAX_QUOTED_REL_NAME_LEN  (MAX_QUOTED_NAME_LEN*2)\n#define MAX_QUOTED_NAME_LEN  (NAMEDATALEN*2+3)\n#define RI_PLAN_CHECK_LOOKUPPK\t\t\t1\n#define RI_KEYS_NONE_NULL\t\t\t\t2\n#define RI_KEYS_SOME_NULL\t\t\t\t1\n#define RI_KEYS_ALL_NULL\t\t\t\t0\n#define RI_MAX_NUMKEYS\t\t\t\t\tINDEX_MAX_KEYS\n\nstatic bool ri_Check_Pk_Match(Relation pk_rel, Relation fk_rel,\n\t\t\t\t  HeapTuple old_row,\n\t\t\t\t  const RI_ConstraintInfo *riinfo);\nstatic Datum ri_setnull(TriggerData *trigdata);\nstatic Datum ri_setdefault(TriggerData *trigdata);\nstatic SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key);\nstatic void ri_HashPreparedPlan(RI_QueryKey *key, SPIPlanPtr plan);\n\nstatic Datum\nRI_FKey_check(TriggerData *trigdata)\n{\n\tconst RI_ConstraintInfo *riinfo;\n\tRelation\tfk_rel;\n\tRelation\tpk_rel;\n\tHeapTuple\tnew_row;\n\tBuffer\t\tnew_row_buf;\n\tRI_QueryKey qkey;\n\tSPIPlanPtr\tqplan;\n\tint\t\t\ti;\n\n\t/*\n\t * Get arguments.\n\t */\n\triinfo = ri_FetchConstraintInfo(trigdata->tg_trigger,\n\t\t\t\t\t\t\t\t\ttrigdata->tg_relation, false);\n\n\tif (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t{\n\t\tnew_row = trigdata->tg_newtuple;\n\t\tnew_row_buf = trigdata->tg_newtuplebuf;\n\t}\n\telse\n\t{\n\t\tnew_row = trigdata->tg_trigtuple;\n\t\tnew_row_buf = trigdata->tg_trigtuplebuf;\n\t}\n\n\t/*\n\t * We should not even consider checking the row if it is no longer valid,\n\t * since it was either deleted (so the deferred check should be skipped)\n\t * or updated (in which case only the latest version of the row should be\n\t * checked).  Test its liveness according to SnapshotSelf.  We need pin\n\t * and lock on the buffer to call HeapTupleSatisfiesVisibility.  Caller\n\t * should be holding pin, but not lock.\n\t */\n\tLockBuffer(new_row_buf, BUFFER_LOCK_SHARE);\n\tif (!HeapTupleSatisfiesVisibility(new_row, SnapshotSelf, new_row_buf))\n\t{\n\t\tLockBuffer(new_row_buf, BUFFER_LOCK_UNLOCK);\n\t\treturn PointerGetDatum(NULL);\n\t}\n\tLockBuffer(new_row_buf, BUFFER_LOCK_UNLOCK);\n\n\t/*\n\t * Get the relation descriptors of the FK and PK tables.\n\t *\n\t * pk_rel is opened in RowShareLock mode since that's what our eventual\n\t * SELECT FOR KEY SHARE will get on it.\n\t */\n\tfk_rel = trigdata->tg_relation;\n\tpk_rel = heap_open(riinfo->pk_relid, RowShareLock);\n\n\tif (riinfo->confmatchtype == FKCONSTR_MATCH_PARTIAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\n\tswitch (ri_NullCheck(RelationGetDescr(fk_rel), new_row, riinfo, false))\n\t{\n\t\tcase RI_KEYS_ALL_NULL:\n\n\t\t\t/*\n\t\t\t * No further check needed - an all-NULL key passes every type of\n\t\t\t * foreign key constraint.\n\t\t\t */\n\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\treturn PointerGetDatum(NULL);\n\n\t\tcase RI_KEYS_SOME_NULL:\n\n\t\t\t/*\n\t\t\t * This is the only case that differs between the three kinds of\n\t\t\t * MATCH.\n\t\t\t */\n\t\t\tswitch (riinfo->confmatchtype)\n\t\t\t{\n\t\t\t\tcase FKCONSTR_MATCH_FULL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Not allowed - MATCH FULL says either all or none of the\n\t\t\t\t\t * attributes can be NULLs\n\t\t\t\t\t */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FOREIGN_KEY_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"insert or update on table \\\"%s\\\" violates foreign key constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tRelationGetRelationName(fk_rel),\n\t\t\t\t\t\t\t\t\tNameStr(riinfo->conname)),\n\t\t\t\t\t\t\t errdetail(\"MATCH FULL does not allow mixing of null and nonnull key values.\"),\n\t\t\t\t\t\t\t errtableconstraint(fk_rel,\n\t\t\t\t\t\t\t\t\t\t\t\tNameStr(riinfo->conname))));\n\t\t\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase FKCONSTR_MATCH_SIMPLE:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * MATCH SIMPLE - if ANY column is null, the key passes\n\t\t\t\t\t * the constraint.\n\t\t\t\t\t */\n\t\t\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tcase FKCONSTR_MATCH_PARTIAL:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * MATCH PARTIAL - all non-null columns must match. (not\n\t\t\t\t\t * implemented, can be done by modifying the query below\n\t\t\t\t\t * to only include non-null columns, or by writing a\n\t\t\t\t\t * special version here)\n\t\t\t\t\t */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t errmsg(\"MATCH PARTIAL not yet implemented\")));\n\t\t\t\t\theap_close(pk_rel, RowShareLock);\n\t\t\t\t\treturn PointerGetDatum(NULL);\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized confmatchtype: %d\",\n\t\t\t\t\t\t riinfo->confmatchtype);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase RI_KEYS_NONE_NULL:\n\n\t\t\t/*\n\t\t\t * Have a full qualified key - continue below for all three kinds\n\t\t\t * of MATCH.\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed\");\n\n\t/*\n\t * Fetch or prepare a saved plan for the real check\n\t */\n\tri_BuildQueryKey(&qkey, riinfo, RI_PLAN_CHECK_LOOKUPPK);\n\n\tif ((qplan = ri_FetchPreparedPlan(&qkey)) == NULL)\n\t{\n\t\tStringInfoData querybuf;\n\t\tchar\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN];\n\t\tchar\t\tattname[MAX_QUOTED_NAME_LEN];\n\t\tchar\t\tparamname[16];\n\t\tconst char *querysep;\n\t\tOid\t\t\tqueryoids[RI_MAX_NUMKEYS];\n\n\t\t/* ----------\n\t\t * The query string built is\n\t\t *\tSELECT 1 FROM ONLY <pktable> x WHERE pkatt1 = $1 [AND ...]\n\t\t *\t\t   FOR KEY SHARE OF x\n\t\t * The type id's for the $ parameters are those of the\n\t\t * corresponding FK attributes.\n\t\t * ----------\n\t\t */\n\t\tinitStringInfo(&querybuf);\n\t\tquoteRelationName(pkrelname, pk_rel);\n\t\tappendStringInfo(&querybuf, \"SELECT 1 FROM ONLY %s x\", pkrelname);\n\t\tquerysep = \"WHERE\";\n\t\tfor (i = 0; i < riinfo->nkeys; i++)\n\t\t{\n\t\t\tOid\t\t\tpk_type = RIAttType(pk_rel, riinfo->pk_attnums[i]);\n\t\t\tOid\t\t\tfk_type = RIAttType(fk_rel, riinfo->fk_attnums[i]);\n\n\t\t\tquoteOneName(attname,\n\t\t\t\t\t\t RIAttName(pk_rel, riinfo->pk_attnums[i]));\n\t\t\tsprintf(paramname, \"$%d\", i + 1);\n\t\t\tri_GenerateQual(&querybuf, querysep,\n\t\t\t\t\t\t\tattname, pk_type,\n\t\t\t\t\t\t\triinfo->pf_eq_oprs[i],\n\t\t\t\t\t\t\tparamname, fk_type);\n\t\t\tquerysep = \"AND\";\n\t\t\tqueryoids[i] = fk_type;\n\t\t}\n\t\tappendStringInfoString(&querybuf, \" FOR KEY SHARE OF x\");\n\n\t\t/* Prepare and save the plan */\n\t\tqplan = ri_PlanCheck(querybuf.data, riinfo->nkeys, queryoids,\n\t\t\t\t\t\t\t &qkey, fk_rel, pk_rel, true);\n\t}\n\n\t/*\n\t * Now check that foreign key exists in PK table\n\t */\n\tri_PerformCheck(riinfo, &qkey, qplan,\n\t\t\t\t\tfk_rel, pk_rel,\n\t\t\t\t\tNULL, new_row,\n\t\t\t\t\tfalse,\n\t\t\t\t\tSPI_OK_SELECT);\n\n\tif (SPI_finish() != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed\");\n\n\theap_close(pk_rel, RowShareLock);\n\n\treturn PointerGetDatum(NULL);\n}"
  }
]