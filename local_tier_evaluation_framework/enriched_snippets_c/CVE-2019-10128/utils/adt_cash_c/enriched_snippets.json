[
  {
    "function_name": "int8_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "1134-1159",
    "snippet": "Datum\nint8_cash(PG_FUNCTION_ARGS)\n{\n\tint64\t\tamount = PG_GETARG_INT64(0);\n\tCash\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* compute amount * scale, checking for overflow */\n\tresult = DatumGetInt64(DirectFunctionCall2(int8mul, Int64GetDatum(amount),\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatum(scale)));\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "DirectFunctionCall2(int8mul, Int64GetDatum(amount),\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatum(scale))"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int8mul",
            "Int64GetDatum(amount)",
            "Int64GetDatum(scale)"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "scale"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nint8_cash(PG_FUNCTION_ARGS)\n{\n\tint64\t\tamount = PG_GETARG_INT64(0);\n\tCash\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* compute amount * scale, checking for overflow */\n\tresult = DatumGetInt64(DirectFunctionCall2(int8mul, Int64GetDatum(amount),\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatum(scale)));\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "int4_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "1104-1129",
    "snippet": "Datum\nint4_cash(PG_FUNCTION_ARGS)\n{\n\tint32\t\tamount = PG_GETARG_INT32(0);\n\tCash\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* compute amount * scale, checking for overflow */\n\tresult = DatumGetInt64(DirectFunctionCall2(int8mul, Int64GetDatum(amount),\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatum(scale)));\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "DirectFunctionCall2(int8mul, Int64GetDatum(amount),\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatum(scale))"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int8mul",
            "Int64GetDatum(amount)",
            "Int64GetDatum(scale)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "scale"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nint4_cash(PG_FUNCTION_ARGS)\n{\n\tint32\t\tamount = PG_GETARG_INT32(0);\n\tCash\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* compute amount * scale, checking for overflow */\n\tresult = DatumGetInt64(DirectFunctionCall2(int8mul, Int64GetDatum(amount),\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatum(scale)));\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "numeric_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "1070-1099",
    "snippet": "Datum\nnumeric_cash(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tamount = PG_GETARG_DATUM(0);\n\tCash\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tDatum\t\tnumeric_scale;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* multiply the input amount by scale factor */\n\tnumeric_scale = DirectFunctionCall1(int8_numeric, Int64GetDatum(scale));\n\tamount = DirectFunctionCall2(numeric_mul, amount, numeric_scale);\n\n\t/* note that numeric_int8 will round to nearest integer for us */\n\tresult = DatumGetInt64(DirectFunctionCall1(numeric_int8, amount));\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "DirectFunctionCall1(numeric_int8, amount)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_int8",
            "amount"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_mul",
            "amount",
            "numeric_scale"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(scale)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "scale"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nnumeric_cash(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tamount = PG_GETARG_DATUM(0);\n\tCash\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tDatum\t\tnumeric_scale;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* multiply the input amount by scale factor */\n\tnumeric_scale = DirectFunctionCall1(int8_numeric, Int64GetDatum(scale));\n\tamount = DirectFunctionCall2(numeric_mul, amount, numeric_scale);\n\n\t/* note that numeric_int8 will round to nearest integer for us */\n\tresult = DatumGetInt64(DirectFunctionCall1(numeric_int8, amount));\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "1031-1065",
    "snippet": "Datum\ncash_numeric(PG_FUNCTION_ARGS)\n{\n\tCash\t\tmoney = PG_GETARG_CASH(0);\n\tNumeric\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tDatum\t\tamount;\n\tDatum\t\tnumeric_scale;\n\tDatum\t\tquotient;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* form the result as money / scale */\n\tamount = DirectFunctionCall1(int8_numeric, Int64GetDatum(money));\n\tnumeric_scale = DirectFunctionCall1(int8_numeric, Int64GetDatum(scale));\n\tquotient = DirectFunctionCall2(numeric_div, amount, numeric_scale);\n\n\t/* forcibly round to exactly the intended number of digits */\n\tresult = DatumGetNumeric(DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\t quotient,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(fpoint)));\n\n\tPG_RETURN_NUMERIC(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NUMERIC",
          "args": [
            "result"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\t quotient,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(fpoint))"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_round",
            "quotient",
            "Int32GetDatum(fpoint)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "fpoint"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_div",
            "amount",
            "numeric_scale"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(scale)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "scale"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(money)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_numeric(PG_FUNCTION_ARGS)\n{\n\tCash\t\tmoney = PG_GETARG_CASH(0);\n\tNumeric\t\tresult;\n\tint\t\t\tfpoint;\n\tint64\t\tscale;\n\tint\t\t\ti;\n\tDatum\t\tamount;\n\tDatum\t\tnumeric_scale;\n\tDatum\t\tquotient;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\n\n\t/* compute required scale factor */\n\tscale = 1;\n\tfor (i = 0; i < fpoint; i++)\n\t\tscale *= 10;\n\n\t/* form the result as money / scale */\n\tamount = DirectFunctionCall1(int8_numeric, Int64GetDatum(money));\n\tnumeric_scale = DirectFunctionCall1(int8_numeric, Int64GetDatum(scale));\n\tquotient = DirectFunctionCall2(numeric_div, amount, numeric_scale);\n\n\t/* forcibly round to exactly the intended number of digits */\n\tresult = DatumGetNumeric(DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\t quotient,\n\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(fpoint)));\n\n\tPG_RETURN_NUMERIC(result);\n}"
  },
  {
    "function_name": "cash_words",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "944-1025",
    "snippet": "Datum\ncash_words(PG_FUNCTION_ARGS)\n{\n\tCash\t\tvalue = PG_GETARG_CASH(0);\n\tuint64\t\tval;\n\tchar\t\tbuf[256];\n\tchar\t   *p = buf;\n\tCash\t\tm0;\n\tCash\t\tm1;\n\tCash\t\tm2;\n\tCash\t\tm3;\n\tCash\t\tm4;\n\tCash\t\tm5;\n\tCash\t\tm6;\n\n\t/* work with positive numbers */\n\tif (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tstrcpy(buf, \"minus \");\n\t\tp += 6;\n\t}\n\telse\n\t\tbuf[0] = '\\0';\n\n\t/* Now treat as unsigned, to avoid trouble at INT_MIN */\n\tval = (uint64) value;\n\n\tm0 = val % INT64CONST(100); /* cents */\n\tm1 = (val / INT64CONST(100)) % 1000;\t/* hundreds */\n\tm2 = (val / INT64CONST(100000)) % 1000; /* thousands */\n\tm3 = (val / INT64CONST(100000000)) % 1000;\t/* millions */\n\tm4 = (val / INT64CONST(100000000000)) % 1000;\t/* billions */\n\tm5 = (val / INT64CONST(100000000000000)) % 1000;\t/* trillions */\n\tm6 = (val / INT64CONST(100000000000000000)) % 1000; /* quadrillions */\n\n\tif (m6)\n\t{\n\t\tstrcat(buf, num_word(m6));\n\t\tstrcat(buf, \" quadrillion \");\n\t}\n\n\tif (m5)\n\t{\n\t\tstrcat(buf, num_word(m5));\n\t\tstrcat(buf, \" trillion \");\n\t}\n\n\tif (m4)\n\t{\n\t\tstrcat(buf, num_word(m4));\n\t\tstrcat(buf, \" billion \");\n\t}\n\n\tif (m3)\n\t{\n\t\tstrcat(buf, num_word(m3));\n\t\tstrcat(buf, \" million \");\n\t}\n\n\tif (m2)\n\t{\n\t\tstrcat(buf, num_word(m2));\n\t\tstrcat(buf, \" thousand \");\n\t}\n\n\tif (m1)\n\t\tstrcat(buf, num_word(m1));\n\n\tif (!*p)\n\t\tstrcat(buf, \"zero\");\n\n\tstrcat(buf, (val / 100) == 1 ? \" dollar and \" : \" dollars and \");\n\tstrcat(buf, num_word(m0));\n\tstrcat(buf, m0 == 1 ? \" cent\" : \" cents\");\n\n\t/* capitalize output */\n\tbuf[0] = pg_toupper((unsigned char) buf[0]);\n\n\t/* return as text datum */\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(buf)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "buf"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "(unsigned char) buf[0]"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "m0 == 1 ? \" cent\" : \" cents\""
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "225-243",
          "snippet": "int\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_word",
          "args": [
            "m0"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "num_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
          "lines": "38-88",
          "snippet": "static const char *\nnum_word(Cash value)\n{\n\tstatic char buf[128];\n\tstatic const char *small[] = {\n\t\t\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\",\n\t\t\"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n\t\t\"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n\t\t\"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"\n\t};\n\tconst char **big = small + 18;\n\tint\t\t\ttu = value % 100;\n\n\t/* deal with the simple cases first */\n\tif (value <= 20)\n\t\treturn small[value];\n\n\t/* is it an even multiple of 100? */\n\tif (!tu)\n\t{\n\t\tsprintf(buf, \"%s hundred\", small[value / 100]);\n\t\treturn buf;\n\t}\n\n\t/* more than 99? */\n\tif (value > 99)\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s hundred %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s hundred and %s\",\n\t\t\t\t\tsmall[value / 100], small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s hundred %s %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10], small[tu % 10]);\n\t}\n\telse\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s\", big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s\", small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s %s\", big[tu / 10], small[tu % 10]);\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/cash.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const char *\nnum_word(Cash value)\n{\n\tstatic char buf[128];\n\tstatic const char *small[] = {\n\t\t\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\",\n\t\t\"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n\t\t\"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n\t\t\"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"\n\t};\n\tconst char **big = small + 18;\n\tint\t\t\ttu = value % 100;\n\n\t/* deal with the simple cases first */\n\tif (value <= 20)\n\t\treturn small[value];\n\n\t/* is it an even multiple of 100? */\n\tif (!tu)\n\t{\n\t\tsprintf(buf, \"%s hundred\", small[value / 100]);\n\t\treturn buf;\n\t}\n\n\t/* more than 99? */\n\tif (value > 99)\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s hundred %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s hundred and %s\",\n\t\t\t\t\tsmall[value / 100], small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s hundred %s %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10], small[tu % 10]);\n\t}\n\telse\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s\", big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s\", small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s %s\", big[tu / 10], small[tu % 10]);\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000000000000000"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000000000000"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000000000"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000000"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"minus \""
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_words(PG_FUNCTION_ARGS)\n{\n\tCash\t\tvalue = PG_GETARG_CASH(0);\n\tuint64\t\tval;\n\tchar\t\tbuf[256];\n\tchar\t   *p = buf;\n\tCash\t\tm0;\n\tCash\t\tm1;\n\tCash\t\tm2;\n\tCash\t\tm3;\n\tCash\t\tm4;\n\tCash\t\tm5;\n\tCash\t\tm6;\n\n\t/* work with positive numbers */\n\tif (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tstrcpy(buf, \"minus \");\n\t\tp += 6;\n\t}\n\telse\n\t\tbuf[0] = '\\0';\n\n\t/* Now treat as unsigned, to avoid trouble at INT_MIN */\n\tval = (uint64) value;\n\n\tm0 = val % INT64CONST(100); /* cents */\n\tm1 = (val / INT64CONST(100)) % 1000;\t/* hundreds */\n\tm2 = (val / INT64CONST(100000)) % 1000; /* thousands */\n\tm3 = (val / INT64CONST(100000000)) % 1000;\t/* millions */\n\tm4 = (val / INT64CONST(100000000000)) % 1000;\t/* billions */\n\tm5 = (val / INT64CONST(100000000000000)) % 1000;\t/* trillions */\n\tm6 = (val / INT64CONST(100000000000000000)) % 1000; /* quadrillions */\n\n\tif (m6)\n\t{\n\t\tstrcat(buf, num_word(m6));\n\t\tstrcat(buf, \" quadrillion \");\n\t}\n\n\tif (m5)\n\t{\n\t\tstrcat(buf, num_word(m5));\n\t\tstrcat(buf, \" trillion \");\n\t}\n\n\tif (m4)\n\t{\n\t\tstrcat(buf, num_word(m4));\n\t\tstrcat(buf, \" billion \");\n\t}\n\n\tif (m3)\n\t{\n\t\tstrcat(buf, num_word(m3));\n\t\tstrcat(buf, \" million \");\n\t}\n\n\tif (m2)\n\t{\n\t\tstrcat(buf, num_word(m2));\n\t\tstrcat(buf, \" thousand \");\n\t}\n\n\tif (m1)\n\t\tstrcat(buf, num_word(m1));\n\n\tif (!*p)\n\t\tstrcat(buf, \"zero\");\n\n\tstrcat(buf, (val / 100) == 1 ? \" dollar and \" : \" dollars and \");\n\tstrcat(buf, num_word(m0));\n\tstrcat(buf, m0 == 1 ? \" cent\" : \" cents\");\n\n\t/* capitalize output */\n\tbuf[0] = pg_toupper((unsigned char) buf[0]);\n\n\t/* return as text datum */\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}"
  },
  {
    "function_name": "cashsmaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "928-938",
    "snippet": "Datum\ncashsmaller(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = (c1 < c2) ? c1 : c2;\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncashsmaller(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = (c1 < c2) ? c1 : c2;\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cashlarger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "913-923",
    "snippet": "Datum\ncashlarger(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = (c1 > c2) ? c1 : c2;\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncashlarger(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = (c1 > c2) ? c1 : c2;\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_div_int2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "894-908",
    "snippet": "Datum\ncash_div_int2(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint16\t\ts = PG_GETARG_INT16(1);\n\tCash\t\tresult;\n\n\tif (s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = c / s;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "1"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_div_int2(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint16\t\ts = PG_GETARG_INT16(1);\n\tCash\t\tresult;\n\n\tif (s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = c / s;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "int2_mul_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "879-888",
    "snippet": "Datum\nint2_mul_cash(PG_FUNCTION_ARGS)\n{\n\tint16\t\ts = PG_GETARG_INT16(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = s * c;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "0"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nint2_mul_cash(PG_FUNCTION_ARGS)\n{\n\tint16\t\ts = PG_GETARG_INT16(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = s * c;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_mul_int2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "865-874",
    "snippet": "Datum\ncash_mul_int2(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint16\t\ts = PG_GETARG_INT16(1);\n\tCash\t\tresult;\n\n\tresult = c * s;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "1"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_mul_int2(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint16\t\ts = PG_GETARG_INT16(1);\n\tCash\t\tresult;\n\n\tresult = c * s;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_div_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "844-859",
    "snippet": "Datum\ncash_div_int4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint32\t\ti = PG_GETARG_INT32(1);\n\tCash\t\tresult;\n\n\tif (i == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = c / i;\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_div_int4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint32\t\ti = PG_GETARG_INT32(1);\n\tCash\t\tresult;\n\n\tif (i == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = c / i;\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "int4_mul_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "828-837",
    "snippet": "Datum\nint4_mul_cash(PG_FUNCTION_ARGS)\n{\n\tint32\t\ti = PG_GETARG_INT32(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = i * c;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nint4_mul_cash(PG_FUNCTION_ARGS)\n{\n\tint32\t\ti = PG_GETARG_INT32(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = i * c;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_mul_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "813-822",
    "snippet": "Datum\ncash_mul_int4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint32\t\ti = PG_GETARG_INT32(1);\n\tCash\t\tresult;\n\n\tresult = c * i;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_mul_int4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint32\t\ti = PG_GETARG_INT32(1);\n\tCash\t\tresult;\n\n\tresult = c * i;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_div_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "792-807",
    "snippet": "Datum\ncash_div_int8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint64\t\ti = PG_GETARG_INT64(1);\n\tCash\t\tresult;\n\n\tif (i == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = c / i;\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_div_int8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint64\t\ti = PG_GETARG_INT64(1);\n\tCash\t\tresult;\n\n\tif (i == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = c / i;\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "int8_mul_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "778-787",
    "snippet": "Datum\nint8_mul_cash(PG_FUNCTION_ARGS)\n{\n\tint64\t\ti = PG_GETARG_INT64(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = i * c;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nint8_mul_cash(PG_FUNCTION_ARGS)\n{\n\tint64\t\ti = PG_GETARG_INT64(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = i * c;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_mul_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "763-772",
    "snippet": "Datum\ncash_mul_int8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint64\t\ti = PG_GETARG_INT64(1);\n\tCash\t\tresult;\n\n\tresult = c * i;\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_mul_int8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tint64\t\ti = PG_GETARG_INT64(1);\n\tCash\t\tresult;\n\n\tresult = c * i;\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_div_flt4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "743-757",
    "snippet": "Datum\ncash_div_flt4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat4\t\tf = PG_GETARG_FLOAT4(1);\n\tCash\t\tresult;\n\n\tif (f == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = rint(c / (float8) f);\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "c / (float8) f"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_div_flt4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat4\t\tf = PG_GETARG_FLOAT4(1);\n\tCash\t\tresult;\n\n\tif (f == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = rint(c / (float8) f);\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "flt4_mul_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "727-736",
    "snippet": "Datum\nflt4_mul_cash(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tf = PG_GETARG_FLOAT4(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = rint((float8) f * c);\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "(float8) f * c"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nflt4_mul_cash(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tf = PG_GETARG_FLOAT4(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = rint((float8) f * c);\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_mul_flt4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "712-721",
    "snippet": "Datum\ncash_mul_flt4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat4\t\tf = PG_GETARG_FLOAT4(1);\n\tCash\t\tresult;\n\n\tresult = rint(c * (float8) f);\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "c * (float8) f"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "1"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_mul_flt4(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat4\t\tf = PG_GETARG_FLOAT4(1);\n\tCash\t\tresult;\n\n\tresult = rint(c * (float8) f);\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_div_flt8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "692-706",
    "snippet": "Datum\ncash_div_flt8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat8\t\tf = PG_GETARG_FLOAT8(1);\n\tCash\t\tresult;\n\n\tif (f == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = rint(c / f);\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "c / f"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_div_flt8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat8\t\tf = PG_GETARG_FLOAT8(1);\n\tCash\t\tresult;\n\n\tif (f == 0.0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tresult = rint(c / f);\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "flt8_mul_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "677-686",
    "snippet": "Datum\nflt8_mul_cash(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tf = PG_GETARG_FLOAT8(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = rint(f * c);\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "f * c"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nflt8_mul_cash(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tf = PG_GETARG_FLOAT8(0);\n\tCash\t\tc = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = rint(f * c);\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_mul_flt8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "662-671",
    "snippet": "Datum\ncash_mul_flt8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat8\t\tf = PG_GETARG_FLOAT8(1);\n\tCash\t\tresult;\n\n\tresult = rint(c * f);\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "c * f"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_mul_flt8(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc = PG_GETARG_CASH(0);\n\tfloat8\t\tf = PG_GETARG_FLOAT8(1);\n\tCash\t\tresult;\n\n\tresult = rint(c * f);\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_div_cash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "642-656",
    "snippet": "Datum\ncash_div_cash(PG_FUNCTION_ARGS)\n{\n\tCash\t\tdividend = PG_GETARG_CASH(0);\n\tCash\t\tdivisor = PG_GETARG_CASH(1);\n\tfloat8\t\tquotient;\n\n\tif (divisor == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tquotient = (float8) dividend / (float8) divisor;\n\tPG_RETURN_FLOAT8(quotient);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "quotient"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\"))"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"division by zero\""
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DIVISION_BY_ZERO"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_div_cash(PG_FUNCTION_ARGS)\n{\n\tCash\t\tdividend = PG_GETARG_CASH(0);\n\tCash\t\tdivisor = PG_GETARG_CASH(1);\n\tfloat8\t\tquotient;\n\n\tif (divisor == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DIVISION_BY_ZERO),\n\t\t\t\t errmsg(\"division by zero\")));\n\n\tquotient = (float8) dividend / (float8) divisor;\n\tPG_RETURN_FLOAT8(quotient);\n}"
  },
  {
    "function_name": "cash_mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "626-636",
    "snippet": "Datum\ncash_mi(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = c1 - c2;\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_mi(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = c1 - c2;\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_pl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "610-620",
    "snippet": "Datum\ncash_pl(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = c1 + c2;\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_pl(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\tCash\t\tresult;\n\n\tresult = c1 + c2;\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "cash_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "592-604",
    "snippet": "Datum\ncash_cmp(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tif (c1 > c2)\n\t\tPG_RETURN_INT32(1);\n\telse if (c1 == c2)\n\t\tPG_RETURN_INT32(0);\n\telse\n\t\tPG_RETURN_INT32(-1);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "-1"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_cmp(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tif (c1 > c2)\n\t\tPG_RETURN_INT32(1);\n\telse if (c1 == c2)\n\t\tPG_RETURN_INT32(0);\n\telse\n\t\tPG_RETURN_INT32(-1);\n}"
  },
  {
    "function_name": "cash_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "583-590",
    "snippet": "Datum\ncash_ge(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 >= c2);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "c1 >= c2"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_ge(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 >= c2);\n}"
  },
  {
    "function_name": "cash_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "574-581",
    "snippet": "Datum\ncash_gt(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 > c2);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "c1 > c2"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_gt(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 > c2);\n}"
  },
  {
    "function_name": "cash_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "565-572",
    "snippet": "Datum\ncash_le(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 <= c2);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "c1 <= c2"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_le(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 <= c2);\n}"
  },
  {
    "function_name": "cash_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "556-563",
    "snippet": "Datum\ncash_lt(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 < c2);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "c1 < c2"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_lt(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 < c2);\n}"
  },
  {
    "function_name": "cash_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "547-554",
    "snippet": "Datum\ncash_ne(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 != c2);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "c1 != c2"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_ne(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 != c2);\n}"
  },
  {
    "function_name": "cash_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "538-545",
    "snippet": "Datum\ncash_eq(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 == c2);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "c1 == c2"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "1"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_eq(PG_FUNCTION_ARGS)\n{\n\tCash\t\tc1 = PG_GETARG_CASH(0);\n\tCash\t\tc2 = PG_GETARG_CASH(1);\n\n\tPG_RETURN_BOOL(c1 == c2);\n}"
  },
  {
    "function_name": "cash_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "523-532",
    "snippet": "Datum\ncash_send(PG_FUNCTION_ARGS)\n{\n\tCash\t\targ1 = PG_GETARG_CASH(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "arg1"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_send(PG_FUNCTION_ARGS)\n{\n\tCash\t\targ1 = PG_GETARG_CASH(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "cash_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "512-518",
    "snippet": "Datum\ncash_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_CASH((Cash) pq_getmsgint64(buf));\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "(Cash) pq_getmsgint64(buf)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_CASH((Cash) pq_getmsgint64(buf));\n}"
  },
  {
    "function_name": "cash_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "309-507",
    "snippet": "Datum\ncash_out(PG_FUNCTION_ARGS)\n{\n\tCash\t\tvalue = PG_GETARG_CASH(0);\n\tchar\t   *result;\n\tchar\t\tbuf[128];\n\tchar\t   *bufptr;\n\tint\t\t\tdigit_pos;\n\tint\t\t\tpoints,\n\t\t\t\tmon_group;\n\tchar\t\tdsymbol;\n\tconst char *ssymbol,\n\t\t\t   *csymbol,\n\t\t\t   *signsymbol;\n\tchar\t\tsign_posn,\n\t\t\t\tcs_precedes,\n\t\t\t\tsep_by_space;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tpoints = lconvert->frac_digits;\n\tif (points < 0 || points > 10)\n\t\tpoints = 2;\t\t\t\t/* best guess in this case, I think */\n\n\t/*\n\t * As with frac_digits, must apply a range check to mon_grouping to avoid\n\t * being fooled by variant CHAR_MAX values.\n\t */\n\tmon_group = *lconvert->mon_grouping;\n\tif (mon_group <= 0 || mon_group > 6)\n\t\tmon_group = 3;\n\n\t/* we restrict dsymbol to be a single byte, but not the other symbols */\n\tif (*lconvert->mon_decimal_point != '\\0' &&\n\t\tlconvert->mon_decimal_point[1] == '\\0')\n\t\tdsymbol = *lconvert->mon_decimal_point;\n\telse\n\t\tdsymbol = '.';\n\tif (*lconvert->mon_thousands_sep != '\\0')\n\t\tssymbol = lconvert->mon_thousands_sep;\n\telse\t\t\t\t\t\t/* ssymbol should not equal dsymbol */\n\t\tssymbol = (dsymbol != ',') ? \",\" : \".\";\n\tcsymbol = (*lconvert->currency_symbol != '\\0') ? lconvert->currency_symbol : \"$\";\n\n\tif (value < 0)\n\t{\n\t\t/* make the amount positive for digit-reconstruction loop */\n\t\tvalue = -value;\n\t\t/* set up formatting data */\n\t\tsignsymbol = (*lconvert->negative_sign != '\\0') ? lconvert->negative_sign : \"-\";\n\t\tsign_posn = lconvert->n_sign_posn;\n\t\tcs_precedes = lconvert->n_cs_precedes;\n\t\tsep_by_space = lconvert->n_sep_by_space;\n\t}\n\telse\n\t{\n\t\tsignsymbol = lconvert->positive_sign;\n\t\tsign_posn = lconvert->p_sign_posn;\n\t\tcs_precedes = lconvert->p_cs_precedes;\n\t\tsep_by_space = lconvert->p_sep_by_space;\n\t}\n\n\t/* we build the digits+decimal-point+sep string right-to-left in buf[] */\n\tbufptr = buf + sizeof(buf) - 1;\n\t*bufptr = '\\0';\n\n\t/*\n\t * Generate digits till there are no non-zero digits left and we emitted\n\t * at least one to the left of the decimal point.  digit_pos is the\n\t * current digit position, with zero as the digit just left of the decimal\n\t * point, increasing to the right.\n\t */\n\tdigit_pos = points;\n\tdo\n\t{\n\t\tif (points && digit_pos == 0)\n\t\t{\n\t\t\t/* insert decimal point, but not if value cannot be fractional */\n\t\t\t*(--bufptr) = dsymbol;\n\t\t}\n\t\telse if (digit_pos < 0 && (digit_pos % mon_group) == 0)\n\t\t{\n\t\t\t/* insert thousands sep, but only to left of radix point */\n\t\t\tbufptr -= strlen(ssymbol);\n\t\t\tmemcpy(bufptr, ssymbol, strlen(ssymbol));\n\t\t}\n\n\t\t*(--bufptr) = ((uint64) value % 10) + '0';\n\t\tvalue = ((uint64) value) / 10;\n\t\tdigit_pos--;\n\t} while (value || digit_pos >= 0);\n\n\t/*----------\n\t * Now, attach currency symbol and sign symbol in the correct order.\n\t *\n\t * The POSIX spec defines these values controlling this code:\n\t *\n\t * p/n_sign_posn:\n\t *\t0\tParentheses enclose the quantity and the currency_symbol.\n\t *\t1\tThe sign string precedes the quantity and the currency_symbol.\n\t *\t2\tThe sign string succeeds the quantity and the currency_symbol.\n\t *\t3\tThe sign string precedes the currency_symbol.\n\t *\t4\tThe sign string succeeds the currency_symbol.\n\t *\n\t * p/n_cs_precedes: 0 means currency symbol after value, else before it.\n\t *\n\t * p/n_sep_by_space:\n\t *\t0\tNo <space> separates the currency symbol and value.\n\t *\t1\tIf the currency symbol and sign string are adjacent, a <space>\n\t *\t\tseparates them from the value; otherwise, a <space> separates\n\t *\t\tthe currency symbol from the value.\n\t *\t2\tIf the currency symbol and sign string are adjacent, a <space>\n\t *\t\tseparates them; otherwise, a <space> separates the sign string\n\t *\t\tfrom the value.\n\t *----------\n\t */\n\tswitch (sign_posn)\n\t{\n\t\tcase 0:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"(%s%s%s)\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"(%s%s%s)\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol);\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "bufptr",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "csymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "signsymbol"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "csymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "signsymbol",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "bufptr"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "bufptr",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "signsymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "csymbol"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "signsymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "csymbol",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "bufptr"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "bufptr",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "csymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "signsymbol"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "csymbol",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "bufptr",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "signsymbol"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "signsymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "bufptr",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "csymbol"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s%s%s%s%s\"",
            "signsymbol",
            "(sep_by_space == 2) ? \" \" : \"\"",
            "csymbol",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "bufptr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"(%s%s%s)\"",
            "bufptr",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "csymbol"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"(%s%s%s)\"",
            "csymbol",
            "(sep_by_space == 1) ? \" \" : \"\"",
            "bufptr"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufptr",
            "ssymbol",
            "strlen(ssymbol)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ssymbol"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CASH",
          "args": [
            "0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_out(PG_FUNCTION_ARGS)\n{\n\tCash\t\tvalue = PG_GETARG_CASH(0);\n\tchar\t   *result;\n\tchar\t\tbuf[128];\n\tchar\t   *bufptr;\n\tint\t\t\tdigit_pos;\n\tint\t\t\tpoints,\n\t\t\t\tmon_group;\n\tchar\t\tdsymbol;\n\tconst char *ssymbol,\n\t\t\t   *csymbol,\n\t\t\t   *signsymbol;\n\tchar\t\tsign_posn,\n\t\t\t\tcs_precedes,\n\t\t\t\tsep_by_space;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/* see comments about frac_digits in cash_in() */\n\tpoints = lconvert->frac_digits;\n\tif (points < 0 || points > 10)\n\t\tpoints = 2;\t\t\t\t/* best guess in this case, I think */\n\n\t/*\n\t * As with frac_digits, must apply a range check to mon_grouping to avoid\n\t * being fooled by variant CHAR_MAX values.\n\t */\n\tmon_group = *lconvert->mon_grouping;\n\tif (mon_group <= 0 || mon_group > 6)\n\t\tmon_group = 3;\n\n\t/* we restrict dsymbol to be a single byte, but not the other symbols */\n\tif (*lconvert->mon_decimal_point != '\\0' &&\n\t\tlconvert->mon_decimal_point[1] == '\\0')\n\t\tdsymbol = *lconvert->mon_decimal_point;\n\telse\n\t\tdsymbol = '.';\n\tif (*lconvert->mon_thousands_sep != '\\0')\n\t\tssymbol = lconvert->mon_thousands_sep;\n\telse\t\t\t\t\t\t/* ssymbol should not equal dsymbol */\n\t\tssymbol = (dsymbol != ',') ? \",\" : \".\";\n\tcsymbol = (*lconvert->currency_symbol != '\\0') ? lconvert->currency_symbol : \"$\";\n\n\tif (value < 0)\n\t{\n\t\t/* make the amount positive for digit-reconstruction loop */\n\t\tvalue = -value;\n\t\t/* set up formatting data */\n\t\tsignsymbol = (*lconvert->negative_sign != '\\0') ? lconvert->negative_sign : \"-\";\n\t\tsign_posn = lconvert->n_sign_posn;\n\t\tcs_precedes = lconvert->n_cs_precedes;\n\t\tsep_by_space = lconvert->n_sep_by_space;\n\t}\n\telse\n\t{\n\t\tsignsymbol = lconvert->positive_sign;\n\t\tsign_posn = lconvert->p_sign_posn;\n\t\tcs_precedes = lconvert->p_cs_precedes;\n\t\tsep_by_space = lconvert->p_sep_by_space;\n\t}\n\n\t/* we build the digits+decimal-point+sep string right-to-left in buf[] */\n\tbufptr = buf + sizeof(buf) - 1;\n\t*bufptr = '\\0';\n\n\t/*\n\t * Generate digits till there are no non-zero digits left and we emitted\n\t * at least one to the left of the decimal point.  digit_pos is the\n\t * current digit position, with zero as the digit just left of the decimal\n\t * point, increasing to the right.\n\t */\n\tdigit_pos = points;\n\tdo\n\t{\n\t\tif (points && digit_pos == 0)\n\t\t{\n\t\t\t/* insert decimal point, but not if value cannot be fractional */\n\t\t\t*(--bufptr) = dsymbol;\n\t\t}\n\t\telse if (digit_pos < 0 && (digit_pos % mon_group) == 0)\n\t\t{\n\t\t\t/* insert thousands sep, but only to left of radix point */\n\t\t\tbufptr -= strlen(ssymbol);\n\t\t\tmemcpy(bufptr, ssymbol, strlen(ssymbol));\n\t\t}\n\n\t\t*(--bufptr) = ((uint64) value % 10) + '0';\n\t\tvalue = ((uint64) value) / 10;\n\t\tdigit_pos--;\n\t} while (value || digit_pos >= 0);\n\n\t/*----------\n\t * Now, attach currency symbol and sign symbol in the correct order.\n\t *\n\t * The POSIX spec defines these values controlling this code:\n\t *\n\t * p/n_sign_posn:\n\t *\t0\tParentheses enclose the quantity and the currency_symbol.\n\t *\t1\tThe sign string precedes the quantity and the currency_symbol.\n\t *\t2\tThe sign string succeeds the quantity and the currency_symbol.\n\t *\t3\tThe sign string precedes the currency_symbol.\n\t *\t4\tThe sign string succeeds the currency_symbol.\n\t *\n\t * p/n_cs_precedes: 0 means currency symbol after value, else before it.\n\t *\n\t * p/n_sep_by_space:\n\t *\t0\tNo <space> separates the currency symbol and value.\n\t *\t1\tIf the currency symbol and sign string are adjacent, a <space>\n\t *\t\tseparates them from the value; otherwise, a <space> separates\n\t *\t\tthe currency symbol from the value.\n\t *\t2\tIf the currency symbol and sign string are adjacent, a <space>\n\t *\t\tseparates them; otherwise, a <space> separates the sign string\n\t *\t\tfrom the value.\n\t *----------\n\t */\n\tswitch (sign_posn)\n\t{\n\t\tcase 0:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"(%s%s%s)\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"(%s%s%s)\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol);\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (cs_precedes)\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  bufptr);\n\t\t\telse\n\t\t\t\tresult = psprintf(\"%s%s%s%s%s\",\n\t\t\t\t\t\t\t\t  bufptr,\n\t\t\t\t\t\t\t\t  (sep_by_space == 1) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  csymbol,\n\t\t\t\t\t\t\t\t  (sep_by_space == 2) ? \" \" : \"\",\n\t\t\t\t\t\t\t\t  signsymbol);\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "cash_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "96-302",
    "snippet": "Datum\ncash_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tCash\t\tresult;\n\tCash\t\tvalue = 0;\n\tCash\t\tdec = 0;\n\tCash\t\tsgn = 1;\n\tbool\t\tseen_dot = false;\n\tconst char *s = str;\n\tint\t\t\tfpoint;\n\tchar\t\tdsymbol;\n\tconst char *ssymbol,\n\t\t\t   *psymbol,\n\t\t\t   *nsymbol,\n\t\t\t   *csymbol;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/*\n\t * frac_digits will be CHAR_MAX in some locales, notably C.  However, just\n\t * testing for == CHAR_MAX is risky, because of compilers like gcc that\n\t * \"helpfully\" let you alter the platform-standard definition of whether\n\t * char is signed or not.  If we are so unfortunate as to get compiled\n\t * with a nonstandard -fsigned-char or -funsigned-char switch, then our\n\t * idea of CHAR_MAX will not agree with libc's. The safest course is not\n\t * to test for CHAR_MAX at all, but to impose a range check for plausible\n\t * frac_digits values.\n\t */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\t\t\t\t/* best guess in this case, I think */\n\n\t/* we restrict dsymbol to be a single byte, but not the other symbols */\n\tif (*lconvert->mon_decimal_point != '\\0' &&\n\t\tlconvert->mon_decimal_point[1] == '\\0')\n\t\tdsymbol = *lconvert->mon_decimal_point;\n\telse\n\t\tdsymbol = '.';\n\tif (*lconvert->mon_thousands_sep != '\\0')\n\t\tssymbol = lconvert->mon_thousands_sep;\n\telse\t\t\t\t\t\t/* ssymbol should not equal dsymbol */\n\t\tssymbol = (dsymbol != ',') ? \",\" : \".\";\n\tcsymbol = (*lconvert->currency_symbol != '\\0') ? lconvert->currency_symbol : \"$\";\n\tpsymbol = (*lconvert->positive_sign != '\\0') ? lconvert->positive_sign : \"+\";\n\tnsymbol = (*lconvert->negative_sign != '\\0') ? lconvert->negative_sign : \"-\";\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- precision '%d'; decimal '%c'; thousands '%s'; currency '%s'; positive '%s'; negative '%s'\\n\",\n\t\t   fpoint, dsymbol, ssymbol, csymbol, psymbol, nsymbol);\n#endif\n\n\t/* we need to add all sorts of checking here.  For now just */\n\t/* strip all leading whitespace and any leading currency symbol */\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (strncmp(s, csymbol, strlen(csymbol)) == 0)\n\t\ts += strlen(csymbol);\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- string is '%s'\\n\", s);\n#endif\n\n\t/* a leading minus or paren signifies a negative number */\n\t/* again, better heuristics needed */\n\t/* XXX - doesn't properly check for balanced parens - djmc */\n\tif (strncmp(s, nsymbol, strlen(nsymbol)) == 0)\n\t{\n\t\tsgn = -1;\n\t\ts += strlen(nsymbol);\n\t}\n\telse if (*s == '(')\n\t{\n\t\tsgn = -1;\n\t\ts++;\n\t}\n\telse if (strncmp(s, psymbol, strlen(psymbol)) == 0)\n\t\ts += strlen(psymbol);\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- string is '%s'\\n\", s);\n#endif\n\n\t/* allow whitespace and currency symbol after the sign, too */\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (strncmp(s, csymbol, strlen(csymbol)) == 0)\n\t\ts += strlen(csymbol);\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- string is '%s'\\n\", s);\n#endif\n\n\t/*\n\t * We accumulate the absolute amount in \"value\" and then apply the sign at\n\t * the end.  (The sign can appear before or after the digits, so it would\n\t * be more complicated to do otherwise.)  Because of the larger range of\n\t * negative signed integers, we build \"value\" in the negative and then\n\t * flip the sign at the end, catching most-negative-number overflow if\n\t * necessary.\n\t */\n\n\tfor (; *s; s++)\n\t{\n\t\t/*\n\t\t * We look for digits as long as we have found less than the required\n\t\t * number of decimal places.\n\t\t */\n\t\tif (isdigit((unsigned char) *s) && (!seen_dot || dec < fpoint))\n\t\t{\n\t\t\tint8\t\tdigit = *s - '0';\n\n\t\t\tif (pg_mul_s64_overflow(value, 10, &value) ||\n\t\t\t\tpg_sub_s64_overflow(value, digit, &value))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\t\tstr, \"money\")));\n\n\t\t\tif (seen_dot)\n\t\t\t\tdec++;\n\t\t}\n\t\t/* decimal point? then start counting fractions... */\n\t\telse if (*s == dsymbol && !seen_dot)\n\t\t{\n\t\t\tseen_dot = true;\n\t\t}\n\t\t/* ignore if \"thousands\" separator, else we're done */\n\t\telse if (strncmp(s, ssymbol, strlen(ssymbol)) == 0)\n\t\t\ts += strlen(ssymbol) - 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* round off if there's another digit */\n\tif (isdigit((unsigned char) *s) && *s >= '5')\n\t{\n\t\t/* remember we build the value in the negative */\n\t\tif (pg_sub_s64_overflow(value, 1, &value))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\")));\n\t}\n\n\t/* adjust for less than required decimal places */\n\tfor (; dec < fpoint; dec++)\n\t{\n\t\tif (pg_mul_s64_overflow(value, 10, &value))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\")));\n\t}\n\n\t/*\n\t * should only be trailing digits followed by whitespace, right paren,\n\t * trailing sign, and/or trailing currency symbol\n\t */\n\twhile (isdigit((unsigned char) *s))\n\t\ts++;\n\n\twhile (*s)\n\t{\n\t\tif (isspace((unsigned char) *s) || *s == ')')\n\t\t\ts++;\n\t\telse if (strncmp(s, nsymbol, strlen(nsymbol)) == 0)\n\t\t{\n\t\t\tsgn = -1;\n\t\t\ts += strlen(nsymbol);\n\t\t}\n\t\telse if (strncmp(s, psymbol, strlen(psymbol)) == 0)\n\t\t\ts += strlen(psymbol);\n\t\telse if (strncmp(s, csymbol, strlen(csymbol)) == 0)\n\t\t\ts += strlen(csymbol);\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"money\", str)));\n\t}\n\n\t/*\n\t * If the value is supposed to be positive, flip the sign, but check for\n\t * the most negative number.\n\t */\n\tif (sgn > 0)\n\t{\n\t\tif (value == PG_INT64_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\")));\n\t\tresult = -value;\n\t}\n\telse\n\t\tresult = value;\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- result is \" INT64_FORMAT \"\\n\", result);\n#endif\n\n\tPG_RETURN_CASH(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CASH",
          "args": [
            "result"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cashin- result is \" INT64_FORMAT \"\\n\"",
            "result"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\"))"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value \\\"%s\\\" is out of range for type %s\"",
            "str",
            "\"money\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"money\", str))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "csymbol"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "s",
            "csymbol",
            "strlen(csymbol)"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\"))"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mul_s64_overflow",
          "args": [
            "value",
            "10",
            "&value"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\"))"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_sub_s64_overflow",
          "args": [
            "value",
            "1",
            "&value"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\t\tstr, \"money\"))"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_sub_s64_overflow",
          "args": [
            "value",
            "digit",
            "&value"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mul_s64_overflow",
          "args": [
            "value",
            "10",
            "&value"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cashin- string is '%s'\\n\"",
            "s"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cashin- string is '%s'\\n\"",
            "s"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cashin- string is '%s'\\n\"",
            "s"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cashin- precision '%d'; decimal '%c'; thousands '%s'; currency '%s'; positive '%s'; negative '%s'\\n\"",
            "fpoint",
            "dsymbol",
            "ssymbol",
            "csymbol",
            "psymbol",
            "nsymbol"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ncash_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tCash\t\tresult;\n\tCash\t\tvalue = 0;\n\tCash\t\tdec = 0;\n\tCash\t\tsgn = 1;\n\tbool\t\tseen_dot = false;\n\tconst char *s = str;\n\tint\t\t\tfpoint;\n\tchar\t\tdsymbol;\n\tconst char *ssymbol,\n\t\t\t   *psymbol,\n\t\t\t   *nsymbol,\n\t\t\t   *csymbol;\n\tstruct lconv *lconvert = PGLC_localeconv();\n\n\t/*\n\t * frac_digits will be CHAR_MAX in some locales, notably C.  However, just\n\t * testing for == CHAR_MAX is risky, because of compilers like gcc that\n\t * \"helpfully\" let you alter the platform-standard definition of whether\n\t * char is signed or not.  If we are so unfortunate as to get compiled\n\t * with a nonstandard -fsigned-char or -funsigned-char switch, then our\n\t * idea of CHAR_MAX will not agree with libc's. The safest course is not\n\t * to test for CHAR_MAX at all, but to impose a range check for plausible\n\t * frac_digits values.\n\t */\n\tfpoint = lconvert->frac_digits;\n\tif (fpoint < 0 || fpoint > 10)\n\t\tfpoint = 2;\t\t\t\t/* best guess in this case, I think */\n\n\t/* we restrict dsymbol to be a single byte, but not the other symbols */\n\tif (*lconvert->mon_decimal_point != '\\0' &&\n\t\tlconvert->mon_decimal_point[1] == '\\0')\n\t\tdsymbol = *lconvert->mon_decimal_point;\n\telse\n\t\tdsymbol = '.';\n\tif (*lconvert->mon_thousands_sep != '\\0')\n\t\tssymbol = lconvert->mon_thousands_sep;\n\telse\t\t\t\t\t\t/* ssymbol should not equal dsymbol */\n\t\tssymbol = (dsymbol != ',') ? \",\" : \".\";\n\tcsymbol = (*lconvert->currency_symbol != '\\0') ? lconvert->currency_symbol : \"$\";\n\tpsymbol = (*lconvert->positive_sign != '\\0') ? lconvert->positive_sign : \"+\";\n\tnsymbol = (*lconvert->negative_sign != '\\0') ? lconvert->negative_sign : \"-\";\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- precision '%d'; decimal '%c'; thousands '%s'; currency '%s'; positive '%s'; negative '%s'\\n\",\n\t\t   fpoint, dsymbol, ssymbol, csymbol, psymbol, nsymbol);\n#endif\n\n\t/* we need to add all sorts of checking here.  For now just */\n\t/* strip all leading whitespace and any leading currency symbol */\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (strncmp(s, csymbol, strlen(csymbol)) == 0)\n\t\ts += strlen(csymbol);\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- string is '%s'\\n\", s);\n#endif\n\n\t/* a leading minus or paren signifies a negative number */\n\t/* again, better heuristics needed */\n\t/* XXX - doesn't properly check for balanced parens - djmc */\n\tif (strncmp(s, nsymbol, strlen(nsymbol)) == 0)\n\t{\n\t\tsgn = -1;\n\t\ts += strlen(nsymbol);\n\t}\n\telse if (*s == '(')\n\t{\n\t\tsgn = -1;\n\t\ts++;\n\t}\n\telse if (strncmp(s, psymbol, strlen(psymbol)) == 0)\n\t\ts += strlen(psymbol);\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- string is '%s'\\n\", s);\n#endif\n\n\t/* allow whitespace and currency symbol after the sign, too */\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif (strncmp(s, csymbol, strlen(csymbol)) == 0)\n\t\ts += strlen(csymbol);\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- string is '%s'\\n\", s);\n#endif\n\n\t/*\n\t * We accumulate the absolute amount in \"value\" and then apply the sign at\n\t * the end.  (The sign can appear before or after the digits, so it would\n\t * be more complicated to do otherwise.)  Because of the larger range of\n\t * negative signed integers, we build \"value\" in the negative and then\n\t * flip the sign at the end, catching most-negative-number overflow if\n\t * necessary.\n\t */\n\n\tfor (; *s; s++)\n\t{\n\t\t/*\n\t\t * We look for digits as long as we have found less than the required\n\t\t * number of decimal places.\n\t\t */\n\t\tif (isdigit((unsigned char) *s) && (!seen_dot || dec < fpoint))\n\t\t{\n\t\t\tint8\t\tdigit = *s - '0';\n\n\t\t\tif (pg_mul_s64_overflow(value, 10, &value) ||\n\t\t\t\tpg_sub_s64_overflow(value, digit, &value))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\t\tstr, \"money\")));\n\n\t\t\tif (seen_dot)\n\t\t\t\tdec++;\n\t\t}\n\t\t/* decimal point? then start counting fractions... */\n\t\telse if (*s == dsymbol && !seen_dot)\n\t\t{\n\t\t\tseen_dot = true;\n\t\t}\n\t\t/* ignore if \"thousands\" separator, else we're done */\n\t\telse if (strncmp(s, ssymbol, strlen(ssymbol)) == 0)\n\t\t\ts += strlen(ssymbol) - 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* round off if there's another digit */\n\tif (isdigit((unsigned char) *s) && *s >= '5')\n\t{\n\t\t/* remember we build the value in the negative */\n\t\tif (pg_sub_s64_overflow(value, 1, &value))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\")));\n\t}\n\n\t/* adjust for less than required decimal places */\n\tfor (; dec < fpoint; dec++)\n\t{\n\t\tif (pg_mul_s64_overflow(value, 10, &value))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\")));\n\t}\n\n\t/*\n\t * should only be trailing digits followed by whitespace, right paren,\n\t * trailing sign, and/or trailing currency symbol\n\t */\n\twhile (isdigit((unsigned char) *s))\n\t\ts++;\n\n\twhile (*s)\n\t{\n\t\tif (isspace((unsigned char) *s) || *s == ')')\n\t\t\ts++;\n\t\telse if (strncmp(s, nsymbol, strlen(nsymbol)) == 0)\n\t\t{\n\t\t\tsgn = -1;\n\t\t\ts += strlen(nsymbol);\n\t\t}\n\t\telse if (strncmp(s, psymbol, strlen(psymbol)) == 0)\n\t\t\ts += strlen(psymbol);\n\t\telse if (strncmp(s, csymbol, strlen(csymbol)) == 0)\n\t\t\ts += strlen(csymbol);\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"money\", str)));\n\t}\n\n\t/*\n\t * If the value is supposed to be positive, flip the sign, but check for\n\t * the most negative number.\n\t */\n\tif (sgn > 0)\n\t{\n\t\tif (value == PG_INT64_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\t\tstr, \"money\")));\n\t\tresult = -value;\n\t}\n\telse\n\t\tresult = value;\n\n#ifdef CASHDEBUG\n\tprintf(\"cashin- result is \" INT64_FORMAT \"\\n\", result);\n#endif\n\n\tPG_RETURN_CASH(result);\n}"
  },
  {
    "function_name": "num_word",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/cash.c",
    "lines": "38-88",
    "snippet": "static const char *\nnum_word(Cash value)\n{\n\tstatic char buf[128];\n\tstatic const char *small[] = {\n\t\t\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\",\n\t\t\"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n\t\t\"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n\t\t\"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"\n\t};\n\tconst char **big = small + 18;\n\tint\t\t\ttu = value % 100;\n\n\t/* deal with the simple cases first */\n\tif (value <= 20)\n\t\treturn small[value];\n\n\t/* is it an even multiple of 100? */\n\tif (!tu)\n\t{\n\t\tsprintf(buf, \"%s hundred\", small[value / 100]);\n\t\treturn buf;\n\t}\n\n\t/* more than 99? */\n\tif (value > 99)\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s hundred %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s hundred and %s\",\n\t\t\t\t\tsmall[value / 100], small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s hundred %s %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10], small[tu % 10]);\n\t}\n\telse\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s\", big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s\", small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s %s\", big[tu / 10], small[tu % 10]);\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/cash.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"common/int.h\"",
      "#include <math.h>",
      "#include <ctype.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s %s\"",
            "big[tu / 10]",
            "small[tu % 10]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\"",
            "small[tu]"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\"",
            "big[tu / 10]"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s hundred %s %s\"",
            "small[value / 100]",
            "big[tu / 10]",
            "small[tu % 10]"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s hundred and %s\"",
            "small[value / 100]",
            "small[tu]"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s hundred %s\"",
            "small[value / 100]",
            "big[tu / 10]"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s hundred\"",
            "small[value / 100]"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/cash.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const char *\nnum_word(Cash value)\n{\n\tstatic char buf[128];\n\tstatic const char *small[] = {\n\t\t\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\",\n\t\t\"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n\t\t\"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n\t\t\"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"\n\t};\n\tconst char **big = small + 18;\n\tint\t\t\ttu = value % 100;\n\n\t/* deal with the simple cases first */\n\tif (value <= 20)\n\t\treturn small[value];\n\n\t/* is it an even multiple of 100? */\n\tif (!tu)\n\t{\n\t\tsprintf(buf, \"%s hundred\", small[value / 100]);\n\t\treturn buf;\n\t}\n\n\t/* more than 99? */\n\tif (value > 99)\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s hundred %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s hundred and %s\",\n\t\t\t\t\tsmall[value / 100], small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s hundred %s %s\",\n\t\t\t\t\tsmall[value / 100], big[tu / 10], small[tu % 10]);\n\t}\n\telse\n\t{\n\t\t/* is it an even multiple of 10 other than 10? */\n\t\tif (value % 10 == 0 && tu > 10)\n\t\t\tsprintf(buf, \"%s\", big[tu / 10]);\n\t\telse if (tu < 20)\n\t\t\tsprintf(buf, \"%s\", small[tu]);\n\t\telse\n\t\t\tsprintf(buf, \"%s %s\", big[tu / 10], small[tu % 10]);\n\t}\n\n\treturn buf;\n}"
  }
]