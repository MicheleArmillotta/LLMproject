[
  {
    "function_name": "pg_timezone_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4766-4876",
    "snippet": "Datum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "funcctx->tuple_desc",
            "values",
            "nulls"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "tm.tm_isdst > 0"
          ],
          "line": 4870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "resInterval"
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2interval",
          "args": [
            "&itm",
            "0",
            "resInterval"
          ],
          "line": 4867
        },
        "resolved": true,
        "details": {
          "function_name": "tm2interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1929-1943",
          "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&itm",
            "0",
            "sizeof(struct pg_tm)"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "tzn ? tzn : \"\""
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "pg_get_timezone_name(tz)"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_get_timezone_name",
          "args": [
            "tz"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "nulls",
            "0",
            "sizeof(nulls)"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tzn",
            "\"Local time zone must be set--see zic manual page\""
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "GetCurrentTransactionStartTimestamp()",
            "&tzoff",
            "&tm",
            "&fsec",
            "&tzn",
            "tz"
          ],
          "line": 4838
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzenumerate_end",
          "args": [
            "tzenum"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzenumerate_next",
          "args": [
            "tzenum"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 4820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 4816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 4",
            "\"is_dst\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"utc_offset\"",
            "INTERVALOID",
            "-1",
            "0"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"abbrev\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"name\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 4806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "4",
            "false"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzenumerate_start",
          "args": [],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 4795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nDatum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}"
  },
  {
    "function_name": "pg_timezone_abbrevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4638-4760",
    "snippet": "Datum\npg_timezone_abbrevs(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tint\t\t   *pindex;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[3];\n\tbool\t\tnulls[3];\n\tconst datetkn *tp;\n\tchar\t\tbuffer[TOKMAXLEN + 1];\n\tint\t\t\tgmtoffset;\n\tbool\t\tis_dst;\n\tunsigned char *p;\n\tstruct pg_tm tm;\n\tInterval   *resInterval;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tMemoryContext oldcontext;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* allocate memory for user context */\n\t\tpindex = (int *) palloc(sizeof(int));\n\t\t*pindex = 0;\n\t\tfuncctx->user_fctx = (void *) pindex;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\tpindex = (int *) funcctx->user_fctx;\n\n\tif (zoneabbrevtbl == NULL ||\n\t\t*pindex >= zoneabbrevtbl->numabbrevs)\n\t\tSRF_RETURN_DONE(funcctx);\n\n\ttp = zoneabbrevtbl->abbrevs + *pindex;\n\n\tswitch (tp->type)\n\t{\n\t\tcase TZ:\n\t\t\tgmtoffset = tp->value;\n\t\t\tis_dst = false;\n\t\t\tbreak;\n\t\tcase DTZ:\n\t\t\tgmtoffset = tp->value;\n\t\t\tis_dst = true;\n\t\t\tbreak;\n\t\tcase DYNTZ:\n\t\t\t{\n\t\t\t\t/* Determine the current meaning of the abbrev */\n\t\t\t\tpg_tz\t   *tzp;\n\t\t\t\tTimestampTz now;\n\t\t\t\tint\t\t\tisdst;\n\n\t\t\t\ttzp = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t\t\tnow = GetCurrentTransactionStartTimestamp();\n\t\t\t\tgmtoffset = -DetermineTimeZoneAbbrevOffsetTS(now,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tp->token,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tzp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdst);\n\t\t\t\tis_dst = (bool) isdst;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized timezone type %d\", (int) tp->type);\n\t\t\tgmtoffset = 0;\t\t/* keep compiler quiet */\n\t\t\tis_dst = false;\n\t\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\t/*\n\t * Convert name to text, using upcasing conversion that is the inverse of\n\t * what ParseDateTime() uses.\n\t */\n\tstrlcpy(buffer, tp->token, sizeof(buffer));\n\tfor (p = (unsigned char *) buffer; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\tvalues[0] = CStringGetTextDatum(buffer);\n\n\t/* Convert offset (in seconds) to an interval */\n\tMemSet(&tm, 0, sizeof(struct pg_tm));\n\ttm.tm_sec = gmtoffset;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&tm, 0, resInterval);\n\tvalues[1] = IntervalPGetDatum(resInterval);\n\n\tvalues[2] = BoolGetDatum(is_dst);\n\n\t(*pindex)++;\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
      "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);",
      "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
      "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 4757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "funcctx->tuple_desc",
            "values",
            "nulls"
          ],
          "line": 4756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "is_dst"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "resInterval"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2interval",
          "args": [
            "&tm",
            "0",
            "resInterval"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "tm2interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1929-1943",
          "snippet": "int\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span)\n{\n\tdouble\t\ttotal_months = (double) tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon;\n\n\tif (total_months > INT_MAX || total_months < INT_MIN)\n\t\treturn -1;\n\tspan->month = total_months;\n\tspan->day = tm->tm_mday;\n\tspan->time = (((((tm->tm_hour * INT64CONST(60)) +\n\t\t\t\t\t tm->tm_min) * INT64CONST(60)) +\n\t\t\t\t   tm->tm_sec) * USECS_PER_SEC) + fsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&tm",
            "0",
            "sizeof(struct pg_tm)"
          ],
          "line": 4746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "buffer"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "*p"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buffer",
            "tp->token",
            "sizeof(buffer)"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "nulls",
            "0",
            "sizeof(nulls)"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized timezone type %d\"",
            "(int) tp->type"
          ],
          "line": 4727
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffsetTS",
          "args": [
            "now",
            "tp->token",
            "tzp",
            "&isdst"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffsetTS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1653-1682",
          "snippet": "int\nDetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,\n\t\t\t\t\t\t\t\tpg_tz *tzp, int *isdst)\n{\n\tpg_time_t\tt = timestamptz_to_time_t(ts);\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\t/*\n\t * If the abbrev matches anything in the zone data, this is pretty easy.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, isdst))\n\t\treturn abbr_offset;\n\n\t/*\n\t * Else, break down the timestamp so we can use DetermineTimeZoneOffset.\n\t */\n\tif (timestamp2tm(ts, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tzone_offset = DetermineTimeZoneOffset(&tm, tzp);\n\t*isdst = tm.tm_isdst;\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\n\nint\nDetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,\n\t\t\t\t\t\t\t\tpg_tz *tzp, int *isdst)\n{\n\tpg_time_t\tt = timestamptz_to_time_t(ts);\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\t/*\n\t * If the abbrev matches anything in the zone data, this is pretty easy.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, isdst))\n\t\treturn abbr_offset;\n\n\t/*\n\t * Else, break down the timestamp so we can use DetermineTimeZoneOffset.\n\t */\n\tif (timestamp2tm(ts, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tzone_offset = DetermineTimeZoneOffset(&tm, tzp);\n\t*isdst = tm.tm_isdst;\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FetchDynamicTimeZone",
          "args": [
            "zoneabbrevtbl",
            "tp"
          ],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "FetchDynamicTimeZone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4602-4631",
          "snippet": "static pg_tz *\nFetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp)\n{\n\tDynamicZoneAbbrev *dtza;\n\n\t/* Just some sanity checks to prevent indexing off into nowhere */\n\tAssert(tp->type == DYNTZ);\n\tAssert(tp->value > 0 && tp->value < tbl->tblsize);\n\n\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tp->value);\n\n\t/* Look up the underlying zone if we haven't already */\n\tif (dtza->tz == NULL)\n\t{\n\t\tdtza->tz = pg_tzset(dtza->zone);\n\n\t\t/*\n\t\t * Ideally we'd let the caller ereport instead of doing it here, but\n\t\t * then there is no way to report the bad time zone name.\n\t\t */\n\t\tif (dtza->tz == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token)));\n\t}\n\treturn dtza->tz;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\n\nstatic pg_tz *\nFetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp)\n{\n\tDynamicZoneAbbrev *dtza;\n\n\t/* Just some sanity checks to prevent indexing off into nowhere */\n\tAssert(tp->type == DYNTZ);\n\tAssert(tp->value > 0 && tp->value < tbl->tblsize);\n\n\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tp->value);\n\n\t/* Look up the underlying zone if we haven't already */\n\tif (dtza->tz == NULL)\n\t{\n\t\tdtza->tz = pg_tzset(dtza->zone);\n\n\t\t/*\n\t\t * Ideally we'd let the caller ereport instead of doing it here, but\n\t\t * then there is no way to report the bad time zone name.\n\t\t */\n\t\tif (dtza->tz == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token)));\n\t}\n\treturn dtza->tz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 4687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 4686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"is_dst\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"utc_offset\"",
            "INTERVALOID",
            "-1",
            "0"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"abbrev\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 4679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "3",
            "false"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 4656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\n\nDatum\npg_timezone_abbrevs(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tint\t\t   *pindex;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[3];\n\tbool\t\tnulls[3];\n\tconst datetkn *tp;\n\tchar\t\tbuffer[TOKMAXLEN + 1];\n\tint\t\t\tgmtoffset;\n\tbool\t\tis_dst;\n\tunsigned char *p;\n\tstruct pg_tm tm;\n\tInterval   *resInterval;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tMemoryContext oldcontext;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* allocate memory for user context */\n\t\tpindex = (int *) palloc(sizeof(int));\n\t\t*pindex = 0;\n\t\tfuncctx->user_fctx = (void *) pindex;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\tpindex = (int *) funcctx->user_fctx;\n\n\tif (zoneabbrevtbl == NULL ||\n\t\t*pindex >= zoneabbrevtbl->numabbrevs)\n\t\tSRF_RETURN_DONE(funcctx);\n\n\ttp = zoneabbrevtbl->abbrevs + *pindex;\n\n\tswitch (tp->type)\n\t{\n\t\tcase TZ:\n\t\t\tgmtoffset = tp->value;\n\t\t\tis_dst = false;\n\t\t\tbreak;\n\t\tcase DTZ:\n\t\t\tgmtoffset = tp->value;\n\t\t\tis_dst = true;\n\t\t\tbreak;\n\t\tcase DYNTZ:\n\t\t\t{\n\t\t\t\t/* Determine the current meaning of the abbrev */\n\t\t\t\tpg_tz\t   *tzp;\n\t\t\t\tTimestampTz now;\n\t\t\t\tint\t\t\tisdst;\n\n\t\t\t\ttzp = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t\t\tnow = GetCurrentTransactionStartTimestamp();\n\t\t\t\tgmtoffset = -DetermineTimeZoneAbbrevOffsetTS(now,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tp->token,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tzp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdst);\n\t\t\t\tis_dst = (bool) isdst;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized timezone type %d\", (int) tp->type);\n\t\t\tgmtoffset = 0;\t\t/* keep compiler quiet */\n\t\t\tis_dst = false;\n\t\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\t/*\n\t * Convert name to text, using upcasing conversion that is the inverse of\n\t * what ParseDateTime() uses.\n\t */\n\tstrlcpy(buffer, tp->token, sizeof(buffer));\n\tfor (p = (unsigned char *) buffer; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\tvalues[0] = CStringGetTextDatum(buffer);\n\n\t/* Convert offset (in seconds) to an interval */\n\tMemSet(&tm, 0, sizeof(struct pg_tm));\n\ttm.tm_sec = gmtoffset;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&tm, 0, resInterval);\n\tvalues[1] = IntervalPGetDatum(resInterval);\n\n\tvalues[2] = BoolGetDatum(is_dst);\n\n\t(*pindex)++;\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}"
  },
  {
    "function_name": "FetchDynamicTimeZone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4602-4631",
    "snippet": "static pg_tz *\nFetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp)\n{\n\tDynamicZoneAbbrev *dtza;\n\n\t/* Just some sanity checks to prevent indexing off into nowhere */\n\tAssert(tp->type == DYNTZ);\n\tAssert(tp->value > 0 && tp->value < tbl->tblsize);\n\n\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tp->value);\n\n\t/* Look up the underlying zone if we haven't already */\n\tif (dtza->tz == NULL)\n\t{\n\t\tdtza->tz = pg_tzset(dtza->zone);\n\n\t\t/*\n\t\t * Ideally we'd let the caller ereport instead of doing it here, but\n\t\t * then there is no way to report the bad time zone name.\n\t\t */\n\t\tif (dtza->tz == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token)));\n\t}\n\treturn dtza->tz;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
      "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token))"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\"",
            "tp->token"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"time zone \\\"%s\\\" not recognized\"",
            "dtza->zone"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_CONFIG_FILE_ERROR"
          ],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "dtza->zone"
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tp->value > 0 && tp->value < tbl->tblsize"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tp->type == DYNTZ"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\n\nstatic pg_tz *\nFetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp)\n{\n\tDynamicZoneAbbrev *dtza;\n\n\t/* Just some sanity checks to prevent indexing off into nowhere */\n\tAssert(tp->type == DYNTZ);\n\tAssert(tp->value > 0 && tp->value < tbl->tblsize);\n\n\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tp->value);\n\n\t/* Look up the underlying zone if we haven't already */\n\tif (dtza->tz == NULL)\n\t{\n\t\tdtza->tz = pg_tzset(dtza->zone);\n\n\t\t/*\n\t\t * Ideally we'd let the caller ereport instead of doing it here, but\n\t\t * then there is no way to report the bad time zone name.\n\t\t */\n\t\tif (dtza->tz == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token)));\n\t}\n\treturn dtza->tz;\n}"
  },
  {
    "function_name": "InstallTimeZoneAbbrevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4591-4597",
    "snippet": "void\nInstallTimeZoneAbbrevs(TimeZoneAbbrevTable *tbl)\n{\n\tzoneabbrevtbl = tbl;\n\t/* reset abbrevcache, which may contain pointers into old table */\n\tmemset(abbrevcache, 0, sizeof(abbrevcache));\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
      "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "abbrevcache",
            "0",
            "sizeof(abbrevcache)"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nvoid\nInstallTimeZoneAbbrevs(TimeZoneAbbrevTable *tbl)\n{\n\tzoneabbrevtbl = tbl;\n\t/* reset abbrevcache, which may contain pointers into old table */\n\tmemset(abbrevcache, 0, sizeof(abbrevcache));\n}"
  },
  {
    "function_name": "ConvertTimeZoneAbbrevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4507-4584",
    "snippet": "TimeZoneAbbrevTable *\nConvertTimeZoneAbbrevs(struct tzEntry *abbrevs, int n)\n{\n\tTimeZoneAbbrevTable *tbl;\n\tSize\t\ttbl_size;\n\tint\t\t\ti;\n\n\t/* Space for fixed fields and datetkn array */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\t/* Count up space for dynamic abbreviations */\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\tSize\t\tdsize;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t}\n\n\t/* Alloc the result ... */\n\ttbl = malloc(tbl_size);\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* ... and fill it in */\n\ttbl->tblsize = tbl_size;\n\ttbl->numabbrevs = n;\n\t/* in this loop, tbl_size reprises the space calculation above */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\t\tdatetkn    *dtoken = tbl->abbrevs + i;\n\n\t\t/* use strlcpy to truncate name if necessary */\n\t\tstrlcpy(dtoken->token, abbr->abbrev, TOKMAXLEN + 1);\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\t/* Allocate a DynamicZoneAbbrev for this abbreviation */\n\t\t\tDynamicZoneAbbrev *dtza;\n\t\t\tSize\t\tdsize;\n\n\t\t\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tbl_size);\n\t\t\tdtza->tz = NULL;\n\t\t\tstrcpy(dtza->zone, abbr->zone);\n\n\t\t\tdtoken->type = DYNTZ;\n\t\t\t/* value is offset from table start to DynamicZoneAbbrev */\n\t\t\tdtoken->value = (int32) tbl_size;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdtoken->type = abbr->is_dst ? DTZ : TZ;\n\t\t\tdtoken->value = abbr->offset;\n\t\t}\n\t}\n\n\t/* Assert the two loops above agreed on size calculations */\n\tAssert(tbl->tblsize == tbl_size);\n\n\t/* Check the ordering, if testing */\n\tAssert(CheckDateTokenTable(\"timezone abbreviations\", tbl->abbrevs, n));\n\n\treturn tbl;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CheckDateTokenTable(\"timezone abbreviations\", tbl->abbrevs, n)"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckDateTokenTable",
          "args": [
            "\"timezone abbreviations\"",
            "tbl->abbrevs",
            "n"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "CheckDateTokenTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4420-4450",
          "snippet": "static bool\nCheckDateTokenTable(const char *tablename, const datetkn *base, int nel)\n{\n\tbool\t\tok = true;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nel; i++)\n\t{\n\t\t/* check for token strings that don't fit */\n\t\tif (strlen(base[i].token) > TOKMAXLEN)\n\t\t{\n\t\t\t/* %.*s is safe since all our tokens are ASCII */\n\t\t\telog(LOG, \"token too long in %s table: \\\"%.*s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t TOKMAXLEN + 1, base[i].token);\n\t\t\tok = false;\n\t\t\tbreak;\t\t\t\t/* don't risk applying strcmp */\n\t\t}\n\t\t/* check for out of order */\n\t\tif (i > 0 &&\n\t\t\tstrcmp(base[i - 1].token, base[i].token) >= 0)\n\t\t{\n\t\t\telog(LOG, \"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t base[i - 1].token,\n\t\t\t\t base[i].token);\n\t\t\tok = false;\n\t\t}\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic bool\nCheckDateTokenTable(const char *tablename, const datetkn *base, int nel)\n{\n\tbool\t\tok = true;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nel; i++)\n\t{\n\t\t/* check for token strings that don't fit */\n\t\tif (strlen(base[i].token) > TOKMAXLEN)\n\t\t{\n\t\t\t/* %.*s is safe since all our tokens are ASCII */\n\t\t\telog(LOG, \"token too long in %s table: \\\"%.*s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t TOKMAXLEN + 1, base[i].token);\n\t\t\tok = false;\n\t\t\tbreak;\t\t\t\t/* don't risk applying strcmp */\n\t\t}\n\t\t/* check for out of order */\n\t\tif (i > 0 &&\n\t\t\tstrcmp(base[i - 1].token, base[i].token) >= 0)\n\t\t{\n\t\t\telog(LOG, \"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t base[i - 1].token,\n\t\t\t\t base[i].token);\n\t\t\tok = false;\n\t\t}\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tbl->tblsize == tbl_size"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "dsize"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "abbr->zone"
          ],
          "line": 4567
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dtza->zone",
            "abbr->zone"
          ],
          "line": 4560
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "dtoken->token",
            "abbr->abbrev",
            "TOKMAXLEN + 1"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "tbl_size"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "tbl_size"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "dsize"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "tbl_size"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimeZoneAbbrevTable *\nConvertTimeZoneAbbrevs(struct tzEntry *abbrevs, int n)\n{\n\tTimeZoneAbbrevTable *tbl;\n\tSize\t\ttbl_size;\n\tint\t\t\ti;\n\n\t/* Space for fixed fields and datetkn array */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\t/* Count up space for dynamic abbreviations */\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\tSize\t\tdsize;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t}\n\n\t/* Alloc the result ... */\n\ttbl = malloc(tbl_size);\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* ... and fill it in */\n\ttbl->tblsize = tbl_size;\n\ttbl->numabbrevs = n;\n\t/* in this loop, tbl_size reprises the space calculation above */\n\ttbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +\n\t\tn * sizeof(datetkn);\n\ttbl_size = MAXALIGN(tbl_size);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstruct tzEntry *abbr = abbrevs + i;\n\t\tdatetkn    *dtoken = tbl->abbrevs + i;\n\n\t\t/* use strlcpy to truncate name if necessary */\n\t\tstrlcpy(dtoken->token, abbr->abbrev, TOKMAXLEN + 1);\n\t\tif (abbr->zone != NULL)\n\t\t{\n\t\t\t/* Allocate a DynamicZoneAbbrev for this abbreviation */\n\t\t\tDynamicZoneAbbrev *dtza;\n\t\t\tSize\t\tdsize;\n\n\t\t\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tbl_size);\n\t\t\tdtza->tz = NULL;\n\t\t\tstrcpy(dtza->zone, abbr->zone);\n\n\t\t\tdtoken->type = DYNTZ;\n\t\t\t/* value is offset from table start to DynamicZoneAbbrev */\n\t\t\tdtoken->value = (int32) tbl_size;\n\n\t\t\tdsize = offsetof(DynamicZoneAbbrev, zone) +\n\t\t\t\tstrlen(abbr->zone) + 1;\n\t\t\ttbl_size += MAXALIGN(dsize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdtoken->type = abbr->is_dst ? DTZ : TZ;\n\t\t\tdtoken->value = abbr->offset;\n\t\t}\n\t}\n\n\t/* Assert the two loops above agreed on size calculations */\n\tAssert(tbl->tblsize == tbl_size);\n\n\t/* Check the ordering, if testing */\n\tAssert(CheckDateTokenTable(\"timezone abbreviations\", tbl->abbrevs, n));\n\n\treturn tbl;\n}"
  },
  {
    "function_name": "TemporalTransform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4474-4497",
    "snippet": "Node *\nTemporalTransform(int32 max_precis, Node *node)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, node);\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_precis = exprTypmod(source);\n\t\tint32\t\tnew_precis = DatumGetInt32(((Const *) typmod)->constvalue);\n\n\t\tif (new_precis < 0 || new_precis == max_precis ||\n\t\t\t(old_precis >= 0 && new_precis >= old_precis))\n\t\t\tret = relabel_to_typmod(source, new_precis);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relabel_to_typmod",
          "args": [
            "source",
            "new_precis"
          ],
          "line": 4493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "((Const *) typmod)->constvalue"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprTypmod",
          "args": [
            "source"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "expr->args"
          ],
          "line": 4487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "typmod",
            "Const"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "expr->args"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list_length(expr->args) >= 2"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "expr->args"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "FuncExpr",
            "node"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nNode *\nTemporalTransform(int32 max_precis, Node *node)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, node);\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_precis = exprTypmod(source);\n\t\tint32\t\tnew_precis = DatumGetInt32(((Const *) typmod)->constvalue);\n\n\t\tif (new_precis < 0 || new_precis == max_precis ||\n\t\t\t(old_precis >= 0 && new_precis >= old_precis))\n\t\t\tret = relabel_to_typmod(source, new_precis);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "CheckDateTokenTables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4452-4463",
    "snippet": "bool\nCheckDateTokenTables(void)\n{\n\tbool\t\tok = true;\n\n\tAssert(UNIX_EPOCH_JDATE == date2j(1970, 1, 1));\n\tAssert(POSTGRES_EPOCH_JDATE == date2j(2000, 1, 1));\n\n\tok &= CheckDateTokenTable(\"datetktbl\", datetktbl, szdatetktbl);\n\tok &= CheckDateTokenTable(\"deltatktbl\", deltatktbl, szdeltatktbl);\n\treturn ok;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
      "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
      "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
      "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckDateTokenTable",
          "args": [
            "\"deltatktbl\"",
            "deltatktbl",
            "szdeltatktbl"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "CheckDateTokenTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4420-4450",
          "snippet": "static bool\nCheckDateTokenTable(const char *tablename, const datetkn *base, int nel)\n{\n\tbool\t\tok = true;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nel; i++)\n\t{\n\t\t/* check for token strings that don't fit */\n\t\tif (strlen(base[i].token) > TOKMAXLEN)\n\t\t{\n\t\t\t/* %.*s is safe since all our tokens are ASCII */\n\t\t\telog(LOG, \"token too long in %s table: \\\"%.*s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t TOKMAXLEN + 1, base[i].token);\n\t\t\tok = false;\n\t\t\tbreak;\t\t\t\t/* don't risk applying strcmp */\n\t\t}\n\t\t/* check for out of order */\n\t\tif (i > 0 &&\n\t\t\tstrcmp(base[i - 1].token, base[i].token) >= 0)\n\t\t{\n\t\t\telog(LOG, \"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t base[i - 1].token,\n\t\t\t\t base[i].token);\n\t\t\tok = false;\n\t\t}\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic bool\nCheckDateTokenTable(const char *tablename, const datetkn *base, int nel)\n{\n\tbool\t\tok = true;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nel; i++)\n\t{\n\t\t/* check for token strings that don't fit */\n\t\tif (strlen(base[i].token) > TOKMAXLEN)\n\t\t{\n\t\t\t/* %.*s is safe since all our tokens are ASCII */\n\t\t\telog(LOG, \"token too long in %s table: \\\"%.*s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t TOKMAXLEN + 1, base[i].token);\n\t\t\tok = false;\n\t\t\tbreak;\t\t\t\t/* don't risk applying strcmp */\n\t\t}\n\t\t/* check for out of order */\n\t\tif (i > 0 &&\n\t\t\tstrcmp(base[i - 1].token, base[i].token) >= 0)\n\t\t{\n\t\t\telog(LOG, \"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t base[i - 1].token,\n\t\t\t\t base[i].token);\n\t\t\tok = false;\n\t\t}\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "POSTGRES_EPOCH_JDATE == date2j(2000, 1, 1)"
          ],
          "line": 4458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "2000",
            "1",
            "1"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "UNIX_EPOCH_JDATE == date2j(1970, 1, 1)"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\n\nbool\nCheckDateTokenTables(void)\n{\n\tbool\t\tok = true;\n\n\tAssert(UNIX_EPOCH_JDATE == date2j(1970, 1, 1));\n\tAssert(POSTGRES_EPOCH_JDATE == date2j(2000, 1, 1));\n\n\tok &= CheckDateTokenTable(\"datetktbl\", datetktbl, szdatetktbl);\n\tok &= CheckDateTokenTable(\"deltatktbl\", deltatktbl, szdeltatktbl);\n\treturn ok;\n}"
  },
  {
    "function_name": "CheckDateTokenTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4420-4450",
    "snippet": "static bool\nCheckDateTokenTable(const char *tablename, const datetkn *base, int nel)\n{\n\tbool\t\tok = true;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nel; i++)\n\t{\n\t\t/* check for token strings that don't fit */\n\t\tif (strlen(base[i].token) > TOKMAXLEN)\n\t\t{\n\t\t\t/* %.*s is safe since all our tokens are ASCII */\n\t\t\telog(LOG, \"token too long in %s table: \\\"%.*s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t TOKMAXLEN + 1, base[i].token);\n\t\t\tok = false;\n\t\t\tbreak;\t\t\t\t/* don't risk applying strcmp */\n\t\t}\n\t\t/* check for out of order */\n\t\tif (i > 0 &&\n\t\t\tstrcmp(base[i - 1].token, base[i].token) >= 0)\n\t\t{\n\t\t\telog(LOG, \"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t base[i - 1].token,\n\t\t\t\t base[i].token);\n\t\t\tok = false;\n\t\t}\n\t}\n\treturn ok;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\"",
            "tablename",
            "base[i - 1].token",
            "base[i].token"
          ],
          "line": 4442
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "base[i - 1].token",
            "base[i].token"
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base[i].token"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic bool\nCheckDateTokenTable(const char *tablename, const datetkn *base, int nel)\n{\n\tbool\t\tok = true;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nel; i++)\n\t{\n\t\t/* check for token strings that don't fit */\n\t\tif (strlen(base[i].token) > TOKMAXLEN)\n\t\t{\n\t\t\t/* %.*s is safe since all our tokens are ASCII */\n\t\t\telog(LOG, \"token too long in %s table: \\\"%.*s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t TOKMAXLEN + 1, base[i].token);\n\t\t\tok = false;\n\t\t\tbreak;\t\t\t\t/* don't risk applying strcmp */\n\t\t}\n\t\t/* check for out of order */\n\t\tif (i > 0 &&\n\t\t\tstrcmp(base[i - 1].token, base[i].token) >= 0)\n\t\t{\n\t\t\telog(LOG, \"ordering error in %s table: \\\"%s\\\" >= \\\"%s\\\"\",\n\t\t\t\t tablename,\n\t\t\t\t base[i - 1].token,\n\t\t\t\t base[i].token);\n\t\t\tok = false;\n\t\t}\n\t}\n\treturn ok;\n}"
  },
  {
    "function_name": "EncodeInterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4229-4413",
    "snippet": "void\nEncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str)\n{\n\tchar\t   *cp = str;\n\tint\t\t\tyear = tm->tm_year;\n\tint\t\t\tmon = tm->tm_mon;\n\tint\t\t\tmday = tm->tm_mday;\n\tint\t\t\thour = tm->tm_hour;\n\tint\t\t\tmin = tm->tm_min;\n\tint\t\t\tsec = tm->tm_sec;\n\tbool\t\tis_before = false;\n\tbool\t\tis_zero = true;\n\n\t/*\n\t * The sign of year and month are guaranteed to match, since they are\n\t * stored internally as \"month\". But we'll need to check for is_before and\n\t * is_zero when determining the signs of day and hour/minute/seconds\n\t * fields.\n\t */\n\tswitch (style)\n\t{\n\t\t\t/* SQL Standard interval format */\n\t\tcase INTSTYLE_SQL_STANDARD:\n\t\t\t{\n\t\t\t\tbool\t\thas_negative = year < 0 || mon < 0 ||\n\t\t\t\tmday < 0 || hour < 0 ||\n\t\t\t\tmin < 0 || sec < 0 || fsec < 0;\n\t\t\t\tbool\t\thas_positive = year > 0 || mon > 0 ||\n\t\t\t\tmday > 0 || hour > 0 ||\n\t\t\t\tmin > 0 || sec > 0 || fsec > 0;\n\t\t\t\tbool\t\thas_year_month = year != 0 || mon != 0;\n\t\t\t\tbool\t\thas_day_time = mday != 0 || hour != 0 ||\n\t\t\t\tmin != 0 || sec != 0 || fsec != 0;\n\t\t\t\tbool\t\thas_day = mday != 0;\n\t\t\t\tbool\t\tsql_standard_value = !(has_negative && has_positive) &&\n\t\t\t\t!(has_year_month && has_day_time);\n\n\t\t\t\t/*\n\t\t\t\t * SQL Standard wants only 1 \"<sign>\" preceding the whole\n\t\t\t\t * interval ... but can't do that if mixed signs.\n\t\t\t\t */\n\t\t\t\tif (has_negative && sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\t\tyear = -year;\n\t\t\t\t\tmon = -mon;\n\t\t\t\t\tmday = -mday;\n\t\t\t\t\thour = -hour;\n\t\t\t\t\tmin = -min;\n\t\t\t\t\tsec = -sec;\n\t\t\t\t\tfsec = -fsec;\n\t\t\t\t}\n\n\t\t\t\tif (!has_negative && !has_positive)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"0\");\n\t\t\t\t}\n\t\t\t\telse if (!sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For non sql-standard interval values, force outputting\n\t\t\t\t\t * the signs to avoid ambiguities with intervals with\n\t\t\t\t\t * mixed sign components.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tyear_sign = (year < 0 || mon < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tday_sign = (mday < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tsec_sign = (hour < 0 || min < 0 ||\n\t\t\t\t\t\t\t\t\t\t\tsec < 0 || fsec < 0) ? '-' : '+';\n\n\t\t\t\t\tsprintf(cp, \"%c%d-%d %c%d %c%d:%02d:\",\n\t\t\t\t\t\t\tyear_sign, abs(year), abs(mon),\n\t\t\t\t\t\t\tday_sign, abs(mday),\n\t\t\t\t\t\t\tsec_sign, abs(hour), abs(min));\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (has_year_month)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d-%d\", year, mon);\n\t\t\t\t}\n\t\t\t\telse if (has_day)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d %d:%02d:\", mday, hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d:%02d:\", hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ISO 8601 \"time-intervals by duration only\" */\n\t\tcase INTSTYLE_ISO_8601:\n\t\t\t/* special-case zero to avoid printing nothing */\n\t\t\tif (year == 0 && mon == 0 && mday == 0 &&\n\t\t\t\thour == 0 && min == 0 && sec == 0 && fsec == 0)\n\t\t\t{\n\t\t\t\tsprintf(cp, \"PT0S\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*cp++ = 'P';\n\t\t\tcp = AddISO8601IntPart(cp, year, 'Y');\n\t\t\tcp = AddISO8601IntPart(cp, mon, 'M');\n\t\t\tcp = AddISO8601IntPart(cp, mday, 'D');\n\t\t\tif (hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t\t*cp++ = 'T';\n\t\t\tcp = AddISO8601IntPart(cp, hour, 'H');\n\t\t\tcp = AddISO8601IntPart(cp, min, 'M');\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tif (sec < 0 || fsec < 0)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\t*cp++ = 'S';\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle = 'iso' */\n\t\tcase INTSTYLE_POSTGRES:\n\t\t\tcp = AddPostgresIntPart(cp, year, \"year\", &is_zero, &is_before);\n\n\t\t\t/*\n\t\t\t * Ideally we should spell out \"month\" like we do for \"year\" and\n\t\t\t * \"day\".  However, for backward compatibility, we can't easily\n\t\t\t * fix this.  bjm 2011-05-24\n\t\t\t */\n\t\t\tcp = AddPostgresIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddPostgresIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tif (is_zero || hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tbool\t\tminus = (hour < 0 || min < 0 || sec < 0 || fsec < 0);\n\n\t\t\t\tsprintf(cp, \"%s%s%02d:%02d:\",\n\t\t\t\t\t\tis_zero ? \"\" : \" \",\n\t\t\t\t\t\t(minus ? \"-\" : (is_before ? \"+\" : \"\")),\n\t\t\t\t\t\tabs(hour), abs(min));\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle != 'iso' */\n\t\tcase INTSTYLE_POSTGRES_VERBOSE:\n\t\tdefault:\n\t\t\tstrcpy(cp, \"@\");\n\t\t\tcp++;\n\t\t\tcp = AddVerboseIntPart(cp, year, \"year\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, hour, \"hour\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, min, \"min\", &is_zero, &is_before);\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tif (sec < 0 || (sec == 0 && fsec < 0))\n\t\t\t\t{\n\t\t\t\t\tif (is_zero)\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\telse if (!is_before)\n\t\t\t\t\t\t*cp++ = '-';\n\t\t\t\t}\n\t\t\t\telse if (is_before)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\tsprintf(cp, \" sec%s\",\n\t\t\t\t\t\t(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\");\n\t\t\t\tis_zero = false;\n\t\t\t}\n\t\t\t/* identically zero? then put in a unitless zero... */\n\t\t\tif (is_zero)\n\t\t\t\tstrcat(cp, \" 0\");\n\t\t\tif (is_before)\n\t\t\t\tstrcat(cp, \" ago\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cp",
            "\" ago\""
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "225-243",
          "snippet": "int\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\" sec%s\"",
            "(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\""
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "sec"
          ],
          "line": 4403
        },
        "resolved": true,
        "details": {
          "function_name": "float8abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "726-732",
          "snippet": "Datum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendSeconds",
          "args": [
            "cp",
            "sec",
            "fsec",
            "MAX_INTERVAL_PRECISION",
            "false"
          ],
          "line": 4401
        },
        "resolved": true,
        "details": {
          "function_name": "AppendSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "394-448",
          "snippet": "static char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);\n\nstatic char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddVerboseIntPart",
          "args": [
            "cp",
            "min",
            "\"min\"",
            "&is_zero",
            "&is_before"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "AddVerboseIntPart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4190-4207",
          "snippet": "static char *\nAddVerboseIntPart(char *cp, int value, const char *units,\n\t\t\t\t  bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\t/* first nonzero value sets is_before */\n\tif (*is_zero)\n\t{\n\t\t*is_before = (value < 0);\n\t\tvalue = abs(value);\n\t}\n\telse if (*is_before)\n\t\tvalue = -value;\n\tsprintf(cp, \" %d %s%s\", value, units, (value == 1) ? \"\" : \"s\");\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nAddVerboseIntPart(char *cp, int value, const char *units,\n\t\t\t\t  bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\t/* first nonzero value sets is_before */\n\tif (*is_zero)\n\t{\n\t\t*is_before = (value < 0);\n\t\tvalue = abs(value);\n\t}\n\telse if (*is_before)\n\t\tvalue = -value;\n\tsprintf(cp, \" %d %s%s\", value, units, (value == 1) ? \"\" : \"s\");\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "cp",
            "\"@\""
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%s%s%02d:%02d:\"",
            "is_zero ? \"\" : \" \"",
            "(minus ? \"-\" : (is_before ? \"+\" : \"\"))",
            "abs(hour)",
            "abs(min)"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddPostgresIntPart",
          "args": [
            "cp",
            "mday",
            "\"day\"",
            "&is_zero",
            "&is_before"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "AddPostgresIntPart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4167-4187",
          "snippet": "static char *\nAddPostgresIntPart(char *cp, int value, const char *units,\n\t\t\t\t   bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%s%s%d %s%s\",\n\t\t\t(!*is_zero) ? \" \" : \"\",\n\t\t\t(*is_before && value > 0) ? \"+\" : \"\",\n\t\t\tvalue,\n\t\t\tunits,\n\t\t\t(value != 1) ? \"s\" : \"\");\n\n\t/*\n\t * Each nonzero field sets is_before for (only) the next one.  This is a\n\t * tad bizarre but it's how it worked before...\n\t */\n\t*is_before = (value < 0);\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nAddPostgresIntPart(char *cp, int value, const char *units,\n\t\t\t\t   bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%s%s%d %s%s\",\n\t\t\t(!*is_zero) ? \" \" : \"\",\n\t\t\t(*is_before && value > 0) ? \"+\" : \"\",\n\t\t\tvalue,\n\t\t\tunits,\n\t\t\t(value != 1) ? \"s\" : \"\");\n\n\t/*\n\t * Each nonzero field sets is_before for (only) the next one.  This is a\n\t * tad bizarre but it's how it worked before...\n\t */\n\t*is_before = (value < 0);\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddISO8601IntPart",
          "args": [
            "cp",
            "min",
            "'M'"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "AddISO8601IntPart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4157-4164",
          "snippet": "static char *\nAddISO8601IntPart(char *cp, int value, char units)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%d%c\", value, units);\n\treturn cp + strlen(cp);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nAddISO8601IntPart(char *cp, int value, char units)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%d%c\", value, units);\n\treturn cp + strlen(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"PT0S\""
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%d:%02d:\"",
            "hour",
            "min"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%d %d:%02d:\"",
            "mday",
            "hour",
            "min"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%d-%d\"",
            "year",
            "mon"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%c%d-%d %c%d %c%d:%02d:\"",
            "year_sign",
            "abs(year)",
            "abs(mon)",
            "day_sign",
            "abs(mday)",
            "sec_sign",
            "abs(hour)",
            "abs(min)"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"0\""
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str)\n{\n\tchar\t   *cp = str;\n\tint\t\t\tyear = tm->tm_year;\n\tint\t\t\tmon = tm->tm_mon;\n\tint\t\t\tmday = tm->tm_mday;\n\tint\t\t\thour = tm->tm_hour;\n\tint\t\t\tmin = tm->tm_min;\n\tint\t\t\tsec = tm->tm_sec;\n\tbool\t\tis_before = false;\n\tbool\t\tis_zero = true;\n\n\t/*\n\t * The sign of year and month are guaranteed to match, since they are\n\t * stored internally as \"month\". But we'll need to check for is_before and\n\t * is_zero when determining the signs of day and hour/minute/seconds\n\t * fields.\n\t */\n\tswitch (style)\n\t{\n\t\t\t/* SQL Standard interval format */\n\t\tcase INTSTYLE_SQL_STANDARD:\n\t\t\t{\n\t\t\t\tbool\t\thas_negative = year < 0 || mon < 0 ||\n\t\t\t\tmday < 0 || hour < 0 ||\n\t\t\t\tmin < 0 || sec < 0 || fsec < 0;\n\t\t\t\tbool\t\thas_positive = year > 0 || mon > 0 ||\n\t\t\t\tmday > 0 || hour > 0 ||\n\t\t\t\tmin > 0 || sec > 0 || fsec > 0;\n\t\t\t\tbool\t\thas_year_month = year != 0 || mon != 0;\n\t\t\t\tbool\t\thas_day_time = mday != 0 || hour != 0 ||\n\t\t\t\tmin != 0 || sec != 0 || fsec != 0;\n\t\t\t\tbool\t\thas_day = mday != 0;\n\t\t\t\tbool\t\tsql_standard_value = !(has_negative && has_positive) &&\n\t\t\t\t!(has_year_month && has_day_time);\n\n\t\t\t\t/*\n\t\t\t\t * SQL Standard wants only 1 \"<sign>\" preceding the whole\n\t\t\t\t * interval ... but can't do that if mixed signs.\n\t\t\t\t */\n\t\t\t\tif (has_negative && sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\t\tyear = -year;\n\t\t\t\t\tmon = -mon;\n\t\t\t\t\tmday = -mday;\n\t\t\t\t\thour = -hour;\n\t\t\t\t\tmin = -min;\n\t\t\t\t\tsec = -sec;\n\t\t\t\t\tfsec = -fsec;\n\t\t\t\t}\n\n\t\t\t\tif (!has_negative && !has_positive)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"0\");\n\t\t\t\t}\n\t\t\t\telse if (!sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For non sql-standard interval values, force outputting\n\t\t\t\t\t * the signs to avoid ambiguities with intervals with\n\t\t\t\t\t * mixed sign components.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tyear_sign = (year < 0 || mon < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tday_sign = (mday < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tsec_sign = (hour < 0 || min < 0 ||\n\t\t\t\t\t\t\t\t\t\t\tsec < 0 || fsec < 0) ? '-' : '+';\n\n\t\t\t\t\tsprintf(cp, \"%c%d-%d %c%d %c%d:%02d:\",\n\t\t\t\t\t\t\tyear_sign, abs(year), abs(mon),\n\t\t\t\t\t\t\tday_sign, abs(mday),\n\t\t\t\t\t\t\tsec_sign, abs(hour), abs(min));\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (has_year_month)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d-%d\", year, mon);\n\t\t\t\t}\n\t\t\t\telse if (has_day)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d %d:%02d:\", mday, hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d:%02d:\", hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ISO 8601 \"time-intervals by duration only\" */\n\t\tcase INTSTYLE_ISO_8601:\n\t\t\t/* special-case zero to avoid printing nothing */\n\t\t\tif (year == 0 && mon == 0 && mday == 0 &&\n\t\t\t\thour == 0 && min == 0 && sec == 0 && fsec == 0)\n\t\t\t{\n\t\t\t\tsprintf(cp, \"PT0S\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*cp++ = 'P';\n\t\t\tcp = AddISO8601IntPart(cp, year, 'Y');\n\t\t\tcp = AddISO8601IntPart(cp, mon, 'M');\n\t\t\tcp = AddISO8601IntPart(cp, mday, 'D');\n\t\t\tif (hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t\t*cp++ = 'T';\n\t\t\tcp = AddISO8601IntPart(cp, hour, 'H');\n\t\t\tcp = AddISO8601IntPart(cp, min, 'M');\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tif (sec < 0 || fsec < 0)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\t*cp++ = 'S';\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle = 'iso' */\n\t\tcase INTSTYLE_POSTGRES:\n\t\t\tcp = AddPostgresIntPart(cp, year, \"year\", &is_zero, &is_before);\n\n\t\t\t/*\n\t\t\t * Ideally we should spell out \"month\" like we do for \"year\" and\n\t\t\t * \"day\".  However, for backward compatibility, we can't easily\n\t\t\t * fix this.  bjm 2011-05-24\n\t\t\t */\n\t\t\tcp = AddPostgresIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddPostgresIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tif (is_zero || hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tbool\t\tminus = (hour < 0 || min < 0 || sec < 0 || fsec < 0);\n\n\t\t\t\tsprintf(cp, \"%s%s%02d:%02d:\",\n\t\t\t\t\t\tis_zero ? \"\" : \" \",\n\t\t\t\t\t\t(minus ? \"-\" : (is_before ? \"+\" : \"\")),\n\t\t\t\t\t\tabs(hour), abs(min));\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle != 'iso' */\n\t\tcase INTSTYLE_POSTGRES_VERBOSE:\n\t\tdefault:\n\t\t\tstrcpy(cp, \"@\");\n\t\t\tcp++;\n\t\t\tcp = AddVerboseIntPart(cp, year, \"year\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, hour, \"hour\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, min, \"min\", &is_zero, &is_before);\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tif (sec < 0 || (sec == 0 && fsec < 0))\n\t\t\t\t{\n\t\t\t\t\tif (is_zero)\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\telse if (!is_before)\n\t\t\t\t\t\t*cp++ = '-';\n\t\t\t\t}\n\t\t\t\telse if (is_before)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\tsprintf(cp, \" sec%s\",\n\t\t\t\t\t\t(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\");\n\t\t\t\tis_zero = false;\n\t\t\t}\n\t\t\t/* identically zero? then put in a unitless zero... */\n\t\t\tif (is_zero)\n\t\t\t\tstrcat(cp, \" 0\");\n\t\t\tif (is_before)\n\t\t\t\tstrcat(cp, \" ago\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "AddVerboseIntPart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4190-4207",
    "snippet": "static char *\nAddVerboseIntPart(char *cp, int value, const char *units,\n\t\t\t\t  bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\t/* first nonzero value sets is_before */\n\tif (*is_zero)\n\t{\n\t\t*is_before = (value < 0);\n\t\tvalue = abs(value);\n\t}\n\telse if (*is_before)\n\t\tvalue = -value;\n\tsprintf(cp, \" %d %s%s\", value, units, (value == 1) ? \"\" : \"s\");\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\" %d %s%s\"",
            "value",
            "units",
            "(value == 1) ? \"\" : \"s\""
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "value"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "float8abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "726-732",
          "snippet": "Datum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nAddVerboseIntPart(char *cp, int value, const char *units,\n\t\t\t\t  bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\t/* first nonzero value sets is_before */\n\tif (*is_zero)\n\t{\n\t\t*is_before = (value < 0);\n\t\tvalue = abs(value);\n\t}\n\telse if (*is_before)\n\t\tvalue = -value;\n\tsprintf(cp, \" %d %s%s\", value, units, (value == 1) ? \"\" : \"s\");\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}"
  },
  {
    "function_name": "AddPostgresIntPart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4167-4187",
    "snippet": "static char *\nAddPostgresIntPart(char *cp, int value, const char *units,\n\t\t\t\t   bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%s%s%d %s%s\",\n\t\t\t(!*is_zero) ? \" \" : \"\",\n\t\t\t(*is_before && value > 0) ? \"+\" : \"\",\n\t\t\tvalue,\n\t\t\tunits,\n\t\t\t(value != 1) ? \"s\" : \"\");\n\n\t/*\n\t * Each nonzero field sets is_before for (only) the next one.  This is a\n\t * tad bizarre but it's how it worked before...\n\t */\n\t*is_before = (value < 0);\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%s%s%d %s%s\"",
            "(!*is_zero) ? \" \" : \"\"",
            "(*is_before && value > 0) ? \"+\" : \"\"",
            "value",
            "units",
            "(value != 1) ? \"s\" : \"\""
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nAddPostgresIntPart(char *cp, int value, const char *units,\n\t\t\t\t   bool *is_zero, bool *is_before)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%s%s%d %s%s\",\n\t\t\t(!*is_zero) ? \" \" : \"\",\n\t\t\t(*is_before && value > 0) ? \"+\" : \"\",\n\t\t\tvalue,\n\t\t\tunits,\n\t\t\t(value != 1) ? \"s\" : \"\");\n\n\t/*\n\t * Each nonzero field sets is_before for (only) the next one.  This is a\n\t * tad bizarre but it's how it worked before...\n\t */\n\t*is_before = (value < 0);\n\t*is_zero = false;\n\treturn cp + strlen(cp);\n}"
  },
  {
    "function_name": "AddISO8601IntPart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "4157-4164",
    "snippet": "static char *\nAddISO8601IntPart(char *cp, int value, char units)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%d%c\", value, units);\n\treturn cp + strlen(cp);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%d%c\"",
            "value",
            "units"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nAddISO8601IntPart(char *cp, int value, char units)\n{\n\tif (value == 0)\n\t\treturn cp;\n\tsprintf(cp, \"%d%c\", value, units);\n\treturn cp + strlen(cp);\n}"
  },
  {
    "function_name": "EncodeDateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3987-4149",
    "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
      "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "\" BC\"",
            "3"
          ],
          "line": 4145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeTimezone",
          "args": [
            "str",
            "tz",
            "style"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTimezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3834-3867",
          "snippet": "static char *\nEncodeTimezone(char *str, int tz, int style)\n{\n\tint\t\t\thour,\n\t\t\t\tmin,\n\t\t\t\tsec;\n\n\tsec = abs(tz);\n\tmin = sec / SECS_PER_MINUTE;\n\tsec -= min * SECS_PER_MINUTE;\n\thour = min / MINS_PER_HOUR;\n\tmin -= hour * MINS_PER_HOUR;\n\n\t/* TZ is negated compared to sign we wish to display ... */\n\t*str++ = (tz <= 0 ? '+' : '-');\n\n\tif (sec != 0)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, sec, 2);\n\t}\n\telse if (min != 0 || style == USE_XSD_DATES)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t}\n\telse\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\treturn str;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nEncodeTimezone(char *str, int tz, int style)\n{\n\tint\t\t\thour,\n\t\t\t\tmin,\n\t\t\t\tsec;\n\n\tsec = abs(tz);\n\tmin = sec / SECS_PER_MINUTE;\n\tsec -= min * SECS_PER_MINUTE;\n\thour = min / MINS_PER_HOUR;\n\tmin -= hour * MINS_PER_HOUR;\n\n\t/* TZ is negated compared to sign we wish to display ... */\n\t*str++ = (tz <= 0 ? '+' : '-');\n\n\tif (sec != 0)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, sec, 2);\n\t}\n\telse if (min != 0 || style == USE_XSD_DATES)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t}\n\telse\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 4126
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\" %.*s\"",
            "MAXTZLEN",
            "tzn"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_ltostr_zeropad",
          "args": [
            "str",
            "(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1)",
            "4"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr_zeropad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "256-313",
          "snippet": "char *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendTimestampSeconds",
          "args": [
            "str",
            "tm",
            "fsec"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "AppendTimestampSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "457-461",
          "snippet": "static char *\nAppendTimestampSeconds(char *cp, struct pg_tm *tm, fsec_t fsec)\n{\n\treturn AppendSeconds(cp, tm->tm_sec, fsec, MAX_TIMESTAMP_PRECISION, true);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic char *\nAppendTimestampSeconds(char *cp, struct pg_tm *tm, fsec_t fsec)\n{\n\treturn AppendSeconds(cp, tm->tm_sec, fsec, MAX_TIMESTAMP_PRECISION, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "months[tm->tm_mon - 1]",
            "3"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "months[tm->tm_mon - 1]",
            "3"
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "days[tm->tm_wday]",
            "3"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "j2day",
          "args": [
            "day"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "j2day",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "335-345",
          "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\" %.*s\"",
            "MAXTZLEN",
            "tzn"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\" %.*s\"",
            "MAXTZLEN",
            "tzn"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
  },
  {
    "function_name": "EncodeTimeOnly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3957-3968",
    "snippet": "void\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EncodeTimezone",
          "args": [
            "str",
            "tz",
            "style"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTimezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3834-3867",
          "snippet": "static char *\nEncodeTimezone(char *str, int tz, int style)\n{\n\tint\t\t\thour,\n\t\t\t\tmin,\n\t\t\t\tsec;\n\n\tsec = abs(tz);\n\tmin = sec / SECS_PER_MINUTE;\n\tsec -= min * SECS_PER_MINUTE;\n\thour = min / MINS_PER_HOUR;\n\tmin -= hour * MINS_PER_HOUR;\n\n\t/* TZ is negated compared to sign we wish to display ... */\n\t*str++ = (tz <= 0 ? '+' : '-');\n\n\tif (sec != 0)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, sec, 2);\n\t}\n\telse if (min != 0 || style == USE_XSD_DATES)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t}\n\telse\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\treturn str;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nEncodeTimezone(char *str, int tz, int style)\n{\n\tint\t\t\thour,\n\t\t\t\tmin,\n\t\t\t\tsec;\n\n\tsec = abs(tz);\n\tmin = sec / SECS_PER_MINUTE;\n\tsec -= min * SECS_PER_MINUTE;\n\thour = min / MINS_PER_HOUR;\n\tmin -= hour * MINS_PER_HOUR;\n\n\t/* TZ is negated compared to sign we wish to display ... */\n\t*str++ = (tz <= 0 ? '+' : '-');\n\n\tif (sec != 0)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, sec, 2);\n\t}\n\telse if (min != 0 || style == USE_XSD_DATES)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t}\n\telse\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendSeconds",
          "args": [
            "str",
            "tm->tm_sec",
            "fsec",
            "MAX_TIME_PRECISION",
            "true"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "AppendSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "394-448",
          "snippet": "static char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);\n\nstatic char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_ltostr_zeropad",
          "args": [
            "str",
            "tm->tm_min",
            "2"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr_zeropad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "256-313",
          "snippet": "char *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}"
  },
  {
    "function_name": "EncodeDateOnly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3872-3946",
    "snippet": "void\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "\" BC\"",
            "3"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_ltostr_zeropad",
          "args": [
            "str",
            "(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1)",
            "4"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr_zeropad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "256-313",
          "snippet": "char *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
  },
  {
    "function_name": "EncodeTimezone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3834-3867",
    "snippet": "static char *\nEncodeTimezone(char *str, int tz, int style)\n{\n\tint\t\t\thour,\n\t\t\t\tmin,\n\t\t\t\tsec;\n\n\tsec = abs(tz);\n\tmin = sec / SECS_PER_MINUTE;\n\tsec -= min * SECS_PER_MINUTE;\n\thour = min / MINS_PER_HOUR;\n\tmin -= hour * MINS_PER_HOUR;\n\n\t/* TZ is negated compared to sign we wish to display ... */\n\t*str++ = (tz <= 0 ? '+' : '-');\n\n\tif (sec != 0)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, sec, 2);\n\t}\n\telse if (min != 0 || style == USE_XSD_DATES)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t}\n\telse\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\treturn str;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ltostr_zeropad",
          "args": [
            "str",
            "hour",
            "2"
          ],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr_zeropad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "256-313",
          "snippet": "char *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "tz"
          ],
          "line": 3841
        },
        "resolved": true,
        "details": {
          "function_name": "float8abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "726-732",
          "snippet": "Datum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nEncodeTimezone(char *str, int tz, int style)\n{\n\tint\t\t\thour,\n\t\t\t\tmin,\n\t\t\t\tsec;\n\n\tsec = abs(tz);\n\tmin = sec / SECS_PER_MINUTE;\n\tsec -= min * SECS_PER_MINUTE;\n\thour = min / MINS_PER_HOUR;\n\tmin -= hour * MINS_PER_HOUR;\n\n\t/* TZ is negated compared to sign we wish to display ... */\n\t*str++ = (tz <= 0 ? '+' : '-');\n\n\tif (sec != 0)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, sec, 2);\n\t}\n\telse if (min != 0 || style == USE_XSD_DATES)\n\t{\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\t\t*str++ = ':';\n\t\tstr = pg_ltostr_zeropad(str, min, 2);\n\t}\n\telse\n\t\tstr = pg_ltostr_zeropad(str, hour, 2);\n\treturn str;\n}"
  },
  {
    "function_name": "datebsearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3798-3826",
    "snippet": "static const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "key",
            "position->token",
            "TOKMAXLEN"
          ],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "DateTimeParseError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3753-3792",
    "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str))"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "datatype",
            "str"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr))"
          ],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr))"
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\"))"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Perhaps you need a different \\\"datestyle\\\" setting.\""
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr))"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "DecodeUnits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3716-3741",
    "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
      "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
      "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
      "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
      "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datebsearch",
          "args": [
            "lowtoken",
            "deltatktbl",
            "szdeltatktbl"
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "datebsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3798-3826",
          "snippet": "static const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lowtoken",
            "tp->token",
            "TOKMAXLEN"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
  },
  {
    "function_name": "DecodeISO8601Interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3507-3703",
    "snippet": "int\nDecodeISO8601Interval(char *str,\n\t\t\t\t\t  int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tdatepart = true;\n\tbool\t\thavefield = false;\n\n\t*dtype = DTK_DELTA;\n\tClearPgTm(tm, fsec);\n\n\tif (strlen(str) < 2 || str[0] != 'P')\n\t\treturn DTERR_BAD_FORMAT;\n\n\tstr++;\n\twhile (*str)\n\t{\n\t\tchar\t   *fieldstart;\n\t\tint\t\t\tval;\n\t\tdouble\t\tfval;\n\t\tchar\t\tunit;\n\t\tint\t\t\tdterr;\n\n\t\tif (*str == 'T')\t\t/* T indicates the beginning of the time part */\n\t\t{\n\t\t\tdatepart = false;\n\t\t\thavefield = false;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfieldstart = str;\n\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\t/*\n\t\t * Note: we could step off the end of the string here.  Code below\n\t\t * *must* exit the loop if unit == '\\0'.\n\t\t */\n\t\tunit = *str++;\n\n\t\tif (datepart)\n\t\t{\n\t\t\tswitch (unit)\t\t/* before T: Y M W D */\n\t\t\t{\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* ISO 8601 4.4.3.3 Alternative Format / Basic */\n\t\t\t\tcase '\\0':\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 8 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_year += val / 10000;\n\t\t\t\t\t\ttm->tm_mon += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_mday += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase '-':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (unit == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*str != '-')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid date unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (unit)\t\t/* after T: H M S */\n\t\t\t{\n\t\t\t\tcase 'H':\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\t\t/* ISO 8601 4.4.3.3 Alternative Format */\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 6 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_hour += val / 10000;\n\t\t\t\t\t\ttm->tm_min += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_sec += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase ':':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str != ':')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid time unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\n\t\thavefield = true;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdjustFractSeconds",
          "args": [
            "fval",
            "tm",
            "fsec",
            "1"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustFractSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "467-479",
          "snippet": "static void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
            "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseISO8601Number",
          "args": [
            "str",
            "&str",
            "&val",
            "&fval"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "ParseISO8601Number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3452-3474",
          "snippet": "static int\nParseISO8601Number(char *str, char **endptr, int *ipart, double *fpart)\n{\n\tdouble\t\tval;\n\n\tif (!(isdigit((unsigned char) *str) || *str == '-' || *str == '.'))\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\tval = strtod(str, endptr);\n\t/* did we not see anything that looks like a double? */\n\tif (*endptr == str || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t/* watch out for overflow */\n\tif (val < INT_MIN || val > INT_MAX)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\t/* be very sure we truncate towards zero (cf dtrunc()) */\n\tif (val >= 0)\n\t\t*ipart = (int) floor(val);\n\telse\n\t\t*ipart = (int) -floor(-val);\n\t*fpart = val - *ipart;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nParseISO8601Number(char *str, char **endptr, int *ipart, double *fpart)\n{\n\tdouble\t\tval;\n\n\tif (!(isdigit((unsigned char) *str) || *str == '-' || *str == '.'))\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\tval = strtod(str, endptr);\n\t/* did we not see anything that looks like a double? */\n\tif (*endptr == str || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t/* watch out for overflow */\n\tif (val < INT_MIN || val > INT_MAX)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\t/* be very sure we truncate towards zero (cf dtrunc()) */\n\tif (val >= 0)\n\t\t*ipart = (int) floor(val);\n\telse\n\t\t*ipart = (int) -floor(-val);\n\t*fpart = val - *ipart;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISO8601IntegerWidth",
          "args": [
            "fieldstart"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "ISO8601IntegerWidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3480-3487",
          "snippet": "static int\nISO8601IntegerWidth(char *fieldstart)\n{\n\t/* We might have had a leading '-' */\n\tif (*fieldstart == '-')\n\t\tfieldstart++;\n\treturn strspn(fieldstart, \"0123456789\");\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nISO8601IntegerWidth(char *fieldstart)\n{\n\t/* We might have had a leading '-' */\n\tif (*fieldstart == '-')\n\t\tfieldstart++;\n\treturn strspn(fieldstart, \"0123456789\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "AdjustFractDays",
          "args": [
            "fval",
            "tm",
            "fsec",
            "DAYS_PER_MONTH"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustFractDays",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "482-494",
          "snippet": "static void\nAdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
            "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPgTm",
          "args": [
            "tm",
            "fsec"
          ],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "ClearPgTm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3057-3067",
          "snippet": "static inline void\nClearPgTm(struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic inline void\nClearPgTm(struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeISO8601Interval(char *str,\n\t\t\t\t\t  int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tdatepart = true;\n\tbool\t\thavefield = false;\n\n\t*dtype = DTK_DELTA;\n\tClearPgTm(tm, fsec);\n\n\tif (strlen(str) < 2 || str[0] != 'P')\n\t\treturn DTERR_BAD_FORMAT;\n\n\tstr++;\n\twhile (*str)\n\t{\n\t\tchar\t   *fieldstart;\n\t\tint\t\t\tval;\n\t\tdouble\t\tfval;\n\t\tchar\t\tunit;\n\t\tint\t\t\tdterr;\n\n\t\tif (*str == 'T')\t\t/* T indicates the beginning of the time part */\n\t\t{\n\t\t\tdatepart = false;\n\t\t\thavefield = false;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfieldstart = str;\n\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\t/*\n\t\t * Note: we could step off the end of the string here.  Code below\n\t\t * *must* exit the loop if unit == '\\0'.\n\t\t */\n\t\tunit = *str++;\n\n\t\tif (datepart)\n\t\t{\n\t\t\tswitch (unit)\t\t/* before T: Y M W D */\n\t\t\t{\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* ISO 8601 4.4.3.3 Alternative Format / Basic */\n\t\t\t\tcase '\\0':\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 8 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_year += val / 10000;\n\t\t\t\t\t\ttm->tm_mon += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_mday += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase '-':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (unit == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*str != '-')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid date unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (unit)\t\t/* after T: H M S */\n\t\t\t{\n\t\t\t\tcase 'H':\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\t\t/* ISO 8601 4.4.3.3 Alternative Format */\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 6 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_hour += val / 10000;\n\t\t\t\t\t\ttm->tm_min += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_sec += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase ':':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str != ':')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid time unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\n\t\thavefield = true;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ISO8601IntegerWidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3480-3487",
    "snippet": "static int\nISO8601IntegerWidth(char *fieldstart)\n{\n\t/* We might have had a leading '-' */\n\tif (*fieldstart == '-')\n\t\tfieldstart++;\n\treturn strspn(fieldstart, \"0123456789\");\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "fieldstart",
            "\"0123456789\""
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nISO8601IntegerWidth(char *fieldstart)\n{\n\t/* We might have had a leading '-' */\n\tif (*fieldstart == '-')\n\t\tfieldstart++;\n\treturn strspn(fieldstart, \"0123456789\");\n}"
  },
  {
    "function_name": "ParseISO8601Number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3452-3474",
    "snippet": "static int\nParseISO8601Number(char *str, char **endptr, int *ipart, double *fpart)\n{\n\tdouble\t\tval;\n\n\tif (!(isdigit((unsigned char) *str) || *str == '-' || *str == '.'))\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\tval = strtod(str, endptr);\n\t/* did we not see anything that looks like a double? */\n\tif (*endptr == str || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t/* watch out for overflow */\n\tif (val < INT_MIN || val > INT_MAX)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\t/* be very sure we truncate towards zero (cf dtrunc()) */\n\tif (val >= 0)\n\t\t*ipart = (int) floor(val);\n\telse\n\t\t*ipart = (int) -floor(-val);\n\t*fpart = val - *ipart;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "-val"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "str",
            "endptr"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nParseISO8601Number(char *str, char **endptr, int *ipart, double *fpart)\n{\n\tdouble\t\tval;\n\n\tif (!(isdigit((unsigned char) *str) || *str == '-' || *str == '.'))\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\tval = strtod(str, endptr);\n\t/* did we not see anything that looks like a double? */\n\tif (*endptr == str || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t/* watch out for overflow */\n\tif (val < INT_MIN || val > INT_MAX)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\t/* be very sure we truncate towards zero (cf dtrunc()) */\n\tif (val >= 0)\n\t\t*ipart = (int) floor(val);\n\telse\n\t\t*ipart = (int) -floor(-val);\n\t*fpart = val - *ipart;\n\treturn 0;\n}"
  },
  {
    "function_name": "DecodeInterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3081-3443",
    "snippet": "int\nDecodeInterval(char **field, int *ftype, int nf, int range,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tis_before = false;\n\tchar\t   *cp;\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\ti;\n\tint\t\t\tdterr;\n\tint\t\t\tval;\n\tdouble\t\tfval;\n\n\t*dtype = DTK_DELTA;\n\ttype = IGNORE_DTF;\n\tClearPgTm(tm, fsec);\n\n\t/* read through list backwards to pick up units before values */\n\tfor (i = nf - 1; i >= 0; i--)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], fmask, range,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\ttype = DTK_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\n\t\t\t\t/*\n\t\t\t\t * Timezone means a token with a leading sign character and at\n\t\t\t\t * least one digit; there could be ':', '.', '-' embedded in\n\t\t\t\t * it as well.\n\t\t\t\t */\n\t\t\t\tAssert(*field[i] == '-' || *field[i] == '+');\n\n\t\t\t\t/*\n\t\t\t\t * Check for signed hh:mm or hh:mm:ss.  If so, process exactly\n\t\t\t\t * like DTK_TIME case above, plus handling the sign.\n\t\t\t\t */\n\t\t\t\tif (strchr(field[i] + 1, ':') != NULL &&\n\t\t\t\t\tDecodeTime(field[i] + 1, fmask, range,\n\t\t\t\t\t\t\t   &tmask, tm, fsec) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* flip the sign on all fields */\n\t\t\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\t\t\t\t*fsec = -(*fsec);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the next type to be a day, if units are not\n\t\t\t\t\t * specified. This handles the case of '1 +02:03' since we\n\t\t\t\t\t * are reading right to left.\n\t\t\t\t\t */\n\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, fall through to DTK_NUMBER case, which can\n\t\t\t\t * handle signed float numbers and signed year-month values.\n\t\t\t\t */\n\n\t\t\t\t/* FALLTHROUGH */\n\n\t\t\tcase DTK_DATE:\n\t\t\tcase DTK_NUMBER:\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t{\n\t\t\t\t\t/* use typmod to decide what rightmost field is */\n\t\t\t\t\tswitch (range)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\t\t\t\t\ttype = DTK_YEAR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\t\t\t\t\ttype = DTK_HOUR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\t\ttype = DTK_MINUTE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terrno = 0;\n\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\tif (*cp == '-')\n\t\t\t\t{\n\t\t\t\t\t/* SQL \"years-months\" syntax */\n\t\t\t\t\tint\t\t\tval2;\n\n\t\t\t\t\tval2 = strtoint(cp + 1, &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val2 < 0 || val2 >= MONTHS_PER_YEAR)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tval2 = -val2;\n\t\t\t\t\tif (((double) val * MONTHS_PER_YEAR + val2) > INT_MAX ||\n\t\t\t\t\t\t((double) val * MONTHS_PER_YEAR + val2) < INT_MIN)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tval = val * MONTHS_PER_YEAR + val2;\n\t\t\t\t\tfval = 0;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '.')\n\t\t\t\t{\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tfval = strtod(cp, &cp);\n\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tfval = -fval;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '\\0')\n\t\t\t\t\tfval = 0;\n\t\t\t\telse\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\t\t*fsec += rint(val + fval);\n\t\t\t\t\t\ttmask = DTK_M(MICROSECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\t\t/* avoid overflowing the fsec field */\n\t\t\t\t\t\ttm->tm_sec += val / 1000;\n\t\t\t\t\t\tval -= (val / 1000) * 1000;\n\t\t\t\t\t\t*fsec += rint((val + fval) * 1000);\n\t\t\t\t\t\ttmask = DTK_M(MILLISECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\t\t*fsec += rint(fval * 1000000);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If any subseconds were specified, consider this\n\t\t\t\t\t\t * microsecond and millisecond input as well.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (fval == 0)\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\ttype = DTK_DAY; /* set for next field */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_WEEK:\n\t\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\t\ttmask = DTK_M(WEEK);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR;\n\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t\ttm->tm_year += val * 10;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 10;\n\t\t\t\t\t\ttmask = DTK_M(DECADE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t\ttm->tm_year += val * 100;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 100;\n\t\t\t\t\t\ttmask = DTK_M(CENTURY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t\ttm->tm_year += val * 1000;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 1000;\n\t\t\t\t\t\ttmask = DTK_M(MILLENNIUM);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\ttype = DecodeUnits(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AGO:\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M);\n\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\n\n\t/* ensure that at least one time field has been found */\n\tif (fmask == 0)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* ensure fractional seconds are fractional */\n\tif (*fsec != 0)\n\t{\n\t\tint\t\t\tsec;\n\n\t\tsec = *fsec / USECS_PER_SEC;\n\t\t*fsec -= sec * USECS_PER_SEC;\n\t\ttm->tm_sec += sec;\n\t}\n\n\t/*----------\n\t * The SQL standard defines the interval literal\n\t *\t '-1 1:00:00'\n\t * to mean \"negative 1 days and negative 1 hours\", while Postgres\n\t * traditionally treats this as meaning \"negative 1 days and positive\n\t * 1 hours\".  In SQL_STANDARD intervalstyle, we apply the leading sign\n\t * to all fields if there are no other explicit signs.\n\t *\n\t * We leave the signs alone if there are additional explicit signs.\n\t * This protects us against misinterpreting postgres-style dump output,\n\t * since the postgres-style output code has always put an explicit sign on\n\t * all fields following a negative field.  But note that SQL-spec output\n\t * is ambiguous and can be misinterpreted on load!\t(So it's best practice\n\t * to dump in postgres style, not SQL style.)\n\t *----------\n\t */\n\tif (IntervalStyle == INTSTYLE_SQL_STANDARD && *field[0] == '-')\n\t{\n\t\t/* Check for additional explicit signs */\n\t\tbool\t\tmore_signs = false;\n\n\t\tfor (i = 1; i < nf; i++)\n\t\t{\n\t\t\tif (*field[i] == '-' || *field[i] == '+')\n\t\t\t{\n\t\t\t\tmore_signs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more_signs)\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than re-determining which field was field[0], just force\n\t\t\t * 'em all negative.\n\t\t\t */\n\t\t\tif (*fsec > 0)\n\t\t\t\t*fsec = -(*fsec);\n\t\t\tif (tm->tm_sec > 0)\n\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\tif (tm->tm_min > 0)\n\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\tif (tm->tm_hour > 0)\n\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\tif (tm->tm_mday > 0)\n\t\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\tif (tm->tm_mon > 0)\n\t\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\tif (tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\t}\n\n\t/* finally, AGO negates everything */\n\tif (is_before)\n\t{\n\t\t*fsec = -(*fsec);\n\t\ttm->tm_sec = -tm->tm_sec;\n\t\ttm->tm_min = -tm->tm_min;\n\t\ttm->tm_hour = -tm->tm_hour;\n\t\ttm->tm_mday = -tm->tm_mday;\n\t\ttm->tm_mon = -tm->tm_mon;\n\t\ttm->tm_year = -tm->tm_year;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
      "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "i",
            "field[i]",
            "&val"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MILLENNIUM"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "CENTURY"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DECADE"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustFractDays",
          "args": [
            "fval",
            "tm",
            "fsec",
            "DAYS_PER_MONTH"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustFractDays",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "482-494",
          "snippet": "static void\nAdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
            "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "WEEK"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustFractSeconds",
          "args": [
            "fval",
            "tm",
            "fsec",
            "SECS_PER_DAY"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustFractSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "467-479",
          "snippet": "static void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
            "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "HOUR"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MINUTE"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "SECOND"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "fval * 1000000"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MILLISECOND"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MICROSECOND"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "cp",
            "&cp"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "cp + 1",
            "&cp",
            "10"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "field[i]",
            "&cp",
            "10"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "HOUR"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "DAY"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MONTH"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "YEAR"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTime",
          "args": [
            "field[i] + 1",
            "fmask",
            "range",
            "&tmask",
            "tm",
            "fsec"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2544-2613",
          "snippet": "static int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field[i] + 1",
            "':'"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "*field[i] == '-' || *field[i] == '+'"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPgTm",
          "args": [
            "tm",
            "fsec"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "ClearPgTm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3057-3067",
          "snippet": "static inline void\nClearPgTm(struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic inline void\nClearPgTm(struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nint\nDecodeInterval(char **field, int *ftype, int nf, int range,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tis_before = false;\n\tchar\t   *cp;\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\ti;\n\tint\t\t\tdterr;\n\tint\t\t\tval;\n\tdouble\t\tfval;\n\n\t*dtype = DTK_DELTA;\n\ttype = IGNORE_DTF;\n\tClearPgTm(tm, fsec);\n\n\t/* read through list backwards to pick up units before values */\n\tfor (i = nf - 1; i >= 0; i--)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], fmask, range,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\ttype = DTK_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\n\t\t\t\t/*\n\t\t\t\t * Timezone means a token with a leading sign character and at\n\t\t\t\t * least one digit; there could be ':', '.', '-' embedded in\n\t\t\t\t * it as well.\n\t\t\t\t */\n\t\t\t\tAssert(*field[i] == '-' || *field[i] == '+');\n\n\t\t\t\t/*\n\t\t\t\t * Check for signed hh:mm or hh:mm:ss.  If so, process exactly\n\t\t\t\t * like DTK_TIME case above, plus handling the sign.\n\t\t\t\t */\n\t\t\t\tif (strchr(field[i] + 1, ':') != NULL &&\n\t\t\t\t\tDecodeTime(field[i] + 1, fmask, range,\n\t\t\t\t\t\t\t   &tmask, tm, fsec) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* flip the sign on all fields */\n\t\t\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\t\t\t\t*fsec = -(*fsec);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the next type to be a day, if units are not\n\t\t\t\t\t * specified. This handles the case of '1 +02:03' since we\n\t\t\t\t\t * are reading right to left.\n\t\t\t\t\t */\n\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, fall through to DTK_NUMBER case, which can\n\t\t\t\t * handle signed float numbers and signed year-month values.\n\t\t\t\t */\n\n\t\t\t\t/* FALLTHROUGH */\n\n\t\t\tcase DTK_DATE:\n\t\t\tcase DTK_NUMBER:\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t{\n\t\t\t\t\t/* use typmod to decide what rightmost field is */\n\t\t\t\t\tswitch (range)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\t\t\t\t\ttype = DTK_YEAR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\t\t\t\t\ttype = DTK_HOUR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\t\ttype = DTK_MINUTE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terrno = 0;\n\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\tif (*cp == '-')\n\t\t\t\t{\n\t\t\t\t\t/* SQL \"years-months\" syntax */\n\t\t\t\t\tint\t\t\tval2;\n\n\t\t\t\t\tval2 = strtoint(cp + 1, &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val2 < 0 || val2 >= MONTHS_PER_YEAR)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tval2 = -val2;\n\t\t\t\t\tif (((double) val * MONTHS_PER_YEAR + val2) > INT_MAX ||\n\t\t\t\t\t\t((double) val * MONTHS_PER_YEAR + val2) < INT_MIN)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tval = val * MONTHS_PER_YEAR + val2;\n\t\t\t\t\tfval = 0;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '.')\n\t\t\t\t{\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tfval = strtod(cp, &cp);\n\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tfval = -fval;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '\\0')\n\t\t\t\t\tfval = 0;\n\t\t\t\telse\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\t\t*fsec += rint(val + fval);\n\t\t\t\t\t\ttmask = DTK_M(MICROSECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\t\t/* avoid overflowing the fsec field */\n\t\t\t\t\t\ttm->tm_sec += val / 1000;\n\t\t\t\t\t\tval -= (val / 1000) * 1000;\n\t\t\t\t\t\t*fsec += rint((val + fval) * 1000);\n\t\t\t\t\t\ttmask = DTK_M(MILLISECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\t\t*fsec += rint(fval * 1000000);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If any subseconds were specified, consider this\n\t\t\t\t\t\t * microsecond and millisecond input as well.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (fval == 0)\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\ttype = DTK_DAY; /* set for next field */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_WEEK:\n\t\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\t\ttmask = DTK_M(WEEK);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR;\n\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t\ttm->tm_year += val * 10;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 10;\n\t\t\t\t\t\ttmask = DTK_M(DECADE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t\ttm->tm_year += val * 100;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 100;\n\t\t\t\t\t\ttmask = DTK_M(CENTURY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t\ttm->tm_year += val * 1000;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 1000;\n\t\t\t\t\t\ttmask = DTK_M(MILLENNIUM);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\ttype = DecodeUnits(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AGO:\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M);\n\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\n\n\t/* ensure that at least one time field has been found */\n\tif (fmask == 0)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* ensure fractional seconds are fractional */\n\tif (*fsec != 0)\n\t{\n\t\tint\t\t\tsec;\n\n\t\tsec = *fsec / USECS_PER_SEC;\n\t\t*fsec -= sec * USECS_PER_SEC;\n\t\ttm->tm_sec += sec;\n\t}\n\n\t/*----------\n\t * The SQL standard defines the interval literal\n\t *\t '-1 1:00:00'\n\t * to mean \"negative 1 days and negative 1 hours\", while Postgres\n\t * traditionally treats this as meaning \"negative 1 days and positive\n\t * 1 hours\".  In SQL_STANDARD intervalstyle, we apply the leading sign\n\t * to all fields if there are no other explicit signs.\n\t *\n\t * We leave the signs alone if there are additional explicit signs.\n\t * This protects us against misinterpreting postgres-style dump output,\n\t * since the postgres-style output code has always put an explicit sign on\n\t * all fields following a negative field.  But note that SQL-spec output\n\t * is ambiguous and can be misinterpreted on load!\t(So it's best practice\n\t * to dump in postgres style, not SQL style.)\n\t *----------\n\t */\n\tif (IntervalStyle == INTSTYLE_SQL_STANDARD && *field[0] == '-')\n\t{\n\t\t/* Check for additional explicit signs */\n\t\tbool\t\tmore_signs = false;\n\n\t\tfor (i = 1; i < nf; i++)\n\t\t{\n\t\t\tif (*field[i] == '-' || *field[i] == '+')\n\t\t\t{\n\t\t\t\tmore_signs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more_signs)\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than re-determining which field was field[0], just force\n\t\t\t * 'em all negative.\n\t\t\t */\n\t\t\tif (*fsec > 0)\n\t\t\t\t*fsec = -(*fsec);\n\t\t\tif (tm->tm_sec > 0)\n\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\tif (tm->tm_min > 0)\n\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\tif (tm->tm_hour > 0)\n\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\tif (tm->tm_mday > 0)\n\t\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\tif (tm->tm_mon > 0)\n\t\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\tif (tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\t}\n\n\t/* finally, AGO negates everything */\n\tif (is_before)\n\t{\n\t\t*fsec = -(*fsec);\n\t\ttm->tm_sec = -tm->tm_sec;\n\t\ttm->tm_min = -tm->tm_min;\n\t\ttm->tm_hour = -tm->tm_hour;\n\t\ttm->tm_mday = -tm->tm_mday;\n\t\ttm->tm_mon = -tm->tm_mon;\n\t\ttm->tm_year = -tm->tm_year;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ClearPgTm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3057-3067",
    "snippet": "static inline void\nClearPgTm(struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic inline void\nClearPgTm(struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n}"
  },
  {
    "function_name": "DecodeSpecial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "3025-3050",
    "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
      "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
      "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
      "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
      "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datebsearch",
          "args": [
            "lowtoken",
            "datetktbl",
            "szdatetktbl"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "datebsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3798-3826",
          "snippet": "static const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lowtoken",
            "tp->token",
            "TOKMAXLEN"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
  },
  {
    "function_name": "DecodeTimezoneAbbrev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2970-3010",
    "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
      "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
      "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
      "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FetchDynamicTimeZone",
          "args": [
            "zoneabbrevtbl",
            "tp"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "FetchDynamicTimeZone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4602-4631",
          "snippet": "static pg_tz *\nFetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp)\n{\n\tDynamicZoneAbbrev *dtza;\n\n\t/* Just some sanity checks to prevent indexing off into nowhere */\n\tAssert(tp->type == DYNTZ);\n\tAssert(tp->value > 0 && tp->value < tbl->tblsize);\n\n\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tp->value);\n\n\t/* Look up the underlying zone if we haven't already */\n\tif (dtza->tz == NULL)\n\t{\n\t\tdtza->tz = pg_tzset(dtza->zone);\n\n\t\t/*\n\t\t * Ideally we'd let the caller ereport instead of doing it here, but\n\t\t * then there is no way to report the bad time zone name.\n\t\t */\n\t\tif (dtza->tz == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token)));\n\t}\n\treturn dtza->tz;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\n\nstatic pg_tz *\nFetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp)\n{\n\tDynamicZoneAbbrev *dtza;\n\n\t/* Just some sanity checks to prevent indexing off into nowhere */\n\tAssert(tp->type == DYNTZ);\n\tAssert(tp->value > 0 && tp->value < tbl->tblsize);\n\n\tdtza = (DynamicZoneAbbrev *) ((char *) tbl + tp->value);\n\n\t/* Look up the underlying zone if we haven't already */\n\tif (dtza->tz == NULL)\n\t{\n\t\tdtza->tz = pg_tzset(dtza->zone);\n\n\t\t/*\n\t\t * Ideally we'd let the caller ereport instead of doing it here, but\n\t\t * then there is no way to report the bad time zone name.\n\t\t */\n\t\tif (dtza->tz == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_CONFIG_FILE_ERROR),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\tdtza->zone),\n\t\t\t\t\t errdetail(\"This time zone name appears in the configuration file for time zone abbreviation \\\"%s\\\".\",\n\t\t\t\t\t\t\t   tp->token)));\n\t}\n\treturn dtza->tz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datebsearch",
          "args": [
            "lowtoken",
            "zoneabbrevtbl->abbrevs",
            "zoneabbrevtbl->numabbrevs"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "datebsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3798-3826",
          "snippet": "static const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lowtoken",
            "tp->token",
            "TOKMAXLEN"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
  },
  {
    "function_name": "DecodeTimezone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2892-2953",
    "snippet": "int\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "cp + 1",
            "&cp",
            "10"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "cp + 1",
            "&cp",
            "10"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "str + 1",
            "&cp",
            "10"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "DecodeNumberField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2805-2884",
    "snippet": "static int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str + 2"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str + 2"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str + 4"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str + (len - 4)"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str + (len - 2)"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "frac * 1000000"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "cp",
            "NULL"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'.'"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}"
  },
  {
    "function_name": "DecodeNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2620-2795",
    "snippet": "static int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeNumberField",
          "args": [
            "flen",
            "str",
            "fmask",
            "tmask",
            "tm",
            "fsec",
            "is2digits"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeNumberField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2805-2884",
          "snippet": "static int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DOY"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseFractionalSecond",
          "args": [
            "cp",
            "fsec"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFractionalSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "497-511",
          "snippet": "static int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\n\nstatic int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "str",
            "&cp",
            "10"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "DecodeTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2544-2613",
    "snippet": "static int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseFractionalSecond",
          "args": [
            "cp",
            "fsec"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFractionalSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "497-511",
          "snippet": "static int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\n\nstatic int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "cp + 1",
            "&cp",
            "10"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "SECOND"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INTERVAL_MASK",
          "args": [
            "MINUTE"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "cp + 1",
            "&cp",
            "10"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "str",
            "&cp",
            "10"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ValidateDate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2465-2534",
    "snippet": "int\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "const int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm->tm_year"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "1",
            "1"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DOY"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};\n\nint\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "DecodeDate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "2355-2459",
    "snippet": "static int\nDecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm)\n{\n\tfsec_t\t\tfsec;\n\tint\t\t\tnf = 0;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tint\t\t\tdterr;\n\tbool\t\thaveTextMonth = false;\n\tint\t\t\ttype,\n\t\t\t\tval,\n\t\t\t\tdmask = 0;\n\tchar\t   *field[MAXDATEFIELDS];\n\n\t*tmask = 0;\n\n\t/* parse this string... */\n\twhile (*str != '\\0' && nf < MAXDATEFIELDS)\n\t{\n\t\t/* skip field separators */\n\t\twhile (*str != '\\0' && !isalnum((unsigned char) *str))\n\t\t\tstr++;\n\n\t\tif (*str == '\\0')\n\t\t\treturn DTERR_BAD_FORMAT;\t/* end of string after separator */\n\n\t\tfield[nf] = str;\n\t\tif (isdigit((unsigned char) *str))\n\t\t{\n\t\t\twhile (isdigit((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse if (isalpha((unsigned char) *str))\n\t\t{\n\t\t\twhile (isalpha((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\n\t\t/* Just get rid of any non-digit, non-alpha characters... */\n\t\tif (*str != '\\0')\n\t\t\t*str++ = '\\0';\n\t\tnf++;\n\t}\n\n\t/* look first for text fields, since that will be unambiguous month */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (isalpha((unsigned char) *field[i]))\n\t\t{\n\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\tif (type == IGNORE_DTF)\n\t\t\t\tcontinue;\n\n\t\t\tdmask = DTK_M(type);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase MONTH:\n\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t\tif (fmask & dmask)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\tfmask |= dmask;\n\t\t\t*tmask |= dmask;\n\n\t\t\t/* mark this field as being completed */\n\t\t\tfield[i] = NULL;\n\t\t}\n\t}\n\n\t/* now pick up remaining numeric fields */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (field[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((len = strlen(field[i])) <= 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tdterr = DecodeNumber(len, field[i], haveTextMonth, fmask,\n\t\t\t\t\t\t\t &dmask, tm,\n\t\t\t\t\t\t\t &fsec, is2digits);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\tif (fmask & dmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tfmask |= dmask;\n\t\t*tmask |= dmask;\n\t}\n\n\tif ((fmask & ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* validation of the field values must wait until ValidateDate() */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DOY"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeNumber",
          "args": [
            "len",
            "field[i]",
            "haveTextMonth",
            "fmask",
            "&dmask",
            "tm",
            "&fsec",
            "is2digits"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2620-2795",
          "snippet": "static int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "field[i]"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "type"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "i",
            "field[i]",
            "&val"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *field[i]"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm)\n{\n\tfsec_t\t\tfsec;\n\tint\t\t\tnf = 0;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tint\t\t\tdterr;\n\tbool\t\thaveTextMonth = false;\n\tint\t\t\ttype,\n\t\t\t\tval,\n\t\t\t\tdmask = 0;\n\tchar\t   *field[MAXDATEFIELDS];\n\n\t*tmask = 0;\n\n\t/* parse this string... */\n\twhile (*str != '\\0' && nf < MAXDATEFIELDS)\n\t{\n\t\t/* skip field separators */\n\t\twhile (*str != '\\0' && !isalnum((unsigned char) *str))\n\t\t\tstr++;\n\n\t\tif (*str == '\\0')\n\t\t\treturn DTERR_BAD_FORMAT;\t/* end of string after separator */\n\n\t\tfield[nf] = str;\n\t\tif (isdigit((unsigned char) *str))\n\t\t{\n\t\t\twhile (isdigit((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse if (isalpha((unsigned char) *str))\n\t\t{\n\t\t\twhile (isalpha((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\n\t\t/* Just get rid of any non-digit, non-alpha characters... */\n\t\tif (*str != '\\0')\n\t\t\t*str++ = '\\0';\n\t\tnf++;\n\t}\n\n\t/* look first for text fields, since that will be unambiguous month */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (isalpha((unsigned char) *field[i]))\n\t\t{\n\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\tif (type == IGNORE_DTF)\n\t\t\t\tcontinue;\n\n\t\t\tdmask = DTK_M(type);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase MONTH:\n\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t\tif (fmask & dmask)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\tfmask |= dmask;\n\t\t\t*tmask |= dmask;\n\n\t\t\t/* mark this field as being completed */\n\t\t\tfield[i] = NULL;\n\t\t}\n\t}\n\n\t/* now pick up remaining numeric fields */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (field[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((len = strlen(field[i])) <= 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tdterr = DecodeNumber(len, field[i], haveTextMonth, fmask,\n\t\t\t\t\t\t\t &dmask, tm,\n\t\t\t\t\t\t\t &fsec, is2digits);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\tif (fmask & dmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tfmask |= dmask;\n\t\t*tmask |= dmask;\n\t}\n\n\tif ((fmask & ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* validation of the field values must wait until ValidateDate() */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "DecodeTimeOnly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "1730-2343",
    "snippet": "int\nDecodeTimeOnly(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO h04mm05s06 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tint\t\t\tmer = HR24;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tchar\t   *abbrev = NULL;\n\tpg_tz\t   *valtz;\n\n\t*dtype = DTK_TIME;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Time zone not allowed? Then should not accept dates or time\n\t\t\t\t * zones no matter what else!\n\t\t\t\t */\n\t\t\t\tif (tzp == NULL)\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t/* Under limited circumstances, we will accept a date... */\n\t\t\t\tif (i == 0 && nf >= 2 &&\n\t\t\t\t\t(ftype[nf - 1] == DTK_DATE || ftype[1] == DTK_TIME))\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\t/* otherwise, this is a time and/or time zone */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with time already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Should not get here and fail. Sanity check only...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t   INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO time\" with embedded field labels? An\n\t\t\t\t * example is \"h04m05s06\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\t/* Only accept a date under limited circumstances */\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal? */\n\t\t\t\t\tif (cp != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Under limited circumstances, we will accept a\n\t\t\t\t\t\t * date...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i == 0 && nf >= 2 && ftype[nf - 1] == DTK_DATE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\t\telse if (flen - strlen(cp) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Interpret as a concatenated date or time Set\n\t\t\t\t\t\t\t * the type field to allow decoding other fields\n\t\t\t\t\t\t\t * later. Example: 20011223 or 040506\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flen > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\t\t\t\t\t (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = DTK_TIME_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, NULL);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/*\n\t * This should match the checks in make_timestamp_internal\n\t */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)) ||\n\t\t*fsec < INT64CONST(0) || *fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/*\n\t * If we had a full timezone spec, compute the offset (we could not do it\n\t * before, because we may need the date to resolve DST status).\n\t */\n\tif (namedTz != NULL)\n\t{\n\t\tlong int\tgmtoff;\n\n\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* if non-DST zone, we do not need to know the date */\n\t\tif (pg_get_timezone_offset(namedTz, &gmtoff))\n\t\t{\n\t\t\t*tzp = -(int) gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a date has to be specified */\n\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, if we had a dynamic timezone abbreviation, resolve it now.\n\t */\n\tif (abbrevTz != NULL)\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneAbbrevOffset(tmp, abbrev, abbrevTz);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\t/* timezone not specified? then use session timezone */\n\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneOffset(tmp, session_timezone);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tmp",
            "session_timezone"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentDateTime",
          "args": [
            "tmp"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "353-362",
          "snippet": "void\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZMOD"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffset",
          "args": [
            "tmp",
            "abbrev",
            "abbrevTz"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1615-1645",
          "snippet": "int\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZMOD"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_get_timezone_offset",
          "args": [
            "namedTz",
            "&gmtoff"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZMOD"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValidateDate",
          "args": [
            "fmask",
            "isjulian",
            "is2digits",
            "bc",
            "tm"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2465-2534",
          "snippet": "int\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};\n\nint\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "field[i]"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZ"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTimeUsec",
          "args": [
            "tm",
            "fsec",
            "NULL"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimeUsec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "370-380",
          "snippet": "void\nGetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\ttz;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n\tif (tzp != NULL)\n\t\t*tzp = tz;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\ttz;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n\tif (tzp != NULL)\n\t\t*tzp = tz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\"))"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date/time value \\\"current\\\" is no longer supported\""
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "type"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "i",
            "field[i]",
            "&val"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimezoneAbbrev",
          "args": [
            "i",
            "field[i]",
            "&val",
            "&valtz"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezoneAbbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2970-3010",
          "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
            "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeNumber",
          "args": [
            "flen",
            "field[i]",
            "false",
            "(fmask | DTK_DATE_M)",
            "&tmask",
            "tm",
            "fsec",
            "&is2digits"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2620-2795",
          "snippet": "static int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeNumberField",
          "args": [
            "flen",
            "field[i]",
            "(fmask | DTK_DATE_M)",
            "&tmask",
            "tm",
            "fsec",
            "&is2digits"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeNumberField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2805-2884",
          "snippet": "static int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDate",
          "args": [
            "field[i]",
            "fmask",
            "&tmask",
            "&is2digits",
            "tm"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2355-2459",
          "snippet": "static int\nDecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm)\n{\n\tfsec_t\t\tfsec;\n\tint\t\t\tnf = 0;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tint\t\t\tdterr;\n\tbool\t\thaveTextMonth = false;\n\tint\t\t\ttype,\n\t\t\t\tval,\n\t\t\t\tdmask = 0;\n\tchar\t   *field[MAXDATEFIELDS];\n\n\t*tmask = 0;\n\n\t/* parse this string... */\n\twhile (*str != '\\0' && nf < MAXDATEFIELDS)\n\t{\n\t\t/* skip field separators */\n\t\twhile (*str != '\\0' && !isalnum((unsigned char) *str))\n\t\t\tstr++;\n\n\t\tif (*str == '\\0')\n\t\t\treturn DTERR_BAD_FORMAT;\t/* end of string after separator */\n\n\t\tfield[nf] = str;\n\t\tif (isdigit((unsigned char) *str))\n\t\t{\n\t\t\twhile (isdigit((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse if (isalpha((unsigned char) *str))\n\t\t{\n\t\t\twhile (isalpha((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\n\t\t/* Just get rid of any non-digit, non-alpha characters... */\n\t\tif (*str != '\\0')\n\t\t\t*str++ = '\\0';\n\t\tnf++;\n\t}\n\n\t/* look first for text fields, since that will be unambiguous month */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (isalpha((unsigned char) *field[i]))\n\t\t{\n\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\tif (type == IGNORE_DTF)\n\t\t\t\tcontinue;\n\n\t\t\tdmask = DTK_M(type);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase MONTH:\n\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t\tif (fmask & dmask)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\tfmask |= dmask;\n\t\t\t*tmask |= dmask;\n\n\t\t\t/* mark this field as being completed */\n\t\t\tfield[i] = NULL;\n\t\t}\n\t}\n\n\t/* now pick up remaining numeric fields */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (field[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((len = strlen(field[i])) <= 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tdterr = DecodeNumber(len, field[i], haveTextMonth, fmask,\n\t\t\t\t\t\t\t &dmask, tm,\n\t\t\t\t\t\t\t &fsec, is2digits);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\tif (fmask & dmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tfmask |= dmask;\n\t\t*tmask |= dmask;\n\t}\n\n\tif ((fmask & ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* validation of the field values must wait until ValidateDate() */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm)\n{\n\tfsec_t\t\tfsec;\n\tint\t\t\tnf = 0;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tint\t\t\tdterr;\n\tbool\t\thaveTextMonth = false;\n\tint\t\t\ttype,\n\t\t\t\tval,\n\t\t\t\tdmask = 0;\n\tchar\t   *field[MAXDATEFIELDS];\n\n\t*tmask = 0;\n\n\t/* parse this string... */\n\twhile (*str != '\\0' && nf < MAXDATEFIELDS)\n\t{\n\t\t/* skip field separators */\n\t\twhile (*str != '\\0' && !isalnum((unsigned char) *str))\n\t\t\tstr++;\n\n\t\tif (*str == '\\0')\n\t\t\treturn DTERR_BAD_FORMAT;\t/* end of string after separator */\n\n\t\tfield[nf] = str;\n\t\tif (isdigit((unsigned char) *str))\n\t\t{\n\t\t\twhile (isdigit((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse if (isalpha((unsigned char) *str))\n\t\t{\n\t\t\twhile (isalpha((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\n\t\t/* Just get rid of any non-digit, non-alpha characters... */\n\t\tif (*str != '\\0')\n\t\t\t*str++ = '\\0';\n\t\tnf++;\n\t}\n\n\t/* look first for text fields, since that will be unambiguous month */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (isalpha((unsigned char) *field[i]))\n\t\t{\n\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\tif (type == IGNORE_DTF)\n\t\t\t\tcontinue;\n\n\t\t\tdmask = DTK_M(type);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase MONTH:\n\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t\tif (fmask & dmask)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\tfmask |= dmask;\n\t\t\t*tmask |= dmask;\n\n\t\t\t/* mark this field as being completed */\n\t\t\tfield[i] = NULL;\n\t\t}\n\t}\n\n\t/* now pick up remaining numeric fields */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (field[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((len = strlen(field[i])) <= 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tdterr = DecodeNumber(len, field[i], haveTextMonth, fmask,\n\t\t\t\t\t\t\t &dmask, tm,\n\t\t\t\t\t\t\t &fsec, is2digits);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\tif (fmask & dmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tfmask |= dmask;\n\t\t*tmask |= dmask;\n\t}\n\n\tif ((fmask & ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* validation of the field values must wait until ValidateDate() */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field[i]",
            "'.'"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2time",
          "args": [
            "time",
            "&tm->tm_hour",
            "&tm->tm_min",
            "&tm->tm_sec",
            "fsec"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "dt2time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1730-1743",
          "snippet": "void\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nvoid\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "cp",
            "&cp"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "val",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimezone",
          "args": [
            "field[i]",
            "tzp"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2892-2953",
          "snippet": "int\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseFractionalSecond",
          "args": [
            "cp",
            "fsec"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFractionalSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "497-511",
          "snippet": "static int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\n\nstatic int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "SECOND"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MINUTE"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "HOUR"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MINUTE"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "HOUR"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "field[i]",
            "&cp",
            "10"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTime",
          "args": [
            "field[i]",
            "(fmask | DTK_DATE_M)",
            "INTERVAL_FULL_RANGE",
            "&tmask",
            "tm",
            "fsec"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2544-2613",
          "snippet": "static int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i]))"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "field[i]"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field[i]",
            "'-'"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *field[i]"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeTimeOnly(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO h04mm05s06 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tint\t\t\tmer = HR24;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tchar\t   *abbrev = NULL;\n\tpg_tz\t   *valtz;\n\n\t*dtype = DTK_TIME;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Time zone not allowed? Then should not accept dates or time\n\t\t\t\t * zones no matter what else!\n\t\t\t\t */\n\t\t\t\tif (tzp == NULL)\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t/* Under limited circumstances, we will accept a date... */\n\t\t\t\tif (i == 0 && nf >= 2 &&\n\t\t\t\t\t(ftype[nf - 1] == DTK_DATE || ftype[1] == DTK_TIME))\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\t/* otherwise, this is a time and/or time zone */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with time already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Should not get here and fail. Sanity check only...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t   INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO time\" with embedded field labels? An\n\t\t\t\t * example is \"h04m05s06\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\t/* Only accept a date under limited circumstances */\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal? */\n\t\t\t\t\tif (cp != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Under limited circumstances, we will accept a\n\t\t\t\t\t\t * date...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i == 0 && nf >= 2 && ftype[nf - 1] == DTK_DATE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\t\telse if (flen - strlen(cp) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Interpret as a concatenated date or time Set\n\t\t\t\t\t\t\t * the type field to allow decoding other fields\n\t\t\t\t\t\t\t * later. Example: 20011223 or 040506\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flen > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\t\t\t\t\t (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = DTK_TIME_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, NULL);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/*\n\t * This should match the checks in make_timestamp_internal\n\t */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)) ||\n\t\t*fsec < INT64CONST(0) || *fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/*\n\t * If we had a full timezone spec, compute the offset (we could not do it\n\t * before, because we may need the date to resolve DST status).\n\t */\n\tif (namedTz != NULL)\n\t{\n\t\tlong int\tgmtoff;\n\n\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* if non-DST zone, we do not need to know the date */\n\t\tif (pg_get_timezone_offset(namedTz, &gmtoff))\n\t\t{\n\t\t\t*tzp = -(int) gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a date has to be specified */\n\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, if we had a dynamic timezone abbreviation, resolve it now.\n\t */\n\tif (abbrevTz != NULL)\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneAbbrevOffset(tmp, abbrev, abbrevTz);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\t/* timezone not specified? then use session timezone */\n\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneOffset(tmp, session_timezone);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "DetermineTimeZoneAbbrevOffsetInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "1690-1715",
    "snippet": "static bool\nDetermineTimeZoneAbbrevOffsetInternal(pg_time_t t, const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst)\n{\n\tchar\t\tupabbr[TZ_STRLEN_MAX + 1];\n\tunsigned char *p;\n\tlong int\tgmtoff;\n\n\t/* We need to force the abbrev to upper case */\n\tstrlcpy(upabbr, abbr, sizeof(upabbr));\n\tfor (p = (unsigned char *) upabbr; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\t/* Look up the abbrev's meaning at this time in this zone */\n\tif (pg_interpret_timezone_abbrev(upabbr,\n\t\t\t\t\t\t\t\t\t &t,\n\t\t\t\t\t\t\t\t\t &gmtoff,\n\t\t\t\t\t\t\t\t\t isdst,\n\t\t\t\t\t\t\t\t\t tzp))\n\t{\n\t\t/* Change sign to agree with DetermineTimeZoneOffset() */\n\t\t*offset = (int) -gmtoff;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_interpret_timezone_abbrev",
          "args": [
            "upabbr",
            "&t",
            "&gmtoff",
            "isdst",
            "tzp"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "*p"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "upabbr",
            "abbr",
            "sizeof(upabbr)"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\n\nstatic bool\nDetermineTimeZoneAbbrevOffsetInternal(pg_time_t t, const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst)\n{\n\tchar\t\tupabbr[TZ_STRLEN_MAX + 1];\n\tunsigned char *p;\n\tlong int\tgmtoff;\n\n\t/* We need to force the abbrev to upper case */\n\tstrlcpy(upabbr, abbr, sizeof(upabbr));\n\tfor (p = (unsigned char *) upabbr; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\t/* Look up the abbrev's meaning at this time in this zone */\n\tif (pg_interpret_timezone_abbrev(upabbr,\n\t\t\t\t\t\t\t\t\t &t,\n\t\t\t\t\t\t\t\t\t &gmtoff,\n\t\t\t\t\t\t\t\t\t isdst,\n\t\t\t\t\t\t\t\t\t tzp))\n\t{\n\t\t/* Change sign to agree with DetermineTimeZoneOffset() */\n\t\t*offset = (int) -gmtoff;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "DetermineTimeZoneAbbrevOffsetTS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "1653-1682",
    "snippet": "int\nDetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,\n\t\t\t\t\t\t\t\tpg_tz *tzp, int *isdst)\n{\n\tpg_time_t\tt = timestamptz_to_time_t(ts);\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\t/*\n\t * If the abbrev matches anything in the zone data, this is pretty easy.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, isdst))\n\t\treturn abbr_offset;\n\n\t/*\n\t * Else, break down the timestamp so we can use DetermineTimeZoneOffset.\n\t */\n\tif (timestamp2tm(ts, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tzone_offset = DetermineTimeZoneOffset(&tm, tzp);\n\t*isdst = tm.tm_isdst;\n\treturn zone_offset;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "&tm",
            "tzp"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "ts",
            "&tz",
            "&tm",
            "&fsec",
            "NULL",
            "tzp"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffsetInternal",
          "args": [
            "t",
            "abbr",
            "tzp",
            "&abbr_offset",
            "isdst"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffsetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1690-1715",
          "snippet": "static bool\nDetermineTimeZoneAbbrevOffsetInternal(pg_time_t t, const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst)\n{\n\tchar\t\tupabbr[TZ_STRLEN_MAX + 1];\n\tunsigned char *p;\n\tlong int\tgmtoff;\n\n\t/* We need to force the abbrev to upper case */\n\tstrlcpy(upabbr, abbr, sizeof(upabbr));\n\tfor (p = (unsigned char *) upabbr; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\t/* Look up the abbrev's meaning at this time in this zone */\n\tif (pg_interpret_timezone_abbrev(upabbr,\n\t\t\t\t\t\t\t\t\t &t,\n\t\t\t\t\t\t\t\t\t &gmtoff,\n\t\t\t\t\t\t\t\t\t isdst,\n\t\t\t\t\t\t\t\t\t tzp))\n\t{\n\t\t/* Change sign to agree with DetermineTimeZoneOffset() */\n\t\t*offset = (int) -gmtoff;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\n\nstatic bool\nDetermineTimeZoneAbbrevOffsetInternal(pg_time_t t, const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst)\n{\n\tchar\t\tupabbr[TZ_STRLEN_MAX + 1];\n\tunsigned char *p;\n\tlong int\tgmtoff;\n\n\t/* We need to force the abbrev to upper case */\n\tstrlcpy(upabbr, abbr, sizeof(upabbr));\n\tfor (p = (unsigned char *) upabbr; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\t/* Look up the abbrev's meaning at this time in this zone */\n\tif (pg_interpret_timezone_abbrev(upabbr,\n\t\t\t\t\t\t\t\t\t &t,\n\t\t\t\t\t\t\t\t\t &gmtoff,\n\t\t\t\t\t\t\t\t\t isdst,\n\t\t\t\t\t\t\t\t\t tzp))\n\t{\n\t\t/* Change sign to agree with DetermineTimeZoneOffset() */\n\t\t*offset = (int) -gmtoff;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamptz_to_time_t",
          "args": [
            "ts"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "timestamptz_to_time_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1691-1700",
          "snippet": "pg_time_t\ntimestamptz_to_time_t(TimestampTz t)\n{\n\tpg_time_t\tresult;\n\n\tresult = (pg_time_t) (t / USECS_PER_SEC +\n\t\t\t\t\t\t  ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\npg_time_t\ntimestamptz_to_time_t(TimestampTz t)\n{\n\tpg_time_t\tresult;\n\n\tresult = (pg_time_t) (t / USECS_PER_SEC +\n\t\t\t\t\t\t  ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY));\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\n\nint\nDetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,\n\t\t\t\t\t\t\t\tpg_tz *tzp, int *isdst)\n{\n\tpg_time_t\tt = timestamptz_to_time_t(ts);\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\t/*\n\t * If the abbrev matches anything in the zone data, this is pretty easy.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, isdst))\n\t\treturn abbr_offset;\n\n\t/*\n\t * Else, break down the timestamp so we can use DetermineTimeZoneOffset.\n\t */\n\tif (timestamp2tm(ts, &tz, &tm, &fsec, NULL, tzp) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tzone_offset = DetermineTimeZoneOffset(&tm, tzp);\n\t*isdst = tm.tm_isdst;\n\treturn zone_offset;\n}"
  },
  {
    "function_name": "DetermineTimeZoneAbbrevOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "1615-1645",
    "snippet": "int\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffsetInternal",
          "args": [
            "t",
            "abbr",
            "tzp",
            "&abbr_offset",
            "&abbr_isdst"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffsetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1690-1715",
          "snippet": "static bool\nDetermineTimeZoneAbbrevOffsetInternal(pg_time_t t, const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst)\n{\n\tchar\t\tupabbr[TZ_STRLEN_MAX + 1];\n\tunsigned char *p;\n\tlong int\tgmtoff;\n\n\t/* We need to force the abbrev to upper case */\n\tstrlcpy(upabbr, abbr, sizeof(upabbr));\n\tfor (p = (unsigned char *) upabbr; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\t/* Look up the abbrev's meaning at this time in this zone */\n\tif (pg_interpret_timezone_abbrev(upabbr,\n\t\t\t\t\t\t\t\t\t &t,\n\t\t\t\t\t\t\t\t\t &gmtoff,\n\t\t\t\t\t\t\t\t\t isdst,\n\t\t\t\t\t\t\t\t\t tzp))\n\t{\n\t\t/* Change sign to agree with DetermineTimeZoneOffset() */\n\t\t*offset = (int) -gmtoff;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool DetermineTimeZoneAbbrevOffsetInternal(pg_time_t t,\n\t\t\t\t\t\t\t\t\t  const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst);\n\nstatic bool\nDetermineTimeZoneAbbrevOffsetInternal(pg_time_t t, const char *abbr, pg_tz *tzp,\n\t\t\t\t\t\t\t\t\t  int *offset, int *isdst)\n{\n\tchar\t\tupabbr[TZ_STRLEN_MAX + 1];\n\tunsigned char *p;\n\tlong int\tgmtoff;\n\n\t/* We need to force the abbrev to upper case */\n\tstrlcpy(upabbr, abbr, sizeof(upabbr));\n\tfor (p = (unsigned char *) upabbr; *p; p++)\n\t\t*p = pg_toupper(*p);\n\n\t/* Look up the abbrev's meaning at this time in this zone */\n\tif (pg_interpret_timezone_abbrev(upabbr,\n\t\t\t\t\t\t\t\t\t &t,\n\t\t\t\t\t\t\t\t\t &gmtoff,\n\t\t\t\t\t\t\t\t\t isdst,\n\t\t\t\t\t\t\t\t\t tzp))\n\t{\n\t\t/* Change sign to agree with DetermineTimeZoneOffset() */\n\t\t*offset = (int) -gmtoff;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffsetInternal",
          "args": [
            "tm",
            "tzp",
            "&t"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffsetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1476-1598",
          "snippet": "static int\nDetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp, pg_time_t *tp)\n{\n\tint\t\t\tdate,\n\t\t\t\tsec;\n\tpg_time_t\tday,\n\t\t\t\tmytime,\n\t\t\t\tprevtime,\n\t\t\t\tboundary,\n\t\t\t\tbeforetime,\n\t\t\t\taftertime;\n\tlong int\tbefore_gmtoff,\n\t\t\t\tafter_gmtoff;\n\tint\t\t\tbefore_isdst,\n\t\t\t\tafter_isdst;\n\tint\t\t\tres;\n\n\t/*\n\t * First, generate the pg_time_t value corresponding to the given\n\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n\t */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tgoto overflow;\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\tday = ((pg_time_t) date) * SECS_PER_DAY;\n\tif (day / SECS_PER_DAY != date)\n\t\tgoto overflow;\n\tsec = tm->tm_sec + (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\tmytime = day + sec;\n\t/* since sec >= 0, overflow could only be from +day to -mytime */\n\tif (mytime < 0 && day > 0)\n\t\tgoto overflow;\n\n\t/*\n\t * Find the DST time boundary just before or following the target time. We\n\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n\t * boundaries can't be closer together than 48 hours, so backing up 24\n\t * hours and finding the \"next\" boundary will work.\n\t */\n\tprevtime = mytime - SECS_PER_DAY;\n\tif (mytime < 0 && prevtime > 0)\n\t\tgoto overflow;\n\n\tres = pg_next_dst_boundary(&prevtime,\n\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n\t\t\t\t\t\t\t   &boundary,\n\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n\t\t\t\t\t\t\t   tzp);\n\tif (res < 0)\n\t\tgoto overflow;\t\t\t/* failure? */\n\n\tif (res == 0)\n\t{\n\t\t/* Non-DST zone, life is simple */\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = mytime - before_gmtoff;\n\t\treturn -(int) before_gmtoff;\n\t}\n\n\t/*\n\t * Form the candidate pg_time_t values with local-time adjustment\n\t */\n\tbeforetime = mytime - before_gmtoff;\n\tif ((before_gmtoff > 0 &&\n\t\t mytime < 0 && beforetime > 0) ||\n\t\t(before_gmtoff <= 0 &&\n\t\t mytime > 0 && beforetime < 0))\n\t\tgoto overflow;\n\taftertime = mytime - after_gmtoff;\n\tif ((after_gmtoff > 0 &&\n\t\t mytime < 0 && aftertime > 0) ||\n\t\t(after_gmtoff <= 0 &&\n\t\t mytime > 0 && aftertime < 0))\n\t\tgoto overflow;\n\n\t/*\n\t * If both before or both after the boundary time, we know what to do. The\n\t * boundary time itself is considered to be after the transition, which\n\t * means we can accept aftertime == boundary in the second case.\n\t */\n\tif (beforetime < boundary && aftertime < boundary)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\tif (beforetime > boundary && aftertime >= boundary)\n\t{\n\t\ttm->tm_isdst = after_isdst;\n\t\t*tp = aftertime;\n\t\treturn -(int) after_gmtoff;\n\t}\n\n\t/*\n\t * It's an invalid or ambiguous time due to timezone transition.  In a\n\t * spring-forward transition, prefer the \"before\" interpretation; in a\n\t * fall-back transition, prefer \"after\".  (We used to define and implement\n\t * this test as \"prefer the standard-time interpretation\", but that rule\n\t * does not help to resolve the behavior when both times are reported as\n\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,\n\t * in some zones such as Europe/Dublin, there is widespread confusion\n\t * about which time offset is \"standard\" time, so it's fortunate that our\n\t * behavior doesn't depend on that.)\n\t */\n\tif (beforetime > aftertime)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\ttm->tm_isdst = after_isdst;\n\t*tp = aftertime;\n\treturn -(int) after_gmtoff;\n\noverflow:\n\t/* Given date is out of range, so assume UTC */\n\ttm->tm_isdst = 0;\n\t*tp = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\n\nstatic int\nDetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp, pg_time_t *tp)\n{\n\tint\t\t\tdate,\n\t\t\t\tsec;\n\tpg_time_t\tday,\n\t\t\t\tmytime,\n\t\t\t\tprevtime,\n\t\t\t\tboundary,\n\t\t\t\tbeforetime,\n\t\t\t\taftertime;\n\tlong int\tbefore_gmtoff,\n\t\t\t\tafter_gmtoff;\n\tint\t\t\tbefore_isdst,\n\t\t\t\tafter_isdst;\n\tint\t\t\tres;\n\n\t/*\n\t * First, generate the pg_time_t value corresponding to the given\n\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n\t */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tgoto overflow;\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\tday = ((pg_time_t) date) * SECS_PER_DAY;\n\tif (day / SECS_PER_DAY != date)\n\t\tgoto overflow;\n\tsec = tm->tm_sec + (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\tmytime = day + sec;\n\t/* since sec >= 0, overflow could only be from +day to -mytime */\n\tif (mytime < 0 && day > 0)\n\t\tgoto overflow;\n\n\t/*\n\t * Find the DST time boundary just before or following the target time. We\n\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n\t * boundaries can't be closer together than 48 hours, so backing up 24\n\t * hours and finding the \"next\" boundary will work.\n\t */\n\tprevtime = mytime - SECS_PER_DAY;\n\tif (mytime < 0 && prevtime > 0)\n\t\tgoto overflow;\n\n\tres = pg_next_dst_boundary(&prevtime,\n\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n\t\t\t\t\t\t\t   &boundary,\n\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n\t\t\t\t\t\t\t   tzp);\n\tif (res < 0)\n\t\tgoto overflow;\t\t\t/* failure? */\n\n\tif (res == 0)\n\t{\n\t\t/* Non-DST zone, life is simple */\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = mytime - before_gmtoff;\n\t\treturn -(int) before_gmtoff;\n\t}\n\n\t/*\n\t * Form the candidate pg_time_t values with local-time adjustment\n\t */\n\tbeforetime = mytime - before_gmtoff;\n\tif ((before_gmtoff > 0 &&\n\t\t mytime < 0 && beforetime > 0) ||\n\t\t(before_gmtoff <= 0 &&\n\t\t mytime > 0 && beforetime < 0))\n\t\tgoto overflow;\n\taftertime = mytime - after_gmtoff;\n\tif ((after_gmtoff > 0 &&\n\t\t mytime < 0 && aftertime > 0) ||\n\t\t(after_gmtoff <= 0 &&\n\t\t mytime > 0 && aftertime < 0))\n\t\tgoto overflow;\n\n\t/*\n\t * If both before or both after the boundary time, we know what to do. The\n\t * boundary time itself is considered to be after the transition, which\n\t * means we can accept aftertime == boundary in the second case.\n\t */\n\tif (beforetime < boundary && aftertime < boundary)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\tif (beforetime > boundary && aftertime >= boundary)\n\t{\n\t\ttm->tm_isdst = after_isdst;\n\t\t*tp = aftertime;\n\t\treturn -(int) after_gmtoff;\n\t}\n\n\t/*\n\t * It's an invalid or ambiguous time due to timezone transition.  In a\n\t * spring-forward transition, prefer the \"before\" interpretation; in a\n\t * fall-back transition, prefer \"after\".  (We used to define and implement\n\t * this test as \"prefer the standard-time interpretation\", but that rule\n\t * does not help to resolve the behavior when both times are reported as\n\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,\n\t * in some zones such as Europe/Dublin, there is widespread confusion\n\t * about which time offset is \"standard\" time, so it's fortunate that our\n\t * behavior doesn't depend on that.)\n\t */\n\tif (beforetime > aftertime)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\ttm->tm_isdst = after_isdst;\n\t*tp = aftertime;\n\treturn -(int) after_gmtoff;\n\noverflow:\n\t/* Given date is out of range, so assume UTC */\n\ttm->tm_isdst = 0;\n\t*tp = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}"
  },
  {
    "function_name": "DetermineTimeZoneOffsetInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "1476-1598",
    "snippet": "static int\nDetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp, pg_time_t *tp)\n{\n\tint\t\t\tdate,\n\t\t\t\tsec;\n\tpg_time_t\tday,\n\t\t\t\tmytime,\n\t\t\t\tprevtime,\n\t\t\t\tboundary,\n\t\t\t\tbeforetime,\n\t\t\t\taftertime;\n\tlong int\tbefore_gmtoff,\n\t\t\t\tafter_gmtoff;\n\tint\t\t\tbefore_isdst,\n\t\t\t\tafter_isdst;\n\tint\t\t\tres;\n\n\t/*\n\t * First, generate the pg_time_t value corresponding to the given\n\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n\t */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tgoto overflow;\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\tday = ((pg_time_t) date) * SECS_PER_DAY;\n\tif (day / SECS_PER_DAY != date)\n\t\tgoto overflow;\n\tsec = tm->tm_sec + (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\tmytime = day + sec;\n\t/* since sec >= 0, overflow could only be from +day to -mytime */\n\tif (mytime < 0 && day > 0)\n\t\tgoto overflow;\n\n\t/*\n\t * Find the DST time boundary just before or following the target time. We\n\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n\t * boundaries can't be closer together than 48 hours, so backing up 24\n\t * hours and finding the \"next\" boundary will work.\n\t */\n\tprevtime = mytime - SECS_PER_DAY;\n\tif (mytime < 0 && prevtime > 0)\n\t\tgoto overflow;\n\n\tres = pg_next_dst_boundary(&prevtime,\n\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n\t\t\t\t\t\t\t   &boundary,\n\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n\t\t\t\t\t\t\t   tzp);\n\tif (res < 0)\n\t\tgoto overflow;\t\t\t/* failure? */\n\n\tif (res == 0)\n\t{\n\t\t/* Non-DST zone, life is simple */\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = mytime - before_gmtoff;\n\t\treturn -(int) before_gmtoff;\n\t}\n\n\t/*\n\t * Form the candidate pg_time_t values with local-time adjustment\n\t */\n\tbeforetime = mytime - before_gmtoff;\n\tif ((before_gmtoff > 0 &&\n\t\t mytime < 0 && beforetime > 0) ||\n\t\t(before_gmtoff <= 0 &&\n\t\t mytime > 0 && beforetime < 0))\n\t\tgoto overflow;\n\taftertime = mytime - after_gmtoff;\n\tif ((after_gmtoff > 0 &&\n\t\t mytime < 0 && aftertime > 0) ||\n\t\t(after_gmtoff <= 0 &&\n\t\t mytime > 0 && aftertime < 0))\n\t\tgoto overflow;\n\n\t/*\n\t * If both before or both after the boundary time, we know what to do. The\n\t * boundary time itself is considered to be after the transition, which\n\t * means we can accept aftertime == boundary in the second case.\n\t */\n\tif (beforetime < boundary && aftertime < boundary)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\tif (beforetime > boundary && aftertime >= boundary)\n\t{\n\t\ttm->tm_isdst = after_isdst;\n\t\t*tp = aftertime;\n\t\treturn -(int) after_gmtoff;\n\t}\n\n\t/*\n\t * It's an invalid or ambiguous time due to timezone transition.  In a\n\t * spring-forward transition, prefer the \"before\" interpretation; in a\n\t * fall-back transition, prefer \"after\".  (We used to define and implement\n\t * this test as \"prefer the standard-time interpretation\", but that rule\n\t * does not help to resolve the behavior when both times are reported as\n\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,\n\t * in some zones such as Europe/Dublin, there is widespread confusion\n\t * about which time offset is \"standard\" time, so it's fortunate that our\n\t * behavior doesn't depend on that.)\n\t */\n\tif (beforetime > aftertime)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\ttm->tm_isdst = after_isdst;\n\t*tp = aftertime;\n\treturn -(int) after_gmtoff;\n\noverflow:\n\t/* Given date is out of range, so assume UTC */\n\ttm->tm_isdst = 0;\n\t*tp = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
      "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_next_dst_boundary",
          "args": [
            "&prevtime",
            "&before_gmtoff",
            "&before_isdst",
            "&boundary",
            "&after_gmtoff",
            "&after_isdst",
            "tzp"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\n\nstatic int\nDetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp, pg_time_t *tp)\n{\n\tint\t\t\tdate,\n\t\t\t\tsec;\n\tpg_time_t\tday,\n\t\t\t\tmytime,\n\t\t\t\tprevtime,\n\t\t\t\tboundary,\n\t\t\t\tbeforetime,\n\t\t\t\taftertime;\n\tlong int\tbefore_gmtoff,\n\t\t\t\tafter_gmtoff;\n\tint\t\t\tbefore_isdst,\n\t\t\t\tafter_isdst;\n\tint\t\t\tres;\n\n\t/*\n\t * First, generate the pg_time_t value corresponding to the given\n\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n\t */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tgoto overflow;\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\tday = ((pg_time_t) date) * SECS_PER_DAY;\n\tif (day / SECS_PER_DAY != date)\n\t\tgoto overflow;\n\tsec = tm->tm_sec + (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\tmytime = day + sec;\n\t/* since sec >= 0, overflow could only be from +day to -mytime */\n\tif (mytime < 0 && day > 0)\n\t\tgoto overflow;\n\n\t/*\n\t * Find the DST time boundary just before or following the target time. We\n\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n\t * boundaries can't be closer together than 48 hours, so backing up 24\n\t * hours and finding the \"next\" boundary will work.\n\t */\n\tprevtime = mytime - SECS_PER_DAY;\n\tif (mytime < 0 && prevtime > 0)\n\t\tgoto overflow;\n\n\tres = pg_next_dst_boundary(&prevtime,\n\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n\t\t\t\t\t\t\t   &boundary,\n\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n\t\t\t\t\t\t\t   tzp);\n\tif (res < 0)\n\t\tgoto overflow;\t\t\t/* failure? */\n\n\tif (res == 0)\n\t{\n\t\t/* Non-DST zone, life is simple */\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = mytime - before_gmtoff;\n\t\treturn -(int) before_gmtoff;\n\t}\n\n\t/*\n\t * Form the candidate pg_time_t values with local-time adjustment\n\t */\n\tbeforetime = mytime - before_gmtoff;\n\tif ((before_gmtoff > 0 &&\n\t\t mytime < 0 && beforetime > 0) ||\n\t\t(before_gmtoff <= 0 &&\n\t\t mytime > 0 && beforetime < 0))\n\t\tgoto overflow;\n\taftertime = mytime - after_gmtoff;\n\tif ((after_gmtoff > 0 &&\n\t\t mytime < 0 && aftertime > 0) ||\n\t\t(after_gmtoff <= 0 &&\n\t\t mytime > 0 && aftertime < 0))\n\t\tgoto overflow;\n\n\t/*\n\t * If both before or both after the boundary time, we know what to do. The\n\t * boundary time itself is considered to be after the transition, which\n\t * means we can accept aftertime == boundary in the second case.\n\t */\n\tif (beforetime < boundary && aftertime < boundary)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\tif (beforetime > boundary && aftertime >= boundary)\n\t{\n\t\ttm->tm_isdst = after_isdst;\n\t\t*tp = aftertime;\n\t\treturn -(int) after_gmtoff;\n\t}\n\n\t/*\n\t * It's an invalid or ambiguous time due to timezone transition.  In a\n\t * spring-forward transition, prefer the \"before\" interpretation; in a\n\t * fall-back transition, prefer \"after\".  (We used to define and implement\n\t * this test as \"prefer the standard-time interpretation\", but that rule\n\t * does not help to resolve the behavior when both times are reported as\n\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,\n\t * in some zones such as Europe/Dublin, there is widespread confusion\n\t * about which time offset is \"standard\" time, so it's fortunate that our\n\t * behavior doesn't depend on that.)\n\t */\n\tif (beforetime > aftertime)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\ttm->tm_isdst = after_isdst;\n\t*tp = aftertime;\n\treturn -(int) after_gmtoff;\n\noverflow:\n\t/* Given date is out of range, so assume UTC */\n\ttm->tm_isdst = 0;\n\t*tp = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "DetermineTimeZoneOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "1454-1460",
    "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffsetInternal",
          "args": [
            "tm",
            "tzp",
            "&t"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffsetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1476-1598",
          "snippet": "static int\nDetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp, pg_time_t *tp)\n{\n\tint\t\t\tdate,\n\t\t\t\tsec;\n\tpg_time_t\tday,\n\t\t\t\tmytime,\n\t\t\t\tprevtime,\n\t\t\t\tboundary,\n\t\t\t\tbeforetime,\n\t\t\t\taftertime;\n\tlong int\tbefore_gmtoff,\n\t\t\t\tafter_gmtoff;\n\tint\t\t\tbefore_isdst,\n\t\t\t\tafter_isdst;\n\tint\t\t\tres;\n\n\t/*\n\t * First, generate the pg_time_t value corresponding to the given\n\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n\t */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tgoto overflow;\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\tday = ((pg_time_t) date) * SECS_PER_DAY;\n\tif (day / SECS_PER_DAY != date)\n\t\tgoto overflow;\n\tsec = tm->tm_sec + (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\tmytime = day + sec;\n\t/* since sec >= 0, overflow could only be from +day to -mytime */\n\tif (mytime < 0 && day > 0)\n\t\tgoto overflow;\n\n\t/*\n\t * Find the DST time boundary just before or following the target time. We\n\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n\t * boundaries can't be closer together than 48 hours, so backing up 24\n\t * hours and finding the \"next\" boundary will work.\n\t */\n\tprevtime = mytime - SECS_PER_DAY;\n\tif (mytime < 0 && prevtime > 0)\n\t\tgoto overflow;\n\n\tres = pg_next_dst_boundary(&prevtime,\n\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n\t\t\t\t\t\t\t   &boundary,\n\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n\t\t\t\t\t\t\t   tzp);\n\tif (res < 0)\n\t\tgoto overflow;\t\t\t/* failure? */\n\n\tif (res == 0)\n\t{\n\t\t/* Non-DST zone, life is simple */\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = mytime - before_gmtoff;\n\t\treturn -(int) before_gmtoff;\n\t}\n\n\t/*\n\t * Form the candidate pg_time_t values with local-time adjustment\n\t */\n\tbeforetime = mytime - before_gmtoff;\n\tif ((before_gmtoff > 0 &&\n\t\t mytime < 0 && beforetime > 0) ||\n\t\t(before_gmtoff <= 0 &&\n\t\t mytime > 0 && beforetime < 0))\n\t\tgoto overflow;\n\taftertime = mytime - after_gmtoff;\n\tif ((after_gmtoff > 0 &&\n\t\t mytime < 0 && aftertime > 0) ||\n\t\t(after_gmtoff <= 0 &&\n\t\t mytime > 0 && aftertime < 0))\n\t\tgoto overflow;\n\n\t/*\n\t * If both before or both after the boundary time, we know what to do. The\n\t * boundary time itself is considered to be after the transition, which\n\t * means we can accept aftertime == boundary in the second case.\n\t */\n\tif (beforetime < boundary && aftertime < boundary)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\tif (beforetime > boundary && aftertime >= boundary)\n\t{\n\t\ttm->tm_isdst = after_isdst;\n\t\t*tp = aftertime;\n\t\treturn -(int) after_gmtoff;\n\t}\n\n\t/*\n\t * It's an invalid or ambiguous time due to timezone transition.  In a\n\t * spring-forward transition, prefer the \"before\" interpretation; in a\n\t * fall-back transition, prefer \"after\".  (We used to define and implement\n\t * this test as \"prefer the standard-time interpretation\", but that rule\n\t * does not help to resolve the behavior when both times are reported as\n\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,\n\t * in some zones such as Europe/Dublin, there is widespread confusion\n\t * about which time offset is \"standard\" time, so it's fortunate that our\n\t * behavior doesn't depend on that.)\n\t */\n\tif (beforetime > aftertime)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\ttm->tm_isdst = after_isdst;\n\t*tp = aftertime;\n\treturn -(int) after_gmtoff;\n\noverflow:\n\t/* Given date is out of range, so assume UTC */\n\ttm->tm_isdst = 0;\n\t*tp = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\n\nstatic int\nDetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp, pg_time_t *tp)\n{\n\tint\t\t\tdate,\n\t\t\t\tsec;\n\tpg_time_t\tday,\n\t\t\t\tmytime,\n\t\t\t\tprevtime,\n\t\t\t\tboundary,\n\t\t\t\tbeforetime,\n\t\t\t\taftertime;\n\tlong int\tbefore_gmtoff,\n\t\t\t\tafter_gmtoff;\n\tint\t\t\tbefore_isdst,\n\t\t\t\tafter_isdst;\n\tint\t\t\tres;\n\n\t/*\n\t * First, generate the pg_time_t value corresponding to the given\n\t * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the\n\t * timezone is GMT.  (For a valid Julian date, integer overflow should be\n\t * impossible with 64-bit pg_time_t, but let's check for safety.)\n\t */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tgoto overflow;\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\tday = ((pg_time_t) date) * SECS_PER_DAY;\n\tif (day / SECS_PER_DAY != date)\n\t\tgoto overflow;\n\tsec = tm->tm_sec + (tm->tm_min + tm->tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\tmytime = day + sec;\n\t/* since sec >= 0, overflow could only be from +day to -mytime */\n\tif (mytime < 0 && day > 0)\n\t\tgoto overflow;\n\n\t/*\n\t * Find the DST time boundary just before or following the target time. We\n\t * assume that all zones have GMT offsets less than 24 hours, and that DST\n\t * boundaries can't be closer together than 48 hours, so backing up 24\n\t * hours and finding the \"next\" boundary will work.\n\t */\n\tprevtime = mytime - SECS_PER_DAY;\n\tif (mytime < 0 && prevtime > 0)\n\t\tgoto overflow;\n\n\tres = pg_next_dst_boundary(&prevtime,\n\t\t\t\t\t\t\t   &before_gmtoff, &before_isdst,\n\t\t\t\t\t\t\t   &boundary,\n\t\t\t\t\t\t\t   &after_gmtoff, &after_isdst,\n\t\t\t\t\t\t\t   tzp);\n\tif (res < 0)\n\t\tgoto overflow;\t\t\t/* failure? */\n\n\tif (res == 0)\n\t{\n\t\t/* Non-DST zone, life is simple */\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = mytime - before_gmtoff;\n\t\treturn -(int) before_gmtoff;\n\t}\n\n\t/*\n\t * Form the candidate pg_time_t values with local-time adjustment\n\t */\n\tbeforetime = mytime - before_gmtoff;\n\tif ((before_gmtoff > 0 &&\n\t\t mytime < 0 && beforetime > 0) ||\n\t\t(before_gmtoff <= 0 &&\n\t\t mytime > 0 && beforetime < 0))\n\t\tgoto overflow;\n\taftertime = mytime - after_gmtoff;\n\tif ((after_gmtoff > 0 &&\n\t\t mytime < 0 && aftertime > 0) ||\n\t\t(after_gmtoff <= 0 &&\n\t\t mytime > 0 && aftertime < 0))\n\t\tgoto overflow;\n\n\t/*\n\t * If both before or both after the boundary time, we know what to do. The\n\t * boundary time itself is considered to be after the transition, which\n\t * means we can accept aftertime == boundary in the second case.\n\t */\n\tif (beforetime < boundary && aftertime < boundary)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\tif (beforetime > boundary && aftertime >= boundary)\n\t{\n\t\ttm->tm_isdst = after_isdst;\n\t\t*tp = aftertime;\n\t\treturn -(int) after_gmtoff;\n\t}\n\n\t/*\n\t * It's an invalid or ambiguous time due to timezone transition.  In a\n\t * spring-forward transition, prefer the \"before\" interpretation; in a\n\t * fall-back transition, prefer \"after\".  (We used to define and implement\n\t * this test as \"prefer the standard-time interpretation\", but that rule\n\t * does not help to resolve the behavior when both times are reported as\n\t * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,\n\t * in some zones such as Europe/Dublin, there is widespread confusion\n\t * about which time offset is \"standard\" time, so it's fortunate that our\n\t * behavior doesn't depend on that.)\n\t */\n\tif (beforetime > aftertime)\n\t{\n\t\ttm->tm_isdst = before_isdst;\n\t\t*tp = beforetime;\n\t\treturn -(int) before_gmtoff;\n\t}\n\ttm->tm_isdst = after_isdst;\n\t*tp = aftertime;\n\treturn -(int) after_gmtoff;\n\noverflow:\n\t/* Given date is out of range, so assume UTC */\n\ttm->tm_isdst = 0;\n\t*tp = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
  },
  {
    "function_name": "DecodeDateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "766-1439",
    "snippet": "int\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZMOD"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffset",
          "args": [
            "tm",
            "abbrev",
            "abbrevTz"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1615-1645",
          "snippet": "int\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZMOD"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZMOD"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValidateDate",
          "args": [
            "fmask",
            "isjulian",
            "is2digits",
            "bc",
            "tm"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2465-2534",
          "snippet": "int\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};\n\nint\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "field[i]"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DTZ"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "cur_tm.tm_year",
            "cur_tm.tm_mon",
            "cur_tm.tm_mday"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentDateTime",
          "args": [
            "&cur_tm"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "353-362",
          "snippet": "void\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTimeUsec",
          "args": [
            "tm",
            "fsec",
            "tzp"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimeUsec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "370-380",
          "snippet": "void\nGetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\ttz;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n\tif (tzp != NULL)\n\t\t*tzp = tz;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\ttz;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n\tif (tzp != NULL)\n\t\t*tzp = tz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\"))"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date/time value \\\"current\\\" is no longer supported\""
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "type"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "i",
            "field[i]",
            "&val"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimezoneAbbrev",
          "args": [
            "i",
            "field[i]",
            "&val",
            "&valtz"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezoneAbbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2970-3010",
          "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
            "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeNumber",
          "args": [
            "flen",
            "field[i]",
            "haveTextMonth",
            "fmask",
            "&tmask",
            "tm",
            "fsec",
            "&is2digits"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2620-2795",
          "snippet": "static int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumber(int flen, char *str, bool haveTextMonth, int fmask,\n\t\t\t int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tint\t\t\tval;\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = 0;\n\n\terrno = 0;\n\tval = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (cp == str)\n\t\treturn DTERR_BAD_FORMAT;\n\n\tif (*cp == '.')\n\t{\n\t\t/*\n\t\t * More than two digits before decimal point? Then could be a date or\n\t\t * a run-together time: 2001.360 20011225 040506.789\n\t\t */\n\t\tif (cp - str > 2)\n\t\t{\n\t\t\tdterr = DecodeNumberField(flen, str,\n\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t}\n\telse if (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* Special case for day of year */\n\tif (flen == 3 && (fmask & DTK_DATE_M) == DTK_M(YEAR) && val >= 1 &&\n\t\tval <= 366)\n\t{\n\t\t*tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));\n\t\ttm->tm_yday = val;\n\t\t/* tm_mon and tm_mday can't actually be set yet ... */\n\t\treturn 0;\n\t}\n\n\t/* Switch based on what we have so far */\n\tswitch (fmask & DTK_DATE_M)\n\t{\n\t\tcase 0:\n\n\t\t\t/*\n\t\t\t * Nothing so far; make a decision about what we think the input\n\t\t\t * is.  There used to be lots of heuristics here, but the\n\t\t\t * consensus now is to be paranoid.  It *must* be either\n\t\t\t * YYYY-MM-DD (with a more-than-two-digit year field), or the\n\t\t\t * field order defined by DateOrder.\n\t\t\t */\n\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\ttm->tm_year = val;\n\t\t\t}\n\t\t\telse if (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*tmask = DTK_M(MONTH);\n\t\t\t\ttm->tm_mon = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR)):\n\t\t\t/* Must be at second field of YY-MM-DD */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are at the first numeric field of a date that included a\n\t\t\t\t * textual month name.  We want to support the variants\n\t\t\t\t * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous\n\t\t\t\t * inputs.  We will also accept MON-DD-YY or DD-MON-YY in\n\t\t\t\t * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.\n\t\t\t\t */\n\t\t\t\tif (flen >= 3 || DateOrder == DATEORDER_YMD)\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(YEAR);\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at second field of MM-DD-YY */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH)):\n\t\t\tif (haveTextMonth)\n\t\t\t{\n\t\t\t\t/* Need to accept DD-MON-YYYY even in YMD mode */\n\t\t\t\tif (flen >= 3 && *is2digits)\n\t\t\t\t{\n\t\t\t\t\t/* Guess that first numeric field is day was wrong */\n\t\t\t\t\t*tmask = DTK_M(DAY);\t/* YEAR is already set */\n\t\t\t\t\ttm->tm_mday = tm->tm_year;\n\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t*is2digits = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Must be at third field of YY-MM-DD */\n\t\t\t\t*tmask = DTK_M(DAY);\n\t\t\t\ttm->tm_mday = val;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase (DTK_M(DAY)):\n\t\t\t/* Must be at second field of DD-MM-YY */\n\t\t\t*tmask = DTK_M(MONTH);\n\t\t\ttm->tm_mon = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* Must be at third field of DD-MM-YY or MM-DD-YY */\n\t\t\t*tmask = DTK_M(YEAR);\n\t\t\ttm->tm_year = val;\n\t\t\tbreak;\n\n\t\tcase (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):\n\t\t\t/* we have all the date, so it must be a time field */\n\t\t\tdterr = DecodeNumberField(flen, str, fmask,\n\t\t\t\t\t\t\t\t\t  tmask, tm,\n\t\t\t\t\t\t\t\t\t  fsec, is2digits);\n\t\t\tif (dterr < 0)\n\t\t\t\treturn dterr;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/* Anything else is bogus input */\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\n\t/*\n\t * When processing a year field, mark it for adjustment if it's only one\n\t * or two digits.\n\t */\n\tif (*tmask == DTK_M(YEAR))\n\t\t*is2digits = (flen <= 2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeNumberField",
          "args": [
            "flen",
            "field[i]",
            "fmask",
            "&tmask",
            "tm",
            "fsec",
            "&is2digits"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeNumberField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2805-2884",
          "snippet": "static int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct pg_tm *tm, fsec_t *fsec, bool *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n\tif ((cp = strchr(str, '.')) != NULL)\n\t{\n\t\t/*\n\t\t * Can we use ParseFractionalSecond here?  Not clear whether trailing\n\t\t * junk should be rejected ...\n\t\t */\n\t\tdouble\t\tfrac;\n\n\t\terrno = 0;\n\t\tfrac = strtod(cp, NULL);\n\t\tif (errno != 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t*fsec = rint(frac * 1000000);\n\t\t/* Now truncate off the fraction for further processing */\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\tif (len >= 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\t/*\n\t\t\t * Start from end and consider first 2 as Day, next 2 as Month,\n\t\t\t * and the rest as Year.\n\t\t\t */\n\t\t\ttm->tm_mday = atoi(str + (len - 2));\n\t\t\t*(str + (len - 2)) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + (len - 4));\n\t\t\t*(str + (len - 4)) = '\\0';\n\t\t\ttm->tm_year = atoi(str);\n\t\t\tif ((len - 4) == 2)\n\t\t\t\t*is2digits = true;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn DTERR_BAD_FORMAT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDate",
          "args": [
            "field[i]",
            "fmask",
            "&tmask",
            "&is2digits",
            "tm"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2355-2459",
          "snippet": "static int\nDecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm)\n{\n\tfsec_t\t\tfsec;\n\tint\t\t\tnf = 0;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tint\t\t\tdterr;\n\tbool\t\thaveTextMonth = false;\n\tint\t\t\ttype,\n\t\t\t\tval,\n\t\t\t\tdmask = 0;\n\tchar\t   *field[MAXDATEFIELDS];\n\n\t*tmask = 0;\n\n\t/* parse this string... */\n\twhile (*str != '\\0' && nf < MAXDATEFIELDS)\n\t{\n\t\t/* skip field separators */\n\t\twhile (*str != '\\0' && !isalnum((unsigned char) *str))\n\t\t\tstr++;\n\n\t\tif (*str == '\\0')\n\t\t\treturn DTERR_BAD_FORMAT;\t/* end of string after separator */\n\n\t\tfield[nf] = str;\n\t\tif (isdigit((unsigned char) *str))\n\t\t{\n\t\t\twhile (isdigit((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse if (isalpha((unsigned char) *str))\n\t\t{\n\t\t\twhile (isalpha((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\n\t\t/* Just get rid of any non-digit, non-alpha characters... */\n\t\tif (*str != '\\0')\n\t\t\t*str++ = '\\0';\n\t\tnf++;\n\t}\n\n\t/* look first for text fields, since that will be unambiguous month */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (isalpha((unsigned char) *field[i]))\n\t\t{\n\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\tif (type == IGNORE_DTF)\n\t\t\t\tcontinue;\n\n\t\t\tdmask = DTK_M(type);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase MONTH:\n\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t\tif (fmask & dmask)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\tfmask |= dmask;\n\t\t\t*tmask |= dmask;\n\n\t\t\t/* mark this field as being completed */\n\t\t\tfield[i] = NULL;\n\t\t}\n\t}\n\n\t/* now pick up remaining numeric fields */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (field[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((len = strlen(field[i])) <= 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tdterr = DecodeNumber(len, field[i], haveTextMonth, fmask,\n\t\t\t\t\t\t\t &dmask, tm,\n\t\t\t\t\t\t\t &fsec, is2digits);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\tif (fmask & dmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tfmask |= dmask;\n\t\t*tmask |= dmask;\n\t}\n\n\tif ((fmask & ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* validation of the field values must wait until ValidateDate() */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm)\n{\n\tfsec_t\t\tfsec;\n\tint\t\t\tnf = 0;\n\tint\t\t\ti,\n\t\t\t\tlen;\n\tint\t\t\tdterr;\n\tbool\t\thaveTextMonth = false;\n\tint\t\t\ttype,\n\t\t\t\tval,\n\t\t\t\tdmask = 0;\n\tchar\t   *field[MAXDATEFIELDS];\n\n\t*tmask = 0;\n\n\t/* parse this string... */\n\twhile (*str != '\\0' && nf < MAXDATEFIELDS)\n\t{\n\t\t/* skip field separators */\n\t\twhile (*str != '\\0' && !isalnum((unsigned char) *str))\n\t\t\tstr++;\n\n\t\tif (*str == '\\0')\n\t\t\treturn DTERR_BAD_FORMAT;\t/* end of string after separator */\n\n\t\tfield[nf] = str;\n\t\tif (isdigit((unsigned char) *str))\n\t\t{\n\t\t\twhile (isdigit((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\t\telse if (isalpha((unsigned char) *str))\n\t\t{\n\t\t\twhile (isalpha((unsigned char) *str))\n\t\t\t\tstr++;\n\t\t}\n\n\t\t/* Just get rid of any non-digit, non-alpha characters... */\n\t\tif (*str != '\\0')\n\t\t\t*str++ = '\\0';\n\t\tnf++;\n\t}\n\n\t/* look first for text fields, since that will be unambiguous month */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (isalpha((unsigned char) *field[i]))\n\t\t{\n\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\tif (type == IGNORE_DTF)\n\t\t\t\tcontinue;\n\n\t\t\tdmask = DTK_M(type);\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\t\tcase MONTH:\n\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t\tif (fmask & dmask)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\tfmask |= dmask;\n\t\t\t*tmask |= dmask;\n\n\t\t\t/* mark this field as being completed */\n\t\t\tfield[i] = NULL;\n\t\t}\n\t}\n\n\t/* now pick up remaining numeric fields */\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tif (field[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((len = strlen(field[i])) <= 0)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tdterr = DecodeNumber(len, field[i], haveTextMonth, fmask,\n\t\t\t\t\t\t\t &dmask, tm,\n\t\t\t\t\t\t\t &fsec, is2digits);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\tif (fmask & dmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tfmask |= dmask;\n\t\t*tmask |= dmask;\n\t}\n\n\tif ((fmask & ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* validation of the field values must wait until ValidateDate() */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field[i]",
            "'.'"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt2time",
          "args": [
            "time",
            "&tm->tm_hour",
            "&tm->tm_min",
            "&tm->tm_sec",
            "fsec"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "dt2time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1730-1743",
          "snippet": "void\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nvoid\ndt2time(Timestamp jd, int *hour, int *min, int *sec, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\n\ttime = jd;\n\n\t*hour = time / USECS_PER_HOUR;\n\ttime -= (*hour) * USECS_PER_HOUR;\n\t*min = time / USECS_PER_MINUTE;\n\ttime -= (*min) * USECS_PER_MINUTE;\n\t*sec = time / USECS_PER_SEC;\n\t*fsec = time - (*sec * USECS_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "cp",
            "&cp"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTimezone",
          "args": [
            "field[i]",
            "tzp"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2892-2953",
          "snippet": "int\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseFractionalSecond",
          "args": [
            "cp",
            "fsec"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFractionalSecond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "497-511",
          "snippet": "static int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\n\nstatic int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "SECOND"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MINUTE"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "HOUR"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MINUTE"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "HOUR"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "field[i]",
            "&cp",
            "10"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTime",
          "args": [
            "field[i]",
            "fmask",
            "INTERVAL_FULL_RANGE",
            "&tmask",
            "tm",
            "fsec"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2544-2613",
          "snippet": "static int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic int\nDecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec)\n{\n\tchar\t   *cp;\n\tint\t\t\tdterr;\n\n\t*tmask = DTK_TIME_M;\n\n\terrno = 0;\n\ttm->tm_hour = strtoint(str, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp != ':')\n\t\treturn DTERR_BAD_FORMAT;\n\terrno = 0;\n\ttm->tm_min = strtoint(cp + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (*cp == '\\0')\n\t{\n\t\ttm->tm_sec = 0;\n\t\t*fsec = 0;\n\t\t/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */\n\t\tif (range == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))\n\t\t{\n\t\t\ttm->tm_sec = tm->tm_min;\n\t\t\ttm->tm_min = tm->tm_hour;\n\t\t\ttm->tm_hour = 0;\n\t\t}\n\t}\n\telse if (*cp == '.')\n\t{\n\t\t/* always assume mm:ss.sss is MINUTE TO SECOND */\n\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\t\ttm->tm_sec = tm->tm_min;\n\t\ttm->tm_min = tm->tm_hour;\n\t\ttm->tm_hour = 0;\n\t}\n\telse if (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\ttm->tm_sec = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\tif (*cp == '\\0')\n\t\t\t*fsec = 0;\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\tif (dterr)\n\t\t\t\treturn dterr;\n\t\t}\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\t}\n\telse\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* do a sanity check */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) ||\n\t\t*fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i]))"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "field[i]"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field[i]",
            "'-'"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *field[i]"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "TZ"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoint",
          "args": [
            "field[i]",
            "&cp",
            "10"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ParseDateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "545-739",
    "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
      "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ispunct",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "pg_tolower((unsigned char) *cp++)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *cp++"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "pg_tolower((unsigned char) *cp++)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *cp++"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "pg_tolower((unsigned char) *cp++)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *cp++"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datebsearch",
          "args": [
            "field[nf]",
            "datetktbl",
            "szdatetktbl"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "datebsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3798-3826",
          "snippet": "static const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn *datebsearch(const char *key, const datetkn *base, int nel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn *datebsearch(const char *key, const datetkn *base, int nel);\n\nstatic const datetkn *\ndatebsearch(const char *key, const datetkn *base, int nel)\n{\n\tif (nel > 0)\n\t{\n\t\tconst datetkn *last = base + nel - 1,\n\t\t\t\t   *position;\n\t\tint\t\t\tresult;\n\n\t\twhile (last >= base)\n\t\t{\n\t\t\tposition = base + ((last - base) >> 1);\n\t\t\t/* precheck the first character for a bit of extra speed */\n\t\t\tresult = (int) key[0] - (int) position->token[0];\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\t/* use strncmp so that we match truncated tokens */\n\t\t\t\tresult = strncmp(key, position->token, TOKMAXLEN);\n\t\t\t\tif (result == 0)\n\t\t\t\t\treturn position;\n\t\t\t}\n\t\t\tif (result < 0)\n\t\t\t\tlast = position - 1;\n\t\t\telse\n\t\t\t\tbase = position + 1;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "pg_tolower((unsigned char) *cp++)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *cp++"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "pg_tolower((unsigned char) *cp++)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *cp++"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "pg_tolower((unsigned char) *cp++)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *cp++"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPEND_CHAR",
          "args": [
            "bufp",
            "bufend",
            "*cp++"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *cp"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ParseFractionalSecond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "497-511",
    "snippet": "static int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "frac * 1000000"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "cp",
            "&cp"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "*cp == '.'"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\n\nstatic int\nParseFractionalSecond(char *cp, fsec_t *fsec)\n{\n\tdouble\t\tfrac;\n\n\t/* Caller should always pass the start of the fraction part */\n\tAssert(*cp == '.');\n\terrno = 0;\n\tfrac = strtod(cp, &cp);\n\t/* check for parse failure */\n\tif (*cp != '\\0' || errno != 0)\n\t\treturn DTERR_BAD_FORMAT;\n\t*fsec = rint(frac * 1000000);\n\treturn 0;\n}"
  },
  {
    "function_name": "AdjustFractDays",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "482-494",
    "snippet": "static void\nAdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
      "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdjustFractSeconds",
          "args": [
            "frac",
            "tm",
            "fsec",
            "SECS_PER_DAY"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustFractSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "467-479",
          "snippet": "static void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
            "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}"
  },
  {
    "function_name": "AdjustFractSeconds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "467-479",
    "snippet": "static void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
      "static void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);",
      "static void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "frac * 1000000"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nstatic void AdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\t   int scale);\nstatic void AdjustFractDays(double frac, struct pg_tm *tm, fsec_t *fsec,\n\t\t\t\tint scale);\n\nstatic void\nAdjustFractSeconds(double frac, struct pg_tm *tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\tsec;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\tsec = (int) frac;\n\ttm->tm_sec += sec;\n\tfrac -= sec;\n\t*fsec += rint(frac * 1000000);\n}"
  },
  {
    "function_name": "AppendTimestampSeconds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "457-461",
    "snippet": "static char *\nAppendTimestampSeconds(char *cp, struct pg_tm *tm, fsec_t fsec)\n{\n\treturn AppendSeconds(cp, tm->tm_sec, fsec, MAX_TIMESTAMP_PRECISION, true);\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppendSeconds",
          "args": [
            "cp",
            "tm->tm_sec",
            "fsec",
            "MAX_TIMESTAMP_PRECISION",
            "true"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "AppendSeconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "394-448",
          "snippet": "static char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);\n\nstatic char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nstatic char *\nAppendTimestampSeconds(char *cp, struct pg_tm *tm, fsec_t fsec)\n{\n\treturn AppendSeconds(cp, tm->tm_sec, fsec, MAX_TIMESTAMP_PRECISION, true);\n}"
  },
  {
    "function_name": "AppendSeconds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "394-448",
    "snippet": "static char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ltostr",
          "args": [
            "cp",
            "Abs(fsec)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "333-392",
          "snippet": "char *\npg_ltostr(char *str, int32 value)\n{\n\tchar\t   *start;\n\tchar\t   *end;\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (value < 0)\n\t{\n\t\t*str++ = '-';\n\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t/* As above, we expect remainder to be negative. */\n\t\t\t*str++ = '0' - remainder;\n\t\t} while (value != 0);\n\t}\n\telse\n\t{\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t*str++ = '0' + remainder;\n\t\t} while (value != 0);\n\t}\n\n\t/* Remember the end+1 and back up 'str' to the last character. */\n\tend = str--;\n\n\t/* Reverse string. */\n\twhile (start < str)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *str;\n\t\t*str-- = swap;\n\t}\n\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr(char *str, int32 value)\n{\n\tchar\t   *start;\n\tchar\t   *end;\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (value < 0)\n\t{\n\t\t*str++ = '-';\n\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t/* As above, we expect remainder to be negative. */\n\t\t\t*str++ = '0' - remainder;\n\t\t} while (value != 0);\n\t}\n\telse\n\t{\n\t\t/* Mark the position we must reverse the string from. */\n\t\tstart = str;\n\n\t\t/* Compute the result string backwards. */\n\t\tdo\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\t\t\t*str++ = '0' + remainder;\n\t\t} while (value != 0);\n\t}\n\n\t/* Remember the end+1 and back up 'str' to the last character. */\n\tend = str--;\n\n\t/* Reverse string. */\n\twhile (start < str)\n\t{\n\t\tchar\t\tswap = *start;\n\n\t\t*start++ = *str;\n\t\t*str-- = swap;\n\t}\n\n\treturn end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "fsec"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "fsec"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "sec"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_ltostr_zeropad",
          "args": [
            "cp",
            "Abs(sec)",
            "2"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ltostr_zeropad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "256-313",
          "snippet": "char *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nchar *\npg_ltostr_zeropad(char *str, int32 value, int32 minwidth)\n{\n\tchar\t   *start = str;\n\tchar\t   *end = &str[minwidth];\n\tint32\t\tnum = value;\n\n\tAssert(minwidth > 0);\n\n\t/*\n\t * Handle negative numbers in a special way.  We can't just write a '-'\n\t * prefix and reverse the sign as that would overflow for INT32_MIN.\n\t */\n\tif (num < 0)\n\t{\n\t\t*start++ = '-';\n\t\tminwidth--;\n\n\t\t/*\n\t\t * Build the number starting at the last digit.  Here remainder will\n\t\t * be a negative number, so we must reverse the sign before adding '0'\n\t\t * in order to get the correct ASCII digit.\n\t\t */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' - remainder;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Build the number starting at the last digit */\n\t\twhile (minwidth--)\n\t\t{\n\t\t\tint32\t\toldval = num;\n\t\t\tint32\t\tremainder;\n\n\t\t\tnum /= 10;\n\t\t\tremainder = oldval - num * 10;\n\t\t\tstart[minwidth] = '0' + remainder;\n\t\t}\n\t}\n\n\t/*\n\t * If minwidth was not high enough to fit the number then num won't have\n\t * been divided down to zero.  We punt the problem to pg_ltostr(), which\n\t * will generate a correct answer in the minimum valid width.\n\t */\n\tif (num != 0)\n\t\treturn pg_ltostr(str, value);\n\n\t/* Otherwise, return last output character + 1 */\n\treturn end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "sec"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "precision >= 0"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic char *AppendSeconds(char *cp, int sec, fsec_t fsec,\n\t\t\t  int precision, bool fillzeros);\n\nstatic char *\nAppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros)\n{\n\tAssert(precision >= 0);\n\n\tif (fillzeros)\n\t\tcp = pg_ltostr_zeropad(cp, Abs(sec), 2);\n\telse\n\t\tcp = pg_ltostr(cp, Abs(sec));\n\n\t/* fsec_t is just an int32 */\n\tif (fsec != 0)\n\t{\n\t\tint32\t\tvalue = Abs(fsec);\n\t\tchar\t   *end = &cp[precision + 1];\n\t\tbool\t\tgotnonzero = false;\n\n\t\t*cp++ = '.';\n\n\t\t/*\n\t\t * Append the fractional seconds part.  Note that we don't want any\n\t\t * trailing zeros here, so since we're building the number in reverse\n\t\t * we'll skip appending zeros until we've output a non-zero digit.\n\t\t */\n\t\twhile (precision--)\n\t\t{\n\t\t\tint32\t\toldval = value;\n\t\t\tint32\t\tremainder;\n\n\t\t\tvalue /= 10;\n\t\t\tremainder = oldval - value * 10;\n\n\t\t\t/* check if we got a non-zero */\n\t\t\tif (remainder)\n\t\t\t\tgotnonzero = true;\n\n\t\t\tif (gotnonzero)\n\t\t\t\tcp[precision] = '0' + remainder;\n\t\t\telse\n\t\t\t\tend = &cp[precision];\n\t\t}\n\n\t\t/*\n\t\t * If we still have a non-zero value then precision must have not been\n\t\t * enough to print the number.  We punt the problem to pg_ltostr(),\n\t\t * which will generate a correct answer in the minimum valid width.\n\t\t */\n\t\tif (value)\n\t\t\treturn pg_ltostr(cp, Abs(fsec));\n\n\t\treturn end;\n\t}\n\telse\n\t\treturn cp;\n}"
  },
  {
    "function_name": "GetCurrentTimeUsec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "370-380",
    "snippet": "void\nGetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\ttz;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n\tif (tzp != NULL)\n\t\t*tzp = tz;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "GetCurrentTransactionStartTimestamp()",
            "&tz",
            "tm",
            "fsec",
            "NULL",
            "NULL"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\ttz;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n\tif (tzp != NULL)\n\t\t*tzp = tz;\n}"
  },
  {
    "function_name": "GetCurrentDateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "353-362",
    "snippet": "void\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
      "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "GetCurrentTransactionStartTimestamp()",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}"
  },
  {
    "function_name": "j2day",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "335-345",
    "snippet": "int\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nj2day(int date)\n{\n\tdate += 1;\n\tdate %= 7;\n\t/* Cope if division truncates towards zero, as it probably does */\n\tif (date < 0)\n\t\tdate += 7;\n\n\treturn date;\n}"
  },
  {
    "function_name": "j2date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "300-325",
    "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
  },
  {
    "function_name": "date2j",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
    "lines": "275-298",
    "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
    "includes": [
      "#include \"utils/tzparser.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"common/string.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
  }
]