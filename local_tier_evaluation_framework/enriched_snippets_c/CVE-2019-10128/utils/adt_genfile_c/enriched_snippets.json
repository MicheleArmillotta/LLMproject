[
  {
    "function_name": "pg_ls_waldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "608-612",
    "snippet": "Datum\npg_ls_waldir(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir_files(fcinfo, XLOGDIR);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ls_dir_files",
          "args": [
            "fcinfo",
            "XLOGDIR"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ls_dir_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "522-598",
          "snippet": "static Datum\npg_ls_dir_files(FunctionCallInfo fcinfo, const char *dir)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"size\",\n\t\t\t\t\t\t   INT8OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"modification\",\n\t\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfctx->location = pstrdup(dir);\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location)));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tDatum\t\tvalues[3];\n\t\tbool\t\tnulls[3];\n\t\tchar\t\tpath[MAXPGPATH * 2];\n\t\tstruct stat attrib;\n\t\tHeapTuple\ttuple;\n\n\t\t/* Skip hidden files */\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t/* Get the file info */\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", fctx->location, de->d_name);\n\t\tif (stat(path, &attrib) < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir)));\n\n\t\t/* Ignore anything but regular files */\n\t\tif (!S_ISREG(attrib.st_mode))\n\t\t\tcontinue;\n\n\t\tvalues[0] = CStringGetTextDatum(de->d_name);\n\t\tvalues[1] = Int64GetDatum((int64) attrib.st_size);\n\t\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(attrib.st_mtime));\n\t\tmemset(nulls, 0, sizeof(nulls));\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic Datum\npg_ls_dir_files(FunctionCallInfo fcinfo, const char *dir)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"size\",\n\t\t\t\t\t\t   INT8OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"modification\",\n\t\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfctx->location = pstrdup(dir);\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location)));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tDatum\t\tvalues[3];\n\t\tbool\t\tnulls[3];\n\t\tchar\t\tpath[MAXPGPATH * 2];\n\t\tstruct stat attrib;\n\t\tHeapTuple\ttuple;\n\n\t\t/* Skip hidden files */\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t/* Get the file info */\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", fctx->location, de->d_name);\n\t\tif (stat(path, &attrib) < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir)));\n\n\t\t/* Ignore anything but regular files */\n\t\tif (!S_ISREG(attrib.st_mode))\n\t\t\tcontinue;\n\n\t\tvalues[0] = CStringGetTextDatum(de->d_name);\n\t\tvalues[1] = Int64GetDatum((int64) attrib.st_size);\n\t\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(attrib.st_mtime));\n\t\tmemset(nulls, 0, sizeof(nulls));\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_ls_waldir(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir_files(fcinfo, XLOGDIR);\n}"
  },
  {
    "function_name": "pg_ls_logdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "601-605",
    "snippet": "Datum\npg_ls_logdir(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir_files(fcinfo, Log_directory);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ls_dir_files",
          "args": [
            "fcinfo",
            "Log_directory"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ls_dir_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "522-598",
          "snippet": "static Datum\npg_ls_dir_files(FunctionCallInfo fcinfo, const char *dir)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"size\",\n\t\t\t\t\t\t   INT8OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"modification\",\n\t\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfctx->location = pstrdup(dir);\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location)));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tDatum\t\tvalues[3];\n\t\tbool\t\tnulls[3];\n\t\tchar\t\tpath[MAXPGPATH * 2];\n\t\tstruct stat attrib;\n\t\tHeapTuple\ttuple;\n\n\t\t/* Skip hidden files */\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t/* Get the file info */\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", fctx->location, de->d_name);\n\t\tif (stat(path, &attrib) < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir)));\n\n\t\t/* Ignore anything but regular files */\n\t\tif (!S_ISREG(attrib.st_mode))\n\t\t\tcontinue;\n\n\t\tvalues[0] = CStringGetTextDatum(de->d_name);\n\t\tvalues[1] = Int64GetDatum((int64) attrib.st_size);\n\t\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(attrib.st_mtime));\n\t\tmemset(nulls, 0, sizeof(nulls));\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic Datum\npg_ls_dir_files(FunctionCallInfo fcinfo, const char *dir)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"size\",\n\t\t\t\t\t\t   INT8OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"modification\",\n\t\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfctx->location = pstrdup(dir);\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location)));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tDatum\t\tvalues[3];\n\t\tbool\t\tnulls[3];\n\t\tchar\t\tpath[MAXPGPATH * 2];\n\t\tstruct stat attrib;\n\t\tHeapTuple\ttuple;\n\n\t\t/* Skip hidden files */\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t/* Get the file info */\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", fctx->location, de->d_name);\n\t\tif (stat(path, &attrib) < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir)));\n\n\t\t/* Ignore anything but regular files */\n\t\tif (!S_ISREG(attrib.st_mode))\n\t\t\tcontinue;\n\n\t\tvalues[0] = CStringGetTextDatum(de->d_name);\n\t\tvalues[1] = Int64GetDatum((int64) attrib.st_size);\n\t\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(attrib.st_mtime));\n\t\tmemset(nulls, 0, sizeof(nulls));\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_ls_logdir(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir_files(fcinfo, Log_directory);\n}"
  },
  {
    "function_name": "pg_ls_dir_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "522-598",
    "snippet": "static Datum\npg_ls_dir_files(FunctionCallInfo fcinfo, const char *dir)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"size\",\n\t\t\t\t\t\t   INT8OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"modification\",\n\t\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfctx->location = pstrdup(dir);\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location)));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tDatum\t\tvalues[3];\n\t\tbool\t\tnulls[3];\n\t\tchar\t\tpath[MAXPGPATH * 2];\n\t\tstruct stat attrib;\n\t\tHeapTuple\ttuple;\n\n\t\t/* Skip hidden files */\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t/* Get the file info */\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", fctx->location, de->d_name);\n\t\tif (stat(path, &attrib) < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir)));\n\n\t\t/* Ignore anything but regular files */\n\t\tif (!S_ISREG(attrib.st_mode))\n\t\t\tcontinue;\n\n\t\tvalues[0] = CStringGetTextDatum(de->d_name);\n\t\tvalues[1] = Int64GetDatum((int64) attrib.st_size);\n\t\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(attrib.st_mtime));\n\t\tmemset(nulls, 0, sizeof(nulls));\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "fctx->dirdesc"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "HeapTupleGetDatum(tuple)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "funcctx->tuple_desc",
            "values",
            "nulls"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nulls",
            "0",
            "sizeof(nulls)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "time_t_to_timestamptz(attrib.st_mtime)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_t_to_timestamptz",
          "args": [
            "attrib.st_mtime"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "time_t_to_timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1669-1679",
          "snippet": "TimestampTz\ntime_t_to_timestamptz(pg_time_t tm)\n{\n\tTimestampTz result;\n\n\tresult = (TimestampTz) tm -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult *= USECS_PER_SEC;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\ntime_t_to_timestamptz(pg_time_t tm)\n{\n\tTimestampTz result;\n\n\tresult = (TimestampTz) tm -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult *= USECS_PER_SEC;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "(int64) attrib.st_size"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "de->d_name"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "attrib.st_mode"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir))"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not stat directory \\\"%s\\\": %m\"",
            "dir"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&attrib"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/%s\"",
            "fctx->location",
            "de->d_name"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDir",
          "args": [
            "fctx->dirdesc",
            "fctx->location"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location))"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "fctx->location"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "dir"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"modification\"",
            "TIMESTAMPTZOID",
            "-1",
            "0"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"size\"",
            "INT8OID",
            "-1",
            "0"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"name\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "3",
            "false"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(directory_fctx)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic Datum\npg_ls_dir_files(FunctionCallInfo fcinfo, const char *dir)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"size\",\n\t\t\t\t\t\t   INT8OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"modification\",\n\t\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfctx->location = pstrdup(dir);\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfctx->location)));\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tDatum\t\tvalues[3];\n\t\tbool\t\tnulls[3];\n\t\tchar\t\tpath[MAXPGPATH * 2];\n\t\tstruct stat attrib;\n\t\tHeapTuple\ttuple;\n\n\t\t/* Skip hidden files */\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\t/* Get the file info */\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", fctx->location, de->d_name);\n\t\tif (stat(path, &attrib) < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat directory \\\"%s\\\": %m\", dir)));\n\n\t\t/* Ignore anything but regular files */\n\t\tif (!S_ISREG(attrib.st_mode))\n\t\t\tcontinue;\n\n\t\tvalues[0] = CStringGetTextDatum(de->d_name);\n\t\tvalues[1] = Int64GetDatum((int64) attrib.st_size);\n\t\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(attrib.st_mtime));\n\t\tmemset(nulls, 0, sizeof(nulls));\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "pg_ls_dir_1arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "515-519",
    "snippet": "Datum\npg_ls_dir_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ls_dir",
          "args": [
            "fcinfo"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "pg_ls_dir_1arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "515-519",
          "snippet": "Datum\npg_ls_dir_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_ls_dir_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_ls_dir(fcinfo);\n}"
  },
  {
    "function_name": "pg_ls_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "442-506",
    "snippet": "Datum\npg_ls_dir(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\tMemoryContext oldcontext;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tbool\t\tmissing_ok = false;\n\t\tbool\t\tinclude_dot_dirs = false;\n\n\t\t/* check the optional arguments */\n\t\tif (PG_NARGS() == 3)\n\t\t{\n\t\t\tif (!PG_ARGISNULL(1))\n\t\t\t\tmissing_ok = PG_GETARG_BOOL(1);\n\t\t\tif (!PG_ARGISNULL(2))\n\t\t\t\tinclude_dot_dirs = PG_GETARG_BOOL(2);\n\t\t}\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\t\tfctx->location = convert_and_check_filename(PG_GETARG_TEXT_PP(0));\n\n\t\tfctx->include_dot_dirs = include_dot_dirs;\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t{\n\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t{\n\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tfctx->location)));\n\t\t}\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tif (!fctx->include_dot_dirs &&\n\t\t\t(strcmp(de->d_name, \".\") == 0 ||\n\t\t\t strcmp(de->d_name, \"..\") == 0))\n\t\t\tcontinue;\n\n\t\tSRF_RETURN_NEXT(funcctx, CStringGetTextDatum(de->d_name));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "fctx->dirdesc"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "CStringGetTextDatum(de->d_name)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "de->d_name"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "de->d_name",
            "\"..\""
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadDir",
          "args": [
            "fctx->dirdesc",
            "fctx->location"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tfctx->location))"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not open directory \\\"%s\\\": %m\"",
            "fctx->location"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "fctx->location"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_and_check_filename",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "convert_and_check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "56-98",
          "snippet": "static char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(directory_fctx)"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_ls_dir(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tstruct dirent *de;\n\tdirectory_fctx *fctx;\n\tMemoryContext oldcontext;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tbool\t\tmissing_ok = false;\n\t\tbool\t\tinclude_dot_dirs = false;\n\n\t\t/* check the optional arguments */\n\t\tif (PG_NARGS() == 3)\n\t\t{\n\t\t\tif (!PG_ARGISNULL(1))\n\t\t\t\tmissing_ok = PG_GETARG_BOOL(1);\n\t\t\tif (!PG_ARGISNULL(2))\n\t\t\t\tinclude_dot_dirs = PG_GETARG_BOOL(2);\n\t\t}\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tfctx = palloc(sizeof(directory_fctx));\n\t\tfctx->location = convert_and_check_filename(PG_GETARG_TEXT_PP(0));\n\n\t\tfctx->include_dot_dirs = include_dot_dirs;\n\t\tfctx->dirdesc = AllocateDir(fctx->location);\n\n\t\tif (!fctx->dirdesc)\n\t\t{\n\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t{\n\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tfctx->location)));\n\t\t}\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = (directory_fctx *) funcctx->user_fctx;\n\n\twhile ((de = ReadDir(fctx->dirdesc, fctx->location)) != NULL)\n\t{\n\t\tif (!fctx->include_dot_dirs &&\n\t\t\t(strcmp(de->d_name, \".\") == 0 ||\n\t\t\t strcmp(de->d_name, \"..\") == 0))\n\t\t\tcontinue;\n\n\t\tSRF_RETURN_NEXT(funcctx, CStringGetTextDatum(de->d_name));\n\t}\n\n\tFreeDir(fctx->dirdesc);\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "pg_stat_file_1arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "433-437",
    "snippet": "Datum\npg_stat_file_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_stat_file(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_stat_file",
          "args": [
            "fcinfo"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "pg_stat_file_1arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "433-437",
          "snippet": "Datum\npg_stat_file_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_stat_file(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_stat_file_1arg(PG_FUNCTION_ARGS)\n{\n\treturn pg_stat_file(fcinfo);\n}"
  },
  {
    "function_name": "pg_stat_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "357-424",
    "snippet": "Datum\npg_stat_file(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tchar\t   *filename;\n\tstruct stat fst;\n\tDatum\t\tvalues[6];\n\tbool\t\tisnull[6];\n\tHeapTuple\ttuple;\n\tTupleDesc\ttupdesc;\n\tbool\t\tmissing_ok = false;\n\n\t/* check the optional argument */\n\tif (PG_NARGS() == 2)\n\t\tmissing_ok = PG_GETARG_BOOL(1);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tif (stat(filename, &fst) < 0)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * This record type had better match the output parameters declared for me\n\t * in pg_proc.h.\n\t */\n\ttupdesc = CreateTemplateTupleDesc(6, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1,\n\t\t\t\t\t   \"size\", INT8OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2,\n\t\t\t\t\t   \"access\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3,\n\t\t\t\t\t   \"modification\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 4,\n\t\t\t\t\t   \"change\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 5,\n\t\t\t\t\t   \"creation\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 6,\n\t\t\t\t\t   \"isdir\", BOOLOID, -1, 0);\n\tBlessTupleDesc(tupdesc);\n\n\tmemset(isnull, false, sizeof(isnull));\n\n\tvalues[0] = Int64GetDatum((int64) fst.st_size);\n\tvalues[1] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_atime));\n\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_mtime));\n\t/* Unix has file status change time, while Win32 has creation time */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tvalues[3] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_ctime));\n\tisnull[4] = true;\n#else\n\tisnull[3] = true;\n\tvalues[4] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_ctime));\n#endif\n\tvalues[5] = BoolGetDatum(S_ISDIR(fst.st_mode));\n\n\ttuple = heap_form_tuple(tupdesc, values, isnull);\n\n\tpfree(filename);\n\n\tPG_RETURN_DATUM(HeapTupleGetDatum(tuple));\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "HeapTupleGetDatum(tuple)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "filename"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "tupdesc",
            "values",
            "isnull"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "S_ISDIR(fst.st_mode)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "fst.st_mode"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "time_t_to_timestamptz(fst.st_ctime)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_t_to_timestamptz",
          "args": [
            "fst.st_ctime"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "time_t_to_timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1669-1679",
          "snippet": "TimestampTz\ntime_t_to_timestamptz(pg_time_t tm)\n{\n\tTimestampTz result;\n\n\tresult = (TimestampTz) tm -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult *= USECS_PER_SEC;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\ntime_t_to_timestamptz(pg_time_t tm)\n{\n\tTimestampTz result;\n\n\tresult = (TimestampTz) tm -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult *= USECS_PER_SEC;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "time_t_to_timestamptz(fst.st_ctime)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "time_t_to_timestamptz(fst.st_mtime)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "time_t_to_timestamptz(fst.st_atime)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "(int64) fst.st_size"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "isnull",
            "false",
            "sizeof(isnull)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 6",
            "\"isdir\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 5",
            "\"creation\"",
            "TIMESTAMPTZOID",
            "-1",
            "0"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 4",
            "\"change\"",
            "TIMESTAMPTZOID",
            "-1",
            "0"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"modification\"",
            "TIMESTAMPTZOID",
            "-1",
            "0"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"access\"",
            "TIMESTAMPTZOID",
            "-1",
            "0"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"size\"",
            "INT8OID",
            "-1",
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "6",
            "false"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename))"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not stat file \\\"%s\\\": %m\"",
            "filename"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&fst"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_and_check_filename",
          "args": [
            "filename_t"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "convert_and_check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "56-98",
          "snippet": "static char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_stat_file(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tchar\t   *filename;\n\tstruct stat fst;\n\tDatum\t\tvalues[6];\n\tbool\t\tisnull[6];\n\tHeapTuple\ttuple;\n\tTupleDesc\ttupdesc;\n\tbool\t\tmissing_ok = false;\n\n\t/* check the optional argument */\n\tif (PG_NARGS() == 2)\n\t\tmissing_ok = PG_GETARG_BOOL(1);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tif (stat(filename, &fst) < 0)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * This record type had better match the output parameters declared for me\n\t * in pg_proc.h.\n\t */\n\ttupdesc = CreateTemplateTupleDesc(6, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1,\n\t\t\t\t\t   \"size\", INT8OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2,\n\t\t\t\t\t   \"access\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3,\n\t\t\t\t\t   \"modification\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 4,\n\t\t\t\t\t   \"change\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 5,\n\t\t\t\t\t   \"creation\", TIMESTAMPTZOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 6,\n\t\t\t\t\t   \"isdir\", BOOLOID, -1, 0);\n\tBlessTupleDesc(tupdesc);\n\n\tmemset(isnull, false, sizeof(isnull));\n\n\tvalues[0] = Int64GetDatum((int64) fst.st_size);\n\tvalues[1] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_atime));\n\tvalues[2] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_mtime));\n\t/* Unix has file status change time, while Win32 has creation time */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tvalues[3] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_ctime));\n\tisnull[4] = true;\n#else\n\tisnull[3] = true;\n\tvalues[4] = TimestampTzGetDatum(time_t_to_timestamptz(fst.st_ctime));\n#endif\n\tvalues[5] = BoolGetDatum(S_ISDIR(fst.st_mode));\n\n\ttuple = heap_form_tuple(tupdesc, values, isnull);\n\n\tpfree(filename);\n\n\tPG_RETURN_DATUM(HeapTupleGetDatum(tuple));\n}"
  },
  {
    "function_name": "pg_read_binary_file_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "348-352",
    "snippet": "Datum\npg_read_binary_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_read_binary_file",
          "args": [
            "fcinfo"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "pg_read_binary_file_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "348-352",
          "snippet": "Datum\npg_read_binary_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_binary_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}"
  },
  {
    "function_name": "pg_read_binary_file_off_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "342-346",
    "snippet": "Datum\npg_read_binary_file_off_len(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_read_binary_file",
          "args": [
            "fcinfo"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "pg_read_binary_file_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "348-352",
          "snippet": "Datum\npg_read_binary_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_binary_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_binary_file_off_len(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_binary_file(fcinfo);\n}"
  },
  {
    "function_name": "pg_read_file_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "336-340",
    "snippet": "Datum\npg_read_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_file_v2(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_read_file_v2",
          "args": [
            "fcinfo"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "pg_read_file_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "251-282",
          "snippet": "Datum\npg_read_file_v2(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_file_v2(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_file_all(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_file_v2(fcinfo);\n}"
  },
  {
    "function_name": "pg_read_file_off_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "330-334",
    "snippet": "Datum\npg_read_file_off_len(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_file_v2(fcinfo);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_read_file_v2",
          "args": [
            "fcinfo"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "pg_read_file_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "251-282",
          "snippet": "Datum\npg_read_file_v2(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_file_v2(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_file_off_len(PG_FUNCTION_ARGS)\n{\n\treturn pg_read_file_v2(fcinfo);\n}"
  },
  {
    "function_name": "pg_read_binary_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "287-319",
    "snippet": "Datum\npg_read_binary_file(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\tbytea\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_binary_file(filename, seek_offset,\n\t\t\t\t\t\t\t  bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_BYTEA_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "result"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_binary_file",
          "args": [
            "filename",
            "seek_offset",
            "bytes_to_read",
            "missing_ok"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "read_binary_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "108-175",
          "snippet": "static bytea *\nread_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t\t bool missing_ok)\n{\n\tbytea\t   *buf;\n\tsize_t\t\tnbytes;\n\tFILE\t   *file;\n\n\tif (bytes_to_read < 0)\n\t{\n\t\tif (seek_offset < 0)\n\t\t\tbytes_to_read = -seek_offset;\n\t\telse\n\t\t{\n\t\t\tstruct stat fst;\n\n\t\t\tif (stat(filename, &fst) < 0)\n\t\t\t{\n\t\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t\t}\n\n\t\t\tbytes_to_read = fst.st_size - seek_offset;\n\t\t}\n\t}\n\n\t/* not sure why anyone thought that int64 length was a good idea */\n\tif (bytes_to_read > (MaxAllocSize - VARHDRSZ))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tif ((file = AllocateFile(filename, PG_BINARY_R)) == NULL)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\treturn NULL;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename)));\n\t}\n\n\tif (fseeko(file, (off_t) seek_offset,\n\t\t\t   (seek_offset >= 0) ? SEEK_SET : SEEK_END) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\n\tbuf = (bytea *) palloc((Size) bytes_to_read + VARHDRSZ);\n\n\tnbytes = fread(VARDATA(buf), 1, (size_t) bytes_to_read, file);\n\n\tif (ferror(file))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename)));\n\n\tSET_VARSIZE(buf, nbytes + VARHDRSZ);\n\n\tFreeFile(file);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bytea *\nread_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t\t bool missing_ok)\n{\n\tbytea\t   *buf;\n\tsize_t\t\tnbytes;\n\tFILE\t   *file;\n\n\tif (bytes_to_read < 0)\n\t{\n\t\tif (seek_offset < 0)\n\t\t\tbytes_to_read = -seek_offset;\n\t\telse\n\t\t{\n\t\t\tstruct stat fst;\n\n\t\t\tif (stat(filename, &fst) < 0)\n\t\t\t{\n\t\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t\t}\n\n\t\t\tbytes_to_read = fst.st_size - seek_offset;\n\t\t}\n\t}\n\n\t/* not sure why anyone thought that int64 length was a good idea */\n\tif (bytes_to_read > (MaxAllocSize - VARHDRSZ))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tif ((file = AllocateFile(filename, PG_BINARY_R)) == NULL)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\treturn NULL;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename)));\n\t}\n\n\tif (fseeko(file, (off_t) seek_offset,\n\t\t\t   (seek_offset >= 0) ? SEEK_SET : SEEK_END) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\n\tbuf = (bytea *) palloc((Size) bytes_to_read + VARHDRSZ);\n\n\tnbytes = fread(VARDATA(buf), 1, (size_t) bytes_to_read, file);\n\n\tif (ferror(file))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename)));\n\n\tSET_VARSIZE(buf, nbytes + VARHDRSZ);\n\n\tFreeFile(file);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_and_check_filename",
          "args": [
            "filename_t"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "convert_and_check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "56-98",
          "snippet": "static char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\"))"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length cannot be negative\""
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "2"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_binary_file(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\tbytea\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_binary_file(filename, seek_offset,\n\t\t\t\t\t\t\t  bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_BYTEA_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "pg_read_file_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "251-282",
    "snippet": "Datum\npg_read_file_v2(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_text_file",
          "args": [
            "filename",
            "seek_offset",
            "bytes_to_read",
            "missing_ok"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "read_text_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "181-199",
          "snippet": "static text *\nread_text_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t   bool missing_ok)\n{\n\tbytea\t   *buf;\n\n\tbuf = read_binary_file(filename, seek_offset, bytes_to_read, missing_ok);\n\n\tif (buf != NULL)\n\t{\n\t\t/* Make sure the input is valid */\n\t\tpg_verifymbstr(VARDATA(buf), VARSIZE(buf) - VARHDRSZ, false);\n\n\t\t/* OK, we can cast it to text safely */\n\t\treturn (text *) buf;\n\t}\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic text *\nread_text_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t   bool missing_ok)\n{\n\tbytea\t   *buf;\n\n\tbuf = read_binary_file(filename, seek_offset, bytes_to_read, missing_ok);\n\n\tif (buf != NULL)\n\t{\n\t\t/* Make sure the input is valid */\n\t\tpg_verifymbstr(VARDATA(buf), VARSIZE(buf) - VARHDRSZ, false);\n\n\t\t/* OK, we can cast it to text safely */\n\t\treturn (text *) buf;\n\t}\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_and_check_filename",
          "args": [
            "filename_t"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "convert_and_check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "56-98",
          "snippet": "static char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\"))"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length cannot be negative\""
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "2"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_file_v2(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "pg_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "206-243",
    "snippet": "Datum\npg_read_file(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\tif (!superuser())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be superuser to read files with adminpack 1.0\"),\n\t\t\t\t  errhint(\"Consider using pg_file_read(), which is part of core, instead.\"))));\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_text_file",
          "args": [
            "filename",
            "seek_offset",
            "bytes_to_read",
            "missing_ok"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "read_text_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "181-199",
          "snippet": "static text *\nread_text_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t   bool missing_ok)\n{\n\tbytea\t   *buf;\n\n\tbuf = read_binary_file(filename, seek_offset, bytes_to_read, missing_ok);\n\n\tif (buf != NULL)\n\t{\n\t\t/* Make sure the input is valid */\n\t\tpg_verifymbstr(VARDATA(buf), VARSIZE(buf) - VARHDRSZ, false);\n\n\t\t/* OK, we can cast it to text safely */\n\t\treturn (text *) buf;\n\t}\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic text *\nread_text_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t   bool missing_ok)\n{\n\tbytea\t   *buf;\n\n\tbuf = read_binary_file(filename, seek_offset, bytes_to_read, missing_ok);\n\n\tif (buf != NULL)\n\t{\n\t\t/* Make sure the input is valid */\n\t\tpg_verifymbstr(VARDATA(buf), VARSIZE(buf) - VARHDRSZ, false);\n\n\t\t/* OK, we can cast it to text safely */\n\t\treturn (text *) buf;\n\t}\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_and_check_filename",
          "args": [
            "filename_t"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "convert_and_check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "56-98",
          "snippet": "static char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\"))"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length cannot be negative\""
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "2"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be superuser to read files with adminpack 1.0\"),\n\t\t\t\t  errhint(\"Consider using pg_file_read(), which is part of core, instead.\")))"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Consider using pg_file_read(), which is part of core, instead.\""
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "superuser",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "superuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "46-50",
          "snippet": "bool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_read_file(PG_FUNCTION_ARGS)\n{\n\ttext\t   *filename_t = PG_GETARG_TEXT_PP(0);\n\tint64\t\tseek_offset = 0;\n\tint64\t\tbytes_to_read = -1;\n\tbool\t\tmissing_ok = false;\n\tchar\t   *filename;\n\ttext\t   *result;\n\n\tif (!superuser())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"must be superuser to read files with adminpack 1.0\"),\n\t\t\t\t  errhint(\"Consider using pg_file_read(), which is part of core, instead.\"))));\n\n\t/* handle optional arguments */\n\tif (PG_NARGS() >= 3)\n\t{\n\t\tseek_offset = PG_GETARG_INT64(1);\n\t\tbytes_to_read = PG_GETARG_INT64(2);\n\n\t\tif (bytes_to_read < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"requested length cannot be negative\")));\n\t}\n\tif (PG_NARGS() >= 4)\n\t\tmissing_ok = PG_GETARG_BOOL(3);\n\n\tfilename = convert_and_check_filename(filename_t);\n\n\tresult = read_text_file(filename, seek_offset, bytes_to_read, missing_ok);\n\tif (result)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "read_text_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "181-199",
    "snippet": "static text *\nread_text_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t   bool missing_ok)\n{\n\tbytea\t   *buf;\n\n\tbuf = read_binary_file(filename, seek_offset, bytes_to_read, missing_ok);\n\n\tif (buf != NULL)\n\t{\n\t\t/* Make sure the input is valid */\n\t\tpg_verifymbstr(VARDATA(buf), VARSIZE(buf) - VARHDRSZ, false);\n\n\t\t/* OK, we can cast it to text safely */\n\t\treturn (text *) buf;\n\t}\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_verifymbstr",
          "args": [
            "VARDATA(buf)",
            "VARSIZE(buf) - VARHDRSZ",
            "false"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verifymbstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1865-1870",
          "snippet": "bool\npg_verifymbstr(const char *mbstr, int len, bool noError)\n{\n\treturn\n\t\tpg_verify_mbstr_len(GetDatabaseEncoding(), mbstr, len, noError) >= 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nbool\npg_verifymbstr(const char *mbstr, int len, bool noError)\n{\n\treturn\n\t\tpg_verify_mbstr_len(GetDatabaseEncoding(), mbstr, len, noError) >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "buf"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "buf"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_binary_file",
          "args": [
            "filename",
            "seek_offset",
            "bytes_to_read",
            "missing_ok"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "read_binary_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
          "lines": "108-175",
          "snippet": "static bytea *\nread_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t\t bool missing_ok)\n{\n\tbytea\t   *buf;\n\tsize_t\t\tnbytes;\n\tFILE\t   *file;\n\n\tif (bytes_to_read < 0)\n\t{\n\t\tif (seek_offset < 0)\n\t\t\tbytes_to_read = -seek_offset;\n\t\telse\n\t\t{\n\t\t\tstruct stat fst;\n\n\t\t\tif (stat(filename, &fst) < 0)\n\t\t\t{\n\t\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t\t}\n\n\t\t\tbytes_to_read = fst.st_size - seek_offset;\n\t\t}\n\t}\n\n\t/* not sure why anyone thought that int64 length was a good idea */\n\tif (bytes_to_read > (MaxAllocSize - VARHDRSZ))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tif ((file = AllocateFile(filename, PG_BINARY_R)) == NULL)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\treturn NULL;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename)));\n\t}\n\n\tif (fseeko(file, (off_t) seek_offset,\n\t\t\t   (seek_offset >= 0) ? SEEK_SET : SEEK_END) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\n\tbuf = (bytea *) palloc((Size) bytes_to_read + VARHDRSZ);\n\n\tnbytes = fread(VARDATA(buf), 1, (size_t) bytes_to_read, file);\n\n\tif (ferror(file))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename)));\n\n\tSET_VARSIZE(buf, nbytes + VARHDRSZ);\n\n\tFreeFile(file);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/htup_details.h\"",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bytea *\nread_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t\t bool missing_ok)\n{\n\tbytea\t   *buf;\n\tsize_t\t\tnbytes;\n\tFILE\t   *file;\n\n\tif (bytes_to_read < 0)\n\t{\n\t\tif (seek_offset < 0)\n\t\t\tbytes_to_read = -seek_offset;\n\t\telse\n\t\t{\n\t\t\tstruct stat fst;\n\n\t\t\tif (stat(filename, &fst) < 0)\n\t\t\t{\n\t\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t\t}\n\n\t\t\tbytes_to_read = fst.st_size - seek_offset;\n\t\t}\n\t}\n\n\t/* not sure why anyone thought that int64 length was a good idea */\n\tif (bytes_to_read > (MaxAllocSize - VARHDRSZ))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tif ((file = AllocateFile(filename, PG_BINARY_R)) == NULL)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\treturn NULL;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename)));\n\t}\n\n\tif (fseeko(file, (off_t) seek_offset,\n\t\t\t   (seek_offset >= 0) ? SEEK_SET : SEEK_END) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\n\tbuf = (bytea *) palloc((Size) bytes_to_read + VARHDRSZ);\n\n\tnbytes = fread(VARDATA(buf), 1, (size_t) bytes_to_read, file);\n\n\tif (ferror(file))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename)));\n\n\tSET_VARSIZE(buf, nbytes + VARHDRSZ);\n\n\tFreeFile(file);\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic text *\nread_text_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t   bool missing_ok)\n{\n\tbytea\t   *buf;\n\n\tbuf = read_binary_file(filename, seek_offset, bytes_to_read, missing_ok);\n\n\tif (buf != NULL)\n\t{\n\t\t/* Make sure the input is valid */\n\t\tpg_verifymbstr(VARDATA(buf), VARSIZE(buf) - VARHDRSZ, false);\n\n\t\t/* OK, we can cast it to text safely */\n\t\treturn (text *) buf;\n\t}\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "read_binary_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "108-175",
    "snippet": "static bytea *\nread_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t\t bool missing_ok)\n{\n\tbytea\t   *buf;\n\tsize_t\t\tnbytes;\n\tFILE\t   *file;\n\n\tif (bytes_to_read < 0)\n\t{\n\t\tif (seek_offset < 0)\n\t\t\tbytes_to_read = -seek_offset;\n\t\telse\n\t\t{\n\t\t\tstruct stat fst;\n\n\t\t\tif (stat(filename, &fst) < 0)\n\t\t\t{\n\t\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t\t}\n\n\t\t\tbytes_to_read = fst.st_size - seek_offset;\n\t\t}\n\t}\n\n\t/* not sure why anyone thought that int64 length was a good idea */\n\tif (bytes_to_read > (MaxAllocSize - VARHDRSZ))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tif ((file = AllocateFile(filename, PG_BINARY_R)) == NULL)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\treturn NULL;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename)));\n\t}\n\n\tif (fseeko(file, (off_t) seek_offset,\n\t\t\t   (seek_offset >= 0) ? SEEK_SET : SEEK_END) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\n\tbuf = (bytea *) palloc((Size) bytes_to_read + VARHDRSZ);\n\n\tnbytes = fread(VARDATA(buf), 1, (size_t) bytes_to_read, file);\n\n\tif (ferror(file))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename)));\n\n\tSET_VARSIZE(buf, nbytes + VARHDRSZ);\n\n\tFreeFile(file);\n\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "file"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "buf",
            "nbytes + VARHDRSZ"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename))"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read file \\\"%s\\\": %m\"",
            "filename"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ferror",
          "args": [
            "file"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "VARDATA(buf)",
            "1",
            "(size_t) bytes_to_read",
            "file"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "buf"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(Size) bytes_to_read + VARHDRSZ"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename))"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseeko",
          "args": [
            "file",
            "(off_t) seek_offset",
            "(seek_offset >= 0) ? SEEK_SET : SEEK_END"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename))"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "filename",
            "PG_BINARY_R"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\"))"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename))"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&fst"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bytea *\nread_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read,\n\t\t\t\t bool missing_ok)\n{\n\tbytea\t   *buf;\n\tsize_t\t\tnbytes;\n\tFILE\t   *file;\n\n\tif (bytes_to_read < 0)\n\t{\n\t\tif (seek_offset < 0)\n\t\t\tbytes_to_read = -seek_offset;\n\t\telse\n\t\t{\n\t\t\tstruct stat fst;\n\n\t\t\tif (stat(filename, &fst) < 0)\n\t\t\t{\n\t\t\t\tif (missing_ok && errno == ENOENT)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t\t}\n\n\t\t\tbytes_to_read = fst.st_size - seek_offset;\n\t\t}\n\t}\n\n\t/* not sure why anyone thought that int64 length was a good idea */\n\tif (bytes_to_read > (MaxAllocSize - VARHDRSZ))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tif ((file = AllocateFile(filename, PG_BINARY_R)) == NULL)\n\t{\n\t\tif (missing_ok && errno == ENOENT)\n\t\t\treturn NULL;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\" for reading: %m\",\n\t\t\t\t\t\t\tfilename)));\n\t}\n\n\tif (fseeko(file, (off_t) seek_offset,\n\t\t\t   (seek_offset >= 0) ? SEEK_SET : SEEK_END) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\n\tbuf = (bytea *) palloc((Size) bytes_to_read + VARHDRSZ);\n\n\tnbytes = fread(VARDATA(buf), 1, (size_t) bytes_to_read, file);\n\n\tif (ferror(file))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\", filename)));\n\n\tSET_VARSIZE(buf, nbytes + VARHDRSZ);\n\n\tFreeFile(file);\n\n\treturn buf;\n}"
  },
  {
    "function_name": "convert_and_check_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/genfile.c",
    "lines": "56-98",
    "snippet": "static char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/xlog_internal.h\"",
      "#include \"access/htup_details.h\"",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\")))"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"path must be in or below the current directory\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_is_relative_and_below_cwd",
          "args": [
            "filename"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\")))"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_is_prefix_of_path",
          "args": [
            "Log_directory",
            "filename"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_absolute_path",
          "args": [
            "Log_directory"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_is_prefix_of_path",
          "args": [
            "DataDir",
            "filename"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\")))"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_contains_parent_reference",
          "args": [
            "filename"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_absolute_path",
          "args": [
            "filename"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_member_of_role",
          "args": [
            "GetUserId()",
            "DEFAULT_ROLE_READ_SERVER_FILES"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "is_member_of_role_nosuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "4969-4981",
          "snippet": "bool\nis_member_of_role_nosuper(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member is a member of, including multi-level\n\t * recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_is_member_of(member), role);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\nis_member_of_role_nosuper(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member is a member of, including multi-level\n\t * recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_is_member_of(member), role);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalize_path",
          "args": [
            "filename"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "arg"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/syslogger.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/htup_details.h\"\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic char *\nconvert_and_check_filename(text *arg)\n{\n\tchar\t   *filename;\n\n\tfilename = text_to_cstring(arg);\n\tcanonicalize_path(filename);\t/* filename can change length here */\n\n\t/*\n\t * Members of the 'pg_read_server_files' role are allowed to access any\n\t * files on the server as the PG user, so no need to do any further checks\n\t * here.\n\t */\n\tif (is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_SERVER_FILES))\n\t\treturn filename;\n\n\t/* User isn't a member of the default role, so check if it's allowable */\n\tif (is_absolute_path(filename))\n\t{\n\t\t/* Disallow '/a/b/data/..' */\n\t\tif (path_contains_parent_reference(filename))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"reference to parent directory (\\\"..\\\") not allowed\"))));\n\n\t\t/*\n\t\t * Allow absolute paths if within DataDir or Log_directory, even\n\t\t * though Log_directory might be outside DataDir.\n\t\t */\n\t\tif (!path_is_prefix_of_path(DataDir, filename) &&\n\t\t\t(!is_absolute_path(Log_directory) ||\n\t\t\t !path_is_prefix_of_path(Log_directory, filename)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t (errmsg(\"absolute path not allowed\"))));\n\t}\n\telse if (!path_is_relative_and_below_cwd(filename))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t (errmsg(\"path must be in or below the current directory\"))));\n\n\treturn filename;\n}"
  }
]